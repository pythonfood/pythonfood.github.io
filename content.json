{"meta":{"title":"PythonFood","subtitle":null,"description":null,"author":"Python Food","url":"http://pythonfood.github.io"},"pages":[{"title":"","date":"2017-12-27T06:07:39.570Z","updated":"2017-12-27T06:07:39.570Z","comments":true,"path":"about/index.html","permalink":"http://pythonfood.github.io/about/index.html","excerpt":"","text":"关于我A snake that grows up slowly 关于工作城市：首堵 关于学习python 关于爱好food 联系我Blog: pythonfood.github.ioGitHub: pythonfood"}],"posts":[{"title":"Scrapy分布式的部署详解","slug":"Scrapy分布式的部署详解","date":"2018-07-05T13:00:00.000Z","updated":"2018-08-16T09:38:18.415Z","comments":true,"path":"2018/07/05/Scrapy分布式的部署详解/","link":"","permalink":"http://pythonfood.github.io/2018/07/05/Scrapy分布式的部署详解/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、部署详解1、scrapyd组件github地址：https://github.com/scrapy/scrapyd 官方文档：http://scrapyd.readthedocs.io/en/stable/ 2、安装pip install scrapyd 如果出现和python3不兼容的问题，打开python包管理的网站：https://pypi.org/ ，搜索scrapyd，找到一个兼容的版本安装。 3、启动scrapyd 会回显它是在http://127.0.0.1:6800/ 上监听的。linux上是http://0.0.0.0:6800/ 4、怎样部署项目？借助scrapyd-client： gitbub地址：https://github.com/scrapy/scrapyd-client 安装pip install scrapyd-client 使用详见官方文档。 5、修改项目修改scrapy.cfg文件[deploy],添加远程主机url = http://123.206.65.37:6800/addversion.json 。 输入命令scrapyd-deploy帮助我们完成项目的部署。远程部署到主机上了。 输入命令curl http://123.206.65.37:6800/listprojects.json可以看到已经上传成功了。 输入命令curl http://123.206.65.37:6800/schedule.json -d project=zhihuuser -d spider=zhihu指定项目和spider远程开启调度进程。 连续输入三个curl http://123.206.65.37:6800/schedule.json -d project=zhihuuser -d spider=zhihu则开启三个调度进程。 输入命令curl http://123.206.65.37:6800/listjobs.json\\?project\\=zhihuuser可以查看当前运行的任务。也可以在浏览器里查看。 输入命令curl http://123.206.65.37:6800/cancel.json -d project=zhihuuser -d job=35a3bce034hkk2j4kl232l43hjkl指定job代号停止任务。 6、python-scrapyd-api库是对scrapyd相关api做了一个封装。这样可以在python代码中调用scrapyd的api了,就不必用curl接口请求的方式调度了。 gitbub地址：https://github.com/djm/python-scrapyd-api 安装pip install python-scrapyd-api 命令行里测试下：12345from scrapyd_api import ScrapydAPIscrapyd = ScrapydAPI(&apos;http://123.206.65.37:6800&apos;)scrapyd.list_projects()scrapyd.list_spiders(zhihuuser) 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"Scrapy分布式架构搭建抓取知乎","slug":"Scrapy分布式架构搭建抓取知乎","date":"2018-07-05T12:00:00.000Z","updated":"2018-08-21T09:39:45.628Z","comments":true,"path":"2018/07/05/Scrapy分布式架构搭建抓取知乎/","link":"","permalink":"http://pythonfood.github.io/2018/07/05/Scrapy分布式架构搭建抓取知乎/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、爬取实战1、在zhihuuser的项目上修改首先从github上复制知乎项目到本地git clone https://github.com/Germey/Zhihu.git。 再在pycharm中打开。 不能在源代码上修改，需要建一个分支git checkout -b distributed。 切换到分支git branch。 2、搭建分布式架构本地项目修改settings.py，引入scrapy-redis，这里redis数据库地址设置的一个阿里云服务器。 zhihu-distributed / scrapy.cfg1234567[settings]default = zhihuuser.settings[deploy]#url = http://localhost:6800/url = http://123.206.65.37:6800/addversion.json # 远程主机的urlproject = zhihuuser zhihu-distributed / zhihuuser / items.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding: utf-8 -*-from scrapy import Item, Fieldclass UserItem(Item): # define the fields for your item here like: id = Field() name = Field() avatar_url = Field() headline = Field() description = Field() url = Field() url_token = Field() gender = Field() cover_url = Field() type = Field() badge = Field() answer_count = Field() articles_count = Field() commercial_question_count = Field() favorite_count = Field() favorited_count = Field() follower_count = Field() following_columns_count = Field() following_count = Field() pins_count = Field() question_count = Field() thank_from_count = Field() thank_to_count = Field() thanked_count = Field() vote_from_count = Field() vote_to_count = Field() voteup_count = Field() following_favlists_count = Field() following_question_count = Field() following_topic_count = Field() marked_answers_count = Field() mutual_followees_count = Field() hosted_live_count = Field() participated_live_count = Field() locations = Field() educations = Field() employments = Field() zhihu-distributed / zhihuuser / middlewares.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# -*- coding: utf-8 -*-from scrapy import signalsclass ZhihuSpiderMiddleware(object): # Not all methods need to be defined. If a method is not defined, # scrapy acts as if the spider middleware does not modify the # passed objects. @classmethod def from_crawler(cls, crawler): # This method is used by Scrapy to create your spiders. s = cls() crawler.signals.connect(s.spider_opened, signal=signals.spider_opened) return s def process_spider_input(response, spider): # Called for each response that goes through the spider # middleware and into the spider. # Should return None or raise an exception. return None def process_spider_output(response, result, spider): # Called with the results returned from the Spider, after # it has processed the response. # Must return an iterable of Request, dict or Item objects. for i in result: yield i def process_spider_exception(response, exception, spider): # Called when a spider or process_spider_input() method # (from other spider middleware) raises an exception. # Should return either None or an iterable of Response, dict # or Item objects. pass def process_start_requests(start_requests, spider): # Called with the start requests of the spider, and works # similarly to the process_spider_output() method, except # that it doesn’t have a response associated. # Must return only requests (not items). for r in start_requests: yield r def spider_opened(self, spider): spider.logger.info('Spider opened: %s' % spider.name) zhihu-distributed / zhihuuser / pipelines.py123456789101112131415161718192021222324252627282930313233# -*- coding: utf-8 -*-import pymongoclass ZhihuPipeline(object): def process_item(self, item, spider): return itemclass MongoPipeline(object): collection_name = 'users' def __init__(self, mongo_uri, mongo_db): self.mongo_uri = mongo_uri self.mongo_db = mongo_db @classmethod def from_crawler(cls, crawler): return cls( mongo_uri=crawler.settings.get('MONGO_URI'), mongo_db=crawler.settings.get('MONGO_DATABASE') ) def open_spider(self, spider): self.client = pymongo.MongoClient(self.mongo_uri) self.db = self.client[self.mongo_db] def close_spider(self, spider): self.client.close() def process_item(self, item, spider): self.db[self.collection_name].update(&#123;'url_token': item['url_token']&#125;, dict(item), True) return item zhihu-distributed / zhihuuser / settings.py123456789101112131415161718192021222324252627# -*- coding: utf-8 -*-BOT_NAME = 'zhihuuser'SPIDER_MODULES = ['zhihuuser.spiders']NEWSPIDER_MODULE = 'zhihuuser.spiders'ROBOTSTXT_OBEY = FalseDEFAULT_REQUEST_HEADERS = &#123; 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36', 'authorization': 'oauth c3cef7c66a1843f8b3a9e6a1e3160e20',&#125;ITEM_PIPELINES = &#123; 'zhihuuser.pipelines.MongoPipeline': 300, # 存取本地pipeline 'scrapy_redis.pipelines.RedisPipeline': 301 # 将爬取结果引入到redis的pipeline里面去&#125;MONGO_URI = 'localhost'MONGO_DATABASE = 'zhihu'SCHEDULER = \"scrapy_redis.scheduler.Scheduler\" # 核心调度器换成scrapy_redis调度器DUPEFILTER_CLASS = \"scrapy_redis.dupefilter.RFPDupeFilter\" # 去重的classREDIS_URL = 'redis://root:redistest@120.27.34.24:6379' # redis数据库的连接地址 zhihu-distributed / zhihuuser / spiders / zhihu.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# -*- coding: utf-8 -*-import jsonfrom scrapy import Spider, Requestfrom zhihuuser.items import UserItemclass ZhihuSpider(Spider): name = \"zhihu\" allowed_domains = [\"www.zhihu.com\"] user_url = 'https://www.zhihu.com/api/v4/members/&#123;user&#125;?include=&#123;include&#125;' follows_url = 'https://www.zhihu.com/api/v4/members/&#123;user&#125;/followees?include=&#123;include&#125;&amp;offset=&#123;offset&#125;&amp;limit=&#123;limit&#125;' followers_url = 'https://www.zhihu.com/api/v4/members/&#123;user&#125;/followers?include=&#123;include&#125;&amp;offset=&#123;offset&#125;&amp;limit=&#123;limit&#125;' start_user = 'tianshansoft' user_query = 'locations,employments,gender,educations,business,voteup_count,thanked_Count,follower_count,following_count,cover_url,following_topic_count,following_question_count,following_favlists_count,following_columns_count,answer_count,articles_count,pins_count,question_count,commercial_question_count,favorite_count,favorited_count,logs_count,marked_answers_count,marked_answers_text,message_thread_token,account_status,is_active,is_force_renamed,is_bind_sina,sina_weibo_url,sina_weibo_name,show_sina_weibo,is_blocking,is_blocked,is_following,is_followed,mutual_followees_count,vote_to_count,vote_from_count,thank_to_count,thank_from_count,thanked_count,description,hosted_live_count,participated_live_count,allow_message,industry_category,org_name,org_homepage,badge[?(type=best_answerer)].topics' follows_query = 'data[*].answer_count,articles_count,gender,follower_count,is_followed,is_following,badge[?(type=best_answerer)].topics' followers_query = 'data[*].answer_count,articles_count,gender,follower_count,is_followed,is_following,badge[?(type=best_answerer)].topics' def start_requests(self): yield Request(self.user_url.format(user=self.start_user, include=self.user_query), self.parse_user) yield Request(self.follows_url.format(user=self.start_user, include=self.follows_query, limit=20, offset=0), self.parse_follows) yield Request(self.followers_url.format(user=self.start_user, include=self.followers_query, limit=20, offset=0), self.parse_followers) def parse_user(self, response): result = json.loads(response.text) item = UserItem() for field in item.fields: if field in result.keys(): item[field] = result.get(field) yield item yield Request( self.follows_url.format(user=result.get('url_token'), include=self.follows_query, limit=20, offset=0), self.parse_follows) yield Request( self.followers_url.format(user=result.get('url_token'), include=self.followers_query, limit=20, offset=0), self.parse_followers) def parse_follows(self, response): results = json.loads(response.text) if 'data' in results.keys(): for result in results.get('data'): yield Request(self.user_url.format(user=result.get('url_token'), include=self.user_query), self.parse_user) if 'paging' in results.keys() and results.get('paging').get('is_end') == False: next_page = results.get('paging').get('next') yield Request(next_page, self.parse_follows) def parse_followers(self, response): results = json.loads(response.text) if 'data' in results.keys(): for result in results.get('data'): yield Request(self.user_url.format(user=result.get('url_token'), include=self.user_query), self.parse_user) if 'paging' in results.keys() and results.get('paging').get('is_end') == False: next_page = results.get('paging').get('next') yield Request(next_page, self.parse_followers) 3、更新代码到github上git status git add -A git commit -m &#39;add distributed&#39; git push origin distributed 4、在腾讯云上部署scrapy环境注意设置mongodb.conf文件，允许远程访问，注释掉bind_ip=127.0.0.1即可允许远程访问了。 从github上复制代码git clone https://github.com/Germey/Zhihu.git -b distributed。 运行爬虫scrapy crawl zhihu，相当于在另一台主机上开启了知乎的爬取。scrapy_resis/unils.py # 一些工具库 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"Scrapy分布式原理及Scrapy-Redis源码解析","slug":"Scrapy分布式原理及Scrapy-Redis源码解析","date":"2018-07-05T11:00:00.000Z","updated":"2018-08-16T09:51:36.279Z","comments":true,"path":"2018/07/05/Scrapy分布式原理及Scrapy-Redis源码解析/","link":"","permalink":"http://pythonfood.github.io/2018/07/05/Scrapy分布式原理及Scrapy-Redis源码解析/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、原理详解1、Scrapy单机架构 2、 单主机爬虫架构 3、分布式爬虫架构 4、队列用什么维护？Redis队列： Redis，非关系型数据库，Key-Value形式存储，结构灵活。 是内存中的数据结构存储系统，处理速度快，性能好。 提供队列、集合等多种存储结构，⽅方便队列维护。 5、怎样来去重？Redis集合： Redis提供集合数据结构，在Redis集合中存储每个Request的指纹。 在向Request队列中加入Request前首先验证这个Request的指纹是否已经加入集合中。 如果已存在，则不添加Request到队列，如果不存在，则将Request添加入队列并将指纹加入集合。 6、怎样防⽌止中断？启动判断： 在每台从机Scrapy启动时都会首先判断当前Redis Request队列是否为空。 如果不为空，则从队列中取得下一个Request执行爬取。 如果为空，则重新开始爬取，第一台从机执行爬取向队列中添加Request。 7、怎样实现该架构？Scrapy-Redis： Scrapy-Redis库实现了如上架构，改写了Scrapy的调度器，队列等组件。 利用它可以方便地实现Scrapy分布式架构。 github地址：https://github.com/rolando/scrapy-redis 安装pip install scrapy-redis 8、源码讲解scrapy_resis/connection.py # 连接redis的基本的库 scrapy_resis/default.py # 一些默认的变量 scrapy_resis/dupefilter.py # 用来去重的一个机制 scrapy_resis/picklecompat.py # 和json的load和dump类似 scrapy_resis/pipelines.py # 管道，增加了集中存储到resids scrapy_resis/queue.py # 队列 scrapy_resis/scheduler.py # 调度器 scrapy_resis/spiders.py # 定义了某些spider scrapy_resis/unils.py # 一些工具库 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"Scrapy+Tushare爬取微博股票数据","slug":"Scrapy-Tushare爬取微博股票数据","date":"2018-07-05T10:00:00.000Z","updated":"2018-08-21T09:45:17.911Z","comments":true,"path":"2018/07/05/Scrapy-Tushare爬取微博股票数据/","link":"","permalink":"http://pythonfood.github.io/2018/07/05/Scrapy-Tushare爬取微博股票数据/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、爬取实战1、安装pip install tushare 2、官网地址http://tushare.org/ 3、命令行演示1234567import tushare as tsresult = ts.get_hs300s() # 获取沪深300print(result)print(type(result))result[&apos;name&apos;].tolist() # 获取沪深300股票名称result[&apos;code&apos;].tolist() # 获取沪深300股票代号 4、实战weibostock / scrapy.cfg123456[settings]default = weibo.settings[deploy]#url = http://localhost:6800/project = weibo weibostock / weibo / items.py1234567891011121314151617# -*- coding: utf-8 -*-from scrapy import Item, Fieldclass WeiboItem(Item): table_name = 'weibo' id = Field() content = Field() forward_count = Field() comment_count = Field() like_count = Field() posted_at = Field() url = Field() user = Field() keyword = Field() # 保存到item，就可以进行赋值了 crawled_at = Field() weibostock / weibo / middlewares.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# -*- coding: utf-8 -*-import jsonimport loggingimport requestsfrom requests.exceptions import ConnectionErrorfrom scrapy.exceptions import IgnoreRequestclass CookiesMiddleWare(): def __init__(self, cookies_pool_url): self.logger = logging.getLogger(__name__) self.cookies_pool_url = cookies_pool_url def _get_random_cookies(self): try: response = requests.get(self.cookies_pool_url) if response.status_code == 200: return json.loads(response.text) except ConnectionError: return None def process_request(self, request, spider): cookies = self._get_random_cookies() if cookies: request.cookies = cookies self.logger.debug('Using Cookies ' + json.dumps(cookies)) else: self.logger.debug('No Valid Cookies') @classmethod def from_crawler(cls, crawler): return cls( cookies_pool_url=crawler.settings.get('COOKIES_POOL_URL') ) def process_response(self, request, response, spider): if response.status in [300, 301, 302, 303]: try: redirect_url = response.headers['location'] if 'login.weibo' in redirect_url or 'login.sina' in redirect_url: # Cookie失效 self.logger.warning('Updating Cookies') elif 'weibo.cn/security' in redirect_url: self.logger.warning('Now Cookies' + json.dumps(request.cookies)) self.logger.warning('One Account is locked!') request.cookies = self._get_random_cookies() self.logger.debug('Using Cookies' + json.dumps(request.cookies)) return request except Exception: raise IgnoreRequest elif response.status in [414]: return request else: return response weibostock / weibo / pipelines.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- coding: utf-8 -*-import reimport timeimport pymongofrom weibo.items import WeiboItemclass WeiboPipeline(object): def parse_time(self, datetime): if re.match('\\d+月\\d+日', datetime): datetime = time.strftime('%Y年', time.localtime()) + datetime if re.match('\\d+分钟前', datetime): minute = re.match('(\\d+)', datetime).group(1) datetime = time.strftime('%Y年%m月%d日 %H:%M', time.localtime(time.time() - float(minute) * 60)) if re.match('今天.*', datetime): datetime = re.match('今天(.*)', datetime).group(1).strip() datetime = time.strftime('%Y年%m月%d日', time.localtime()) + ' ' + datetime return datetime def process_item(self, item, spider): if isinstance(item, WeiboItem): if item.get('content'): item['content'] = item['content'].lstrip(':').strip() if item.get('posted_at'): item['posted_at'] = item['posted_at'].strip() item['posted_at'] = self.parse_time(item.get('posted_at')) return itemclass MongoPipeline(object): def __init__(self, mongo_uri, mongo_db): self.mongo_uri = mongo_uri self.mongo_db = mongo_db @classmethod def from_crawler(cls, crawler): return cls( mongo_uri=crawler.settings.get('MONGO_URI'), mongo_db=crawler.settings.get('MONGO_DATABASE') ) def open_spider(self, spider): self.client = pymongo.MongoClient(self.mongo_uri) self.db = self.client[self.mongo_db] def close_spider(self, spider): self.client.close() def process_item(self, item, spider): self.db[item.table_name].update(&#123;'id': item.get('id')&#125;, &#123;'$set': dict(item)&#125;, True) return item weibostock / weibo / settings.py12345678910111213141516171819202122# -*- coding: utf-8 -*-BOT_NAME = 'weibo'SPIDER_MODULES = ['weibo.spiders']NEWSPIDER_MODULE = 'weibo.spiders'ROBOTSTXT_OBEY = FalseDOWNLOADER_MIDDLEWARES = &#123; 'weibo.middlewares.CookiesMiddleWare': 543,&#125;ITEM_PIPELINES = &#123; 'weibo.pipelines.WeiboPipeline': 300, 'weibo.pipelines.MongoPipeline': 301,&#125;COOKIES_POOL_URL = 'http://localhost:5000/weibo/random'MONGO_URI = 'localhost'MONGO_DATABASE = 'weibo' weibostock / weibo / spiders / search.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# -*- coding: utf-8 -*-import refrom scrapy import Spider, Request, FormRequestfrom weibo.items import WeiboItemimport tushare as tsclass SearchSpider(Spider): name = \"search\" allowed_domains = [\"weibo.cn\"] search_url = 'http://weibo.cn/search/mblog' max_page = 200 def start_requests(self): result = ts.get_sz50s() # 深圳50股票 # result = ts.get_zz500s() # result = ts.get_hs300s() self.keywords = result['code'].tolist() # 股票代号生成列表 for keyword in self.keywords: url = '&#123;url&#125;?keyword=&#123;keyword&#125;'.format(url=self.search_url, keyword=keyword) for page in range(self.max_page + 1): data = &#123; 'mp': str(self.max_page), 'page': str(page) &#125; yield FormRequest(url, callback=self.parse_index, formdata=data, meta=&#123;'keyword': keyword&#125;) # meta参数传递数据保存item def parse_index(self, response): weibos = response.xpath('//div[@class=\"c\" and contains(@id, \"M_\")]') for weibo in weibos: is_forward = bool(weibo.xpath('.//span[@class=\"cmt\"]').extract_first()) if is_forward: detail_url = weibo.xpath('.//a[contains(., \"原文评论[\")]//@href').extract_first() else: detail_url = weibo.xpath('(.//a[contains(., \"评论[\")]/@href)').extract_first() yield Request(detail_url, callback=self.parse_detail, meta=&#123;'keyword': response.meta.get('keyword')&#125;) # meta参数传递数据保存item def parse_detail(self, response): url = response.url content = ''.join(response.xpath('//div[@id=\"M_\"]//span[@class=\"ctt\"]//text()').extract()) id = re.search('comment\\/(.*?)\\?', response.url).group(1) comment_count = response.xpath('//span[@class=\"pms\"]//text()').re_first('评论\\[(.*?)\\]') forward_count = response.xpath('//a[contains(., \"转发[\")]//text()').re_first('转发\\[(.*?)\\]') like_count = response.xpath('//a[contains(., \"赞[\")]//text()').re_first('赞\\[(.*?)\\]') posted_at = response.xpath('//div[@id=\"M_\"]//span[@class=\"ct\"]//text()').extract_first(default=None) user = response.xpath('//div[@id=\"M_\"]/div[1]/a/text()').extract_first() keyword = response.meta.get('keyword') # 接收的时候用response.meta.get()获得关键字 weibo_item = WeiboItem() for field in weibo_item.fields: try: weibo_item[field] = eval(field) except NameError: print('Field is Not Defined', field) yield weibo_item 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"Scrapy+Cookies池抓取新浪微博","slug":"Scrapy-Cookies池抓取新浪微博","date":"2018-07-05T09:00:00.000Z","updated":"2018-08-21T09:44:48.051Z","comments":true,"path":"2018/07/05/Scrapy-Cookies池抓取新浪微博/","link":"","permalink":"http://pythonfood.github.io/2018/07/05/Scrapy-Cookies池抓取新浪微博/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、爬取实战1、抓取移动端微博http://weibo.cn/search/mblog 2、启动cookies池(1)启动redis服务。 (2)cmd输入命令python import.py ,再输入微博账号密码，导入数据库。 (3)cmd输入命令python run.py,启动cookies池服务，地址localhost:5000 3、实战weibosearch / scrapy.cfg123456[settings]default = weibo.settings[deploy]#url = http://localhost:6800/project = weibo weibosearch / weibo / items.py12345678910111213141516# -*- coding: utf-8 -*-from scrapy import Item, Fieldclass WeiboItem(Item): table_name = 'weibo' # 数据表名称 id = Field() content = Field() forward_count = Field() comment_count = Field() like_count = Field() posted_at = Field() url = Field() user = Field() crawled_at = Field() # 爬取时间 weibosearch / weibo / middlewares.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# -*- coding: utf-8 -*-import jsonimport loggingimport requestsfrom requests.exceptions import ConnectionErrorfrom scrapy.exceptions import IgnoreRequestclass CookiesMiddleWare(): def __init__(self, cookies_pool_url): self.logger = logging.getLogger(__name__) self.cookies_pool_url = cookies_pool_url def _get_random_cookies(self): # 从cookie池读取cookie try: response = requests.get(self.cookies_pool_url) if response.status_code == 200: return json.loads(response.text) except ConnectionError: return None def process_request(self, request, spider): # 请求request设置cookies cookies = self._get_random_cookies() if cookies: request.cookies = cookies self.logger.debug('Using Cookies ' + json.dumps(cookies)) else: self.logger.debug('No Valid Cookies') @classmethod def from_crawler(cls, crawler): # 获取settings配置cookie池信息 return cls( cookies_pool_url=crawler.settings.get('COOKIES_POOL_URL') ) def process_response(self, request, response, spider): # 返回response,状态码为300重新获取cookies if response.status in [300, 301, 302, 303]: try: redirect_url = response.headers['location'] # 获得重定向url if 'login.weibo' in redirect_url or 'login.sina' in redirect_url: # 如果登录字段在重定向url,则Cookie失效 self.logger.warning('Updating Cookies') elif 'weibo.cn/security' in redirect_url: # 如果安全提示字段在重定向url，账号被锁 self.logger.warning('Now Cookies' + json.dumps(request.cookies)) self.logger.warning('One Account is locked!') request.cookies = self._get_random_cookies() # request需要重新获取cookies self.logger.debug('Using Cookies' + json.dumps(request.cookies)) return request # 重新返回request except Exception: raise IgnoreRequest elif response.status in [414]: # 状态码414返回request return request else: return response # 正常情况返回response weibosearch / weibo / pipelines.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- coding: utf-8 -*-import reimport timeimport pymongofrom weibo.items import WeiboItemclass WeiboPipeline(object): def parse_time(self, datetime): # 清洗发布时间显示，都转换为：x年x月x日 x时:x分 if re.match('\\d+月\\d+日', datetime): # x月x日 x时:x分 datetime = time.strftime('%Y年', time.localtime()) + datetime if re.match('\\d+分钟前', datetime): # x分中前 minute = re.match('(\\d+)', datetime).group(1) datetime = time.strftime('%Y年%m月%d日 %H:%M', time.localtime(time.time() - float(minute) * 60)) if re.match('今天.*', datetime): # 今天 x时:x分 datetime = re.match('今天(.*)', datetime).group(1).strip() datetime = time.strftime('%Y年%m月%d日', time.localtime()) + ' ' + datetime return datetime def process_item(self, item, spider): if isinstance(item, WeiboItem): # 如果item是WeiboItem if item.get('content'): item['content'] = item['content'].lstrip(':').strip() # 内容处理 if item.get('posted_at'): item['posted_at'] = item['posted_at'].strip() item['posted_at'] = self.parse_time(item.get('posted_at')) # 时间处理 return itemclass MongoPipeline(object): def __init__(self, mongo_uri, mongo_db): self.mongo_uri = mongo_uri self.mongo_db = mongo_db @classmethod def from_crawler(cls, crawler): # 获取settings配置信息 return cls( mongo_uri=crawler.settings.get('MONGO_URI'), mongo_db=crawler.settings.get('MONGO_DATABASE') ) def open_spider(self, spider): # 开启spider时连接数据库 self.client = pymongo.MongoClient(self.mongo_uri) self.db = self.client[self.mongo_db] def close_spider(self, spider): # 关闭spider时关闭数据库 self.client.close() def process_item(self, item, spider): # 主程序，往数据表跟新或插入数据，同时去重 self.db[item.table_name].update(&#123;'id': item.get('id')&#125;, &#123;'$set': dict(item)&#125;, True) return item weibosearch / weibo / settings.py12345678910111213141516171819202122# -*- coding: utf-8 -*-BOT_NAME = 'weibo'SPIDER_MODULES = ['weibo.spiders']NEWSPIDER_MODULE = 'weibo.spiders'ROBOTSTXT_OBEY = FalseDOWNLOADER_MIDDLEWARES = &#123; 'weibo.middlewares.CookiesMiddleWare': 543,&#125;ITEM_PIPELINES = &#123; 'weibo.pipelines.WeiboPipeline': 300, 'weibo.pipelines.MongoPipeline': 301,&#125;COOKIES_POOL_URL = 'http://localhost:5000/weibo/random' # cookie池服务地址MONGO_URI = 'localhost'MONGO_DATABASE = 'weibo' weibosearch / weibo / spiders / search.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- coding: utf-8 -*-import refrom scrapy import Spider, Request, FormRequestfrom weibo.items import WeiboItemclass SearchSpider(Spider): name = \"search\" allowed_domains = [\"weibo.cn\"] search_url = 'http://weibo.cn/search/mblog' max_page = 200 # 最大请求页为200 keywords = ['000001'] # 搜索关键字列表，示例是一个股票代码 def start_requests(self): # 初始请求 for keyword in self.keywords: url = '&#123;url&#125;?keyword=&#123;keyword&#125;'.format(url=self.search_url, keyword=keyword) # 格式化请求的url for page in range(self.max_page + 1): data = &#123; 'mp': str(self.max_page), # 参数mp最大请求页 'page': str(page) # 请求页 &#125; yield FormRequest(url, callback=self.parse_index, formdata=data) # 生成器生成FormRequest,回调parse_index def parse_index(self, response): # 解析索引页 weibos = response.xpath('//div[@class=\"c\" and contains(@id, \"M_\")]') # 获得微博列表 print(len(weibos), weibos) for weibo in weibos: # 循环微博列表 is_forward = bool(weibo.xpath('.//span[@class=\"cmt\"]').extract_first()) # 是否转发 if is_forward: detail_url = weibo.xpath('.//a[contains(., \"原文评论[\")]//@href').extract_first() # 如果转发的，获取原文评论 else: detail_url = weibo.xpath('(.//a[contains(., \"评论[\")]/@href)').extract_first() # 如果不是转发的，获取评论 yield Request(detail_url, callback=self.parse_detail) # 生成request，回调parse_detail def parse_detail(self, response): # 解析详情页 url = response.url content = ''.join(response.xpath('//div[@id=\"M_\"]//span[@class=\"ctt\"]//text()').extract()) # 微博正文需要拼接 id = re.search('comment\\/(.*?)\\?', response.url).group(1) comment_count = response.xpath('//span[@class=\"pms\"]//text()').re_first('评论\\[(.*?)\\]') forward_count = response.xpath('//a[contains(., \"转发[\")]//text()').re_first('转发\\[(.*?)\\]') like_count = response.xpath('//a[contains(., \"赞[\")]//text()').re_first('赞\\[(.*?)\\]') posted_at = response.xpath('//div[@id=\"M_\"]//span[@class=\"ct\"]//text()').extract_first(default=None) user = response.xpath('//div[@id=\"M_\"]/div[1]/a/text()').extract_first() weibo_item = WeiboItem() # 实例化weiboitem for field in weibo_item.fields: # 遍历weiboitem的字段 try: weibo_item[field] = eval(field) # eval可以动态的获取field进行赋值 except NameError: print('Field is Not Defined', field) yield weibo_item 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"Scrapy爬取知乎用户信息实战","slug":"Scrapy爬取知乎用户信息实战","date":"2018-07-05T08:00:00.000Z","updated":"2018-08-21T09:39:50.251Z","comments":true,"path":"2018/07/05/Scrapy爬取知乎用户信息实战/","link":"","permalink":"http://pythonfood.github.io/2018/07/05/Scrapy爬取知乎用户信息实战/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、爬取实战1、爬取知乎用户信息假设一个用户有三个粉丝，三个粉丝又各自有三个粉丝，以此类推，粉丝数越来越多。我们可以采取递归方式的抓取方式，只要是有粉丝有关注的用户都可以适用这种抓取方式。那些零关注零粉丝的⼤大虾就放过他们吧。 2、思路(1)选定起始人 选定一位关注数或粉丝数多的大V作为爬取起始点。 (2)获取粉丝和关注列表 通过知乎接口获得该大V的粉丝列表和关注列表。 (3)获取列表用户信息 通过知乎接口获得列表中每位用户的详细信息。 (4)获取每位用户粉丝和关注 进一步对列表中的每一个用户，获取他们的粉丝和关注列表，实现递归爬取。 3、实战以大V轮子哥为起始人：https://www.zhihu.com/people/excited-vczh/activities 从关注列表和粉丝列表两大递归方向获取每个用户的信息。 zhihuuser / scrapy.cfg123456[settings]default = zhihuuser.settings[deploy]#url = http://localhost:6800/project = zhihuuser zhihuuser / zhihuuser / items.py123456789101112131415161718192021222324252627282930313233343536373839404142434445# -*- coding: utf-8 -*-from scrapy import Item, Fieldclass UserItem(Item): # 定义保存数据的数据结构 # define the fields for your item here like: id = Field() name = Field() avatar_url = Field() headline = Field() description = Field() url = Field() url_token = Field() gender = Field() cover_url = Field() type = Field() badge = Field() answer_count = Field() articles_count = Field() commercial_question_count = Field() favorite_count = Field() favorited_count = Field() follower_count = Field() following_columns_count = Field() following_count = Field() pins_count = Field() question_count = Field() thank_from_count = Field() thank_to_count = Field() thanked_count = Field() vote_from_count = Field() vote_to_count = Field() voteup_count = Field() following_favlists_count = Field() following_question_count = Field() following_topic_count = Field() marked_answers_count = Field() mutual_followees_count = Field() hosted_live_count = Field() participated_live_count = Field() locations = Field() educations = Field() employments = Field() zhihuuser / zhihuuser / middlewares.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- coding: utf-8 -*-from scrapy import signalsclass ZhihuSpiderMiddleware(object): # Not all methods need to be defined. If a method is not defined, # scrapy acts as if the spider middleware does not modify the # passed objects. @classmethod def from_crawler(cls, crawler): # This method is used by Scrapy to create your spiders. s = cls() crawler.signals.connect(s.spider_opened, signal=signals.spider_opened) return s def process_spider_input(response, spider): # Called for each response that goes through the spider # middleware and into the spider. # Should return None or raise an exception. return None def process_spider_output(response, result, spider): # Called with the results returned from the Spider, after # it has processed the response. # Must return an iterable of Request, dict or Item objects. for i in result: yield i def process_spider_exception(response, exception, spider): # Called when a spider or process_spider_input() method # (from other spider middleware) raises an exception. # Should return either None or an iterable of Response, dict # or Item objects. pass def process_start_requests(start_requests, spider): # Called with the start requests of the spider, and works # similarly to the process_spider_output() method, except # that it doesn’t have a response associated. # Must return only requests (not items). for r in start_requests: yield r def spider_opened(self, spider): spider.logger.info('Spider opened: %s' % spider.name) zhihuuser / zhihuuser / pipelines.py1234567891011121314151617181920212223242526272829303132333435# -*- coding: utf-8 -*-import pymongoclass ZhihuPipeline(object): def process_item(self, item, spider): return itemclass MongoPipeline(object): # 保存数据到mongodb collection_name = 'users' # 定义数据库集合名称 def __init__(self, mongo_uri, mongo_db): self.mongo_uri = mongo_uri self.mongo_db = mongo_db @classmethod def from_crawler(cls, crawler): # 获取settings中的MONGO_URI和MONGO_DATABASE return cls( mongo_uri=crawler.settings.get('MONGO_URI'), mongo_db=crawler.settings.get('MONGO_DATABASE') ) def open_spider(self, spider): # 启动spider时连接mongo_db self.client = pymongo.MongoClient(self.mongo_uri) self.db = self.client[self.mongo_db] def close_spider(self, spider): # 关闭spider时关闭数据库 self.client.close() def process_item(self, item, spider): # 项目管道主程序，update()有去重、插入、更新多重作用。 # 第一个参数是查询条件，第二个传入的参数，第三个参数设置为True表示按照查询条件，如果查询到了进行更行，没查找到则进行插入 self.db[self.collection_name].update(&#123;'url_token': item['url_token']&#125;, dict(item), True) return item zhihuuser / zhihuuser / settings.py123456789101112131415161718192021# -*- coding: utf-8 -*-BOT_NAME = 'zhihuuser'SPIDER_MODULES = ['zhihuuser.spiders']NEWSPIDER_MODULE = 'zhihuuser.spiders'ROBOTSTXT_OBEY = False # 设置为False，表示不遵守robotstxt协议，防止部分内容不能爬取DEFAULT_REQUEST_HEADERS = &#123; # 知乎这两个headers字段必须设置，不然不能正常访问 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36', 'authorization': 'oauth c3cef7c66a1843f8b3a9e6a1e3160e20',&#125;ITEM_PIPELINES = &#123; 'zhihuuser.pipelines.MongoPipeline': 300, # 设置启动MongoPipeline # 'scrapy_redis.pipelines.RedisPipeline': 301&#125;MONGO_URI = 'localhost' # 设置MongoDB的hostMONGO_DATABASE = 'zhihu' # 设置MongoDB的数据库名称 zhihuuser / zhihuuser / spiders / zhihu.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# -*- coding: utf-8 -*-import jsonfrom scrapy import Spider, Requestfrom zhihuuser.items import UserItemclass ZhihuSpider(Spider): name = \"zhihu\" allowed_domains = [\"www.zhihu.com\"] user_url = 'https://www.zhihu.com/api/v4/members/&#123;user&#125;?include=&#123;include&#125;' follows_url = 'https://www.zhihu.com/api/v4/members/&#123;user&#125;/followees?include=&#123;include&#125;&amp;offset=&#123;offset&#125;&amp;limit=&#123;limit&#125;' followers_url = 'https://www.zhihu.com/api/v4/members/&#123;user&#125;/followers?include=&#123;include&#125;&amp;offset=&#123;offset&#125;&amp;limit=&#123;limit&#125;' start_user = 'excited-vczh' user_query = 'locations,employments,gender,educations,business,voteup_count,thanked_Count,follower_count,following_count,cover_url,following_topic_count,following_question_count,following_favlists_count,following_columns_count,answer_count,articles_count,pins_count,question_count,commercial_question_count,favorite_count,favorited_count,logs_count,marked_answers_count,marked_answers_text,message_thread_token,account_status,is_active,is_force_renamed,is_bind_sina,sina_weibo_url,sina_weibo_name,show_sina_weibo,is_blocking,is_blocked,is_following,is_followed,mutual_followees_count,vote_to_count,vote_from_count,thank_to_count,thank_from_count,thanked_count,description,hosted_live_count,participated_live_count,allow_message,industry_category,org_name,org_homepage,badge[?(type=best_answerer)].topics' follows_query = 'data[*].answer_count,articles_count,gender,follower_count,is_followed,is_following,badge[?(type=best_answerer)].topics' followers_query = 'data[*].answer_count,articles_count,gender,follower_count,is_followed,is_following,badge[?(type=best_answerer)].topics' def start_requests(self): # 起始请求 # 请求起始人，回调用户解析 yield Request(self.user_url.format(user=self.start_user, include=self.user_query), self.parse_user) # 请求关注列表，回调关注列表解析 yield Request(self.follows_url.format(user=self.start_user, include=self.follows_query, limit=20, offset=0), self.parse_follows) # 请求粉丝列表，回调粉丝列表解析 yield Request(self.followers_url.format(user=self.start_user, include=self.followers_query, limit=20, offset=0), self.parse_followers) def parse_user(self, response): # 用户解析 result = json.loads(response.text) item = UserItem() for field in item.fields: # 返回结果生成item if field in result.keys(): item[field] = result.get(field) yield item # 请求关注列表，回调关注列表解析 yield Request( self.follows_url.format(user=result.get('url_token'), include=self.follows_query, limit=20, offset=0), self.parse_follows) # 请求粉丝列表，回调粉丝列表解析 yield Request( self.followers_url.format(user=result.get('url_token'), include=self.followers_query, limit=20, offset=0), self.parse_followers) def parse_follows(self, response): # 关注列表解析 results = json.loads(response.text) if 'data' in results.keys(): for result in results.get('data'): # 请求用户界面，回调用户解析 yield Request(self.user_url.format(user=result.get('url_token'), include=self.user_query), self.parse_user) if 'paging' in results.keys() and results.get('paging').get('is_end') == False: next_page = results.get('paging').get('next') # 请求下一页，回调关注列表解析 yield Request(next_page, self.parse_follows) def parse_followers(self, response): # 粉丝列表解析 results = json.loads(response.text) if 'data' in results.keys(): for result in results.get('data'): # 请求用户界面，回调用户解析 yield Request(self.user_url.format(user=result.get('url_token'), include=self.user_query), self.parse_user) if 'paging' in results.keys() and results.get('paging').get('is_end') == False: next_page = results.get('paging').get('next') # 请求下一页，回调粉丝列表解析 yield Request(next_page, self.parse_followers) 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"Scrapy中Download Middleware的用法","slug":"Scrapy中Download-Middleware的用法","date":"2018-07-05T07:00:00.000Z","updated":"2018-08-16T05:02:51.753Z","comments":true,"path":"2018/07/05/Scrapy中Download-Middleware的用法/","link":"","permalink":"http://pythonfood.github.io/2018/07/05/Scrapy中Download-Middleware的用法/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、基本使用1、Downloader Middleware中文文档0.25.0http://scrapy-chs.readthedocs.io/zh_CN/latest/topics/downloader-middleware.html 2、Downloader Middleware下载器中间件下载器中间件是介于Scrapy的request/response处理的钩子框架。 是用于全局修改Scrapy request和response的一个轻量、底层的系统。 3、激活下载器中间件 settings中设置DOWNLOADER_MIDDLEWARES选项。 设置一个字典(dict)，键为中间件类的路径，值为其中间件的顺序(order)。例如： 123DOWNLOADER_MIDDLEWARES = &#123; &apos;myproject.middlewares.CustomDownloaderMiddleware&apos;: 543,&#125; DOWNLOADER_MIDDLEWARES设置会与Scrapy定义的DOWNLOADER_MIDDLEWARES_BASE 设置合并(但不是覆盖)， 而后根据顺序(order)进行排序，最后得到启用中间件的有序列表: 第一个中间件是最靠近引擎的，最后一个中间件是最靠近下载器的。 如果想禁止内置的(在 DOWNLOADER_MIDDLEWARES_BASE 中设置并默认启用的)中间件， 必须在项目的 DOWNLOADER_MIDDLEWARES 设置中定义该中间件，并将其值赋为 None 。 例如，关闭user-agent中间件: 1234DOWNLOADER_MIDDLEWARES = &#123; &apos;myproject.middlewares.CustomDownloaderMiddleware&apos;: 543, &apos;scrapy.contrib.downloadermiddleware.useragent.UserAgentMiddleware&apos;: None,&#125; 获得内置的DOWNLOADER_MIDDLEWARES_BASE中间件，命令行输入命令scrapy settings --get=DOWNLOADER_MIDDLEWARES_BASE，回显例如： 1234567891011121314&#123;&quot;scrapy.downloadermiddlewares.robotstxt.RobotsTxtMiddleware&quot;: 100, &quot;scrapy.downloadermiddlewares.httpauth.HttpAuthMiddleware&quot;: 300, &quot;scrapy.downloadermiddlewares.downloadtimeout.DownloadTimeoutMiddleware&quot;: 350, &quot;scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware&quot;: 400, &quot;scrapy.downloadermiddlewares.useragent.UserAgentMiddleware&quot;: 500, &quot;scrapy.downloadermiddlewares.retry.RetryMiddleware&quot;: 550, &quot;scrapy.downloadermiddlewares.ajaxcrawl.AjaxCrawlMiddleware&quot;: 560, &quot;scrapy.downloadermiddlewares.redirect.MetaRefreshMiddleware&quot;: 580, &quot;scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware&quot;: 590, &quot;scrapy.downloadermiddlewares.redirect.RedirectMiddleware&quot;: 600, &quot;scrapy.downloadermiddlewares.cookies.CookiesMiddleware&quot;: 700, &quot;scrapy.downloadermiddlewares.httpproxy.HttpProxyMiddleware&quot;: 750, &quot;scrapy.downloadermiddlewares.stats.DownloaderStats&quot;: 850, &quot;scrapy.downloadermiddlewares.httpcache.HttpCacheMiddleware&quot;: 900&#125; 4、编写下载器中间件 process_request(request, spider) process_response(request, response, spider) process_exception(request, exception, spider) 详见官方文档 5、其他内置的MIDDLEWARE详见官方文档 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"Scrapy中Item Pipeline的用法","slug":"Scrapy中Item-Pipeline的用法","date":"2018-07-05T06:00:00.000Z","updated":"2018-08-16T05:05:49.875Z","comments":true,"path":"2018/07/05/Scrapy中Item-Pipeline的用法/","link":"","permalink":"http://pythonfood.github.io/2018/07/05/Scrapy中Item-Pipeline的用法/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、基本使用1、Item Pipeline中文文档0.24.0http://scrapy-chs.readthedocs.io/zh_CN/latest/topics/item-pipeline.html 2、Item Pipeline的一些典型应用 清理HTML数据 验证爬取的数据(检查item包含某些字段) 查重(并丢弃) 将爬取结果保存到数据库中 3、Item Pipeline process_item() 每个item pipeline组件都需要调用该方法，这个方法必须返回一个 Item (或任何继承类)对象， 或是抛出 DropItem 异常。 open_spider() 当spider被开启时，这个方法被调用。 close_spider() 当spider被关闭时，这个方法被调用。 from_crawler() 可以获取项目settings中的一些配置信息。 4、Item Pipeline样例 将item写入JSON文件： 1234567891011121314import jsonclass JsonWriterPipeline(object): def open_spider(self, spider): self.file = open(&apos;items.jl&apos;, &apos;w&apos;) def close_spider(self, spider): self.file.close() def process_item(self, item, spider): line = json.dumps(dict(item)) + &quot;\\n&quot; self.file.write(line) return item 将item写入MongoDB数据库： 123456789101112131415161718192021222324252627import pymongoclass MongoPipeline(object): collection_name = &apos;scrapy_items&apos; def __init__(self, mongo_uri, mongo_db): self.mongo_uri = mongo_uri self.mongo_db = mongo_db @classmethod def from_crawler(cls, crawler): return cls( mongo_uri=crawler.settings.get(&apos;MONGO_URI&apos;), mongo_db=crawler.settings.get(&apos;MONGO_DATABASE&apos;, &apos;items&apos;) ) def open_spider(self, spider): self.client = pymongo.MongoClient(self.mongo_uri) self.db = self.client[self.mongo_db] def close_spider(self, spider): self.client.close() def process_item(self, item, spider): self.db[self.collection_name].insert_one(dict(item)) return item 截取item网页截图： 12345678910111213141516171819202122232425262728293031323334import scrapyimport hashlibfrom urllib.parse import quoteclass ScreenshotPipeline(object): &quot;&quot;&quot;Pipeline that uses Splash to render screenshot of every Scrapy item.&quot;&quot;&quot; SPLASH_URL = &quot;http://localhost:8050/render.png?url=&#123;&#125;&quot; def process_item(self, item, spider): encoded_item_url = quote(item[&quot;url&quot;]) screenshot_url = self.SPLASH_URL.format(encoded_item_url) request = scrapy.Request(screenshot_url) dfd = spider.crawler.engine.download(request, spider) dfd.addBoth(self.return_item, item) return dfd def return_item(self, response, item): if response.status != 200: # Error happened, return item. return item # Save screenshot to file, filename will be hash of url. url = item[&quot;url&quot;] url_hash = hashlib.md5(url.encode(&quot;utf8&quot;)).hexdigest() filename = &quot;&#123;&#125;.png&quot;.format(url_hash) with open(filename, &quot;wb&quot;) as f: f.write(response.body) # Store filename in item. item[&quot;screenshot_filename&quot;] = filename return item 去重： 12345678910111213from scrapy.exceptions import DropItemclass DuplicatesPipeline(object): def __init__(self): self.ids_seen = set() def process_item(self, item, spider): if item[&apos;id&apos;] in self.ids_seen: raise DropItem(&quot;Duplicate item found: %s&quot; % item) else: self.ids_seen.add(item[&apos;id&apos;]) return item 5、启用一个Item Pipeline组件：在settings的ITEM_PIPELINES选项里填写：pipline名称:数字优先级。通常将这些数字定义在0-1000范围内，数字越小优先级越高。例如： 1234ITEM_PIPELINES = &#123; &apos;myproject.pipelines.PricePipeline&apos;: 300, &apos;myproject.pipelines.JsonWriterPipeline&apos;: 800,&#125; 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"Scrapy中Spiders用法","slug":"Scrapy中Spiders用法","date":"2018-07-05T05:00:00.000Z","updated":"2018-08-16T05:05:00.989Z","comments":true,"path":"2018/07/05/Scrapy中Spiders用法/","link":"","permalink":"http://pythonfood.github.io/2018/07/05/Scrapy中Spiders用法/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、基本使用1、scrapy中文文档文档地址：http://scrapy-chs.readthedocs.io/zh_CN/latest 其中spider部分：http://scrapy-chs.readthedocs.io/zh_CN/latest/topics/spiders.html 2、Spider中文文档0.25.0里未翻译的部分简介 custom_settings 类里面的一个特定设置，可以覆盖settings里面的全局设置。以字典形式覆盖即可,例如： 123456custom_settings = &#123; DEFAULT_REQUEST_HEADERS = &#123; &apos;Accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&apos;, &apos;Accept-Language&apos;: &apos;en&apos;, &#125;&#125; crawler 是Crawler类的一个实例对象，扩展访问scrapy核心组件和挂载scrapy的唯一途径。 settings 是Settings类的一个实例对象，可以控制包括核心插件、pipeline、其他spider组件的相应的配置。 from_crawler() 是一个类方法，在类里面定义这个方法，可以通过这个类拿到全局的settings的一些设置。例如： 1234567891011def __init__(self, mongo_uri, mongo_db, *args, **kwargs): super(MySpider, self).__init__(*args, **kwargs) self.mongo_uri = mongo_uri self.mongo_db = mongo_db@classmethoddef from_crawler(cls, crawler): return cls( mongo_uri=crawler.settings.get(&apos;MONGO_URI&apos;), mongo_db=crawler.settings.get(&apos;MONGO_DB&apos;) ) 3、Spider英文文档1.5.0中增加部分简介 logger 可以直接调用logger输出日志，例如： 1self.logger.info(response.status) Spider arguments 可以通过命令行scrapy crawl myspider -a category=electronics，指定category传入一些相应的额外参数。例如： 123456789import scrapyclass MySpider(scrapy.Spider): name = &apos;myspider&apos; def __init__(self, category=None, *args, **kwargs): super(MySpider, self).__init__(*args, **kwargs) self.start_urls = [&apos;http://www.example.com/categories/%s&apos; % category] # ... 4、特定的spider后面还提供了一些特定的spider，应用于一些定制化的需求。例如：CrawlSpider、XMLFeedSpider、CSVFeedSpider、SitemapSpider。 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"Scrapy中选择器用法","slug":"Scrapy中选择器用法","date":"2018-07-05T04:00:00.000Z","updated":"2018-08-16T05:02:11.340Z","comments":true,"path":"2018/07/05/Scrapy中选择器用法/","link":"","permalink":"http://pythonfood.github.io/2018/07/05/Scrapy中选择器用法/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、基本使用1、选择器是scrapy内置的一个selector对象测试的网址：https://doc.scrapy.org/en/latest/_static/selectors-sample1.html 2、命令行模式测试scrapy shell https://doc.scrapy.org/en/latest/_static/selectors-sample1.html # 进入交互模式 response.selector # scrapy内置的选择器的类 response.selector.xpath(&#39;//title/text()&#39;) # xpath()返回一个Selector的list response.selector.css(&#39;title::text&#39;) # css()返回一个Selector的list response.selector.xpath(&#39;//title/text()&#39;).extract_first() # extract_first()可以获取具体的内容 response.selector.css(&#39;title::text&#39;).extract() # extract可以获取具体内容的列表 response.xpath(&#39;//title/text()&#39; # 直接用.xpath简写模式，可以省去.selector response.css(&#39;title::text&#39;) # .css简写模式 response.xpath(&#39;//div[@id=&quot;images&quot;]&#39;) # 1.首先用xpath定位到这个div标签 response.xpath(&#39;//div[@id=&quot;images&quot;]&#39;).css(&#39;img&#39;) # 2.然后用css获取img标签的list response.xpath(&#39;//div[@id=&quot;images&quot;]&#39;).css(&#39;img::attr(src)&#39;) # 3.接着用::attr获取src属性的列表 response.xpath(&#39;//div[@id=&quot;images&quot;]&#39;).css(&#39;img::attr(src)&#39;).extract() # 4.最后用extract获取具体的属性值列表 response.xpath(&#39;//div[@id=&quot;images&quot;]&#39;).css(&#39;img::attr(src)&#39;).extract_first(defaut=&#39;&#39;) #用default设置默认值，查找不到的话用default代替 response.xpath(&#39;//a/@href&#39;).extract() # xpath获取属性值 response.css(&#39;a::attr(href)&#39;).extract() # css获取属性值 response.xpath(&#39;//a/text()&#39;).extract() # xpath获取内容值 response.css(&#39;a::text&#39;).extract() # css获取内容值 response.xpath(&#39;//a[contains(@href,&quot;image&quot;)]/@href&#39;).extract() # xpath查找所有a标签下href属性名称包含”image”的超链接值 response.css(&#39;a[href*=image]::attr(href)&#39;).extract() # css查找所有a标签下href属性名称包含”image”的超链接值 response.xpath(&#39;//a[contains(@href,&quot;image&quot;)]/img/@src&#39;).extract() # xpath查找所有a标签(href属性名称包含”image”)下img标签下src属性值 response.css(&#39;a[href*=image] img::attr(src)&#39;).extract() # css查找所有a标签(href属性名称包含”image”)下img标签下src属性值 response.css(&#39;a::text&#39;).re(&#39;Name\\:(.*)&#39;) # 通过re正则匹配，返回的是（.*）里的内容，‘Name\\:’是匹配的起始位置 response.css(&#39;a::text&#39;).re_first(&#39;Name\\:(.*)&#39;).strip() # rere_first返回正则匹配的第一个值，strip()去除前后的空格 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"Scrapy命令行详解","slug":"Scrapy命令行详解","date":"2018-07-05T03:00:00.000Z","updated":"2018-08-16T02:58:55.552Z","comments":true,"path":"2018/07/05/Scrapy命令行详解/","link":"","permalink":"http://pythonfood.github.io/2018/07/05/Scrapy命令行详解/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、命令行详解1、Scrapy官方文档https://doc.scrapy.org/en/latest/ 2、命令行详解scrapy startproject testproject # 新建项目 cd testproject scrapy genspider baidu www.baidu.com # 生成spider cd testproject cd spiders scrapy genspider -l # 列出所有的模板 scrapy genspider -t crawl zhihu www.zhihu.com # 指定crwal模板，生成spider scrapy crawl zhihu # 运行爬虫 scrapy crawl baidu scrapy check # 检查代码错误 scrapy list # 列出项目所有的spider scrapy edit zhihu # 在命令行下编辑spider cd ../../../ scrapy fetch http://www.baidu.com # download一个网页，返回网页源代码 scrapy fetch --nolog http://www.baidu.com # 返回网页源代码时，不会显示日志信息 scrapy fetch --headers http://www.baidu.com # 返回网页源代码时，返回headers信息 scrapy fetch --no-redirect http://www.baidu.com # 请求网页时，不能重定向 scrapy view http://www.baidu.com # 请求网页，生成document下载下来，并用浏览器自动打开 scrapy view http://www.taobao.com # 会发现淘宝的网页很多内容不显示，因为都是用ajax加载的 scrapy shell https://www.baidu.com # 进入命令行交互模式 request # 交互模式下进行操作 reponse.text # 交互模式下进行操作 reponse.headers # 交互模式下进行操作 response.css(&#39;title::text&#39;).extract_first() # 交互模式下进行操作 view(response) # 交互模式下进行操作 exit() # 退出交互模式 cd D:\\PycharmProjects\\quotetutroial scrapy parse http://quotes.toscrape.com --callback parse # parse方法，传入url，指定参数，看下解析结果 scrapy settings --get MONGO_URI # settings方法，获取一些配置信息 scrapy settings -h # 获取一些帮助信息 scrapy settings --getbool=ROBOTSTXT_OBEY # 验证下是否遵循ROBOTSTXT_OBEY这个规则 scrapy runspider quotes.py # 运行spider，注意文件名带.py scrapy version # 输出scrapy版本 scrapy version -v # 输出一些依赖库的版本 scrapy bench # 测试下当前的爬行速度 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"Scrapy框架基本使用","slug":"Scrapy框架基本使用","date":"2018-07-05T02:00:00.000Z","updated":"2018-08-21T09:48:51.757Z","comments":true,"path":"2018/07/05/Scrapy框架基本使用/","link":"","permalink":"http://pythonfood.github.io/2018/07/05/Scrapy框架基本使用/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、基本使用1、目标站点http://quotes.toscrape.com/ 2、流程框架(1)抓取第一页 请求第一页URL并得到源代码，进行下一步分析。 (2)获取内容和下一页链接 分析源代码，获取首页内容，获取下一页链接等待进一步爬取。 (3)翻页爬取 请求下一页信息，分析内容并请求再下一页链接。 (4)保存爬取结果 将爬取结果保存为特定格式如文本、数据库。 3、爬虫实战命令行输入： 新建工程：scrapy startproject quotetutroial 进入目录：cd quotetutroial 生成爬虫：scrapy genspider quotes quotes.toscrape.com 项目结构： scrapy.cfg 配置文件 items.py 保存数据的数据结构 middlewares.py 爬取过程中定义的一些中间件 pipelines.py 项目管道，可以输出一些items settings.py 定义的一些配置信息 spider/quotes.py 主要的运行代码 运行爬虫：scrapy crawl quotes 4、项目代码quotetutroial / scrapy.cfg1234567891011# Automatically created by: scrapy startproject## For more information about the [deploy] section see:# https://scrapyd.readthedocs.io/en/latest/deploy.html[settings]default = quotetutroial.settings[deploy]#url = http://localhost:6800/project = quotetutroial quotetutroial / quotetutroial / items.py12345678910111213141516# -*- coding: utf-8 -*-# Define here the models for your scraped items## See documentation in:# https://doc.scrapy.org/en/latest/topics/items.htmlimport scrapyclass QuoteItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() # 爬取完后，一个一个进行赋值，生成一个整体 text = scrapy.Field() author = scrapy.Field() tags = scrapy.Field() quotetutroial / quotetutroial / middlewares.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102# -*- coding: utf-8 -*-# Define here the models for your spider middleware## See documentation in:# https://doc.scrapy.org/en/latest/topics/spider-middleware.htmlfrom scrapy import signalsclass QuotetutroialSpiderMiddleware(object): # Not all methods need to be defined. If a method is not defined, # scrapy acts as if the spider middleware does not modify the # passed objects. @classmethod def from_crawler(cls, crawler): # This method is used by Scrapy to create your spiders. s = cls() crawler.signals.connect(s.spider_opened, signal=signals.spider_opened) return s def process_spider_input(self, response, spider): # Called for each response that goes through the spider # middleware and into the spider. # Should return None or raise an exception. return None def process_spider_output(self, response, result, spider): # Called with the results returned from the Spider, after # it has processed the response. # Must return an iterable of Request, dict or Item objects. for i in result: yield i def process_spider_exception(self, response, exception, spider): # Called when a spider or process_spider_input() method # (from other spider middleware) raises an exception. # Should return either None or an iterable of Response, dict # or Item objects. pass def process_start_requests(self, start_requests, spider): # Called with the start requests of the spider, and works # similarly to the process_spider_output() method, except # that it doesn’t have a response associated. # Must return only requests (not items). for r in start_requests: yield r def spider_opened(self, spider): spider.logger.info('Spider opened: %s' % spider.name)class QuotetutroialDownloaderMiddleware(object): # Not all methods need to be defined. If a method is not defined, # scrapy acts as if the downloader middleware does not modify the # passed objects. @classmethod def from_crawler(cls, crawler): # This method is used by Scrapy to create your spiders. s = cls() crawler.signals.connect(s.spider_opened, signal=signals.spider_opened) return s def process_request(self, request, spider): # Called for each request that goes through the downloader # middleware. # Must either: # - return None: continue processing this request # - or return a Response object # - or return a Request object # - or raise IgnoreRequest: process_exception() methods of # installed downloader middleware will be called return None def process_response(self, request, response, spider): # Called with the response returned from the downloader. # Must either; # - return a Response object # - return a Request object # - or raise IgnoreRequest return response def process_exception(self, request, exception, spider): # Called when a download handler or a process_request() # (from other downloader middleware) raises an exception. # Must either: # - return None: continue processing this exception # - return a Response object: stops process_exception() chain # - return a Request object: stops process_exception() chain pass def spider_opened(self, spider): spider.logger.info('Spider opened: %s' % spider.name) quotetutroial / quotetutroial / pipelines.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# -*- coding: utf-8 -*-# Define your item pipelines here## Don't forget to add your pipeline to the ITEM_PIPELINES setting# See: https://doc.scrapy.org/en/latest/topics/item-pipeline.htmlimport pymongofrom scrapy.exceptions import DropItemclass TextPipeline(object): def __init__(self): self.limit = 50 def process_item(self, item, spider): if item['text']: if len(item['text']) &gt; self.limit: item['text'] = item['text'][0:self.limit].rstrip() + '...' return item else: return DropItem('Missing Text')class MongoPipeline(object): def __init__(self, mongo_uri, mongo_db): self.mongo_uri = mongo_uri self.mongo_db = mongo_db @classmethod def from_crawler(cls, crawler): # from_crawler方法可以从setting.py里拿到相应的配置信息 return cls( mongo_uri=crawler.settings.get('MONGO_URI'), mongo_db=crawler.settings.get('MONGO_DB') ) # 这是一个类方法，需要返回一个class对象 def open_spider(self, spider): # open_spider方法定义爬虫将要启动时的操作 self.client = pymongo.MongoClient(self.mongo_uri) self.db = self.client[self.mongo_db] def process_item(self, item, spider): name = item.__class__.__name__ # 将item的名称传给下边db表名 self.db[name].insert(dict(item)) return item def close_spider(self, spider): self.client.close() # 要想pipeline生效，需要在settings.py里指定ITEM_PIPELINES,序号越小优先级越高 # 这里指定了两个pipeline，假设删掉一个pipline，那么只会执行另外一个pipline quotetutroial / quotetutroial / settings.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293# -*- coding: utf-8 -*-# Scrapy settings for quotetutroial project## For simplicity, this file contains only settings considered important or# commonly used. You can find more settings consulting the documentation:## https://doc.scrapy.org/en/latest/topics/settings.html# https://doc.scrapy.org/en/latest/topics/downloader-middleware.html# https://doc.scrapy.org/en/latest/topics/spider-middleware.htmlBOT_NAME = 'quotetutroial'SPIDER_MODULES = ['quotetutroial.spiders']NEWSPIDER_MODULE = 'quotetutroial.spiders'MONGO_URI = 'localhost'MONGO_DB = 'quotestutorial'# Crawl responsibly by identifying yourself (and your website) on the user-agent#USER_AGENT = 'quotetutroial (+http://www.yourdomain.com)'# Obey robots.txt rulesROBOTSTXT_OBEY = True# Configure maximum concurrent requests performed by Scrapy (default: 16)#CONCURRENT_REQUESTS = 32# Configure a delay for requests for the same website (default: 0)# See https://doc.scrapy.org/en/latest/topics/settings.html#download-delay# See also autothrottle settings and docs#DOWNLOAD_DELAY = 3# The download delay setting will honor only one of:#CONCURRENT_REQUESTS_PER_DOMAIN = 16#CONCURRENT_REQUESTS_PER_IP = 16# Disable cookies (enabled by default)#COOKIES_ENABLED = False# Disable Telnet Console (enabled by default)#TELNETCONSOLE_ENABLED = False# Override the default request headers:#DEFAULT_REQUEST_HEADERS = &#123;# 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',# 'Accept-Language': 'en',#&#125;# Enable or disable spider middlewares# See https://doc.scrapy.org/en/latest/topics/spider-middleware.html#SPIDER_MIDDLEWARES = &#123;# 'quotetutroial.middlewares.QuotetutroialSpiderMiddleware': 543,#&#125;# Enable or disable downloader middlewares# See https://doc.scrapy.org/en/latest/topics/downloader-middleware.html#DOWNLOADER_MIDDLEWARES = &#123;# 'quotetutroial.middlewares.QuotetutroialDownloaderMiddleware': 543,#&#125;# Enable or disable extensions# See https://doc.scrapy.org/en/latest/topics/extensions.html#EXTENSIONS = &#123;# 'scrapy.extensions.telnet.TelnetConsole': None,#&#125;# Configure item pipelines# See https://doc.scrapy.org/en/latest/topics/item-pipeline.htmlITEM_PIPELINES = &#123; #'quotetutroial.pipelines.TextPipeline': 300, 'quotetutroial.pipelines.MongoPipeline': 400,&#125;# Enable and configure the AutoThrottle extension (disabled by default)# See https://doc.scrapy.org/en/latest/topics/autothrottle.html#AUTOTHROTTLE_ENABLED = True# The initial download delay#AUTOTHROTTLE_START_DELAY = 5# The maximum download delay to be set in case of high latencies#AUTOTHROTTLE_MAX_DELAY = 60# The average number of requests Scrapy should be sending in parallel to# each remote server#AUTOTHROTTLE_TARGET_CONCURRENCY = 1.0# Enable showing throttling stats for every response received:#AUTOTHROTTLE_DEBUG = False# Enable and configure HTTP caching (disabled by default)# See https://doc.scrapy.org/en/latest/topics/downloader-middleware.html#httpcache-middleware-settings#HTTPCACHE_ENABLED = True#HTTPCACHE_EXPIRATION_SECS = 0#HTTPCACHE_DIR = 'httpcache'#HTTPCACHE_IGNORE_HTTP_CODES = []#HTTPCACHE_STORAGE = 'scrapy.extensions.httpcache.FilesystemCacheStorage' quotetutroial / quotetutroial / spiders / quotes.py12345678910111213141516171819202122232425262728293031323334# -*- coding: utf-8 -*-import scrapyfrom quotetutroial.items import QuoteItemclass QuotesSpider(scrapy.Spider): name = 'quotes' allowed_domains = ['quotes.toscrape.com'] start_urls = ['http://quotes.toscrape.com/'] def parse(self, response): quotes = response.css('.quote') for quote in quotes: item = QuoteItem() text = quotes.css('.text::text').extract_first() # ::text是scrapy的语法格式，表示获取文本 author = quotes.css('.author::text').extract_first() # extract_first()表示获取第一个结果 tags = quotes.css('.tags .tag::text').extract() # extract()表示获取所有结果 # 这里可以在终端里使用命令scrapy shell quotes.toscrape.com进入交互模式！！！ # 输入exit()退出交互模式 item['text'] = text item['author'] = author item['tags'] = tags yield item next = response.css('.pager .next a::attr(href)').extract_first() url = response.urljoin(next) # 因为next是不完全的url，所以需要调用urljoin生成完整的url yield scrapy.Request(url=url, callback=self.parse) # 回调自身parse，实现翻页 # 此时可以命令行输入命令scrapy crawl quotes -o quotes.json保存数据 # 还可以输入命令scrapy crawl quotes -o quotes.jl保存数据成json line格式 # 还可以输入命令scrapy crawl quotes -o quotes.csv保存数据成csv格式 # 还可以输入命令scrapy crawl quotes -o quotes.xml保存数据成xml格式 # 还可以输入命令scrapy crawl quotes -o quotes.pickle保存数据成pickle格式 # 还可以输入命令scrapy crawl quotes -o quotes.marshal保存数据成marshal格式 # 还可以输入命令scrapy crawl quotes -o ftp://user:pass@ftp.example.com/path/quotes.csv保存数据到ftp服务器 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"Scrapy框架安装","slug":"Scrapy框架安装","date":"2018-07-05T01:00:00.000Z","updated":"2018-08-16T02:58:28.473Z","comments":true,"path":"2018/07/05/Scrapy框架安装/","link":"","permalink":"http://pythonfood.github.io/2018/07/05/Scrapy框架安装/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、框架安装1、Scrapy安装scrapy依赖的库比较多，至少需要依赖库有pywin32、Twisted、pyOpenSSL、lxml。而在不同平台环境又各不相同，所以安装之前最好确保依赖库安装好，尤其是windows。 2、windows最好的安装方式是通过wheel文件来安装。首先需要安装wheel库： pip install wheel (1)安装lxml 进入http://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml ，找到与python版本和系统版本对应的whl文件，下载后通过pip安装： pip install C:\\Users\\tester\\Downloads\\lxml‑3.7.2‑cp36‑cp36m‑win32.whl (2)安装OpenSSL 进入https://pypi.python.org/pypi/pyOpenSSL#downloads ，找到与python版本和系统版本对应的whl文件，下载后通过pip安装： pip install C:\\Users\\tester\\Downloads\\pyOpenSSL-16.2.0-py2.py3-none-any.whl (3)安装Twisted 进入http://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted ，找到与python版本和系统版本对应的whl文件，下载后通过pip安装： pip install C:\\Users\\tester\\Downloads\\Twisted‑17.1.0‑cp36‑cp36m‑win32.whl (4)安装pywin32 进入https://sourceforge.net/projects/pywin32/files/pywin32/Build%20220/ ，找到与python版本和系统版本对应的安装包，运行安装即可。 (5)安装Scrapy 最后安装Scrapy，pip安装即可： pip install Scrapy 3、Anaconda安装可以轻松的使用conda命令安装Scrapy： conda install Scrapy 4、安装验证安装完，cmd输入命令scarpy可以验证。 进一步创建一个工程： scrapy startproject hello cd hello scrapy genspider baidu www.baidu.com scrapy crawl baidu 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"Pyspider架构概述及用法详解","slug":"Pyspider架构概述及用法详解","date":"2018-07-04T02:00:00.000Z","updated":"2018-08-16T02:27:23.585Z","comments":true,"path":"2018/07/04/Pyspider架构概述及用法详解/","link":"","permalink":"http://pythonfood.github.io/2018/07/04/Pyspider架构概述及用法详解/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、官方详解1、官方文档http://docs.pyspider.org/en/latest/ 2、中文翻译http://www.pyspider.cn/book/pyspider/pyspider-Quickstart-2.html 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"PySpider框架基本使用及抓取TripAdvisor实战","slug":"PySpider框架基本使用及抓取TripAdvisor实战","date":"2018-07-04T01:00:00.000Z","updated":"2018-08-16T02:26:36.285Z","comments":true,"path":"2018/07/04/PySpider框架基本使用及抓取TripAdvisor实战/","link":"","permalink":"http://pythonfood.github.io/2018/07/04/PySpider框架基本使用及抓取TripAdvisor实战/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、爬取实战1、PySpider框架 去重处理 结果监控 多进程处理 PyQuery提取 错误重试 WebUI管理 代码简洁 JavaScript渲染 2、安装cmd管理员身份运行，执行命令pip install pyspider 3、运行cmd输入命令pyspider。浏览器输入地址：http://localhost:5000/ ps:需要安装过phantomjs 4、实战1234567891011121314151617181920212223242526272829303132333435363738394041424344#!/usr/bin/env python# -*- encoding: utf-8 -*-# Created on 2018-06-07 22:43:08# Project: TripAdvisorfrom pyspider.libs.base_handler import *import pymongoclass Handler(BaseHandler): crawl_config = &#123; &#125; client = pymongo.MongoClient('localhost') db = client['trip'] @every(minutes=24 * 60) def on_start(self): self.crawl('http://www.tripadvisor.cn/Attractions-g186338-Activities-c47-t163-London_England.html#ATTRACTION_LIST', callback=self.index_page, validate_cert=False) @config(age=10 * 24 * 60 * 60) def index_page(self, response): for each in response.doc('.listing_title &gt; a').items(): self.crawl(each.attr.href, callback=self.detail_page, validate_cert=False) next = response.doc('.pagination .nav.next').attr.href self.crawl(next, callback=self.index_page, validate_cert=False) @config(priority=2) def detail_page(self, response): name = response.doc('.heading_title').text() rating = response.doc('div &gt; .more').text() adress = response.doc('.location &gt; .address').text() phone = response.doc('.phone &gt; div').text() return &#123; \"url\":response.url, \"name\":name, \"rating\":rating, \"adress\":adress, \"phone\":phone &#125; def on_result(self,result): if result: self.save_to_mongo(result) def save_to_mongo(self,result): if self.db['london'].insert(result): print('save to mongodb:',result) 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"使用Redis+Flask维护动态Cookies池","slug":"使用Redis-Flask维护动态Cookies池","date":"2018-07-03T05:00:00.000Z","updated":"2018-08-15T12:27:01.678Z","comments":true,"path":"2018/07/03/使用Redis-Flask维护动态Cookies池/","link":"","permalink":"http://pythonfood.github.io/2018/07/03/使用Redis-Flask维护动态Cookies池/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、Cookies池详解1、为什么要维护cookie池有的网站需要登录后才能爬取，如新浪微博 爬取过程中如果频率过高会导致封号，那么如果想要获得非常多的数据，则需要非常多的账号 2、cookie池的要求 自动登录更新 定时验证筛选 提供外部接口（可将池架在远程的服务器上，实现远程部署 3、cookie池的架构账号队列 ===》 生成器 ===》 cookies队列（对外提供API） ===》 定时检测器 4、cookie池的实现需要先将一定量的账号密码之类的cookie存进Redis数据库，然后利用python调用并维护。 关于cookies池的维护，有以下开源项目案例可供参考：https://github.com/Germey/CookiesPool 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"使用代理处理反爬抓取微信文章","slug":"使用代理处理反爬抓取微信文章","date":"2018-07-03T04:00:00.000Z","updated":"2018-08-15T13:05:59.205Z","comments":true,"path":"2018/07/03/使用代理处理反爬抓取微信文章/","link":"","permalink":"http://pythonfood.github.io/2018/07/03/使用代理处理反爬抓取微信文章/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、爬取实战1、流程框架(1)抓取索引页内容 利用requests请求目标站点，得到索引网页HTML代码，返回结果。 (2)代理设置 如果遇到302状态码，则证明IP被封，切换代理重试。 (3)分析详情页内容 请求详情页，分析得到标题，正文等内容。 (4)将数据保存到数据库 将结构化数据保存到MongoDB。 2、实战123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146import pymongoimport requestsfrom requests.exceptions import ConnectionErrorfrom lxml.etree import XMLSyntaxErrorfrom urllib.parse import urlencodefrom pyquery import PyQuery as pqfrom wxconfig import *# 设置数据库连接client = pymongo.MongoClient(MONGO_URI)db = client[MONGO_DB]# 爬取urlbase_url = 'http://weixin.sogou.com/weixin?'# 请求头，需要带上cookie，不然只能访问10页数据headers = &#123; 'Cookie': 'SUID=F6177C7B3220910A000000058E4D679; SUV=1491392122762346; ABTEST=1|1491392129|v1; SNUID=0DED8681FBFEB69230E6BF3DFB2F8D6B; ld=OZllllllll2Yi2balllllV06C77lllllWTZgdkllll9lllllxv7ll5@@@@@@@@@@; LSTMV=189%2C31; LCLKINT=1805; weixinIndexVisited=1; SUIR=0DED8681FBFEB69230E6BF3DFB2F8D6B; JSESSIONID=aaa-BcHIDk9xYdr4odFSv; PHPSESSID=afohijek3ju93ab6l0eqeph902; sct=21; IPLOC=CN; ppinf=5|1491580643|1492790243|dHJ1c3Q6MToxfGNsaWVudGlkOjQ6MjAxN3x1bmlxbmFtZToyNzolRTUlQjQlOTQlRTUlQkElODYlRTYlODklOER8Y3J0OjEwOjE0OTE1ODA2NDN8cmVmbmljazoyNzolRTUlQjQlOTQlRTUlQkElODYlRTYlODklOER8dXNlcmlkOjQ0Om85dDJsdUJfZWVYOGRqSjRKN0xhNlBta0RJODRAd2VpeGluLnNvaHUuY29tfA; pprdig=j7ojfJRegMrYrl96LmzUhNq-RujAWyuXT_H3xZba8nNtaj7NKA5d0ORq-yoqedkBg4USxLzmbUMnIVsCUjFciRnHDPJ6TyNrurEdWT_LvHsQIKkygfLJH-U2MJvhwtHuW09enCEzcDAA_GdjwX6_-_fqTJuv9w9Gsw4rF9xfGf4; sgid=; ppmdig=1491580643000000d6ae8b0ebe76bbd1844c993d1ff47cea', 'Host': 'weixin.sogou.com', 'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36'&#125;# 开始时是否启用代理proxy = Nonedef get_proxy(): # 代理获取函数，这里使用类flask的接口 try: response = requests.get(PROXY_POOL_URL) if response.status_code == 200: return response.text # 没有异常直接结束 return None except ConnectionError: return None def get_html(url, count=1): print('Crawling', url) print('Try Count', count) global proxy #设置访问深度 if count &gt;= MAX_COUNT: print('Tried Too Many Counts') return None try: # 判断启用代理和有代理 if proxy: # 给代理池取出的数据加上协议头 proxies = &#123; 'http':'http://' + proxy &#125; # 需要设置allow_redirects=False,禁止requests自动处理重定向 response = requests.get(url, headers=headers, proxies=proxies, allow_redirects=False) else: response = requests.get(url, headers=headers, allow_redirects=False) # 如果请求成功返回 if response.status_code == 200: return response.text if response.status_code == 302: # 出现302说明IP被封，需要更换代理 print('302') # 获取一个新代理 proxy = get_proxy() if proxy: print('Using Proxy', proxy) # 获取到代理ip重新获取网页 return get_html(url) else: print('Get Proxy Failed') # 没有代理了，直接退出 return None except ConnectionError as e: print('Error Occurred', e.args) proxy = get_proxy() count += 1 return get_html(url, count)def get_index(keyword,page): data = &#123; 'query':keyword, 'type':2, 'page':page &#125; queries = urlencode(data) url = base_url + queries html = get_html(url) return htmldef parse_index(html): doc = pq(html) items = doc('.news-box .news-list li .txt-box h3 a').items() for item in items: yield item.attr('href') def get_detail(url): try: response = requests.get(url) if response.status_code == 200: return response.text return None except ConnectionError: return None def parse_detail(html): try: doc = pq(html) title = doc('.rich_media_title').text() content = doc('.rich_media_content').text() date = doc('#post-date').text() nickname = doc('#js_profile_qrcode &gt; div &gt; strong').text() wechat = doc('#js_profile_qrcode &gt; div &gt; p:nth-child(3) &gt; span').text() return &#123; 'title': title, 'content': content, 'date': date, 'nickname': nickname, 'wechat': wechat &#125; except XMLSyntaxError: return None def save_to_mongo(data): if db['articles'].update(&#123;'title':data['title']&#125;,&#123;'$set':data&#125;,True): print('Saved to Mongo', data['title']) else: print('Saved to Mongo Failed', data['title']) def main(): # 设置访问的页数和次数 for page in range(1, 5): # 传入访问的关键字 html = get_index(KEYWORD, page) # 获取到html文件，获取链接 if html: article_urls = parse_index(html) for article_url in article_urls: article_html = get_detail(article_url) if article_html: # 解析文章内容 article_data = parse_detail(article_html) print(article_data) # 保存到数据库 if article_data: save_to_mongo(article_data) if __name__ == '__main__': main() wxconfig.py 1234567# coding: utf-8PROXY_POOL_URL = 'http://127.0.0.1:5000/get'KEYWORD = '风景'MONGO_URI = 'localhost'MONGO_DB = 'weixin'MAX_COUNT = 5 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"使用Redis+Flask维护动态代理池","slug":"使用Redis-Flask维护动态代理池","date":"2018-07-03T03:00:00.000Z","updated":"2018-08-15T13:06:45.676Z","comments":true,"path":"2018/07/03/使用Redis-Flask维护动态代理池/","link":"","permalink":"http://pythonfood.github.io/2018/07/03/使用Redis-Flask维护动态代理池/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、代理池详解1、代理池的维护目前有很多网站提供免费代理，而且种类齐全，比如各个地区、各个匿名级别的都有，不过质量实在不敢恭维，毕竟都是免费公开的，可能一个代理无数个人在用也说不定。所以我们需要做的是大量抓取这些免费代理，然后筛选出其中可用的代理存储起来供我们使用，不可用的进行剔除。 2、获取代理途径维护一个代理池第一步就是要找到提供免费代理的站点，例如PROXY360。可以看到网页里提供了一些免费代理列表，包括服务器地址、端口、代理种类、地区、更新时间等等信息。 当前我们需要的就是代理服务器和端口信息，将其爬取下来即可。 3、代理池的要求 多占抓取，异步检测 定时筛选，持续更新 提供接口，易于获取 4、代理池的架构Internet ===》 代理获取器 ===》 代理筛选器 ===》 代理调度器（对外提供API） ===》 定时检测器 5、维护代理那么爬取下代理之后怎样保存呢？ 首先我们需要确保的目标是可以边取边存，另外还需要定时检查队列中不可用的代理将其剔除，所以需要易于存取。 另外怎样区分哪些是最新的可用的，哪些是旧的，如果用修改时间来标注是可以的，不过更简单的方法就是维护一个队列，只从一端存入，例如右端，这样就能确保最新的代理在队列右端，而在左端则是存入时间较长的代理，如果要取一个可用代理，从队列右端取一个就好了。 那么对于队列的左端，不能让它一直老化下去，还需要做的操作就是定时从队列左端取出代理，然后进行检测，如果可用，重新将其加入右端。 通过以上操作，就保证了代理一直是最新可用的。 所以目前来看，既能高效处理，又可以做到队列动态维护，合适的方法就是利用Redis数据库的队列。 可以定义一个类来维护一个Redis队列，比如get方法是批量从左端取出代理，put方法是从右端放入可用代理，pop方法是从右端取出最新可用代理。 123456789101112131415161718192021import redisfrom proxypool.error import PoolEmptyErrorfrom proxypool.setting import HOST, PORTclass RedisClient(object): def __init__(self, host=HOST, port=PORT): self._db = redis.Redis(host, port) def get(self, count=1): proxies = self._db.lrange(\"proxies\", 0, count - 1) self._db.ltrim(\"proxies\", count, -1) return proxies def put(self, proxy): self._db.rpush(\"proxies\", proxy) def pop(self): try: return self._db.rpop(\"proxies\").decode('utf-8') except: raise PoolEmptyError 6、检测代理那么如何来检测代理是否可用？可以使用这个代理来请求某个站点，比如百度，如果获得正常的返回结果，那证明代理可用，否则代理不可用。 12345conn = RedisClient()proxies = &#123;'http': proxy&#125;r = requests.get('https://www.baidu.com', proxies=proxies)if r.status_code == 200: conn.put(proxy) 7、获取可用代理现在我们维护了一个代理池，那么这个代理池需要是可以公用的。 比如现在有多个爬虫项目都需要用到代理，而代理池的维护作为另外的一个项目，他们之间如果要建立连接，最恰当的方式就是接口。 所以可以利用Web服务器来实现一个接口，其他的项目通过请求这个接口得到内容获取到一个可用代理，这样保证了代理池的通用性。 所以要实现这个还需要一个Web服务器，例如Flask，Tornado等等。 例如使用Flask，定义一个路由，然后调用的RedisClient的pop方法，返回结果即可。 1234@app.route('/')def get_proxy(): conn = RedisClient() return conn.pop() 这样一来，整个程序运行起来后，浏览器输入localhost:5000/get，请求网页就可以看到一个可用代理了。 8、使用代理使用代理时只需要请求这个站点，就可以拿到可使用的代理了。 可以定义一个简单的方法，返回网页内容即代理，然后在爬取方法里设置代理使用即可。 12345678def get_proxy(): r = requests.get('http://127.0.0.1:5000/get') return r.textdef crawl(url, proxy): proxies = &#123;'http': get_proxy()&#125; r = requests.get(url, proxies=proxies) # do something 9、github项目源代码https://github.com/Germey/ProxyPool PS:项目requirements.txt文件中缺少一个依赖库fake-useragent，需要手动pip安装。 还有如果报错’TypeError: expected string or bytes-like object’,找到对应的代码，是一个爬取代理网站的方法，删除或屏蔽掉就可以了。 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"使用Selenium模拟浏览器抓取淘宝商品美食信息","slug":"使用Selenium模拟浏览器抓取淘宝商品美食信息","date":"2018-07-03T02:00:00.000Z","updated":"2018-08-15T10:09:18.837Z","comments":true,"path":"2018/07/03/使用Selenium模拟浏览器抓取淘宝商品美食信息/","link":"","permalink":"http://pythonfood.github.io/2018/07/03/使用Selenium模拟浏览器抓取淘宝商品美食信息/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、爬取实战1、准备selenium、pyquery、re、pymongo 2、流程(1)目标站点分析:用浏览器打开淘宝首页输入‘美食’，打开审查元素，分析我们要的商品信息都在Element里哪个分段。 (2)搜索关键字:利用Selenium驱动浏览器搜索关键字，得到查询后的商品列表。 (3)分析页码并翻页:得到商品页码数，模拟翻页，得到后续页面的商品列表。 (4)分析提取商品内容:利用PyQuery分析源码，解析得到商品列表。 (5)储存到MongoDB:将商品列表信息储存到数据库MongoDB。 3、实战123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import reimport pymongofrom selenium import webdriverfrom selenium.common.exceptions import TimeoutExceptionfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECfrom pyquery import PyQuery as pqfrom config import *'''使用PhantomJS无界面浏览器，注意需要设置下窗口大小，否则有的元素获取不到会报错'''#browser = webdriver.PhantomJS()#browser.set_window_size(1400,900)'''可以给PhantomJS设置些选项，从而增加效率。比如：不加载图片、设置缓存等'''#SERVICE_ARGS = ['--load-images=false', '--disk-cache=true']#browser = webdriver.PhantomJS(service_args=SERVICE_ARGS)#browser.set_window_size(1400,900)'''chrome也可以设置无界面模式，Mac和Linux需要chrome59版本，Windows需要chrome60版本'''#chrome_options = webdriver.ChromeOptions()#chrome_options.add_argument('--headless')#browser = webdriver.Chrome(chrome_options=chrome_options)browser = webdriver.Chrome()wait = WebDriverWait(browser,10)client = pymongo.MongoClient(MONGO_URL) #声明mongodb客户端，MONGO_URL从配置文件config.py获取db = client[MONGO_DB] #定义数据库，MONGO_DB从配置文件config.py获取。注意中括号[]def search(): #首页搜索关键字 print('正在搜索') try: browser.get('http://www.taobao.com') input = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR,'#q'))) #等待搜索框加载 submit = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR,'#J_TSearchForm &gt; div.search-button &gt; button.btn-search'))) #等待搜索按钮加载 input.send_keys(KEYWORD) #输入搜索关键字，KEYWORD从配置文件config.py获取 submit.click() total = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR,'#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.total'))) #获取总页数 get_products() return total.text #返回总页数 except TimeoutException: #捕捉browser超时异常 return search() #超时异常后，重新进行搜索即可def next_page(page_number): #输入页码，进行翻页 print('正在翻页') try: input = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR,'#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.form &gt; input'))) #等待页码输入框 submit = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR,'#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.form &gt; span.btn.J_Submit'))) #等待提交按钮 input.clear() #输入前先清除内容 input.send_keys(page_number) submit.click() wait.until(EC.text_to_be_present_in_element((By.CSS_SELECTOR,'#mainsrp-pager &gt; div &gt; div &gt; div &gt; ul &gt; li.item.active &gt; span'),str(page_number))) #等待高亮页码数值显示跳转的页码，确定跳转完成 get_products() except TimeoutException: return next_page(page_number) #超时异常后，重新进行翻页即可 def get_products(): #获取当页商品数据 wait.until(EC.presence_of_element_located((By.CSS_SELECTOR,'#mainsrp-itemlist .items .item'))) html = browser.page_source #获取当前页面源码 doc = pq(html) #声明pyquery对象 items = doc('#mainsrp-itemlist .items .item').items() # 获取当前页所有商品对象 for item in items: #遍历所有商品 product = &#123; 'image':item.find('.pic .img').attr('src'), 'price':item.find('.price').text(), 'deal':item.find('.deal-cnt').text()[:-3], 'title':item.find('.title').text(), 'shop':item.find('.shop').text(), 'location':item.find('.location').text() &#125; save_to_mongo(product) def save_to_mongo(result): #保存到mongodb数据库 try: if db[MONGO_TABLE].insert(result): #判断数据插入到数据表中，MONGO_TABLE从配置文件config.py中获取 print('存储到MongoDB成功',result) except Exception: print('存储到MongoDB失败',result)def main(): try: total = search() total = int(re.compile('(\\d+)').search(total).group(1)) #正则匹配对象，搜索总页数字符串，结果索引1，转为int型就是总页数了 for i in range(2,total+1): #从第二页开始循环翻页 next_page(i) except Exception: print('浏览器出错啦') finally: print('爬取完成') browser.close() #完成后一定关闭浏览器 if __name__ == '__main__': main() config.py123456789# coding: utf-8#config.pyKEYWORD = '美食'MONGO_URL = 'localhost'MONGO_DB = 'taobao'MONGO_TABLE = 'product' 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"分析Ajax爬取今日头条街拍美图","slug":"分析Ajax爬取今日头条街拍美图","date":"2018-07-03T02:00:00.000Z","updated":"2018-08-15T03:36:41.354Z","comments":true,"path":"2018/07/03/分析Ajax爬取今日头条街拍美图/","link":"","permalink":"http://pythonfood.github.io/2018/07/03/分析Ajax爬取今日头条街拍美图/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、爬取实战1、准备工作请确保已经安装好requests库，使用的编辑器是PyCharm。 2、抓取分析(1)抓取前分析抓取对象：打开今日头条首页https://www.toutiao.com/ (2)右上角输入“街拍”，搜索进入街拍。 (3)这时打开开发者工具，查看所有的网络请求。首先，打开第一个网络请求，这个请求的URL就是当前的链接http://www.toutiao.com/search/?keyword=街拍 ，打开Preview选项卡查看Response Body。如果页面中的内容是根据第一个请求得到的结果渲染出来的，那么第一个请求的源代码中必然会包含页面结果中的文字。 (4)实际没有结果中的文字，可以初步判断这些内容是由Ajax加载，然后用JavaScript渲染出来的。接下来，我们可以切换到XHR过滤选项卡，查看一下有没有Ajax请求。不出所料，此处出现了一个比较常规的Ajax请求，看看它的结果是否包含了页面中的相关数据。 (5)点击data字段展开，发现这里有许多条数据。点击第一条展开，可以发现有一个title字段，它的值正好就是页面中第一条数据的标题。再检查一下其他数据，也正好是一一对应的。 (6)我们的目的是要抓取其中的美图，这里一组图就对应前面data字段中的一条数据。每条数据还有一个image_detail字段，它是列表形式，这其中就包含了组图的所有图片列表,因此，我们只需要将列表中的url字段提取出来并下载下来就好了。每一组图都建立一个文件夹，文件夹的名称就为组图的标题。 (7)接下来，就可以直接用Python来模拟这个Ajax请求，然后提取出相关美图链接并下载。但是在这之前，我们还需要分析一下URL的规律。切换回Headers选项卡，观察一下它的请求URL和Headers信息。 (8)可以看到，这是一个GET请求，请求URL的参数有offset、format、keyword、autoload、count和cur_tab。我们需要找出这些参数的规律，因为这样才可以方便地用程序构造出来。 (9)接下来，可以滑动页面，多加载一些新结果。在加载的同时可以发现，Network中又出现了许多Ajax请求，这里观察一下后续链接的参数，发现变化的参数只有offset，其他参数都没有变化，而且第二次请求的offset值为20，第三次为40，第四次为60，所以可以发现规律，这个offset值就是偏移量，进而可以推断出count参数就是一次性获取的数据条数。因此，我们可以用offset参数来控制数据分页。这样一来，我们就可以通过接口批量获取数据了，然后将数据解析，将图片下载下来即可。 PS：崔老师教程的第(6)步中查找的字段image_detail，实际上没有发现，这里使用image_list代替。 3、实战演练123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import requestsimport osfrom urllib.parse import urlencodefrom hashlib import md5from multiprocessing.pool import Pool#加载单个Ajax请求的结果。其中唯一变化的参数就是offset。def get_page(offset): params = &#123; 'autoload':'true', 'count':'20', 'cur_tab':'1', 'format':'json', 'keyword':'街拍', 'offset':offset &#125; url = 'http://www.toutiao.com/search_content/?'+ urlencode(params) #urlencode()方法构造请求的GET参数 try: response = requests.get(url) if response.status_code == 200: return response.json() # 返回json格式数据 except requests.ConnectionError: print('请求索引页出错') return None#提取每条数据的image_list字段中的每一张图片链接，将图片链接和图片所属的标题一并返回，此时可以构造一个生成器。 def get_images(json): if json.get('data'): #json中data存在 for item in json.get('data'): title = item.get('title') if item.get('image_list'): #item中image_list存在 images = item.get('image_list') for image in images: yield&#123; #构造生成器 'image':'http:'+ image['url'], 'title':title'''保存图片，其中item就是前面get_images()方法返回的一个字典。首先根据item的title来创建文件夹。然后请求这个图片链接，获取图片的二进制数据，以二进制的形式写入文件。图片的名称可以使用其内容的MD5值，这样可以去除重复。 '''def save_image(item): if not os.path.exists(item.get('title')): #判断路径不存在 os.mkdir(item.get('title')) #用title创建文件夹 try: response = requests.get(item.get('image')) #请求图片地址 if response.status_code == 200: file_path = '&#123;0&#125;/&#123;1&#125;.&#123;2&#125;'.format(item.get('title'),md5(response.content).hexdigest(),'jpg') #定义图片路径，图片命名用图片内容MD5值16进制表示 if not os.path.exists(file_path): #判断路径不存在 with open(file_path,'wb') as f: f.write(response.content) #写入二进制文件 else: print('Already Downloaded', file_path) except requests.ConnectionError: print('Failed to Save Image') def main(offset): json = get_page(offset) for item in get_images(json): print(item) save_image(item) group_start = 1group_end = 5 if __name__ == '__main__': pool = Pool() groups = ([i*20 for i in range(group_start,group_end+1)]) #构造一个offset数组 pool.map(main,groups) #多进程进程池，调用其map()方法实现多进程下载 pool.close() pool.join() 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"Requests+正则表达式爬取猫眼电影TOP100","slug":"Requests-正则表达式爬取猫眼电影TOP100","date":"2018-07-03T01:00:00.000Z","updated":"2018-08-15T03:30:35.985Z","comments":true,"path":"2018/07/03/Requests-正则表达式爬取猫眼电影TOP100/","link":"","permalink":"http://pythonfood.github.io/2018/07/03/Requests-正则表达式爬取猫眼电影TOP100/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、爬取实战1、目标站点分析我们需要抓取的目标站点为http://maoyan.com/board/4 ，打开之后便可以查看到榜单信息。排名第一的电影是霸王别姬，页面中显示的有效信息有影片名称、主演、上映时间、上映地区、评分、图片等信息。 将网页滚动到最下方，可以发现有分页的列表，直接点击第2页，观察页面的URL和内容发生了怎样的变化，可以发现页面的URL变成http://maoyan.com/board/4?offset=10 ，比之前的URL多了一个参数，那就是offset=10，而目前显示的结果是排行11~20名的电影，初步推断这是一个偏移量的参数。再点击下一页，发现页面的URL变成了http://maoyan.com/board/4?offset=20 ，参数offset变成了20，而显示的结果是排行21~30的电影。 由此可以总结出规律，offset代表偏移量值，如果偏移量为n，则显示的电影序号就是n+1到n+10，每页显示10个。所以，如果想获取TOP100电影，只需要分开请求10次，而10次的offset参数分别设置为0、10、20、…90即可，这样获取不同的页面之后，再用正则表达式提取出相关信息，就可以得到TOP100的所有电影信息了。 2、流程框架(1)抓取单页内容： 利用requests请求目标站点得到单个网页的HTML代码，返回结果。 (2)正则表达式分析： 根据HTML代码分析得到电影名称、主演、上映时间、评分、图片链接等信息。 (3)保存至文件： 通过文件的形式将结果保存，每一部电影一个结果一行Json字符串。 (4)开启循环及多线程： 对多项内容遍历，开启多线程提高抓取速度。 3、爬虫实战12345678910111213141516171819202122232425262728293031323334353637383940414243444546import requestsimport re import jsonfrom multiprocessing import Poolheaders = &#123;'User-Agent': 'Mozilla/5.0Safari/537.36'&#125; #设定自己的headersdef get_one_page(url): response = requests.get(url,headers=headers) #添加头部信息,不然会被禁 if response.status_code == 200: return response.text return Nonedef parse_one_page(html): #匹配过程保证起始符和终止符存在 pattern = re.compile('&lt;dd&gt;.*?board-index.*?&gt;(\\d+)&lt;/i&gt;.*?data-src=\"(.*?)\".*?name\"&gt;&lt;a.*?&gt;(.*?)&lt;/a&gt;.*?star\"&gt;(.*?)&lt;/p&gt;.*?releasetime\"&gt;(.*?)&lt;/p&gt;.*?integer\"&gt;(.*?)&lt;/i&gt;.*?fraction\"&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;',re.S) items = re.findall(pattern,html) for item in items: yield&#123; 'index':item[0], 'image':item[1], 'title':item[2], 'actor':item[3].strip()[3:], 'time':item[4].strip()[5:], 'score':item[5]+item[6] &#125;def write_to_file(content): with open('猫眼电影TOP100.txt','a',encoding='utf-8') as f: f.write(json.dumps(content,ensure_ascii=False) + '\\n') f.close def main(offset): url = 'http://maoyan.com/board/4?offset' + str(offset) #url设置偏移量 html = get_one_page(url) #print(html) items = parse_one_page(html) for item in items: print(item) write_to_file(item) if __name__ == '__main__': for i in range(10): main(offset=i * 10) #pool = Pool() # 使用进程池，提高抓取效率（使用多进程需要屏蔽for循环） #pool.map(main,[i*10 for i in range(10)]) 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"爬虫-selenium库","slug":"爬虫-selenium库","date":"2018-07-02T07:00:00.000Z","updated":"2018-08-14T09:52:56.689Z","comments":true,"path":"2018/07/02/爬虫-selenium库/","link":"","permalink":"http://pythonfood.github.io/2018/07/02/爬虫-selenium库/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、Selenium库详解1、什么是SeleniumSelenium是一个自动化测试工具，利用它可以驱动浏览器执行特定的动作，如点击、下拉等操作，同时还可以获取浏览器当前呈现的页面的源代码，做到可见即可爬。对于一些JavaScript动态渲染的页面来说，此种抓取方式非常有效。 2、安装pip install selenium 3、基本使用1234567891011121314151617181920from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.support.wait import WebDriverWaitbrowser = webdriver.Chrome()try: browser.get('https://www.baidu.com') input = browser.find_element_by_id('kw') input.send_keys('python') input.send_keys(Keys.ENTER) wait = WebDriverWait(browser,10) wait.until(EC.presence_of_element_located((By.ID,'content_left'))) print(browser.current_url) print(browser.get_cookies()) print(browser.page_source)finally: browser.close() 4、声明浏览器对象Selenium支持非常多的浏览器，如Chrome、Firefox、Edge等，还有Android、BlackBerry等手机端的浏览器。另外，也支持无界面浏览器PhantomJS。 1234567from selenium import webdriver browser = webdriver.Chrome()browser = webdriver.Firefox()browser = webdriver.Edge()browser = webdriver.PhantomJS()browser = webdriver.Safari() 5、访问页面123456from selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.taobao.com')print(browser.page_source)browser.close() 6、查找节点1234567891011121314151617#单个节点from selenium import webdriverfrom selenium.webdriver.common.by import Bybrowser = webdriver.Chrome()browser.get('https://www.taobao.com')input1 = browser.find_element_by_id('q')input2 = browser.find_element_by_css_selector('#q')input3 = browser.find_element_by_xpath('//*[@id=\"q\"]')print(input1,input2,input3)#Selenium还提供了查找元素通用方法find_element()，它需要传入两个参数：查找方式By和值。#这种查找方式的功能和上面列举的查找函数完全一致，不过参数更加灵活。input1_same = browser.find_element(By.ID,'q') #等价于find_element_by_id('q')print(input1_same)browser.close() 所有获取单个节点的方法： find_element_by_id find_element_by_name find_element_by_xpath find_element_by_link_text find_element_by_partial_link_text find_element_by_tag_name find_element_by_class_name find_element_by_css_selector 12345678910111213#多个节点from selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.taobao.com')lis = browser.find_elements_by_css_selector('.service-bd li')print(lis)#也可以直接用find_elements()方法来选择lis_same = browser.find_elements(By.CSS_SELECTOR,'.service-bd li') #等价于find_elements_by_css_selector('.service-bd li')print(lis_same)browser.close() 所有获取多个节点的方法： find_elements_by_id find_elements_by_name find_elements_by_xpath find_elements_by_link_text find_elements_by_partial_link_text find_elements_by_tag_name find_elements_by_class_name find_elements_by_css_selector 7、元素交互官方文档：http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.remote.webelement 1234567891011121314from selenium import webdriverimport timebrowser = webdriver.Chrome()browser.get('https://www.taobao.com')input = browser.find_element_by_id('q')input.send_keys('iphone')time.sleep(1)input.clear()input.send_keys('ipad')button = browser.find_element_by_class_name('btn-search')button.click()time.sleep(3)browser.close() 8、交互动作(动作链)还有一些操作，它们没有特定的执行对象，比如鼠标拖曳、键盘按键等，这些动作用另一种方式来执行，那就是动作链。 将动作附加到动作链中串行执行。 官方文档：http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.common.action_chains 123456789101112131415from selenium import webdriverfrom selenium.webdriver import ActionChainsimport timebrowser = webdriver.Chrome()browser.get('http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable')time.sleep(5)browser.switch_to.frame('iframeResult')source = browser.find_element_by_css_selector('#draggable')target = browser.find_element_by_css_selector('#droppable')actions = ActionChains(browser) #声明动作链对象actions.drag_and_drop(source,target) #定义拖放动作actions.perform() #执行动作链time.sleep(3)browser.close() 9、执行JavaScript对于某些操作，Selenium API并没有提供。比如，下拉进度条，它可以直接模拟运行JavaScript，此时使用execute_script()方法即可实现。 123456789from selenium import webdriverimport timebrowser = webdriver.Chrome()browser.get('https://www.zhihu.com/explore')browser.execute_script('window.scrollTo(0,document.body.scrollHeight)')browser.execute_script('alert(\"To Bottom\")')time.sleep(3)browser.close() 10、获取元素信息Selenium已经提供了选择节点的方法，返回的是WebElement类型，那么它也有相关的方法和属性来直接提取节点信息，如属性、文本等。这样的话，我们就可以不用通过解析源代码来提取信息了，非常方便。 123456789101112#获取属性from selenium import webdriverimport timebrowser = webdriver.Chrome()browser.get('https://www.zhihu.com/explore')logo = browser.find_element_by_id('zh-top-link-logo')print(logo)print(logo.get_attribute('class')) #获取class属性time.sleep(3)browser.close() 123456789101112#获取文本值from selenium import webdriverimport timebrowser = webdriver.Chrome()browser.get('https://www.zhihu.com/explore')input = browser.find_element_by_class_name('zu-top-add-question')print(input)print(input.text) #获取文本值time.sleep(3)browser.close() 123456789101112131415#获取id、位置、标签名和大小from selenium import webdriverimport timebrowser = webdriver.Chrome()browser.get('https://www.zhihu.com/explore')input = browser.find_element_by_class_name('zu-top-add-question')print(input)print(input.id) #获取节点idprint(input.location) #获取该节点在页面中的相对位置print(input.tag_name) #获取标签名称print(input.size) #获取节点的大小，也就是宽高time.sleep(3)browser.close() 11、切换Frame网页中有一种节点叫作iframe，也就是子Frame，相当于页面的子页面，它的结构和外部网页的结构完全一致。Selenium打开页面后，它默认是在父级Frame里面操作，而此时如果页面中还有子Frame，它是不能获取到子Frame里面的节点的。这时就需要使用switch_to.frame()方法来切换Frame。 123456789101112131415161718from selenium import webdriverfrom selenium.common.exceptions import NoSuchElementExceptionimport timebrowser = webdriver.Chrome()browser.get('http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable')browser.switch_to.frame('iframeResult') #切换到子frametry: logo = browser.find_element_by_class_name('logo')except NoSuchElementException: print('NO LOGO')browser.switch_to.parent_frame() #切换回父framelogo = browser.find_element_by_class_name('logo')print(logo)print(logo.text)time.sleep(3)browser.close() 12、延时等待这里等待的方式有两种：一种是隐式等待，一种是显式等待。 隐式等待，如果Selenium没有在DOM中找到节点，将继续等待，超出设定时间后，则抛出找不到节点的异常。隐式等待的效果其实并没有那么好，因为我们只规定了一个固定时间，而页面的加载时间会受到网络条件的影响。 显式等待，它指定要查找的节点，然后指定一个最长等待时间。如果在规定时间内加载出来了这个节点，就返回查找的节点；如果到了规定时间依然没有加载出该节点，则抛出超时异常。 12345678910#隐式等待from selenium import webdriverbrowser = webdriver.Chrome()browser.implicitly_wait(10) #隐式等待10秒browser.get('https://www.zhihu.com/explore')input = browser.find_element_by_class_name('zu-top-add-question')print(input)browser.close() 12345678910111213#显示等待from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECbrowser = webdriver.Chrome()browser.get('https://www.taobao.com/')wait = WebDriverWait(browser,10) #声明WebDriverWait对象，指定最长等待时间input = wait.until(EC.presence_of_element_located((By.ID,'q'))) #调用它的until()方法，传入要等待条件button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR,'.btn-search')))print(input,button)browser.close() 等待条件及其含义： title_is：标题是某内容 title_contains：标题包含某内容 presence_of_element_located：节点加载出来，传入定位元组，如(By.ID, ‘p’) visibility_of_element_located：节点可见，传入定位元组 visibility_of：可见，传入节点对象 presence_of_all_elements_located：所有节点加载出来 text_to_be_present_in_element：某个节点文本包含某文字 text_to_be_present_in_element_value：某个节点值包含某文字 frame_to_be_available_and_switch_to_it：加载并切换 invisibility_of_element_located：节点不可见 element_to_be_clickable：节点可点击 staleness_of：判断一个节点是否仍在DOM，可判断页面是否已经刷新 element_to_be_selected：节点可选择，传节点对象 element_located_to_be_selected：节点可选择，传入定位元组 element_selection_state_to_be：传入节点对象以及状态，相等返回True，否则返回False element_located_selection_state_to_be：传入定位元组以及状态，相等返回True，否则返回False alert_is_present：是否出现警告 等待条件的参数及用法参考官方文档：http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.support.expected_conditions 13、前进后退12345678910111213from selenium import webdriverimport timebrowser = webdriver.Chrome()browser.get('https://www.baidu.com/')browser.get('https://www.taobao.com/')browser.get('https://www.python.org/')browser.back() #后退time.sleep(2)browser.forward() #前进time.sleep(2)browser.close() 14、CookiesSelenium可以方便地对Cookies进行操作，例如获取、添加、删除Cookies等 12345678910from selenium import webdriver browser = webdriver.Chrome()browser.get('https://www.zhihu.com/explore')print(browser.get_cookies()) #获取cookiesbrowser.add_cookie(&#123;'name': 'name', 'domain': 'www.zhihu.com', 'value': 'germey'&#125;) #添加cookieprint(browser.get_cookies())browser.delete_all_cookies() #删除全部cookiesprint(browser.get_cookies())browser.close() 15、选项卡管理在访问网页的时候，会开启一个个选项卡。Selenium也可以对选项卡进行操作。 1234567891011121314from selenium import webdriverimport time browser = webdriver.Chrome()browser.get('https://www.baidu.com')browser.execute_script('window.open()') #借助javascript开启新的选项卡print(browser.window_handles) #window_handles获取当前所有选项卡句柄browser.switch_to_window(browser.window_handles[1]) #切换到第二个选项卡browser.get('https://www.taobao.com')time.sleep(2)browser.switch_to_window(browser.window_handles[0]) #切换回第一个选项卡browser.get('https://python.org')time.sleep(2)browser.close() 16、异常处理官方文档：http://selenium-python.readthedocs.io/api.html#module-selenium.common.exceptions 12345from selenium import webdriver browser = webdriver.Chrome()browser.get('https://www.baidu.com')browser.find_element_by_id('hello') #选择一个并不存在的节点，此时就会遇到异常。 1234567891011121314from selenium import webdriverfrom selenium.common.exceptions import TimeoutException,NoSuchElementExceptionbrowser = webdriver.Chrome()try: browser.get('https://www.baidu.com')except TimeoutException: print('Time Out')try: browser.find_element_by_id('hello')except NoSuchElementException: print('No Element')finally: browser.close() 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"爬虫-pyquery库","slug":"爬虫-pyquery库","date":"2018-07-02T06:00:00.000Z","updated":"2018-08-14T09:47:15.801Z","comments":true,"path":"2018/07/02/爬虫-pyquery库/","link":"","permalink":"http://pythonfood.github.io/2018/07/02/爬虫-pyquery库/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、PyQuery库详解1、什么是PyQuery库强大而灵活的网页解析库。如果你觉得正则写起来太麻烦，如果你觉得BeautifulSoup语法太难记，如果你熟悉jQuery的语法，那么PyQuery就是你的绝佳选择！！！ http://pyquery.readthedocs.io 2、安装pip install pyquery 3、初始化初始化pyquery的时候，也需要传入HTML文本来初始化一个PyQuery对象。它的初始化方式有多种，比如直接传入字符串，传入URL，传入文件名，等等。 12345678910111213141516171819202122232425#三种初始化方式from pyquery import PyQuery as pq#1.字符串初始化html = ''' &lt;div&gt; &lt;ul&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;&gt;/li &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"boid\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ''' doc1 = pq(html)print(doc1('li'))#2.URL初始化 doc2 = pq(url='http://www.baidu.com')print(doc2('head'))#3.文件初始化doc3 = pq(filename='demo.html')print(doc3('li')) 4、CSS选择器12345678910111213141516from pyquery import PyQuery as pqhtml = ''' &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;&gt;/li &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"boid\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ''' doc = pq(html)print(doc('#container .list li')) #空格代表嵌套关系,依次传入了id、class、标签print(type(doc('#container .list li'))) 5、查找元素123456789101112131415161718192021222324252627282930#子元素from pyquery import PyQuery as pqhtml = '''&lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;&gt;/li &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"boid\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ''' doc = pq(html)# 查找子孙节点需要用到find()方法，此时传入的参数是CSS选择器items = doc.find('.list')print(items)print(type(items))lis = doc.find('li')print(lis)print(type(lis))child1 = items.children() #children()方法查找子节点print(child1)print(type(child1))child2 = items.children('.active') #筛选子节点中符合条件的节点print(child2)print(type(child2)) 1234567891011121314151617181920212223242526272829#父元素from pyquery import PyQuery as pqhtml = '''&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;'''doc = pq(html)items = doc('.list') #首先用.list选取class为list的节点container = items.parent() #parent()得到父节点print(container)print(type(container))parents = items.parents() #parents()得到祖先节点print(parents)print(type(parents))parent = items.parents('.wrap') #筛选祖先节点中符合条件的节点print(parent) 1234567891011121314151617181920212223#兄弟元素from pyquery import PyQuery as pqhtml = '''&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;'''doc = pq(html)li = doc('.list .item-0.active') #注意：.item-0和.active之间没有空格，表示这两个class并存的节点print(li.siblings()) #siblings()获取兄弟节点print(li.siblings('.active')) #筛选兄弟节点中符合条件的节点 1234567891011121314151617181920212223242526#遍历from pyquery import PyQuery as pqhtml = '''&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;'''doc = pq(html)li = doc('.item-0.active')print(li) #单个节点可以直接打印输出print(str(li)) #也可以直接转成字符串lis = doc('li').items() #多个节点的结果，需要items()遍历来获取print(type(lis))for l in lis: print(li,type(li)) 6、获取信息1234567891011121314151617181920212223#获取属性from pyquery import PyQuery as pqhtml = '''&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"boid\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; ''' doc = pq(html)a = doc('.item-0.active a')print(a,type(a))print(a.attr('href')) #调用attr()方法获取属性值print(a.attr.href) #调用attr属性来获取属性值，这两种方式都可以 12345678910111213141516171819202122232425262728293031#获取文本from pyquery import PyQuery as pqhtml = '''&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"boid\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; ''' doc = pq(html)a = doc('.item-0.active a')print(a,type(a))print(a.text()) #text()获取节点内部的纯文本li = doc('.item-0.active')print(li)print(li.html()) #html()获取节点内部的HTML文本#注意，如果选中的结果是多个节点lis = doc('li')print(lis.html()) #html()方法返回的是第一个li节点的内部HTML文本print(lis.text()) #text()则返回所有的li节点内部的纯文本，中间用空格分割开print(type(lis.text())) #text()返回结果是一个字符串 7、DOM操作1234567891011121314151617181920212223242526272829303132from pyquery import PyQuery as pqhtml = '''&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"boid\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; ''' doc = pq(html)li = doc('.item-0.active')print(li)li.removeClass('active') #removeClass()移除class属性print(li)li.addClass('active') #addClass()增加class属性print(li)li.attr('name','link') #attr(属性名，属性值)来修改属性，如果只传入第一个参数的属性名，则是获取这个属性值print(li)li.text('changed item') #text(纯文本)来修改节点内纯文本，如果不传参数则是获取节点内纯文本print(li)li.html('&lt;span&gt;changed item&lt;/span&gt;') #html(html文本)来修改节点内html文本，如果不传参数则是获取节点内html文本print(li) 12345678910111213141516# remove()移除from pyquery import PyQuery as pqhtml = '''&lt;div class=\"wrap\"&gt; Hello, World &lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;/div&gt;'''doc = pq(html)wrap = doc('.wrap')print(wrap.text()) #获取的所有文本。现在想提取'Hello, World'这个字符串，而不要p节点内部的字符串，需要怎样操作呢？wrap.find('p').remove() #remove()方法移除节点print(wrap.text()) #此时wrap内部就只剩下'Hello, World'这句话了 还有很多节点操作的方法：append()、empty()和prepend()等，和jQuery的用法完全一致。官方文档：http://pyquery.readthedocs.io/en/latest/api.html。 8、伪类选择器CSS选择器之所以强大，还有一个很重要的原因，那就是它支持多种多样的伪类选择器，例如选择第一个节点、最后一个节点、奇偶数节点、包含某一文本的节点等。 12345678910111213141516171819202122232425262728from pyquery import PyQuery as pqhtml = '''&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;'''doc = pq(html)li = doc('li:first-child') #第一个print(li)li1 = doc('li:last-child') #最后一个print(li1)li2 = doc('li:nth-child(2)') #指定缩写顺序，第二个print(li2)li3 = doc('li:gt(2)') #大于2的print(li3)li4 = doc('li:nth-child(2n)') #偶数print(li4)li5 = doc('li:contains(second)') #包含secondprint(li5) 关于CSS选择器的更多用法，可以参考http://www.w3school.com.cn/css/index.asp 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"爬虫-beautifulsoup库","slug":"爬虫-beautifulsoup库","date":"2018-07-02T05:00:00.000Z","updated":"2018-08-14T09:43:09.814Z","comments":true,"path":"2018/07/02/爬虫-beautifulsoup库/","link":"","permalink":"http://pythonfood.github.io/2018/07/02/爬虫-beautifulsoup库/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、BeautifulSoup库详解1、什么是BeautifulSoupBeautiful Soup就是Python的一个HTML或XML的解析库，可以用它来方便地从网页中提取数据。利用它不用编写正则表达式即可方便实现网页信息的提取。 2、安装pip install beautifulsoup4 3、解析器 解析器 使用方法 优势 劣势 Python标准库 BeautifulSoup(markup, “html.parser”) Python的内置标准库、执行速度适中、文档容错能力强 Python 2.7.3及Python 3.2.2之前的版本文档容错能力差 lxml HTML解析器 BeautifulSoup(markup, “lxml”) 速度快、文档容错能力强 需要安装C语言库 lxml XML解析器 BeautifulSoup(markup, “xml”) 速度快、唯一支持XML的解析器 需要安装C语言库 html5lib BeautifulSoup(markup, “html5lib”) 最好的容错性、以浏览器的方式解析文档、生成HTML5格式的文档 速度慢、不依赖外部扩展 4、基本用法1234567891011121314151617from bs4 import BeautifulSouphtml = ''''' &lt;html&gt;&lt;head&gt;&lt;title&gt;The Domouse's story&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;p class=\"title\"name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt; &lt;p class=\"story\"&gt;Once upon a time there were little sisters;and their names were &lt;a href=\"http://example.com/elsie\"class=\"sister\"id=\"link1\"&gt;&lt;!--Elsie--&gt;&lt;/a&gt; &lt;a hred=\"http://example.com/lacle\"class=\"sister\"id=\"link2\"&gt;Lacle&lt;/a&gt;and &lt;a hred=\"http://example.com/tilie\"class=\"sister\"id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at bottom of a well.&lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt; ''' soup = BeautifulSoup(html,'lxml')print(soup.title.string) #打印标题print(soup.prettify()) #格式化代码 5、标签选择器1234567891011121314151617181920# 选择元素from bs4 import BeautifulSouphtml = ''' &lt;html&gt;&lt;head&gt;&lt;title&gt;The Domouse's story&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;p class=\"title\"name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt; &lt;p class=\"story\"&gt;Once upon a time there were little sisters;and their names were &lt;a href=\"http://example.com/elsie\"class=\"sister\"id=\"link1\"&gt;&lt;!--Elsie--&gt;&lt;/a&gt; &lt;a hred=\"http://example.com/lacle\"class=\"sister\"id=\"link2\"&gt;Lacle&lt;/a&gt;and &lt;a hred=\"http://example.com/tilie\"class=\"sister\"id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at bottom of a well.&lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt; ''' soup = BeautifulSoup(html,'lxml')print(soup.title)print(type(soup.title))print(soup.head)print(soup.p) #只能返回第一个标签 12345678910111213141516#获取名称from bs4 import BeautifulSouphtml = ''' &lt;html&gt;&lt;head&gt;&lt;title&gt;The Domouse's story&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;p class=\"title\"name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt; &lt;p class=\"story\"&gt;Once upon a time there were little sisters;and their names were &lt;a href=\"http://example.com/elsie\"class=\"sister\"id=\"link1\"&gt;&lt;!--Elsie--&gt;&lt;/a&gt; &lt;a hred=\"http://example.com/lacle\"class=\"sister\"id=\"link2\"&gt;Lacle&lt;/a&gt;and &lt;a hred=\"http://example.com/tilie\"class=\"sister\"id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at bottom of a well.&lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt; ''' soup = BeautifulSoup(html,'lxml')print(soup.title.name) #打印标签名称 1234567891011121314151617#获取属性from bs4 import BeautifulSouphtml = ''' &lt;html&gt;&lt;head&gt;&lt;title&gt;The Domouse's story&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;p class=\"title\"name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt; &lt;p class=\"story\"&gt;Once upon a time there were little sisters;and their names were &lt;a href=\"http://example.com/elsie\"class=\"sister\"id=\"link1\"&gt;&lt;!--Elsie--&gt;&lt;/a&gt; &lt;a hred=\"http://example.com/lacle\"class=\"sister\"id=\"link2\"&gt;Lacle&lt;/a&gt;and &lt;a hred=\"http://example.com/tilie\"class=\"sister\"id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at bottom of a well.&lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt; ''' soup = BeautifulSoup(html,'lxml')print(soup.p.attrs['name'])print(soup.p['name']) #两种方式都可以获取标签属性 12345678910111213141516#获取内容from bs4 import BeautifulSouphtml = ''' &lt;html&gt;&lt;head&gt;&lt;title&gt;The Domouse's story&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;p class=\"title\"name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt; &lt;p class=\"story\"&gt;Once upon a time there were little sisters;and their names were &lt;a href=\"http://example.com/elsie\"class=\"sister\"id=\"link1\"&gt;&lt;!--Elsie--&gt;&lt;/a&gt; &lt;a hred=\"http://example.com/lacle\"class=\"sister\"id=\"link2\"&gt;Lacle&lt;/a&gt;and &lt;a hred=\"http://example.com/tilie\"class=\"sister\"id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at bottom of a well.&lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt; ''' soup = BeautifulSoup(html,'lxml')print(soup.p.string) 6、嵌套选择123456789101112131415from bs4 import BeautifulSouphtml = ''' &lt;html&gt;&lt;head&gt;&lt;title&gt;The Domouse's story&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;p class=\"title\"name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt; &lt;p class=\"story\"&gt;Once upon a time there were little sisters;and their names were &lt;a href=\"http://example.com/elsie\"class=\"sister\"id=\"link1\"&gt;&lt;!--Elsie--&gt;&lt;/a&gt; &lt;a hred=\"http://example.com/lacle\"class=\"sister\"id=\"link2\"&gt;Lacle&lt;/a&gt;and &lt;a hred=\"http://example.com/tilie\"class=\"sister\"id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at bottom of a well.&lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt; ''' soup = BeautifulSoup(html,'lxml')print(soup.head.title.string) 12345678910111213141516171819202122232425262728293031#子节点和子孙节点from bs4 import BeautifulSouphtml = '''&lt;html&gt; &lt;head&gt; &lt;title&gt;The Domouse's story&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were little sisters;and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\"id=\"link1\"&gt; &lt;span&gt;Elsle&lt;/span&gt; &lt;/a&gt; &lt;a hred=\"http://example.com/lacle\"class=\"sister\" id=\"link2\"&gt;Lacle&lt;/a&gt; and &lt;a hred=\"http://example.com/tilie\"class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt; ''' soup = BeautifulSoup(html,'lxml')print(soup.p.contents) #子节点以列表形式返回print(soup.p.children) #不同之处：children实际上是一个迭代器，需要用循环的方式才能将内容取出for i,child in enumerate(soup.p.children): print(i,child)print(soup.p.descendants) #获取所有的子孙节点，也是一个迭代器for l,child1 in enumerate(soup.p.descendants): print(l,child1) 1234567891011121314151617181920212223242526#父节点和祖先节点from bs4 import BeautifulSouphtml = '''&lt;html&gt; &lt;head&gt; &lt;title&gt;The Domouse's story&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were little sisters;and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\"id=\"link1\"&gt; &lt;span&gt;Elsle&lt;/span&gt; &lt;/a&gt; &lt;a hred=\"http://example.com/lacle\"class=\"sister\" id=\"link2\"&gt;Lacle&lt;/a&gt; and &lt;a hred=\"http://example.com/tilie\"class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt; ''' soup = BeautifulSoup(html,'lxml')print(soup.a.parent) #返回父标签的整个内容print(list(enumerate(soup.a.parents))) #所有祖先节点（包括父标签） 1234567891011121314151617181920212223242526#兄弟节点from bs4 import BeautifulSouphtml = '''&lt;html&gt; &lt;head&gt; &lt;title&gt;The Domouse's story&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were little sisters;and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\"id=\"link1\"&gt; &lt;span&gt;Elsle&lt;/span&gt; &lt;/a&gt; &lt;a hred=\"http://example.com/lacle\"class=\"sister\" id=\"link2\"&gt;Lacle&lt;/a&gt; and &lt;a hred=\"http://example.com/tilie\"class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt; ''' soup = BeautifulSoup(html,'lxml')print(list(enumerate(soup.a.next_siblings))) #后面的兄弟节点 print(list(enumerate(soup.a.previous_siblings))) #前面的兄弟节点 7、标准选择器find_all(name,attrs,recursive,text,**kargs) 可根据签名、属性、内容查找文档 123456789101112131415161718192021222324252627#namefrom bs4 import BeautifulSoup html = '''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"name=\"elements\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\"Id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\"Id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div&gt; ''' soup = BeautifulSoup(html,'lxml')print(soup.find_all('ul')) #返回列表类型print(soup.find_all('ul')[0])for ul in soup.find_all('ul'): print(ul.find_all('li')) 123456789101112131415161718192021222324#attrsfrom bs4 import BeautifulSoup html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\" name=\"elements\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;''' soup = BeautifulSoup(html,'lxml')print(soup.find_all(attrs=&#123;\"id\":\"list-1\"&#125;))print(soup.find_all(attrs=&#123;\"name\":\"elements\"&#125;)) 123456789101112131415161718192021222324#常用属性from bs4 import BeautifulSoup html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\" name=\"elements\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;''' soup = BeautifulSoup(html,'lxml')print(soup.find_all(id='list-1'))print(soup.find_all(class_='element')) #注意：由于class在Python里是一个关键字，所以后面需要加一个下划线 1234567891011121314151617181920212223#textfrom bs4 import BeautifulSoup html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\" name=\"elements\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;''' soup = BeautifulSoup(html,'lxml')print(soup.find_all(text='Foo')) find(name，attrs，recursive，text，**kwargs) find返回单个元素，find_all返回所有元素 123456789101112131415161718192021222324from bs4 import BeautifulSoup html = ''''' &lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"name=\"elelments\"&gt; &lt;ul class=\"list\"Id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\"Id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div&gt; ''' soup = BeautifulSoup(html,'lxml')print(soup.find('ul'))print(type(soup.find('ul')))print(soup.find('page')) 其他常用方法： find_parents()：返回所有祖先节点和find_parent()返回直接父节点 find_next_siblings()：返回所有兄弟节点和find_next_sibling()返回后面第一个兄弟节点 find_previous_siblings()：返回前面的所有兄弟节点和find_previous_sibling()：返回前面第一个兄弟节点 find_all_next()：返回节点后所有符合条件的节点和find_next()：返回第一个符合条件的节点 find_all_previous()：返回节点前所有符合条件的节点和find_previous()：返回节点前第一个符合条件的节点 8、CSS选择器通过select()直接传入CSS选择器即可完成选择 12345678910111213141516171819202122232425from bs4 import BeautifulSoup html = '''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"name=\"elelments\"&gt; &lt;ul class=\"list\"Id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\"Id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div&gt; ''' soup = BeautifulSoup(html,'lxml') print(soup.select('.panel .panel-heading')) #传入css选择器print(soup.select('ul li')) # 传入标签print(soup.select('#list-2 .element')) #传入idprint(type(soup.select('ul')[0])) 12345678910111213141516171819202122232425#嵌套选择from bs4 import BeautifulSoup html = '''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"name=\"elelments\"&gt; &lt;ul class=\"list\"Id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\"Id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div&gt; ''' soup = BeautifulSoup(html,'lxml') for ul in soup.select('ul'): print(ul.select('li'))#可以直接传入选择器实现嵌套比这种方式更方便 12345678910111213141516171819202122232425#获取属性from bs4 import BeautifulSoup html = '''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"name=\"elelments\"&gt; &lt;ul class=\"list\"Id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\"Id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div&gt; ''' soup = BeautifulSoup(html,'lxml') for ul in soup.select('ul'): print(ul['id']) #直接传入中括号和属性名 print(ul.attrs['id']) #通过attrs属性获取属性值,两种方式都可以 1234567891011121314151617181920212223#获取内容html = ''''' &lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"name=\"elelments\"&gt; &lt;ul class=\"list\"Id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\"Id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div&gt; ''' soup = BeautifulSoup(html,'lxml') for li in soup.select('li'): print(li.string) #string属性获取文本 print(li.get_text()) #get_text()方法获取文本，两种都行 总结： (1)推荐使用’lxml’解析库，必要时使用html.parser (2)标签选择器筛选功能但速度快 (3)建议使用find()，find_all()查询匹配单个结果或者多个结果 (4)如果对CSS选择器熟悉建议选用select() (5)记住常用的获取属性和文本值得方法 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"爬虫-re库","slug":"爬虫-re库","date":"2018-07-02T04:00:00.000Z","updated":"2018-08-14T09:29:30.055Z","comments":true,"path":"2018/07/02/爬虫-re库/","link":"","permalink":"http://pythonfood.github.io/2018/07/02/爬虫-re库/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、Re库详解1、什么是正则表达式正则表达式对子符串操作的一种逻辑公式，就是事先定义好的一些特定字符、及这些特定字符的组合，组成一个‘规则字符串’，这个‘规则字符串’用来表达对字符串的一种过滤逻辑。 2、样例展示开源中国提供的正则表达式测试工具：http://tool.oschina.net/regex/ 。输入待匹配的文本，然后选择常用的正则表达式，就可以得出相应的匹配结果了。 3、常用的匹配规则 模式 描述 \\w 匹配字母、数字及下划线 \\W 匹配不是字母、数字及下划线的字符 \\s 匹配任意空白字符，等价于[\\t\\n\\r\\f] \\S 匹配任意非空字符 \\d 匹配任意数字，等价于[0-9] \\D 匹配任意非数字的字符 \\A 匹配字符串开头 \\Z 匹配字符串结尾，如果存在换行，只匹配到换行前的结束字符串 \\z 匹配字符串结尾，如果存在换行，同时还会匹配换行符 \\G 匹配最后匹配完成的位置 \\n 匹配一个换行符 \\t 匹配一个制表符 ^ 匹配一行字符串的开头 $ 匹配一行字符串的结尾 . 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符 […] 用来表示一组字符，单独列出，比如[amk]匹配a、m或k [^…] 不在[]中的字符，比如[^abc]匹配除了a、b、c之外的字符 * 匹配0个或多个表达式 + 匹配1个或多个表达式 ? 匹配0个或1个前面的正则表达式定义的片段，非贪婪方式 {n} 精确匹配n个前面的表达式 {n, m} 匹配n到m次由前面正则表达式定义的片段，贪婪方式 a&#124;b 匹配a或b ( ) 匹配括号内的表达式，也表示一个组 4、常用的修饰符(匹配模式) 修饰符 描述 re.I 使匹配对大小写不敏感 re.L 做本地化识别（locale-aware）匹配 re.M 多行匹配，影响^和$ re.S 使.匹配包括换行在内的所有字符 re.U 根据Unicode字符集解析字符。这个标志影响\\w、\\W、 \\b和\\B re.X 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解 5、re.match尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回None re.match(pattern,string,flags=0) 123456789#常规匹配import re content = 'Hello 123 4567 World_This is a Regex Demo' print(len(content))result = re.match('^Hello\\s\\d\\d\\d\\s\\d&#123;4&#125;.*Demo$',content)print(result)print(result.group())print(result.span()) 123456789#泛匹配import re content = 'Hello 123 4567 World_This is a Regex Demo' print(len(content))result = re.match('^Hello.*Demo$',content)print(result)print(result.group())print(result.span()) 123456789101112#匹配目标import re content = 'Hello 1234567 World_This is a Regex Demo'print(len(content))#可以使用()括号将想提取的子字符串括起来。()实际上标记了一个子表达式的开始和结束位置，被标记的每个子表达式会依次对应每一个分组，调用group()方法传入分组的索引即可获取提取的结果。result = re.match('^Hello\\s(\\d+)\\sWorld.*Demo$',content) print(result)print(result.group())print(result.group(1)) # 将第一括号括起来的内容打印出来，依次可推group(2)print(result.span())print(result.groups()) 123456789#贪婪匹配import recontent = 'Hello 1234567 World_This is a Regex Demo'print(len(content))result = re.match('^Hel.*(\\d+).*Demo$',content)print(result)print(result.group(1))#在贪婪匹配下，.*会匹配尽可能多的字符。正则表达式中.*后面\\d+至少一个数字，但并没有指定具体多少个数字，因此，.*就尽可能匹配多的字符，这里就把123456匹配了，给\\d+留下一个可满足条件的数字7。 12345678#非贪婪匹配content = 'Hello 1234567 World_This is a Regex Demo'print(len(content))result = re.match('Hel.*?(\\d+).*Demo$',content) #非贪婪匹配的写法是.*?print(result)print(result.group(1))#非贪婪匹配就是尽可能匹配少的字符。当.*?匹配到Hello后面的空白字符时，再往后的字符就是数字了，而\\d+恰好可以匹配，那么这里.*?就不再进行匹配，交给\\d+去匹配后面的数字。#这里需要注意，如果匹配的结果在字符串结尾，.*?就有可能匹配不到任何内容了，因为它会匹配尽可能少的字符。需要用贪婪匹配.* 123456789#匹配模式(修饰符)import recontent = '''Hello 1234567 World_This is a Regex Demo''' result = re.match('He.*?(\\d+).*?Demo$',content) #.匹配的是除换行符之外的任意字符，当遇到换行符时，.*?就不能匹配了print(result)result1 = re.match('He.*?(\\d+).*?Demo$',content,re.S) # 只需加一个修饰符re.S,使.匹配包括换行在内的所有字符print(result1) 12345678#转义匹配import recontent = 'prince is $5.00'result = re.match('prince is $5.00',content)print(result)result1 = re.match('prince is \\$5\\.00',content) #遇到用于正则匹配模式的特殊字符时，在前面加反斜线转义一下print(result1) 总结：尽量使用泛匹配，使用括号得到匹配目标，尽量使用非贪婪模式、有换行符就用re.S 6、re.searchmatch()方法是从字符串的开头开始匹配的，一旦开头不匹配，那么整个匹配就失败了. 这里有另外一个方法search()会依次扫描字符串，直到找到第一个符合规则的字符串，然后返回匹配内容，如果搜索完了还没有找到，就返回None。 1234567import re content = 'Extra stings Hello 1234567 World_This is a Regex Demo Extra stings'result = re.match('Hello.*?(\\d+).*?Demo', content)print(result)result1 = re.search('Hello.*?(\\d+).*?Demo', content)print(result1) 总结：为了匹配方便，能用search()就不用match()。 123456789101112131415161718192021222324252627# 匹配练习import rehtml = '''&lt;div id=\"songs-list\"&gt; &lt;h2 class=\"title\"&gt;经典老歌&lt;/h2&gt; &lt;p class=\"introduction\"&gt; 经典老歌列表 &lt;/p&gt; &lt;ul id=\"list\" class=\"list-group\"&gt; &lt;li data-view=\"2\"&gt;一路上有你&lt;/li&gt; &lt;li data-view=\"7\"&gt; &lt;a href=\"/2.mp3\" singer=\"任贤齐\"&gt;沧海一声笑&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"4\" class=\"active\"&gt; &lt;a href=\"/3.mp3\" singer=\"齐秦\"&gt;往事随风&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"6\"&gt;&lt;a href=\"/4.mp3\" singer=\"beyond\"&gt;光辉岁月&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt;&lt;a href=\"/5.mp3\" singer=\"陈慧琳\"&gt;记事本&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt; &lt;a href=\"/6.mp3\" singer=\"邓丽君\"&gt;&lt;i class=\"fa fa-user\"&gt;&lt;/i&gt;但愿人长久&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''result = re.search('&lt;li.*?active.*?singer=\"(.*?)\"&gt;(.*?)&lt;/a&gt;',html,re.S)print(result.groups())print(result.group(1),result.group(2)) 7、re.findall搜索字符，以列表的形式返回全部匹配的字符串。 123456789101112131415161718192021222324252627282930313233import rehtml = '''&lt;div id=\"songs-list\"&gt; &lt;h2 class=\"title\"&gt;经典老歌&lt;/h2&gt; &lt;p class=\"introduction\"&gt; 经典老歌列表 &lt;/p&gt; &lt;ul id=\"list\" class=\"list-group\"&gt; &lt;li data-view=\"2\"&gt;一路上有你&lt;/li&gt; &lt;li data-view=\"7\"&gt; &lt;a href=\"/2.mp3\" singer=\"任贤齐\"&gt;沧海一声笑&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"4\" class=\"active\"&gt; &lt;a href=\"/3.mp3\" singer=\"齐秦\"&gt;往事随风&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"6\"&gt;&lt;a href=\"/4.mp3\" singer=\"beyond\"&gt;光辉岁月&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt;&lt;a href=\"/5.mp3\" singer=\"陈慧琳\"&gt;记事本&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt; &lt;a href=\"/6.mp3\" singer=\"邓丽君\"&gt;但愿人长久&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''results = re.findall('&lt;li.*?href=\"/(.*?)\".*?singer=\"(.*?)\"&gt;(.*?)&lt;/a&gt;',html,re.S)print(results)print(type(results))for result in results: print(result[0],result[1],result[2]) results1 = re.findall('&lt;li.*?&gt;\\s*?(&lt;/a.*?&gt;)?(\\w+)(&lt;/a&gt;)?\\s*?&lt;/li&gt;',html,re.S)print(results1)for result1 in results1: print(result1[1]) 8、re.sub替换字符串中每一个匹配的字符串后返回替换后的字符串。 re.sub(正则表达式，要替换成的字符串，原字符串) 123456789101112import re content = 'Extra stings Hello 1234567 World_This is a Regex Demo Extra stings'result = re.sub('\\d+','',content) #去掉数字print(result)result1 = re.sub('\\d+','Replacement',content) #数字替换为字符print(result1)result2 = re.sub('(\\d+)',r'\\1 8910',content) #如果要替换的字符串包含自己本身用\\1表示，正则表达式需要用()print(result2) 1234567891011121314151617181920212223242526272829import re html = '''''&lt;div id=\"songs-list\"&gt; &lt;h2 class=\"title\"&gt;经典老歌&lt;/h2&gt; &lt;p class=\"introduction\"&gt; 经典老歌列表 &lt;/p&gt; &lt;ul id=\"list\"class=\"list-group\"&gt; &lt;li data-view=\"2\"&gt;一路上有你&lt;/li&gt; &lt;li data-view=\"7\"&gt; &lt;a href=\"/2.mp3\"singer=\"任贤齐\"&gt;沧海一声笑&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"4\"class=\"active\"&gt; &lt;a href=\"/3.mp3\"singer=\"齐秦\"&gt;往事随风&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"6\"&gt;&lt;a href=\"/4.mp3\"singer=\"begoud\"&gt;光辉岁月&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt;&lt;a href=\"/5.mp3\"singer=\"陈慧琳\"&gt;记事本&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt; &lt;a href=\"/6.mp3\"singer=\"邓丽君\"&gt;但愿人长久&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;''' html = re.sub('&lt;a.*?&gt;|&lt;/a&gt;','',html) #首先去掉a标签print(html)results = re.findall('&lt;li.*?&gt;(.*?)&lt;/li&gt;',html,re.S) #然后再查找所有歌名print(results)for result in results: print(result.strip()) 9、re.compile将正则字符串编译成正则表达式对象，以便在后面的匹配中复用。 12345678910import re content = '''Hello 1234545 World_This is a Regex Demo''' pattern = re.compile('Hello.*Demo',re.S) #编译正则表达式对象result = re.match(pattern,content) #正则对象复用print(result)result1 = re.match('Hello.*Demo',content,re.S)print(result1) 10、实战练习12345678910111213import requestsimport re content = requests.get('https://book.douban.com/').text #获取网页源代码#print(content)pattern = re.compile('&lt;li.*?\"cover\"&gt;.*?href=\"(.*?)\" title=\"(.*?)\".*?\"more-meta\".*?\"author\"&gt;(.*?)&lt;/span&gt;.*?\"year\"&gt;(.*?)&lt;/span&gt;.*?&lt;/li&gt;',re.S)results = re.findall(pattern,content)print(results)for result in results: url,name,author,time = result author = re.sub('\\s','',author) time = re.sub('\\s','',time) print(url,name,author,time) 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"爬虫-requests库","slug":"爬虫-requests库","date":"2018-07-02T03:00:00.000Z","updated":"2018-08-14T09:14:32.334Z","comments":true,"path":"2018/07/02/爬虫-requests库/","link":"","permalink":"http://pythonfood.github.io/2018/07/02/爬虫-requests库/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、Requests库详解1、什么是Requests库Requests库是用Python编写的，基于urllib，采用Apache2 Licensed开源协议的HTTP库。 相比urllib库，Requests库更加方便，可以节约我们大量的工作，完全满足HTTP测试需求。 2、安装pip install request 3、Requests库用法详解12345678import requestsresponse = requests.get('http://www.baidu.com')print(type(response))print(response.status_code)print(type(response.text))print(response.text)print(response.cookies) 123456789# 各种请求（HTTP测试网站：http://httpbin.org/）import requestsrequests.get('http://httpbin.org/get')requests.post('http://httpbin.org/post')requests.delete('http://httpbin.org/delete')requests.put('http://httpbin.org/put')requests.head('http://httpbin.org/get')requests.options('http://httpbin.org/get') 12345# 基本get请求import requestsresponse = requests.get('http://httpbin.org/get')print(response.text) 123456789# 带参数get请求import requestsdata=&#123; 'name':'asr', 'age':'12'&#125;response = requests.get('http://httpbin.org/get',params=data)print(response.text) 1234567891011# 解析jsonimport requestsimport jsonresponse = requests.get('http://httpbin.org/get')print(response.text)print(type(response.text))print(response.json())print(type(response.json()))print(json.loads(response.text))print(type(json.loads(response.text))) 123456789101112# 获取二进制数据import requestsresponse = requests.get('https://github.com/favicon.ico')print(response.text)print(type(response.text))print(response.content) # 获取二进制数据用response.contentprint(type(response.content))with open('favicon.ico','wb') as f: f.write(response.content) f.close() 12345678910# 添加headersimport requestsresponse = requests.get('http://www.zhihu.com/explore') #不加headers不能访问print(response.text)headers = &#123;'User-Agent':'Mozilla/5.0 (Windows NT 10.0; rv:60.0) Gecko/20100101 Firefox/60.0'&#125;response1 = requests.get('http://www.zhihu.com/explore',headers=headers)print(response1.text) 123456789101112# 基本post请求import requestsdata = &#123; 'name':'jk', 'age':18&#125;headers=&#123; 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; rv:60.0) Gecko/20100101 Firefox/60.0'&#125;response = requests.post('http://httpbin.org/post',data=data,headers=headers)print(response.json()) 123456789# response属性import requestsresponse = requests.get('http://www.douban.com')print(type(response.status_code),response.status_code)print(type(response.headers),response.headers)print(type(response.cookies),response.cookies)print(type(response.url),response.url)print(type(response.history),response.history) 12345# 状态码判断import requestsresponse =requests.get('http://www.jianshu.com')exit() if not response.status_code==requests.codes.forbidden else print('403 forbidden') #状态码查询对象，可以从下表中查找 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778# 信息性状态码100: ('continue',),101: ('switching_protocols',),102: ('processing',),103: ('checkpoint',),122: ('uri_too_long', 'request_uri_too_long'),# 成功状态码200: ('ok', 'okay', 'all_ok', 'all_okay', 'all_good', '\\\\o/', '✓'),201: ('created',),202: ('accepted',),203: ('non_authoritative_info', 'non_authoritative_information'),204: ('no_content',),205: ('reset_content', 'reset'),206: ('partial_content', 'partial'),207: ('multi_status', 'multiple_status', 'multi_stati', 'multiple_stati'),208: ('already_reported',),226: ('im_used',),# 重定向状态码300: ('multiple_choices',),301: ('moved_permanently', 'moved', '\\\\o-'),302: ('found',),303: ('see_other', 'other'),304: ('not_modified',),305: ('use_proxy',),306: ('switch_proxy',),307: ('temporary_redirect', 'temporary_moved', 'temporary'),308: ('permanent_redirect', 'resume_incomplete', 'resume',), # These 2 to be removed in 3.0# 客户端错误状态码400: ('bad_request', 'bad'),401: ('unauthorized',),402: ('payment_required', 'payment'),403: ('forbidden',),404: ('not_found', '-o-'),405: ('method_not_allowed', 'not_allowed'),406: ('not_acceptable',),407: ('proxy_authentication_required', 'proxy_auth', 'proxy_authentication'),408: ('request_timeout', 'timeout'),409: ('conflict',),410: ('gone',),411: ('length_required',),412: ('precondition_failed', 'precondition'),413: ('request_entity_too_large',),414: ('request_uri_too_large',),415: ('unsupported_media_type', 'unsupported_media', 'media_type'),416: ('requested_range_not_satisfiable', 'requested_range', 'range_not_satisfiable'),417: ('expectation_failed',),418: ('im_a_teapot', 'teapot', 'i_am_a_teapot'),421: ('misdirected_request',),422: ('unprocessable_entity', 'unprocessable'),423: ('locked',),424: ('failed_dependency', 'dependency'),425: ('unordered_collection', 'unordered'),426: ('upgrade_required', 'upgrade'),428: ('precondition_required', 'precondition'),429: ('too_many_requests', 'too_many'),431: ('header_fields_too_large', 'fields_too_large'),444: ('no_response', 'none'),449: ('retry_with', 'retry'),450: ('blocked_by_windows_parental_controls', 'parental_controls'),451: ('unavailable_for_legal_reasons', 'legal_reasons'),499: ('client_closed_request',),# 服务端错误状态码500: ('internal_server_error', 'server_error', '/o\\\\', '✗'),501: ('not_implemented',),502: ('bad_gateway',),503: ('service_unavailable', 'unavailable'),504: ('gateway_timeout',),505: ('http_version_not_supported', 'http_version'),506: ('variant_also_negotiates',),507: ('insufficient_storage',),509: ('bandwidth_limit_exceeded', 'bandwidth'),510: ('not_extended',),511: ('network_authentication_required', 'network_auth', 'network_authentication') 4、Requests高级操作123456789# 文件上传import requestsfiles = &#123; 'files':open('favicon.ico','rb')&#125;response = requests.post('http://httpbin.org/post',files=files)print(response.text) 1234567# 获取cookiesimport requestsresponse = requests.get('http://www.baidu.com')print(response.cookies)for k,v in response.cookies.items(): print(k +'='+ v) 1234567891011# 会话维持import requestsrequests.get('http://httpbin.org/cookies/set/number/123456789') #为网站的访问设置cookie response = requests.get('http://httpbin.org/cookies') #与上面的行为时独立的，所以获取不到任何与cookie相关的信息print(response.text)s = requests.Session() #声明Session对象，使用这个对象发起两次GET请求（相当于同一个浏览器发出来的请求）s.get('http://httpbin.org/cookies/set/number/123456789')r = s.get('http://httpbin.org/cookies')print(r.text) 1234567891011121314151617181920212223242526# 证书验证import requests#直接请求https会报错SLLError#response = requests.get('https://www.12306.cn')#print(response.status_code)#添加verify=False可以忽略证书验证，但是还是会报警告#response = requests.get('https://www.12306.cn',verify=False)#print(response.text)# 1.引入requests.packages.urllib3设置忽略警告from requests.packages import urllib3urllib3.disable_warnings()response = requests.get('https://www.12306.cn',verify=False)print(response.status_code)# 2.通过捕获警告到日志的方式忽略警告import logginglogging.captureWarnings(True)response = requests.get('https://www.12306.cn',verify=False)print(response.status_code)# 3.指定一个本地证书用作客户端证书，这可以是单个文件（包含密钥和证书）或一个包含两个文件路径的元组response = requests.get('https://www.12306.cn',cert=('/path/server.crt', '/path/key'))print(response.status_code) 123456789101112131415161718192021# 代理设置import requestsproxies = &#123; \"http\": \"http://10.10.1.10:3128\", \"https\": \"http://10.10.1.10:1080\",&#125;requests.get(\"https://www.taobao.com\", proxies=proxies)# 若代理需要使用HTTP Basic Auth，可以使用类似http://user:password@host:port这样的语法来设置代理。proxies = &#123; \"http\": \"http://user:password@10.10.1.10:3128/\",&#125;requests.get(\"https://www.taobao.com\", proxies=proxies)# 除了基本的HTTP代理外，requests还支持SOCKS协议的代理。pip3 install 'requests[socks]'proxies = &#123; 'http': 'socks5://user:password@host:port', 'https': 'socks5://user:password@host:port'&#125;requests.get(\"https://www.taobao.com\", proxies=proxies) 123456789101112# 超时设置 import requestsr = requests.get('https://www.taobao.com',timeout=1)print(r.status_code)# 分别指定连接（connect）和读取（read）两个阶段超时，可以传入一个元组r = requests.get('https://www.taobao.com',timeout=(5.11,30))# 想永久等待，可以直接将timeout设置为None,或直接不加参数r = requests.get('https://www.taobao.com',timeout=None)r = requests.get('https://www.taobao.com') 123456789# 身份认证import requestsr = requests.get('http://120.27.34.24.9001',auth=('username', 'password'))print(r.status_code)#上面代码是简写，实际调用的requests.auth.HTTPBasicAuth from requests.auth import HTTPBasicAuthr=requests.get('http://120.27.34.24.9001',auth=HTTPBasicAuth('username', 'password')) 12345678910111213# 异常处理# http://docs.python-requests.org/en/master/api/#exceptionsimport requestsfrom requests.exceptions import ReadTimeout,HTTPError,RequestExceptiontry: r = requests.get('https://www.taobao.com',timeout=0.1)except ReadTimeout: print('ReadTimeout')except HTTPError: print('HTTPError')except RequestException: print('RequestException') 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"爬虫-urllib库","slug":"爬虫-urllib库","date":"2018-07-02T02:00:00.000Z","updated":"2018-08-14T09:09:16.035Z","comments":true,"path":"2018/07/02/爬虫-urllib库/","link":"","permalink":"http://pythonfood.github.io/2018/07/02/爬虫-urllib库/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、Urllib库详解1、Urllib库 urllib.request：请求模块 urllib.error：异常处理模块 urllib.parse：url解析模块（拆分、合并等） urllib.robotparser：robot.txt解析模块 urllib.request.urlopen(url,data = None,[timeout]*,cafile = None,capath = None,cadefault = False,context = None) 1234# get请求import urllib.requestresponse = urllib.request.urlopen('http://www.baidu.com')print(response.read().decode('utf-8')) 1234567# post请求import urllib.requestimport urllib.parsedata = bytes(urllib.parse.urlencode(&#123;'word':'hello'&#125;),encoding='utf8')response = urllib.request.urlopen('http://httpbin.org/post',data=data)print(response.read()) 12345# time超时import urllib.requestresponse = urllib.request.urlopen('http://httpbin.org/get',timeout=1)print(response.read()) 12345678910# error错误import socketimport urllib.requestimport urllib.errortry: response = urllib.request.urlopen('http://httpbin.org/get',timeout = 0.1)except urllib.error.URLError as e: if isinstance(e.reason,socket.timeout): print('TIME OUT') 2、响应12345# 响应类型import urllib.requestresponse = urllib.request.urlopen('https://www.python.org')print(type(response)) 12345678# 状态码、响应头import urllib.requestresponse = urllib.request.urlopen('https://www.python.org')print(response.status)print(response.getheaders()) #print(response.getheaders(\"Server\")) 3、Request12345import urllib.requestrequest = urllib.request.Request('https://www.python.org')response = urllib.request.urlopen(request)print(response.read().decode('utf-8')) 123456789101112131415# Request添加header、dataimport urllib.requestimport urllib.parseurl = 'http://httpbin.org/post'headers = &#123; 'User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64)', 'Host':'httpbin.org'&#125;dict = &#123;'name':'Germey' &#125;data = bytes(urllib.parse.urlencode(dict),encoding=\"utf8\")request = urllib.request.Request(url=url,headers=headers,data=data,method='POST')response = urllib.request.urlopen(request)print(response.read().decode('utf-8')) 12345678910111213# 另外一种添加header方式import urllib.requestimport urllib.parseurl = 'http://httpbin.org/post'dict = &#123;'name':'Germey' &#125;data = bytes(urllib.parse.urlencode(dict),encoding=\"utf8\")request = urllib.request.Request(url=url,data=data,method='POST')request.add_header( 'User-Agent','Mozilla/5.0 (Windows NT 6.1; WOW64)') # 注意key,value之间用逗号隔开request.add_header('Host','httpbin.org')response = urllib.request.urlopen(request)print(response.read().decode('utf-8')) 4、Handlerhttps://docs.python.org/3/library/urllib.request.html#module-urllib.request 123456789101112# 代理import urllib.requestproxy_handler = urllib.request.ProxyHandler( &#123; 'http':'http://127.0.0.1:9743', 'https':'https://127.0.0.1:9743' &#125;)opener = urllib.request.build_opener(proxy_handler)response = opener.open('http://www.baidu.com')print(response.read().decode('utf-8')) 5、Cookie客户端保存，用来记录客户身份的文本文件、维持登录状态 12345678910# cookie获取import urllib.requestimport http.cookiejarcookie = http.cookiejar.CookieJar() # 设置一个cookie栈 handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)response = opener.open('http://www.baidu.com')for item in cookie: print(item.name+'='+item.value) 12345678910# 保存cookie为文本文件import urllib.requestimport http.cookiejarfilename = 'cookie.txt'cookie = http.cookiejar.MozillaCookieJar(filename)handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)response = opener.open('http://www.baidu.com')cookie.save(ignore_discard=True,ignore_expires=True) #保存cookie 12345678910# 另外一种cookie保存格式import urllib.requestimport http.cookiejarfilename = 'cookie_LWP.txt'cookie = http.cookiejar.LWPCookieJar(filename)handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)response = opener.open('http://www.baidu.com')cookie.save(ignore_discard=True,ignore_expires=True) #保存cookie 12345678910# 用什么方式保存cookie，就用什么方式读取import urllib.requestimport http.cookiejarcookie = http.cookiejar.LWPCookieJar()cookie.load('cookie_LWP.txt',ignore_discard=True,ignore_expires=True)handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)response = opener.open('http://www.baidu.com')print(response.read().decode('utf-8')) 6、异常处理https://docs.python.org/3/library/urllib.error.html#module-urllib.error 1234567from urllib import requestfrom urllib import errortry: response = request.urlopen('http://www.cuiqingcai.com/index.html')except error.URLError as e: print(e.reason) 123456789101112# 可以捕捉的异常from urllib import requestfrom urllib import errortry: response = request.urlopen('http://www.cuiqingcai.com/index.html')except error.HTTPError as e: # 先捕捉子类异常 print(e.reason,e.code,e.headers,sep='\\n')except error.URLError as e: # 再捕捉父类异常 print(e.reason)else: print('Request Successfully') 1234567891011# 验证异常是那种原因from urllib import requestfrom urllib import errorimport sockettry: response = request.urlopen('http://www.baidu.com',timeout=0.01)except error.URLError as e: print(type(e.reason)) if isinstance(e.reason,socket.timeout): print('Time Out') 7、URL解析https://docs.python.org/3/library/urllib.parse.html#module-urllib.parse (1)urlparse 将url进行分割，分割成几个部分，再依次将其复制 parse.urlparse(urlstring,scheme=&#39;&#39;,allow_fragments = True) 1234567891011121314151617from urllib.parse import urlparseresult = urlparse('https://www.baidu.com/s?wd=urllib&amp;ie=UTF-8') # 解析url为6个部分print(type(result))print(result)result1 = urlparse('www.baidu.com/s?wd=urllib&amp;ie=UTF-8',scheme='https') # 无协议类型，自行添加协议类型print(result1)result2 = urlparse('http://www.baidu.com/s?wd=urllib&amp;ie=UTF-8',scheme='https') # 有协议类型，添加协议类型还是会显示默认协议print(result2)result3 = urlparse('http://www.baidu.com/s?wd=urllib&amp;ie=UTF-8#comment',allow_fragments=True) # allow_fragments为Trueprint(result3)result4 = urlparse('http://www.baidu.com/s?wd=urllib&amp;ie=UTF-8#comment',allow_fragments=False) # allow_fragments为False，会自行向前拼接print(result4) (2)urlunparse urlparse的反函数 123456from urllib.parse import urlunparse#data可以通过urlparse得出的参数往里面带，注意：即使是空符号也要写进去，不然会出错data = ['http', 'www.baidu.com', 'index.html', 'user', 'a=6', 'comment'] result = urlunparse(data)print(result) (3)urljoin 拼接url 12345678910from urllib.parse import urljoinresult = urljoin('http://www.baidu.com','FQA.html') # 正常拼接print(result)result1 = urljoin('http://www.baidu.com','http://www.taobao.com/FQA.html') # 后面url会覆盖前面url共有的部分，多余部分自行拼接print(result1)result2 = urljoin('http://www.baidu.com/about','https://www.taobao.com/FQA.html') # 后面url会覆盖前面url共有的部分，总之以后面为准print(result2) (4)urlencode 字典对象转化为get请求参数 12345678910from urllib.parse import urlencodeparams=&#123; 'name':'Arise', 'age':'21' &#125;base_url = 'http://www.baidu.com?'url = base_url + urlencode(params)print(url) 8、robotparser用来解析robot.txt（只做了解） https://docs.python.org/3/library/urllib.robotparser.html#module-urllib.robotparser 12345678910111213141516import urllib.robotparser rp = urllib.robotparser.RobotFileParser() rp.set_url(\"http://www.musi-cal.com/robots.txt\") rp.read() rrate = rp.request_rate(\"*\") print(rrate.requests)#3 rrate.seconds #20 rp.crawl_delay(\"*\") #6 rp.can_fetch(\"*\", \"http://www.musi-cal.com/cgi-bin/search?city=San+Francisco\") #False rp.can_fetch(\"*\", \"http://www.musi-cal.com/\") #True 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"爬虫-基本原理","slug":"爬虫-基本原理","date":"2018-07-02T01:00:00.000Z","updated":"2018-08-14T07:42:06.707Z","comments":true,"path":"2018/07/02/爬虫-基本原理/","link":"","permalink":"http://pythonfood.github.io/2018/07/02/爬虫-基本原理/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、爬虫基本原理1、什么是爬虫 请求网站并提取数据的自动化程序。 2、爬虫基本流程 (1)发起请求：通过HTTP库向目标站点发起请求，即发送一个Request，请求可以包含额外的headers等信息，等待服务器响应。(2)获取响应内容：如果服务器能正常响应，会得到一个Response，Response的内容是所获取的页面内容，类型可能有HTML、Json字符串、二进制数据（如图片视频）等类型。(3)解析内容：得到的内容可能是HTML，可以用正则表达式、网页解析库进行解析。可能是Json,可以直接转换为Json对象解析。可能是二进制数据，可以做保存或者进一步的处理。(4)保存数据：保存形式多样，可以保存为文本，可以保存至数据库，或者保存特定格式的文件。 3、Request与Response (1)浏览器就发送消息给该网址所在的服务器，这个过程叫做HTTP Request。(2)服务器收到浏览器发送的消息后，能够根据浏览器发送消息的内容，做响应处理，然后把消息回传给浏览器。这个过程叫做HTTP Response。(3)浏览器收到服务器的Response信息后，会对信息进行相应处理，然后展示。 4、Request (1)请求方式：主要有GET、POST两种类型，另外还有HEAD、PUT、DELETE、OPTIONS等。(2)请求URL：URL全称统一资源定位符，如一个网页文档、一张图片、一个视频都可以用URL唯一来确定。(3)请求头：包含请求时的头部信息，如User-Agent、Host、Cookies等信息。(4)请求体：请求时额外携带的数据，如表单提交时的表单数据（eg：fromdata）。 5、Response (1)响应状态：有多重响应状态，如200代表成功、301是跳转、404为找不到网页、502服务器错误(2)响应头：如内容类型、内容长度、服务器信息、设置Cookie等等；(3)响应体：最主要的部分，包含了请求资源的内容，如网页HTML、图片二进制数据等； 6、能抓怎样的数据 (1)网页文本：如HTML文档，JSON格式文本等。(2)图片：获取二进制文本文件，保存为图片格式。(3)视频：同样为二进制文件，保存为音频格式即可，抓取方法如图片抓取方法。(4)其他：只要是能请求到的，都能获取。 7、解析方式 (1)直接处理(2)Json解析(3)正则表达式(4)BeautifulSoup(5)PyQuery(6)XPath 8、为啥抓到的和浏览器看到的不一样 由于JavaScript渲染的问题，在network看到的代码（我们通过Python）与element中看到（JavaScript渲染的）不一样。 9、怎么解决JavaScript渲染的问题 (1)分析Ajax请求：返回Json格式数据。(2)Selenium/WebDriver：来模拟一个浏览器。(3)Splash：https://github.com/scrapinghub/splash(4)PyV8、Ghost.py： 10、怎样保存数据 (1)文本：纯文本、Json、Xml等。(2)关系型数据库：如MySQL、Oracle、SQL Server等具有结构化表结构形式存储。(3)非关系型数据库：MongoDB、Redis等Key-Value形式存储。(4)二进制文件：如图片、视频、音频等等直接保存成特定格式即可。 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"爬虫-phantomjs配置","slug":"爬虫-phantomjs配置","date":"2018-07-01T04:00:00.000Z","updated":"2018-08-14T07:49:50.220Z","comments":true,"path":"2018/07/01/爬虫-phantomjs配置/","link":"","permalink":"http://pythonfood.github.io/2018/07/01/爬虫-phantomjs配置/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、PhantomJS下载国内镜像：http://npm.taobao.org/dist/phantomjs/ 二、PhantomJS安装(1)将zip包解压到自定义路径即可D:\\Program Files\\PhantomJS\\phantomjs-2.1.1-windows(2)配置环境变量D:\\Program Files\\PhantomJS\\phantomjs-2.1.1-windows\\bin 三、验证环境cmd输入命令python进入交互环境1234from selenium import webdriverdriver = webdriver.PhantomJS() # PhantomJS对应chromedriver必须是2.0以上driver.get(&apos;http://www.baidu.com&apos;)driver.page_source # 由于PhantomJS没有界面，通过page_source打印网页信息 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"爬虫-redis配置","slug":"爬虫-redis配置","date":"2018-07-01T03:00:00.000Z","updated":"2018-08-14T07:49:22.672Z","comments":true,"path":"2018/07/01/爬虫-redis配置/","link":"","permalink":"http://pythonfood.github.io/2018/07/01/爬虫-redis配置/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、Redis下载64位可以从github下载:https://github.com/MicrosoftArchive/redis/releases32位下载:https://pan.baidu.com/s/1mig98a0 （只找到一个百度网盘的） 二、Redis安装1、64位安装 (1)运行msi安装软件，根据提示安装即可。(2)服务运行端口是6379 2、32位安装 (1)将zip包解压到自定义安装路径即可 D:\\Program Files\\Redis(2)双击redis-server.exe或cmd进入redis路径输入命令D:\\Program Files\\Redis&gt;redis-server.exe Redis.conf就可以启动服务。 三、Redis Desktop Manager官网地址：https://redisdesktop.com/download64位可以从github下载：https://github.com/uglide/RedisDesktopManager/releases32位下载：https://pan.baidu.com/s/1kU8sY3P （只找到一个百度网盘的） 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"爬虫-mongodb配置","slug":"爬虫-mongodb配置","date":"2018-07-01T02:00:00.000Z","updated":"2018-08-14T07:39:29.918Z","comments":true,"path":"2018/07/01/爬虫-mongodb配置/","link":"","permalink":"http://pythonfood.github.io/2018/07/01/爬虫-mongodb配置/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、mongodb下载：官网地址：https://www.mongodb.com/64位下载地址：http://dl.mongodb.org/dl/win32/x86_6432位下载地址：https://www.mongodb.org/dl/win32 二、windows64位安装 (1)下载的将zip包解压到自定义路径 D:\\Program Files\\MongoDB\\Server\\3.2 或将msi安装软件安装到自定义路径 D:\\Program Files\\MongoDB\\Server\\3.2 (2)在monggodb安装路径下新建data文件夹 D:\\Program Files\\MongoDB\\Server\\3.2\\data (3)在data文件夹下新建db和log两个文件夹 D:\\Program Files\\MongoDB\\Server\\3.2\\data\\db` D:\\Program Files\\MongoDB\\Server\\3.2\\data\\log` (4)在log文件夹下新建日志文件MongoDB.log D:\\Program Files\\MongoDB\\Server\\3.2\\data\\log\\MongoDB.log (5)管理员方式打开cmd，进入到mongodb安装路径的\\bin目录下，输入命令安装D:\\Program Files\\MongoDB\\Server\\3.2\\bin&gt;mongod --dbpath &quot;D:\\Program Files\\MongoDB\\Server\\3.2\\data\\db&quot; --logpath &quot;D:\\Program Files\\MongoDB\\Server\\3.2\\data\\log\\MongoDB.log&quot; --install --serviceName &quot;MongoDB&quot; (6)安装完成后，手动启动MongoDB服务，浏览器打开http://localhost:27017/ (7)cmd使用monggodb数据库，输入命令mongo 三、windows32位安装 (1)32位安装过程和64位大致相同，但是安装后一般会碰到几个异常： 安装服务报这个错误：32-bit servers don’t have journaling enabled by default. Please use –journal if you want durability. 32位的mongodb数据库存储引擎只能是：mmapv1 (2)综上，32位的安装命令需要添加–journal选项和指定存储引擎mmapv1D:\\Program Files\\MongoDB\\Server\\3.2\\bin&gt;mongod --dbpath &quot;D:\\Program Files\\MongoDB\\Server\\3.2\\data\\db&quot; --logpath &quot;D:\\Program Files\\MongoDB\\Server\\3.2\\data\\log\\MongoDB.log&quot; --install --serviceName &quot;MongoDB&quot; --journal --storageEngine=mmapv1 (3)cmd输入命令net start MongoDB启动服务。然后连接到mongodb数据库，输入命令mongo (4)如果启动mongodb服务时提示“发生服务特定错误100”：在mongodb安装路径的data目录下两个文件mongod.lock和storage.bson，一般删除mongod.lock重启服务就好了。如果还提示“发生服务特定错误100”，就把storage.bson一起删掉再重启服务。 四、Robomongo可视化客户端64位下载地址：https://robomongo.org/download32位下载地址：http://pan.baidu.com/s/1c02GmHE （只找到一个百度网盘的） 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"爬虫-anaconda配置","slug":"爬虫-anaconda配置","date":"2018-07-01T01:00:00.000Z","updated":"2018-08-14T07:39:15.229Z","comments":true,"path":"2018/07/01/爬虫-anaconda配置/","link":"","permalink":"http://pythonfood.github.io/2018/07/01/爬虫-anaconda配置/","excerpt":"崔庆才老师爬虫的学习笔记。","text":"崔庆才老师爬虫的学习笔记。 一、anaconda安装1、国内镜像站 https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/ 2、配置环境变量 D:\\Program Files\\Anaconda3D:\\Program Files\\Anaconda3\\ScriptsD:\\Program Files\\Anaconda3\\Library\\binD:\\Program Files\\Anaconda3\\Library\\usr\\binD:\\Program Files\\Anaconda3\\Library\\mingw-w64\\bin 二、解决python多版本1、修改python3 python3安装路径下，复制python.exe为python3.exe。python3安装路径的\\Scripts目录下，复制pip.exe为pip3.exe。 2、修改anaconda ananconda安装路径下，复制python.exe为python-conda.exe。ananconda安装路径的\\Scripts目录下，复制pip.exe为pip-conda.exe。ananconda安装路径的\\Scripts目录下，复制pip-script.py为pip-conda-script.py。 3、验证多版本设置cmd输入命令python3，进入python3的交互界面。cmd输入命令pip3 list，显示python3下安装的库。cmd输入命令python-conda，进入anaconda下python的交互界面。cmd输入命令pip-conda list，显示anaconda下安装的库。 4、默认python设置 python3和anaconda的环境变量，谁在前谁就是默认的python。例如python3的环境变量在anaconda之前，则cmd输入python，进入python3的交互界面。 三、jupyter编辑器1、运行jupyter cmd输入命令jupyter notebook,会自动打开浏览器http://localhost:8888/tree 2、修改保存路径 (1)cmd输入命令jupyter notebook --generate-config生成配置文件。(2)根据提示找到文件路径C:\\Users\\tester.jupyter\\jupyter_notebook_config.py(3)打开配置文件，找到jupyter默认路径这行#c.NotebookApp.notebook_dir = ‘’(4)去掉#号，修改默认路径为c.NotebookApp.notebook_dir = ‘D:\\JupyterProjects’ 持续更新…","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://pythonfood.github.io/tags/爬虫/"}]},{"title":"django-签到系统","slug":"django-签到系统","date":"2018-06-01T01:00:00.000Z","updated":"2018-08-14T07:38:53.499Z","comments":true,"path":"2018/06/01/django-签到系统/","link":"","permalink":"http://pythonfood.github.io/2018/06/01/django-签到系统/","excerpt":"虫师所写django签到系统的学习笔记。","text":"虫师所写django签到系统的学习笔记。 一、Hello Django1、查看django命令 D:> django-admin 2、创建项目 D:> django-admin startproject guest guest/ guest/ __init__.py：一个空的文件，用它标识一个目录为 Python 的标准包。 settings.py：Django 项目的配置文件，包括 Django 模块应用配置，数据库配置，模板配置等。 urls.py：Django 项目的 URL 声明。 wsgi.py：为 WSGI 兼容的 Web 服务器服务项目的切入点。 manage.py：一个命令行工具，可以让你在使用 Django 项目时以不同的方式进行交互。 3、查看 manage 所提供的命令 D:\\guest&gt; python manage.py 4、创建应用 D:\\guest&gt; python manage.py startapp sign guest/ sign/ migrations/：用于记录 models 中数据的变更。 admin.py：映射 models 中的数据到 Django 自带的 admin 后台。 apps.py：在新的 Django 版本中新增，用于应用程序的配置。 models.py：创建应用程序数据表模型（对应数据库的相关操作）。 tests.py：创建 Django 测试。 views.py：控制向前端显示哪些数据。 5、运行项目 D:\\guest&gt; python manage.py runserver 默认8000端口启动项目，也可以指定IP和端口：D:\\guest&gt; python manage.py runserver 127.0.0.1:8001 6、使用视图显示 Hello Django (1)首先配置 guest/guest/settings.py ，将 sign 应用添加到项目中。1234INSTALLED_APPS = [ ... 'sign', # 添加sign应用] (2)再配置 guest/guest/urls.py ，添加 index/ 目录。123456from django.conf.urls import url, include # url控制需要导入urlpatterns = [ path('admin/', admin.site.urls), url(r'^index/$', views.index), # 添加 index/ 路径配置] (3)接着编辑 guest/sign/views.py ，创建 index() 视图函数。1234from django.http import HttpResponsedef index(request): return HttpResponse('Hello Django') (4)运行项目，访问127.0.0.1:8000，即可显示’Hello Django’。 7、使用模板显示 Hello Django (1)在应用 guest/sign/ 目录下，创建 templates/index.html 。（注意需要创建templates目录）12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;Django Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello Django&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; (2)编辑 guest/sign/views.py，用 index() 视图函数返回 index.html。（注意html文件路径不需要写templates）1234from django.shortcuts import renderdef index(request): return render(request, 'index.html') # 这里抛弃 HttpResponse 类，转而使用 Django 的 render 函数 (3)运行项目，访问127.0.0.1:8000，即可显示’Hello Django’。 8、MTV模式 (1)首先理解 Model-View-Controller（MVC）模式：数据存取逻辑、表现逻辑、业务逻辑。 (2)由于 Controller 由框架自行处理，而 Django 里更关注的是模型（Model）、模板(Template)和视图（Views）， Django 也被称为 MTV 框架 ： M（Model），即数据存取层。该层处理与数据相关的所有事务： 如何存取、如何验证有效。 T（Template），即表现层。该层处理与表现相关的决定： 如何在页面或其他类型文档中进行显示。 V（View），即业务逻辑层。该层包含存取模型及调取恰当模板的相关逻辑。 你可以把它看作模型与模板之间的桥梁。 二、Views 视图1、写个简单的登录 (1)…/templates/index.html编写登录表单代码代码。表单方法使用 method=”post”，提交路径为 action=”/login_action/“。(2)注意页面需要添加跨站请求伪造（ CSRF）令牌，在Html表单中使用Django模板标签：{% csrf_token %}(3)打开 …/guest/urls.py 文件添加 login_action/的路由。(4)打开 …/sign/views.py 文件，创建 login_action 视图函数。(5)在 …/templates/index.html 页面中添加 Django 模板：。(6)刷新网页，填入账号密码，验证效果。 2、添加登录成功页 (1)首先创建 …/templates/event_manage.html 页面，编写html代码。(2)修改 …/sign/views.py 中的 login_action 函数，登录成功后重定向到 /event_manage/ 路径。(3)在 …/guest/urls.py 文件中添加路径 event_manage/的路由：views.event_manage。(4)在 …/sign/views.py 中添加event_manage视图函数，返回event_manage.html。 3、Cookie 的使用 (1)修改…/sign/views.py 文件login_action函数设置cookie：response.set_cookie(&#39;user&#39;, username)(2)修改…/sign/views.py 文件 event_manage函数获取cookie： request.COOKIES.get(&#39;user&#39;, &#39;&#39;, 3600)(3)修改…/templates/event_manage.html 页面，添加标签来显示用户登录的用户名。 4、Session 的使用 (1)修改…/sign/views.py文件，在 login_action 函数中将 session 信息记录到浏览器：request.session[&#39;user&#39;]=username 。(2)修改…/sign/views.py文件，在 event_manage 函数中读取浏览器 session：username=request.session.get(&#39;user&#39;,&#39;&#39;) 。(3)既然要服务器端记录用户的数据，需要创建 django_session 表，不过Django已经准备好了，我们需要生成他们，进行数据迁移：D:\\guest&gt; python3 manage.py migrate 5、登录 Admin 后台 执行 manage.py 的“migrate”命令时，Django 同时也帮我们生成了 auth_user 表。同时，我们可以通过 URL 地址：http://127.0.0.1:8000/admin/ 来访问 Django 自带的 Admin 管理后台。在此之前,先来创建登录 Admin 后台的管理员账号： D:\\guest&gt; python3 manage.py createsuperuser Username (leave blank to use ‘fnngj’): admin #输入用户名 Email address: admin@mail.com #输入邮箱 Password: admin123456 #输入密码 Password (again): admin123456 #重复输入密码 6、引用 Django 认证登录 (1)打开…/sign/views.py 文件修改 login_action 函数，认证给出的用户名和密码：user = auth.authenticate(username=username, password=password)(2)通过 if 语句判断 authenticate()返回（即user）如果不为 None，说明用户认证通过。(3)来调用 login()函数进行 登录：auth.login(request, user) 7、关上窗户 (1)直接访问：http://127.0.0.1:8000/event_manage/， 我们不需要通过登录也可以直接访问到登录成功的页面。我们要把这些“窗户”都关上，使用户只能通过登录来访问系统： 如果想限制某个视图函数必须登录才能访问，只需要在这个函数的前面加上： @login_required 。 (2)仔细看，会发布在访问被@login_required 装饰的视图时，默认会跳转的 URL 中会包含 “/accounts/login/”，为什么不让它直接跳转到登录页面呢？不但要告诉你窗户是关着的，还要帮你指引到门的位置： 修改…/urls.py 文件，添加以下路径：url(r’^accounts/login/$’, views.index)。 当用户访问：http://127.0.0.1:8000/ 、 http://127.0.0.1:8000/index/ 、 http://127.0.0.1:8000/event_manage/ ，都会跳转到登录页面。 三、Model 模型1、设计系统表 Django 提供完善的模型（model）层主要用来创建和存取数据，不需要我们直接对数据库操作。每个模型是一个 Python 类，继承 django.db.models.model 类。该模型的每个属性表示一个数据库表字段。 (1)打开…/sign/models.py 文件，完成表的创建。(2)进行数据库迁移： D:\\guest&gt; python3 manage.py makemigrations sign D:\\guest&gt; python3 manage.py migrate 2、admin 后台管理 创建的发布会和嘉宾表 同样可以通过 Admin 后台去管理： 打开…/sign/admin.py 文件，通知 admin 管理工具为这些模块逐一提供界面：admin.site.register()。 打开…/sign/admin.py 文件，定义 list_display 要在列表中显示哪些字段，当然，这些字段名称必须是模型中的数据表类中定义的。 打开…/sign/admin.py 文件，search_fields 创建表字段的搜索器，设置搜索关键字匹配多个表字段。 list_filter 用于创建字段过滤器。 3、基本数据访问 python manage.py shell # dos下进入django的shell模式 from sign.models import Event,Guest table.objects.all() # 获得 table（Event、Gues 表）中的所有对象 quit() # 退出shell (1)插入数据123from datetime import datetime e1 = Event(id=2,name='红米 Pro 发布会',limit=2000,status=True,address='北京水立方',start_time=datetime(2016,8,10,14,0,0)) e1.save() ps：修改 settings.py 文件保存后，需要执行 quit() 命令退出 shell 模式，并重新执行 Python3 manage.py shell 进入，刚才的设置才会生效。也可以通过 table.objects.create()方法将两步合为一步：12Event.objects.create(id=3,name='红米 MAX发布会',limit=2000,status=True, address='北京会展中心',start_time=datetime(2016,9,22,14,0,0)) &lt;Event: 红米MAX发布会&gt; Guest.objects.create(realname='andy',phone=13611001101,email= 'andy@mail.com',sign=False,event_id=3) (2)查询数据12345678table.objects.get() # 从数据库表中取得一条匹配的结果，返回一个对象，如果记录不存在的话，那么它会报DoesNotExist类型错误：e1 = Event.objects.get(name='红米MAX发布会') e1e1.addresstable.objects.filter() # 方法是从数据库的取得匹配的结果，返回一个对象列表，如果记录不存在的话，它会返回[]：e2 = Event.objects.filter(name__contains='发布会') e2 (3)删除数据123#通过 delete()方法删除：g2 = Guest.objects.get(phone='13611001101') g2.delete() (4)更新数据123g3=Guest.objects.get(phone='13611001101') g3.realname='andy2' g3.save() 4、配置 MySQL (1)要在…/guest/settings.py 文件中修改数据库相关配置。(2)安装pymysql库。(3)创建数据库。(4)切换了数据库后，之前 Sqlite3 数据库里的数据并不能复制到 MySQL 中，所以需要重新进行数据库同步，使数据模型重新在 MySQL 数据库中生成表：D:\\guest&gt; python manage.py migrate(5)直接进行数据迁移会报错！这是因为Django 在连接 MySQL 数据库时默认使用的是 MySQLdb 驱动，然而我们没有安装该驱动，因为它并不支持 Python3，我们现在安装的是 PyMySQL 驱动，如何让当前的 Django 通过 PyMySQL 来连接 MySQL 数据库呢？方法很简单，在…/guest/__init__.py 目录下添加：123import pymysqlpymysql.install_as_MySQLdb()#添加完后，再执行数据迁移命令。 (6) 因为更换了数据库，所以，Admin 后台超级管理员账号（admin/admin123456）也需要重新创建： D:\\guest&gt; python3 manage.py createsuperuser Username (leave blank to use ‘fnngj’): admin #输入用户名 Email address: admin@mail.com #输入邮箱 Password: admin123456 #输入密码 Password (again): admin123456 #重复输入密码 四、Template 模板1、Django-bootstrap3 (1)安装 pip install django-bootstrap3(2)在…/guest/settings.py 文件中添加 bootstrap3 应用。 2、发布会管理 (1)打开…/sign/views.py 文件，修改 event_manage()视图函数：12event_list = Event.objects.all() # 从数据库查询所有发布会return render(request,\"event_manage.html\",&#123;\"user\": username, \"events\":event_list&#125;) # 将发布会列表返回给前端 (2)打开并编写…/templates/event_manage.html 页面：123456789101112131415&lt;!-- &lt;head&gt;中引入bootstrap：--&gt;&#123;% load bootstrap3 %&#125; &#123;% bootstrap_css %&#125;&#123;% bootstrap_javascript %&#125; &lt;!-- &lt;body&gt;中遍历显示出所有发布会列表：--&gt;&#123;% for event in events %&#125;&lt;tr&gt; &lt;td&gt;&#123;&#123; event.id &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; event.name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; event.status &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; event.address &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; event.start_time &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; (3)在…/templates/event_manage.html 页面上创建搜索表单。(4)在…/guest/urls.py 文件中添加搜索路径的路由：url(r&#39;^search_name/$&#39;, views.search_name)(5)打开…/sign/views.py 文件，创建 search_name()视图函数。 3、嘉宾管理 (1)创建…/templates/guest_manage.html 页面：12345678910&#123;% for guest in guests %&#125;&lt;tr&gt; &lt;td&gt;&#123;&#123; guest.id &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; guest.realname &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; guest.phone &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; guest.email &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; guest.sign &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; guest.event &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; (2)在…/guest/urls.py 文件中添加嘉宾路径的路由。(3)打开…/sign/views.py 文件，创建 guest_manage()视图函数。 4、分页器 Paginator Django 已经为我们准备好了 Paginator 分页类。所以，只需要调用它即可完成列表的分页功能，进入 Django 的 shell 模式，练习 Paginator 类的基本使用:123456789101112131415161718192021222324252627D:\\guest&gt; python3 manage.py shell&gt;&gt;&gt; from django.core.paginator import Paginator&gt;&gt;&gt; from sign.models import Guest&gt;&gt;&gt; guest_list = Guest.objects.all() # 查询 uest 表的所有数据&gt;&gt;&gt; p = Paginator(guest_list, 2) # 创建每页 2 条数据的分页器 &gt;&gt;&gt; p.count # 查看共多少条数据&gt;&gt;&gt; p.page_range # 查看共分多少页 ##########第一页#############&gt;&gt;&gt; page1 = p.page(1) # 获取第 1 页的数据&gt;&gt;&gt; page1 # 当前第几页 &gt;&gt;&gt; page1.object_list # 当前页的对象 &gt;&gt;&gt; for p in page1: # 循环打印第 1 页嘉宾的 realname ... p.realname##########第二页#############&gt;&gt;&gt; page2 = p.page(2)&gt;&gt;&gt; page2.start_index() # 本页的第一条数据 &gt;&gt;&gt; page2.end_index() # 本页的最后一条数据 &gt;&gt;&gt; page2.has_previous() # 是否有上一页 &gt;&gt;&gt; page2.has_next() # 是否有下一页&gt;&gt;&gt; page2.previous_page_number() # 上一页是第几页&gt;&gt;&gt; page2.next_page_number() # 下一页是第几页 ##########第三页#############&gt;&gt;&gt; page3 = p.page(3) &gt;&gt;&gt; page3.has_other_pages() # 是否有其他页 (1)打开…/sign/views.py 文件，修改 guest_manage()视图函数。(2)在…/templates/guest_manage.html 页面也需要添加分页器的代码。 5、签到功能 (1)在…/templates/event_manage.html 页面，增加签到列链接。(2)在…/guest/urls.py 文件中添加路径路由。(3)打开…/sign/views.py 文件，创建 sign_index()视图函数。(4)创建…/templates/sign_index.html 签到页面。(5)打开…/guest/urls.py 文件，添加签到路径的路由。(6)打开…/sign/views.py 文件，创建 sign_index_action()视图函数。(7)修改…/templates/sign_index.html 页面，增加 sign_index_action()视图函数返回的提示信息的位置：12345&lt;font color=\"red\"&gt; &lt;br&gt;&#123;&#123; hint &#125;&#125; &lt;br&gt;&#123;&#123; guest.realname &#125;&#125; &lt;br&gt;&#123;&#123; guest.phone &#125;&#125; &lt;/font&gt; 6、退出系统 (1)打开…/urls.py 文件，添加退出目录的路由。(2)打开…/sign/views.py 文件，创建 logout()视图函数：123auth.logout(request) #退出登录 response = HttpResponseRedirect('/index/') return response 五、开发 Web 接口首先，单独创建…/sign/views_if.py文件，该项目的接口方法都在这里。 1、发布会添加接口 (1)首先，判断 eid、 name、limit、address、start_time 等字段均不能为空，否则 JsonResponse()返回相应的 状态码和提示。(2)接下来，判断发布会 id 是否存在，以及发布会名称（name）是否存在；如果存在将返回相应的状态码和 提示信息。(3)再接下来，判断发布会状态是否为空，如果为空，将状态设置为 1（True）。(4)最后，将数据插入到 Event 表，在插入的过程中如果日期格式错误，将抛出 ValidationError 异常，接收 该异常并返回相应的状态和提示，否则，插入成功，返回状态码 200 和“addeventsuccess”的提示。 2、发布会查询接口 (1)通过GET请求接收发布会id和name参数。两个参数都是可选的。首先，判断当两个参数同时为空，接 口返回状态码 10021，参数错误。(2)如果发布会 id 不为空，优先通过 id 查询，因为 id 的唯一性，所以，查询结果只会有一条，将查询结果 以 key:value 对的方式存放到定义的 event 字典中，并将数据字典作为整个返回字典中 data 对应的值返回。(3)name 查询为模糊查询，查询数据可能会有多条，返回的数据稍显复杂；首先将查询的每一条数据放到一 个字典 event 中，再把每一个字典再放到数组 datas 中，最后再将整个数组做为返回字典中 data 对应的值返回。 3、嘉宾添加接口 (1)通过POST请求接收嘉宾参数：关联的发布会id、姓名、手机号和邮箱等参数。(2)首先，判断 eid、realname、phone 等参数均不能为空。(3)接下来，判断嘉宾关联的发布会 id 是否存在，以及关联的发布会状态是否为 True（即 1），如果不存在 或不为 True，将返回相应的状态码和提示信息。(4)接下来判断发布会人数限制。(5)再接下来的步骤是判断当前时间是否大于发布会时间，如果大于则说明发布已开始，或者早已经结束。那么该发布会就应该不能允许再添加嘉宾。(6)最后，插入嘉宾数据，如果发布会的手机号重复则抛 IntegrityError 异常，接收该异常并返回相应的状态 码和提示信息。如果添加成功，则返回状态码 200 和“addguestsuccess”的提示。 4、嘉宾查询接口 嘉宾查询接口与发布会查询接口相似，只是参数与查询条件判断有所不同，这里就不再一一说明。 5、嘉宾签到接口 (1)签到接口通过POST请求接收发布会id和嘉宾手机号。签到接口的判断条件比较多。(2)首先，判断两个参数均不能为空。(3)接着，判断发布会 id 是否存在，以及发布会状态是否为 True，如果不存在或不为 True，将返回相应的状 态码和提示信息。(4)再接着，判断当前时间是否大于发布会时间，如果大于发布会时间说明发布会已开始，不允许签到。(5)然后，再判断嘉宾的手机号是否存在，以及嘉宾的手机号与发布会 id 是否为对应关系。否则返回相应的 错误码和提示信息。(6)最后，判断该嘉宾的状态是否为已签到，如果已签到，返回相应的状态码和提示；如果未签到修改状态 为已签到，并返回状态码 200 和“signsuccess”的提示。 6、配置接口路径 (1)打开…/guest/urls.py文件，添加接口基本路径“/api/”：url(r&#39;^api/&#39;, include(&#39;sign.urls&#39;, namespace=&quot;sign&quot;))(2)创建…/sign/urls.py文件，配置具体接口的二级路径：1234567891011121314app_name='sign' # django2.0里必须添加应用名称urlpatterns = [ # guest system interface: # ex : /api/add_event/ url(r'^add_event/', views_if.add_event, name='add_event'), # ex : /api/add_guest/ url(r'^add_guest/', views_if.add_guest, name='add_guest'), # ex : /api/get_event_list/ url(r'^get_event_list/', views_if.get_event_list, name='get_event_list'), # ex : /api/get_guest_list/ url(r'^get_guest_list/', views_if.get_guest_list, name='get_guest_list'), # ex : /api/user_sign/ url(r'^user_sign/', views_if.user_sign, name='user_sign'),] 7、编写 Web 接口文档 六、接口的安全机制1、用户认证 (1)重新创建…/sign/views_if_sec.py 视图文件，添加用户认证函数。(2)增加发布会查询接口函数，函数首先调用用户认证函数，进行用户认证。(3)在…/sign/urls.py 文件中添加新的安全接口指向：url(r&#39;^sec_get_event_list/&#39;, views_if_sec.get_event_list, name=&#39;get_event_list&#39;) 2、数字签名 在使用 HTTP/SOAP 协议传输数据的时候，签名作为其中一个参数，可以起到关键作用： 1)鉴权：通过客户的密钥，服务端的密钥匹配： 例如一个接口传参为：http://127.0.0.1:8000/api/?a=1&amp;b=2 假设签名的密钥为：@admin123 加上签名之后的接口参数为：http://127.0.0.1:8000/sign/?a=1&amp;b=2&amp;sign=@admin123 sign 参数明文传输是不安全的，一般会通过加密算法进行加密, “@admin123” 经过 MD5 加密得到：4b9db269c5f978e1264480b0a7619eea 单做为鉴权，带签名的接口为：http://127.0.0.1:8000/sign/?a=1&amp;b=2&amp;sign=4b9db269c5f978e1264480b0a7619eea 服务器接收到请求后，同样需要对“@admin123”进行 MD5 加密，比对与传来的 sign 加密串是否一致，从而来鉴别调用者是否有权限方位该接口。 2)数据防篡改：参数是明文传输，将参数及密钥加密作为签名与服务器匹配： 同样是这样一个带参数的接口：http://127.0.0.1:8000/api/?a=1&amp;b=2 假设签名的密钥为：@admin123 签名的明文为：a=1&amp;b=2&amp;api_key=@admin123 将签名的明文生成 MD5 加密串：786bfe32ae1d3764f208e03ca0bfaf13 带参数的接口串为：http://127.0.0.1:8000/sign/?a=1&amp;b=2&amp;sign=786bfe32ae1d3764f208e03ca0bfaf13 因为整个接口的参数做了加密，所以，只要任意一个参数发改变，那签名的验证就会失败。从而起到了鉴权及数据完整性的保护。 (1)打开…/sign/views_if_sec.py 视图文件，添加用户签名函数。(2)增加添加发布会接口函数，函数首先调用用户签名函数，进行签名验证。(3)在…/sign/urls.py 文件中添加新的安全接口路由：url(r&#39;sec_add_event/&#39;, views_if_sec.add_event, name=&#39;add_event&#39;) 3、接口加密 PyCrypto 是一个免费的加密算法库，支持常见的 DES、AES 加密以及 MD5、SHA 各种 HASH 运算。安装PyCryoto库： pip install Crypto (1)客户端请求接口时，进行了AES加密，在服务端需要进行解密验证。代码详见虫师原文地址。(2)打开…/sign/views_if_sec.py 视图文件，编写解密函数。(3)在获取嘉宾例表的接口中调用 aes_encryption()函数进行 AES 加密字符串解密。(4)在…/sign/urls.py 文件中添加新的安全接口指向：url(r&#39;^sec_get_guest_list/&#39;, views_if_sec.get_guest_list, name=&#39;get_guest_list&#39;) 七、REST APIREST（即 RepresentationalStateTransfer 的缩写）中文翻译为“表现层状态转化”： 资源（Resources），所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。你可以用一个 URI（统一资源定位符）指向它，每种资源对应一个特定的 URI。要获取这个资源，访问它的 URI 就可以。 表现层（Representation），把”资源”具体呈现出来的形式。URI 只代表资源的实体，不代表它的形式。严格地说，有些网址最后的“.html”后缀名是不必要的，因为这个后缀名表示格式，属于“表现层”范畴，而 URI 应该只代表“资源”的位置。它的具体表现形式，应该在 HTTP 请求的头信息中用 Accept 和 Content-Type 字段指定，这两个字段才是对”表现层”的描述。 状态转化（StateTransfer），互联网通信协议 HTTP 协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生“状态转化”（StateTransfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。客户端用到的手段，只能是 HTTP 协议。具体来说，就是 HTTP 协议里面，四个表示操作方式的动词： GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源（也可 以用于更新资源），PUT 用来更新资源，DELETE 用来删除资源。 Django-REST-Framework是一个强大而灵活的工具用于构建 WebAPIs。通过该框架可以创建 REST 风格的 WebSeriver 应用。安装：pip install djangorestframework 1、创建简单的 API (1)&gt; django-admin startproject django_rest(2)&gt; cd django_rest(3)\\django_rest&gt; python3 manage.py startapp api(4)打开 settings.py 文件添加应用：’rest_framework’和’api’(5)在 settings.py 文件末尾添加:1234REST_FRAMEWORK = &#123; 'DEFAULT_PERMISSION_CLASSES': ('rest_framework.permissions.IsAdminUser',), 'PAGE_SIZE': 10 &#125; (6)执行数据库迁移 \\django_rest&gt; python3 manage.py migrate(7)创建超级管理员账户\\django_rest&gt; python3 manage.py createsuperuser(8)创建数据序列化，创建…/api/serializers.py 文件,代码见文件。(9)创建视图，打开…/api/views.py 视图文件，代码见文件。(10)打开…/django_rest/urls.py 文件，添加路径的路由，代码见文件。(11)启动服务 …\\django_rest&gt; python3 manage.py runserver 2、 集成发布会系统 API (1)接下来在 django_rest 项目的基础上增加发布会和嘉宾管理的接口。(2)打开…/api/models.py 文件，创建模型。(3)进行数据库迁移：12\\django_rest&gt; python3 manage.py makemigrations api\\django_rest&gt; python3 manage.py migrate (4)打开…/api/serializers.py 文件，添加发布会数据序列化。(5)打开…/api/views.py 视图文件，定义发布会视图类。(6)打开…/django_rest/urls.py 文件，添加 URL 配置。(7)启动项目，使用浏览器打开：http://127.0.0.1:8000/ 八、项目代码1、guest项目 guest/ guest/ __init__.py settings.py urls.py wsgi.py sign/ migrations/ __init__.py 0001_initial.py templates/ event_manage.html guest_manage.html index.html sign_index.html __init__.py admin.py apps.py models.py tests.py urls.py views.py views_if.py views_if_sec.py db.sqlite3 manage.py guest/guest/__init__.py123import pymysqlpymysql.install_as_MySQLdb() # 让当前的 Django 通过 PyMySQL 来连接 MySQL 数据库 guest/guest/settings.py12345678910111213141516171819202122232425262728293031323334353637import os......INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'sign', # 添加sign应用 'bootstrap3', # 添加]... ...# 配置mysql数据库DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'HOST': '127.0.0.1', 'PORT': '3306', 'NAME': 'guest', 'USER': 'root', 'PASSWORD': '123456', 'OPTIONS': &#123; 'init_command': \"SET sql_mode='STRICT_TRANS_TABLES'\", &#125;, &#125;&#125;... ... guest/guest/urls.py123456789101112131415161718from django.contrib import adminfrom django.urls import pathfrom django.conf.urls import url, include # url控制需要导入from sign import views # 导入 sign 应用 views 文件urlpatterns = [ path('admin/', admin.site.urls), url(r'^index/$', views.index), # 添加 index/路径配置 url(r'^login_action/$', views.login_action), url(r'^event_manage/$', views.event_manage), url(r'^accounts/login/$', views.index), url(r'^search_name/$', views.search_name), url(r'^guest_manage/$', views.guest_manage), url(r'^sign_index/(?P&lt;event_id&gt;[0-9]+)/$', views.sign_index), # 配置二级目录，发布会 id，要求必须为数字 url(r'^sign_index_action/(?P&lt;event_id&gt;[0-9]+)/$', views.sign_index_action), url(r'^logout/$', views.logout), url(r'^api/', include('sign.urls', namespace=\"sign\")),] guest/sign/admin.py123456789101112131415from django.contrib import adminfrom sign.models import Event,Guestclass EventAdmin(admin.ModelAdmin): list_display = ['id', 'name', 'status', 'address', 'start_time'] # 显示字段 search_fields = ['name'] # 搜索栏 list_filter = ['status'] # 过滤器class GuestAdmin(admin.ModelAdmin): list_display = ['realname', 'phone', 'email', 'sign', 'create_time', 'event'] # 显示字段 search_fields = ['realname', 'phone'] # 搜索栏 list_filter = ['sign'] # 过滤器admin.site.register(Event, EventAdmin) # 用 EventAdmin 选项注册 Event 模块。admin.site.register(Guest, GuestAdmin) # 用 GuestAdmin 选项注册 Guest 模块。 guest/sign/models.py12345678910111213141516171819202122232425262728293031from django.db import models# 发布会表class Event(models.Model): \"\"\"默认都会生成自增id，在创建模型时不需要声明该字段\"\"\" name = models.CharField(max_length=100) # 发布会标题 limit = models.IntegerField() # 参加人数 status = models.BooleanField() # 发布会状态 address = models.CharField(max_length=200) # 地址 start_time = models.DateTimeField('event time') # 发布会时间 create_time = models.DateTimeField(auto_now=True) # 创建时间（自动获取当前时间） def __str__(self): return self.name # __str__()方法告诉 Python 如何将对象以 str 的方式显示出来。 # 嘉宾表class Guest(models.Model): \"\"\"默认都会生成自增id，在创建模型时不需要声明该字段\"\"\" event = models.ForeignKey(Event, on_delete=models.CASCADE) # 关联发布会id realname = models.CharField(max_length=64) # 姓名 phone = models.CharField(max_length=16) # 手机号 email = models.EmailField() # 邮箱 sign = models.BooleanField() # 签到状态 create_time = models.DateTimeField(auto_now=True) # 创建时间（自动获取当前时间） class Meta: \"\"\"通过发布会id+手机号来做为联合主键\"\"\" unique_together = (\"event\", \"phone\") def __str__(self): return self.realname # __str__()方法告诉 Python 如何将对象以 str 的方式显示出来。 guest/sign/urls.py123456789101112131415161718192021222324252627from django.conf.urls import urlfrom sign import views_if, views_if_secapp_name='sign' # django2.0里必须添加应用名称，和urls路由里对应。或者直接在urls路由里添加路径也可以urlpatterns = [ # guest system interface: # ex : /api/add_event/ url(r'^add_event/', views_if.add_event, name='add_event'), # ex : /api/add_guest/ url(r'^add_guest/', views_if.add_guest, name='add_guest'), # ex : /api/get_event_list/ url(r'^get_event_list/', views_if.get_event_list, name='get_event_list'), # ex : /api/get_guest_list/ url(r'^get_guest_list/', views_if.get_guest_list, name='get_guest_list'), # ex : /api/user_sign/ url(r'^user_sign/', views_if.user_sign, name='user_sign'), # security interface: # ex : /api/sec_get_event_list/ url(r'sec_get_event_list/', views_if_sec.get_event_list, name='get_event_list'), # security interface: # ex : /api/sec_add_event/ url(r'sec_add_event/', views_if_sec.add_event, name='add_event'), # security interface: # ex : /aip/sec_add_event/ url(r'^sec_get_guest_list/', views_if_sec.get_guest_list, name='get_guest_list'), ] guest/sign/views.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788from django.shortcuts import render, get_object_or_404from django.http import HttpResponse, HttpResponseRedirect from django.contrib import authfrom django.contrib.auth.decorators import login_requiredfrom sign.models import Event,Guestfrom django.core.paginator import Paginator, EmptyPage, PageNotAnIntegerdef index(request): # return HttpResponse('Hello Django') return render(request, 'index.html') # 这里抛弃 HttpResponse 类，转而使用 Django 的 render 函数def login_action(request): if request.method == 'POST': username = request.POST.get('username', '') password = request.POST.get('password', '') user = auth.authenticate(username=username, password=password) # 认证给出的用户名和密码 if user is not None: #return HttpResponse('login success!') #response.set_cookie('user', username) # 添加浏览器cookie auth.login(request, user) # 登录 request.session['user'] = username # 将 session 信息记录到浏览器 return HttpResponseRedirect('/event_manage/') else: return render(request, 'index.html', &#123;'error': 'username or password error!'&#125;) else: return render(request, 'index.html', &#123;'error': 'username or password error!'&#125;)@login_required def event_manage(request): event_list = Event.objects.all() #username = request.COOKIES.get('user', '', 3600) # 读取浏览器cookie username = request.session.get('user', '') # 读取浏览器 session return render(request, 'event_manage.html', &#123;\"user\": username, \"events\": event_list&#125;)@login_requireddef search_name(request): username = request.session.get('user', '') search_name = request.GET.get('name', '') event_list = Event.objects.filter(name__contains=search_name) return render(request, \"event_manage.html\", &#123;\"user\": username, \"events\": event_list&#125;)@login_required def guest_manage(request): username = request.session.get('user', '') guest_list = Guest.objects.all() paginator = Paginator(guest_list, 2) # 划分每页显示 2 条数据 page = request.GET.get('page') # 通过 GET 请求得到当前要显示第几页的数 try: contacts = paginator.page(page) # 获取第 page 页的数据 except PageNotAnInteger: # 如果当前没有页数，抛 PageNotAnInteger 异常 contacts = paginator.page(1) # 返回第一页的数据 except EmptyPage: # 如果超出最大页数的范围，抛 EmptyPage 异常 contacts = paginator.page(paginator.num_pages) # 返回最后一页面的数据 return render(request, \"guest_manage.html\", &#123;\"user\": username, \"guests\": contacts&#125;)@login_requireddef sign_index(request, event_id): event = get_object_or_404(Event, id=event_id) return render(request, 'sign_index.html', &#123;'event': event&#125;)@login_requireddef sign_index_action(request, event_id): event = get_object_or_404(Event, id=event_id) phone = request.POST.get('phone','') # 首先，查询 Guest 表判断用户输入的手机号是否存在，如果不存在将提示用户“手机号为空或不存在” result = Guest.objects.filter(phone = phone) if not result: return render(request, 'sign_index.html', &#123;'event': event, 'hint': 'phone error.'&#125;) # 然后，通过手机和发布会 id 两个条件来查询 Guest 表，如果结果为空将提示用户“该用户未参加此次发布会” result = Guest.objects.filter(phone=phone,event_id=event_id) if not result: return render(request, 'sign_index.html', &#123;'event': event, 'hint':'eventidorphoneerror.'&#125;) # 最后，再通过手机号查询 Guest 表，判断该手机号的签到状态是否为 1，如果为 1，表示已经签过到了， 返回用户“已签到”，否则，将提示用户“签到成功！”，并返回签到用户的信息。 result = Guest.objects.get(phone=phone,event_id=event_id) if result.sign: return render(request, 'sign_index.html', &#123;'event': event, 'hint': \"user has sign in.\"&#125;) else: Guest.objects.filter(phone=phone,event_id=event_id).update(sign = '1') return render(request, 'sign_index.html', &#123;'event': event, 'hint':'sign in success!', 'guest': result&#125;)@login_requireddef logout(request): auth.logout(request) # 退出登录 response = HttpResponseRedirect('/index/') return response guest/sign/views_if.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221from django.http import JsonResponsefrom sign.models import Eventfrom django.core.exceptions import ValidationError, ObjectDoesNotExistfrom django.db.utils import IntegrityErrorimport time# 添加发布会接口def add_event(request): # 通过POST请求接收发布会参数 eid = request.POST.get('eid','') # 发布会id name = request.POST.get('name','') # 发布会标题 limit = request.POST.get('limit','') # 限制人数 status = request.POST.get('status','') # 状态 address = request.POST.get('address','') # 地址 start_time = request.POST.get('start_time','') # 发布会时间 # 首先，判断 eid、 name、limit、address、start_time 等字段均不能为空 if eid =='' or name == '' or limit == '' or address == '' or start_time == '': return JsonResponse(&#123;'status':10021,'message':'parameter error'&#125;) # 接下来，判断发布会 id 是否存在 result =Event.objects.filter(id=eid) if result: return JsonResponse(&#123;'status':10022,'message':'event id already exists'&#125;) # 接下来，判断发布会名称 name 是否存在 result = Event.objects.filter(name=name) if result: return JsonResponse(&#123;'status':10023, 'message':'event name already exists'&#125;) # 再接下来，判断发布会状态是否为空，如果为空，将状态设置为 1（True）。 if status == '': status = 1 # 最后，将数据插入到 Event 表，在插入的过程中如果日期格式错误，将抛出 ValidationError 异常 try: Event.objects.create(id=eid,name=name,limit=limit,address=address,status=int(status),start_time=start_time) except ValidationError: error = 'start_time format error. It must be in YYYY-MM-DD HH:MM:SS format.' return JsonResponse(&#123;'status':10024,'message':error&#125;) # 否则，插入成功，返回状态码 200 和“addeventsuccess”的提示。 return JsonResponse(&#123;'status':200,'message':'add event success'&#125;) # 发布会查询def get_event_list(request): # 通过GET请求接收发布会id和name参数。两个参数都是可选的 eid = request.GET.get(\"eid\", \"\") # 发布会id name = request.GET.get(\"name\", \"\") # 发布会名称 # 首先，判断当两个参数同时为空，接 口返回状态码 10021，参数错误。 if eid == '' and name == '': return JsonResponse(&#123;'status':10021,'message':'parameter error'&#125;) # 如果发布会 id 不为空，优先通过 id 查询，因为 id 的唯一性，所以，查询结果只会有一条 if eid != '': event = &#123;&#125; try: result = Event.objects.get(id=eid) except ObjectDoesNotExist: return JsonResponse(&#123;'status':10022, 'message':'query result is empty'&#125;) else: event['eid'] = result.id event['name'] = result.name event['limit'] = result.limit event['status'] = result.status event['address'] = result.address event['start_time'] = result.start_time return JsonResponse(&#123;'status':200, 'message':'success', 'data':event&#125;) # name 查询为模糊查询，查询数据可能会有多条 if name != '': datas = [] results = Event.objects.filter(name__contains=name) if results: for r in results: event = &#123;&#125; event['eid'] = r.id event['name'] = r.name event['limit'] = r.limit event['status'] = r.status event['address'] = r.address event['start_time'] = r.start_time datas.append(event) return JsonResponse(&#123;'status':200, 'message':'success', 'data':datas&#125;) else: return JsonResponse(&#123;'status':10022, 'message':'query result is empty'&#125;) # 添加嘉宾接口def add_guest(request): # 通过POST请求接收嘉宾参数 eid = request.POST.get('eid','') # 关联发布会id realname = request.POST.get('realname','') # 姓名 phone = request.POST.get('phone','') # 手机号 email = request.POST.get('email','') # 邮箱 # 首先，判断 eid、realname、phone 等参数均不能为空 if eid =='' or realname == '' or phone == '': return JsonResponse(&#123;'status':10021,'message':'parameter error'&#125;) # 接下来，判断嘉宾关联的发布会 id 是否存在 result = Event.objects.filter(id=eid) if not result: return JsonResponse(&#123;'status':10022,'message':'event id null'&#125;) # 接下来，判断及关联的发布会状态是否为 True（即 1） result = Event.objects.get(id=eid).status if not result: return JsonResponse(&#123;'status':10023,'message':'event status is not available'&#125;) # 接下来，判断发布会人数限制 event_limit = Event.objects.get(id=eid).limit # 发布会限制人数 guest_limit = Guest.objects.filter(event_id=eid) # 发布会已添加的嘉宾数 if len(guest_limit) &gt;= event_limit: return JsonResponse(&#123;'status':10024,'message':'event number is full'&#125;) # 再接下来的步骤是判断当前时间是否大于发布会时间，如果大于则说明发布已开始，或者早已经结束。 event_time = Event.objects.get(id=eid).start_time # 发布会时间 timeArray = time.strptime(str(event_time), \"%Y-%m-%d %H:%M:%S\") e_time = int(time.mktime(timeArray)) now_time = str(time.time()) # 当前时间 ntime = now_time.split(\".\")[0] n_time = int(ntime) if n_time &gt;= e_time: return JsonResponse(&#123;'status':10025,'message':'event has started'&#125;) # 最后，插入嘉宾数据，如果发布会的手机号重复则抛 IntegrityError 异常，接收该异常并返回相应的状态 码和提示信息 try: Guest.objects.create(realname=realname,phone=int(phone),email=email,sign=0,event_id=int(eid)) except IntegrityError: return JsonResponse(&#123;'status':10026,'message':'the event guest phone number repeat'&#125;) # 如果添加成功，则返回状态码 200 和“addguestsuccess”的提示 return JsonResponse(&#123;'status':200,'message':'add guest success'&#125;) # 嘉宾查询接口def get_guest_list(request): eid = request.GET.get(\"eid\", \"\") # 关联发布会id phone = request.GET.get(\"phone\", \"\") # 嘉宾手机号 if eid == '': return JsonResponse(&#123;'status':10021,'message':'eid cannot be empty'&#125;) if eid != '' and phone == '': datas = [] results = Guest.objects.filter(event_id=eid) if results: for r in results: guest = &#123;&#125; guest['realname'] = r.realname guest['phone'] = r.phone guest['email'] = r.email guest['sign'] = r.sign datas.append(guest) return JsonResponse(&#123;'status':200, 'message':'success', 'data':datas&#125;) else: return JsonResponse(&#123;'status':10022, 'message':'query result is empty'&#125;) if eid != '' and phone != '': guest = &#123;&#125; try: result = Guest.objects.get(phone=phone,event_id=eid) except ObjectDoesNotExist: return JsonResponse(&#123;'status':10022, 'message':'query result is empty'&#125;) else: guest['realname'] = result.realname guest['phone'] = result.phone guest['email'] = result.email guest['sign'] = result.sign return JsonResponse(&#123;'status':200, 'message':'success', 'data':guest&#125;) # 用户签到接口def user_sign(request): # 签到接口通过POST请求接收发布会id和嘉宾手机号 eid = request.POST.get('eid','') # 发布会id phone = request.POST.get('phone','') # 嘉宾手机号 # 首先，判断两个参数均不能为空 if eid =='' or phone == '': return JsonResponse(&#123;'status':10021,'message':'parameter error'&#125;) # 接着，判断发布会 id 是否存在 result = Event.objects.filter(id=eid) if not result: return JsonResponse(&#123;'status':10022,'message':'event id null'&#125;) # 接着，判断发布会状态是否为 True result = Event.objects.get(id=eid).status if not result: return JsonResponse(&#123;'status':10023,'message':'event status is not available'&#125;) # 再接着，判断当前时间是否大于发布会时间，如果大于发布会时间说明发布会已开始，不允许签到 event_time = Event.objects.get(id=eid).start_time # 发布会时间 timeArray = time.strptime(str(event_time), \"%Y-%m-%d %H:%M:%S\") e_time = int(time.mktime(timeArray)) now_time = str(time.time()) # 当前时间 ntime = now_time.split(\".\")[0] n_time = int(ntime) if n_time &gt;= e_time: return JsonResponse(&#123;'status':10024,'message':'event has started'&#125;) # 然后，再判断嘉宾的手机号是否存在 result = Guest.objects.filter(phone=phone) if not result: return JsonResponse(&#123;'status':10025,'message':'user phone null'&#125;) # 然后，再判断嘉宾的手机号与发布会 id 是否为对应关系 result = Guest.objects.filter(phone=phone,event_id=eid) if not result: return JsonResponse(&#123;'status':10026,'message':'user did not participate in the conference'&#125;) # 最后，判断该嘉宾的状态是否为已签到，如果已签到，返回相应的状态码和提示 result = Guest.objects.get(event_id=eid,phone=phone).sign if result: return JsonResponse(&#123;'status':10027,'message':'user has sign in'&#125;) # 如果未签到修改状态 为已签到，并返回状态码 200 和“signsuccess”的提示。 else: Guest.objects.filter(phone=phone).update(sign='1') return JsonResponse(&#123;'status':200,'message':'sign success'&#125;) guest/sign/views_if_sec.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254from django.http import JsonResponsefrom sign.models import Event, Guestfrom django.core.exceptions import ObjectDoesNotExist, ValidationErrorfrom django.contrib import auth as django_authimport base64, timeimport hashlibfrom django.http import HttpResponse#from Crypto.Cipher import AES # 请安装 Cryptoimport json# 用户认证def user_auth(request): # request.META 包含了所有本次 HTTP 请求的 Header 信息;HTTP_AUTHORIZATION 用于获取 HTTPauthorization; # 得到的数据是这样的：Basic YWRtaW46YWRtaW4xMjM0NTY= get_http_auth = request.META.get('HTTP_AUTHORIZATION','b') # split()方法拆分成 list,拆分后的数据是这样的：['Basic','YWRtaW46YWRtaW4xMjM0NTY='] auth = get_http_auth.split() # 取出 list 中的加密串，通过 base64 对加密串进行解码。得到的数据是：('admin',':','admin123456') try: auth_parts = base64.b64decode(auth[1]).decode('utf-8').partition(':') # 如果获取不到 Auth 信息，将会抛 IndexError 异常 except IndexError: return \"null\" # 取出元组中对应的用户 id 和密码。最终于数据： admin admin123456 userid, password = auth_parts[0], auth_parts[2] # 调用 Django 的认证模块，对得到 Auth 信息进行认证。成功将返回 “success”，失败则返回“fail” user = django_auth.authenticate(username=userid, password=password) if user is not None and user.is_active: django_auth.login(request, user) return \"success\" else: return \"fail\"# 发布会查询接口---增加用户认证def get_event_list(request): auth_result = user_auth(request) # 调用认证函数 if auth_result == \"null\": return JsonResponse(&#123;'status':10011,'message':'user auth null'&#125;) if auth_result == 'fail': return JsonResponse(&#123;'status':10012,'message':'user auth fail'&#125;) # 通过GET请求接收发布会id和name参数。两个参数都是可选的 eid = request.GET.get(\"eid\", \"\") # 发布会id name = request.GET.get(\"name\", \"\") # 发布会名称 # 首先，判断当两个参数同时为空，接 口返回状态码 10021，参数错误。 if eid == '' and name == '': return JsonResponse(&#123;'status':10021,'message':'parameter error'&#125;) # 如果发布会 id 不为空，优先通过 id 查询，因为 id 的唯一性，所以，查询结果只会有一条 if eid != '': event = &#123;&#125; try: result = Event.objects.get(id=eid) except ObjectDoesNotExist: return JsonResponse(&#123;'status':10022, 'message':'query result is empty'&#125;) else: event['eid'] = result.id event['name'] = result.name event['limit'] = result.limit event['status'] = result.status event['address'] = result.address event['start_time'] = result.start_time return JsonResponse(&#123;'status':200, 'message':'success', 'data':event&#125;) # name 查询为模糊查询，查询数据可能会有多条 if name != '': datas = [] results = Event.objects.filter(name__contains=name) if results: for r in results: event = &#123;&#125; event['eid'] = r.id event['name'] = r.name event['limit'] = r.limit event['status'] = r.status event['address'] = r.address event['start_time'] = r.start_time datas.append(event) return JsonResponse(&#123;'status':200, 'message':'success', 'data':datas&#125;) else: return JsonResponse(&#123;'status':10022, 'message':'query result is empty'&#125;) # 用户签名+时间戳def user_sign(request): # 通过 POST 方法获取两个参数 time 和 sign 两个参数 if request.method == \"post\": client_time = request.POST.get('time', '') # 客户端时间戳 client_sign= request.POST.get('sign', '') # 客户端签名 else: return \"error\" if client_time == '' or client_sign == '': return \"sign null\" # 服务器时间 now_time = time.time() # 例：1466426831.9126902 # Python3 生成的的时间戳精度太高，我们只需要小数点前面的 10 位即可 server_time = str(now_time).split('.')[0] # 获取时间差 time_difference = int(server_time) - int(client_time) # 接口的请求时间是离现在超过 60 秒,返回请求超时 if time_difference &gt;= 60: return \"timeout\" # 签名检查 md5 = hashlib.md5() # 签名参数的生成：密钥字符串(“&amp;Guest-Bugmaster”)和客户端发来的时间戳， 两者拼接成一个新的字符串 sign_str = client_time + \"&amp;Guest-Bugmaster\" sing_bytes_utf8 = sign_str.encode(encoding=\"utf-8\") # 通过 MD5 对其进行加密。从而将加密后的字符串作为 sign 的字段的参数 md5.update(sing_bytes_utf8) server_sign = md5.hexdigest # 两端使用相同的规则生成的加密后的字符串，进行比较 if server_sign != client_sign: return \"sign fail\" else: return \"sign right\" # 添加发布会接口---增加签名+时间戳def add_event(request): sign_result = user_sign(request) # 调用签名函数 if sign_result == \"error\": return JsonResponse(&#123;'status':10011,'message':'request error'&#125;) elif sign_result == \"sign null\": return JsonResponse(&#123;'status':10012,'message':'user sign null'&#125;) elif sign_result == \"timeout\": return JsonResponse(&#123;'status':10013,'message':'user sign timeout'&#125;) elif sign_result == \"sign fail\": return JsonResponse(&#123;'status':10014,'message':'user sign error'&#125;) # 通过POST请求接收发布会参数 eid = request.POST.get('eid','') # 发布会id name = request.POST.get('name','') # 发布会标题 limit = request.POST.get('limit','') # 限制人数 status = request.POST.get('status','') # 状态 address = request.POST.get('address','') # 地址 start_time = request.POST.get('start_time','') # 发布会时间 # 首先，判断 eid、 name、limit、address、start_time 等字段均不能为空 if eid =='' or name == '' or limit == '' or address == '' or start_time == '': return JsonResponse(&#123;'status':10021,'message':'parameter error'&#125;) # 接下来，判断发布会 id 是否存在 result =Event.objects.filter(id=eid) if result: return JsonResponse(&#123;'status':10022,'message':'event id already exists'&#125;) # 接下来，判断发布会名称 name 是否存在 result = Event.objects.filter(name=name) if result: return JsonResponse(&#123;'status':10023, 'message':'event name already exists'&#125;) # 再接下来，判断发布会状态是否为空，如果为空，将状态设置为 1（True）。 if status == '': status = 1 # 最后，将数据插入到 Event 表，在插入的过程中如果日期格式错误，将抛出 ValidationError 异常 try: Event.objects.create(id=eid,name=name,limit=limit,address=address,status=int(status),start_time=start_time) except ValidationError: error = 'start_time format error. It must be in YYYY-MM-DD HH:MM:SS format.' return JsonResponse(&#123;'status':10024,'message':error&#125;) # 否则，插入成功，返回状态码 200 和“addeventsuccess”的提示。 return JsonResponse(&#123;'status':200,'message':'add event success'&#125;) # AES加密算法 BS = 16# 通过 upad 匿名函数对字符串的长度还原unpad = lambda s : s[0: - ord(s[-1])]def decryptBase64(src): \"\"\" 对 Base64 字符串解密 \"\"\" return base64.urlsafe_b64decode(src)def decryptAES(src, key): \"\"\" 解析AES密文 \"\"\" # 调用 decryptBase64()方法，将 Base64 加密字符串解密为 AES 加密字符串。 src = decryptBase64(src) iv = b\"1172311105789011\" # 通过 decrypt() 对 AES 加密串进行解密。 cryptor = AES.new(key, AES.MODE_CBC, iv) text = cryptor.decrypt(src).decode() return unpad(text)def aes_encryption(request): # 服务器端与合法客户端约定的密钥 app_key。 app_key = 'W7v4D60fds2Cmk2U' # 判断客户端请求是否为 POST，通过 POST.get()方法接收 data 参数 if request.method == 'POST': data = request.POST.get(\"data\", \"\") else: return \"error\" # 解密，调用解密函数 decryptAES() ，传参加密字符串和 app_key decode = decryptAES(data, app_key) # 转化为字典，将解密后字符串通过 json.loads()方法转化成字典，并将该字典做为 aes_encryption()函数的返回值 dict_data = json.loads(decode) return dict_data# 嘉宾查询接口----AES算法def get_guest_list(request): dict_data = aes_encryption(request) # 调用加密字符串解密函数 if dict_data == \"error\": return JsonResponse(&#123;'status':10011,'message':'request error'&#125;) # 取出对应的发布会id和嘉宾手机号 eid = dict_data['eid'] phone = dict_data['phone'] if eid == '': return JsonResponse(&#123;'status':10021,'message':'eid cannot be empty'&#125;) if eid != '' and phone == '': datas = [] results = Guest.objects.filter(event_id=eid) if results: for r in results: guest = &#123;&#125; guest['realname'] = r.realname guest['phone'] = r.phone guest['email'] = r.email guest['sign'] = r.sign datas.append(guest) return JsonResponse(&#123;'status':200, 'message':'success', 'data':datas&#125;) else: return JsonResponse(&#123;'status':10022, 'message':'query result is empty'&#125;) if eid != '' and phone != '': guest = &#123;&#125; try: result = Guest.objects.get(phone=phone,event_id=eid) except ObjectDoesNotExist: return JsonResponse(&#123;'status':10022, 'message':'query result is empty'&#125;) else: guest['realname'] = result.realname guest['phone'] = result.phone guest['email'] = result.email guest['sign'] = result.sign return JsonResponse(&#123;'status':200, 'message':'success', 'data':guest&#125;) guest/sign/templates/index.html123456789101112131415&lt;html&gt; &lt;head&gt; &lt;title&gt;Django Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;发布会管理&lt;/h1&gt; &lt;form method=\"post\" action=\"/login_action/\"&gt; &lt;input name=\"username\" type=\"text\" placeholder=\"username\"&gt;&lt;br&gt; &lt;input name=\"password\" type=\"password\" placeholder=\"password\"&gt;&lt;br&gt; &#123;&#123; error &#125;&#125;&lt;br&gt; &lt;button id=\"btn\" type=\"submit\"&gt;登录&lt;/button&gt; &#123;% csrf_token %&#125; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; guest/sign/templates/event_manage.html1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;html lang=\"zh-CN\"&gt; &lt;head&gt; &#123;% load bootstrap3 %&#125; &#123;% bootstrap_css %&#125; &#123;% bootstrap_javascript %&#125; &lt;title&gt;Guest Manage&lt;/title&gt; &lt;/head&gt; &lt;body role=\"document\"&gt; &lt;!-- 导航栏 --&gt; &lt;nav class=\"navbar navbar-inverse navbar-fixed-top\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;a class=\"navbar-brand\" href=\"/event_manage/\"&gt;Guest Manage System&lt;/a&gt; &lt;/div&gt; &lt;div id=\"navbar\" class=\"collapse navbar-collapse\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"#\"&gt;发布会&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/guest_manage/\"&gt;嘉宾&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"nav navbar-nav navbar-right\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&#123;&#123;user&#125;&#125;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/logout/\"&gt;退出&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt; &lt;!--发布会搜索表单--&gt; &lt;div class=\"page-header\" style=\"padding-top: 60px;\"&gt; &lt;div id=\"navbar\" class=\"navbar-collapse collapse\"&gt; &lt;form class=\"navbar-form\" method=\"get\" action=\"/search_name/\"&gt; &lt;div class=\"form-group\"&gt; &lt;input name=\"name\" type=\"text\" placeholder=\"名称\" class=\"form-control\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-success\"&gt;搜索&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 发布会列表 --&gt; &lt;div class=\"row\" style=\"padding-top: 80px;\"&gt; &lt;div class=\"col-md-6\"&gt; &lt;table class=\"table table-striped\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt;&lt;th&gt;名称&lt;/th&gt;&lt;th&gt;状态&lt;/th&gt;&lt;th&gt;地址&lt;/th&gt;&lt;th&gt;时间&lt;/th&gt; &lt;th&gt;签到&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for event in events %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123; event.id &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; event.name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; event.status &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; event.address &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; event.start_time &#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=\"/sign_index/&#123;&#123; event.id &#125;&#125;/\" target=\"&#123;&#123; event.id &#125;&#125;_blank\"&gt; sign&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; guest/sign/templates/guest_manage.html1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;html lang=\"zh-CN\"&gt; &lt;head&gt; &#123;% load bootstrap3 %&#125; &#123;% bootstrap_css %&#125; &#123;% bootstrap_javascript %&#125; &lt;title&gt;Guest Manage&lt;/title&gt; &lt;/head&gt; &lt;body role=\"document\"&gt; &lt;!-- 导航栏 --&gt; &lt;nav class=\"navbar navbar-inverse navbar-fixed-top\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;a class=\"navbar-brand\" href=\"/event_manage/\"&gt;Guest Manage System&lt;/a&gt; &lt;/div&gt; &lt;div id=\"navbar\" class=\"collapse navbar-collapse\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li&gt;&lt;a href=\"/event_manage/\"&gt;发布会&lt;/a&gt;&lt;/li&gt; &lt;li class=\"active\"&gt;&lt;a href=\"#\"&gt;嘉宾&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"nav navbar-nav navbar-right\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&#123;&#123;user&#125;&#125;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/logout/\"&gt;退出&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt; &lt;!-- 嘉宾列表 --&gt; &lt;div class=\"row\" style=\"padding-top: 80px;\"&gt; &lt;div class=\"col-md-6\"&gt; &lt;table class=\"table table-striped\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt;&lt;th&gt;名称&lt;/th&gt;&lt;th&gt;手机&lt;/th&gt;&lt;th&gt;Email&lt;/th&gt;&lt;th&gt;签到&lt;/th&gt; &lt;th&gt;发布会&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for guest in guests %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123; guest.id &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; guest.realname &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; guest.phone &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; guest.email &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; guest.sign &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; guest.event &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 列表分页器 --&gt; &lt;div class=\"pagination\"&gt; &lt;span class=\"step-links\"&gt; &#123;% if guests.has_previous %&#125; &lt;a href=\"?page=&#123;&#123; guests.previous_page_number &#125;&#125;\"&gt;previous&lt;/a&gt; &#123;% endif %&#125; &lt;span class=\"current\"&gt; Page &#123;&#123; guests.number &#125;&#125; of &#123;&#123; guests.paginator.num_pages &#125;&#125;. &lt;/span&gt; &#123;% if guests.has_next %&#125; &lt;a href=\"?page=&#123;&#123; guests.next_page_number &#125;&#125;\"&gt;next&lt;/a&gt; &#123;% endif %&#125; &lt;/span&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; guest/sign/templates/sign_index.html123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;html lang=\"zh-CN\"&gt; &lt;head&gt; &#123;% load bootstrap3 %&#125; &#123;% bootstrap_css %&#125; &#123;% bootstrap_javascript %&#125; &lt;title&gt;Guest Manage&lt;/title&gt; &lt;/head&gt; &lt;body role=\"document\"&gt; &lt;!-- 导航栏 --&gt; &lt;nav class=\"navbar navbar-inverse navbar-fixed-top\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;!--将页面标题设置为发布会名称--&gt; &lt;a class=\"navbar-brand\" href=\"#\"&gt;&#123;&#123; event.name &#125;&#125;&lt;/a&gt; &lt;/div&gt; &lt;div id=\"navbar\" class=\"collapse navbar-collapse\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li&gt;&lt;a href=\"/event_manage/\"&gt;发布会&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/guest_manage/\"&gt;嘉宾&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt; &lt;!-- 签到功能 --&gt; &lt;div class=\"page-header\" style=\"padding-top: 80px;\"&gt; &lt;div id=\"navbar\" class=\"navbar-collapse collapse\"&gt; &lt;form class=\"navbar-form\" method=\"post\" action=\"/sign_index_action/&#123;&#123; event.id &#125;&#125;/\"&gt; &lt;div class=\"form-group\"&gt; &lt;input name=\"phone\" type=\"text\" placeholder=\"输入手机号\" class=\"form-control\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-success\"&gt;签到&lt;/button&gt; &#123;% csrf_token %&#125; &lt;font color=\"red\"&gt; &lt;br&gt;&#123;&#123; hint &#125;&#125; &lt;br&gt;&#123;&#123; guest.realname &#125;&#125; &lt;br&gt;&#123;&#123; guest.phone &#125;&#125; &lt;/font&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 2、django_rest项目 django_rest/ django_rest/ __init__.py settings.py urls.py wsgi.py api/ migrations/ __init__.py 0001_initial.py __init__.py admin.py apps.py models.py serializers.py tests.py views.py db.sqlite3 manage.py guest/django_rest/settings.py1234567import os# 在文件末尾添加 REST_FRAMEWORK = &#123; 'DEFAULT_PERMISSION_CLASSES': ('rest_framework.permissions.IsAdminUser',), 'PAGE_SIZE': 10 &#125; guest/django_rest/urls.py123456789101112131415161718192021222324from django.contrib import adminfrom django.urls import pathfrom django.conf.urls import url, includefrom rest_framework import routersfrom api import views\"\"\"因为我们使用的是 viewset，所以我们可以使用 routers 类自动生成 URLconf\"\"\"#Routers provide an easy way of automatically determining the URL conf. router = routers.DefaultRouter()router.register(r'users',views.UserViewSet)router.register(r'groups',views.GroupViewSet)router.register(r'event', views.EventViewSet) router.register(r'guest', views.GuestViewSet)# Wire up our API using automatic URL routing. # Additionally, we include login URLs for the browsable API. urlpatterns = [ path('admin/', admin.site.urls), url(r'^', include(router.urls)), url(r'api-auth/', include('rest_framework.urls',namespace='rest_framework'))] guest/api/models.py123456789101112131415161718192021222324252627282930from django.db import models# Create your models here.# 发布会class Event(models.Model): name = models.CharField(max_length=100) limit = models.IntegerField() status = models.BooleanField() address = models.CharField(max_length=200) start_time = models.DateTimeField('events time') create_time = models.DateTimeField(auto_now=True) def __str__(self): return self.name# 嘉宾class Guest(models.Model): event = models.ForeignKey(Event, on_delete=models.CASCADE) realname = models.CharField(max_length=64) phone = models.CharField(max_length=16) email = models.EmailField() sign = models.BooleanField() create_time = models.DateTimeField(auto_now=True) class Meta: unique_together = ('phone', 'event') def __str__(self): return self.realname guest/api/serializers.py123456789101112131415161718192021222324252627from django.contrib.auth.models import User, Groupfrom rest_framework import serializersfrom api.models import Event, Guest\"\"\"使用的是 HyperlinkedModelSerializer，也可以使用主键或者其他关系。但使用 HyperlinkedModelSerializer 是一个好的 RESTful 设计\"\"\"class UserSerializer(serializers.HyperlinkedModelSerializer): class Meta: model = User fields = ('url', 'username', 'email', 'groups') class GroupSerializer(serializers.HyperlinkedModelSerializer): class Meta: model = Group fields = ('url', 'name')class EventSerializer(serializers.HyperlinkedModelSerializer): class Meta: model = Event fields = ('url','name','address','start_time','limit','status') class GuestSerializer(serializers.HyperlinkedModelSerializer): class Meta: model = Guest fields = ('url','realname','phone','email','sign','event') guest/api/views.py1234567891011121314151617181920212223242526272829303132333435363738394041424344from django.shortcuts import renderfrom django.contrib.auth.models import User, Groupfrom rest_framework import viewsetsfrom api.serializers import UserSerializer, GroupSerializerfrom api.serializers import EventSerializer, GuestSerializer from api.models import Event, Guest\"\"\"在 django RESTframework 中，所有常见的行为都被归到 ViewSets 中。当然我们可以将这些行为分拆出 来，但使用 ViewSets，使 view 的逻辑更为清楚。使用 queryset 和 serializer_class 使我们能更好的控制 API 行为，这也是我们推荐的使用方式。\"\"\"# Create your views here.# ViewSets define the view behavior.class UserViewSet(viewsets.ModelViewSet): \"\"\" API endpoint that allows users to be viewed or edited. \"\"\" queryset = User.objects.all().order_by('-date_joined') serializer_class = UserSerializer class GroupViewSet(viewsets.ModelViewSet): \"\"\" API endpoint that allows groups to be viewed or edited. \"\"\" queryset = Group.objects.all() serializer_class = GroupSerializer class EventViewSet(viewsets.ModelViewSet): \"\"\" API endpoint that allows events to be viewed or edited. \"\"\" queryset = Event.objects.all() serializer_class = EventSerializerclass GuestViewSet(viewsets.ModelViewSet): \"\"\" API endpoint that allows guests to be viewed or edited. \"\"\" queryset = Guest.objects.all() serializer_class = GuestSerializer 持续更新…—title: django-签到系统date: 2018-08-14 15:36:35 tags:","categories":[{"name":"django","slug":"django","permalink":"http://pythonfood.github.io/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://pythonfood.github.io/tags/django/"}]},{"title":"持续集成-jenkins","slug":"持续集成-jenkins","date":"2018-05-01T04:00:00.000Z","updated":"2018-05-11T06:59:51.195Z","comments":true,"path":"2018/05/01/持续集成-jenkins/","link":"","permalink":"http://pythonfood.github.io/2018/05/01/持续集成-jenkins/","excerpt":"持续集成jenkins使用笔记。","text":"持续集成jenkins使用笔记。 一、持续集成流程(1)提交代码(2)拉取代码(3)编译(4)打包(5)配置(6)测试(7)反馈问题(8)开发处理(9)回到(1) 二、持续集成工具(1)代码管理工具： Git：官网下载安装https://git-scm.com/downloadsGitHub：官网地址https://github.com/ (2)集成工具： Jenkins：官网下载安装https://jenkins.io/download/1)安装后会自动启动浏览器，输入http://localhost:80802)根据页面中标红路径找到管理员密码吗3)输入管理员密码，点击【Continue】4)安装插件，默认选项即可5)安装完需要创建用户，此处点击【Continue as admin】使用默认账户即可6)点击【Start using Jekins】启动7)修改密码，进入【admin-设置】，向上拉找到密码处即可修改 三、Jenkins系统配置(1)插件管理： 1)进入【系统管理-管理插件-已安装】查看下面插件： Git Plugin GitHub Plugin Gradle Plugin Android Emulator Plugin 2)未安装的进入【可选插件】里安装即可 (2)Gradle配置： 1)进入【系统管理-全局工具配置】找到【Gradle安装】2)点击【新增Gradle】3)选择自动安装，名称输入和版本一致即可4)再点击【Apply】-【Save】 (3)GitHub配置： 1)进入【系统管理-系统设置】找到【GitHub】2)点击【Add GitHub Server】3)在【GitHub Server】的【API URL】输入(https://api.github.com)4)再点击【Credentials】右侧的问号设置权限，展开的内容里右键点击【personal access token】新窗口打开github5)在github页面【Token description】输入自定义名称,勾选【repo】,点击【Generate token】6)在github页面生成Personal access tokens后复制7)回到jenkins页面点击【add】-【jenkins】8)在弹出窗口里【Kind】类别选择【Secret text】,将刚才复制的token粘贴到【Secret】，再点击【add】就创建了身份信息9)可以点击【Test connection】验证一下，验证通过后点击【保存】 四、Jenkins JOB配置创建任务： 1)点击页面中【创建一个新任务】2)输入任务名称，选择【构建一个自由风格的软件项目】，点击【确定】进入设置界面3)进行自定义配置后点击【保存】 五、JOB配置小示例进入创建的任务详情界面，点击【配置】进行job配置(1)拉取代码： 1)【源码管理】选择【Git】，输入代码库的URL地址2)点击【Add】-【jenkins】配置github权限3)弹出界面输入github的帐户名和密码，点击【Add】添加4)【Credentials】选择刚添加的github账户 (2)编译、打包： 1)【构建】点击【增加构建步骤】2)选择【Invoke Gradle script】3)【Gradle Version】选择对应版本4)【Tasks】填写“build”等信息 (3)配置： 1)【构建】点击【增加构建步骤】2)选择【Install Android package】3)【APK file】填写生成的apk路径（此处可以先生构建一次4)查看路径，再复制到这里）5)勾选【Uninstall existing APK first】 (4)测试： 1)【构建】点击【增加构建步骤】2)选择【Run Android monkey tester】3)【Package IDs】输入包名4)【Event count】输入执行次数5)【Delay between events】输入间隔时间ms6)点击【Apply】,点击【保存】 (5)立即构建： 1)进入创建的任务详情界面2)点击【立即构建】进行构建3)点击构建的任务可以查看详情4)【Console Output】可以查看日志信息 (6)定时构建： 1)进入创建的任务详情界面2)点击【配置】进行job配置3)【构建触发器】下选择【Build periodically】4)【日程表】里输入规则，例如“H/15 ”(每15分钟构建一次)5)点击【日程表】右侧问号，可以查看规则描述6)点击【Apply】,点击【保存】 持续更新…","categories":[{"name":"持续集成","slug":"持续集成","permalink":"http://pythonfood.github.io/categories/持续集成/"}],"tags":[{"name":"jenkins","slug":"jenkins","permalink":"http://pythonfood.github.io/tags/jenkins/"}]},{"title":"unittest测试框架","slug":"unittest测试框架","date":"2018-05-01T01:00:00.000Z","updated":"2018-05-11T06:59:06.744Z","comments":true,"path":"2018/05/01/unittest测试框架/","link":"","permalink":"http://pythonfood.github.io/2018/05/01/unittest测试框架/","excerpt":"unittest中最核心的四个概念是：test fixture, test case, test suite, test runner。","text":"unittest中最核心的四个概念是：test fixture, test case, test suite, test runner。 一、unittest框架(1)Test Fixture setup() testcase() teardown() (2)Test Case(3)Test Suite(4)Test Runner 二、unittest小示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445import unittestdemo1import unittestdemo2import unittestfrom appium import webdriverclass MyTestCase(unittest.TestCase): #初始化setup def setUp(self): desired_caps=&#123;&#125; desired_caps[&apos;platformName&apos;]=&apos;Android&apos; desired_caps[&apos;platformVersion&apos;]=&apos;5.1.1&apos; desired_caps[&apos;deviceName&apos;]=&apos;61f9c06a&apos; desired_caps[&apos;appPackage&apos;]=&apos;com.android.contacts&apos; desired_caps[&apos;appActivity&apos;]=&apos;com.android.contacts.DialtactsContactsEntryActivity&apos; desired_caps[&apos;unicodeKeyboard&apos;]=&apos;true&apos; desired_caps[&apos;resetKeyboard&apos;]=&apos;true&apos; self.driver = webdriver.Remote(&apos;http://127.0.0.1:4723/wd/hub&apos;, desired_caps) #测试用例1 def test_something(self): self.assertEqual(False, True) print(&apos;test_something&apos;) #测试用例2 def test_anything(self): self.assertEqual(True, True) print(&apos;test_anything&apos;) #释放资源teardown def tearDown(self): self.driver.quit()if __name__ ==&quot;__main__&quot;: #以类的形式添加测试用例 cases1 = unittest.TestLoader().loadTestsFromTestCase(unittestdemo1.MyTestCase) cases2 = unittest.TestLoader().loadTestsFromTestCase(unittestdemo2.MyTestCase) #定义suite suite = unittest.TestSuite([cases1, cases2]) #以单条测试用例形式装载 suite.addTest(MyTestCase(&apos;test_something&apos;)) suite.addTest(MyTestCase(&apos;test_anything&apos;)) #定义runner runner = unittest.TextTestRunner(verbosity=2) #用runner执行suite runner.run(suite) 三、DDT数据驱动模式(1)官网下载安装：https://pypi.python.org/pypi/ddt(2)使用前导入模块from ddt import ddt,data,unpack(3)首先说明测试类使用的是ddt测试框架： 12@ddtclass MyTestCase(unittest.TestCase) (4)数据驱动主要是解决带参数的测试用例：1）使用元组存放测试的数据，一个参数的情况： 12@data(1,-3,2,0)def testcase(self, value): 2）使用元组存放测试的数据，多个参数的情况： 123@data((3,2),(4,3),(5,3))@unpackdef testcase(self, value1, value2): 四、DDT小示例 123456789101112131415161718from ddt import ddt,data,unpack@ddtclass MyTestCase(unittest.TestCase): @data(1,2,3) def test_something(self, value): print(value) self.assertEqual(value, 2) @data((1,2),(2,3)) @unpack def test_anything(self, value1, value2): print(value1,value2) self.assertEqual(value2, value1+1)if __name__ == &apos;__main__&apos;: unittest.main() ps:使用ddt框架后，测试用例的名称会改变，所以装载Test Suite时不能使用单条测试用例装载了，尽量使用类的形式装载Test Suite。 持续更新…","categories":[{"name":"测试框架","slug":"测试框架","permalink":"http://pythonfood.github.io/categories/测试框架/"}],"tags":[{"name":"unittest","slug":"unittest","permalink":"http://pythonfood.github.io/tags/unittest/"}]},{"title":"接口测试-python","slug":"接口测试-python","date":"2018-04-01T04:00:00.000Z","updated":"2018-05-11T07:10:53.301Z","comments":true,"path":"2018/04/01/接口测试-python/","link":"","permalink":"http://pythonfood.github.io/2018/04/01/接口测试-python/","excerpt":"接口测试python实现脚本测试笔记。","text":"接口测试python实现脚本测试笔记。 一、requests模块(1)安装pip install requests(2)使用前导入import requests 二、GET请求ddt自动化(1)代码结构： 1)构造Header2)构造cookies3)发送Get请求4)获取返回值5)对结果进行校验 (2)代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env python3#coding=utf-8import requestsimport unittestimport ddt@ddt.ddtclass ApiTestClass(unittest.TestCase): @ddt.data(&apos;android&apos;,&apos;&apos;,&apos;ios&apos;) def test_Get(self,os_phone): #header部分配置 headers = &#123;&apos;User-Agent&apos;:&apos;Dalvik/1.6.0 (Linux; U; Android 4.3; Coolpad 8720L Build/JSS15Q)&apos;, &apos;Host&apos;:&apos;bdsp.x.jd.com&apos;, &apos;Connection&apos;:&apos;Keep-Alive&apos;, &apos;Accept-Encoding&apos;:&apos;gzip&apos; &#125; #cookies部分配置 cookies = dict(search_test = &apos;1&apos;) #get请求获得返回数据 res = requests.get(&apos;http://bdsp.x.jd.com/app/config?os=&apos;+os_phone+&apos;&amp;key=wx3ebc9e606b4f9242&amp;sdkv=5&apos;, headers = headers, cookies = cookies) print(res.text) print(res.status_code) #测试点校验 self.assertTrue(&apos;15*1000&apos; in res.text) if __name__ == &apos;__main__&apos;: cases = unittest.TestLoader().loadTestsFromTestCase(ApiTestClass) suite = unittest.TestSuite([cases]) #suite.addTest(ApiTestClass(&apos;test_Get&apos;)) runner = unittest.TextTestRunner() runner.run(suite) 三、POST请求ddt自动化(1)代码结构： 1)构造Keyword(即request body)2)构造Header3)构造cookies4)发送Get请求5)获取返回值6)对结果进行校验 (2)代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import requestsimport unittestimport ddt@ddt.ddtclass ApiTestClass(unittest.TestCase): @ddt.data((&apos;60.206.137.140&apos;,&apos;hjfwp9VflXZU3FsuM3cu6PBV&apos;), (&apos;&apos;,&apos;&apos;) ) @ddt.unpack def test_Post(self,m_host,m_accessToken): #header部分配置 headers = &#123;&apos;Content-Type&apos;:&apos;application/x-www-form-urlencoded&apos;, &apos;Content-Length&apos;:&apos;36&apos;, &apos;Host&apos;:m_host, &apos;Connection&apos;:&apos;Keep-Alive&apos;, &apos;Accept-Encoding&apos;:&apos;gzip&apos;, &apos;User-Agent&apos;:&apos;okhttp/3.8.1&apos; &#125; #cookies部分配置 cookies = dict(search_test = &apos;1&apos;) #data部分配置 keyword = &#123;&apos;accessToken&apos;:m_accessToken&#125; #post请求获得返回数据 res = requests.post(&apos;http://60.206.137.140/iot_api/family/queryFamilyList.json&apos;, headers = headers, cookies = cookies, data = keyword ) print(res.text) print(res.status_code) #测试点校验 self.assertTrue(&apos;北京市北京市&apos; in res.text) if __name__ == &apos;__main__&apos;: cases = unittest.TestLoader().loadTestsFromTestCase(ApiTestClass) suite = unittest.TestSuite([cases]) #suite.addTest(ApiTestClass(&apos;test_Post&apos;)) runner = unittest.TextTestRunner() runner.run(suite) 持续更新…","categories":[{"name":"接口测试","slug":"接口测试","permalink":"http://pythonfood.github.io/categories/接口测试/"}],"tags":[{"name":"接口脚本","slug":"接口脚本","permalink":"http://pythonfood.github.io/tags/接口脚本/"}]},{"title":"接口测试-jmeter","slug":"接口测试-jmeter","date":"2018-04-01T03:00:00.000Z","updated":"2018-05-11T06:58:28.803Z","comments":true,"path":"2018/04/01/接口测试-jmeter/","link":"","permalink":"http://pythonfood.github.io/2018/04/01/接口测试-jmeter/","excerpt":"接口测试jmeter工具使用笔记。","text":"接口测试jmeter工具使用笔记。 一、jmeter安装1、安装java 2、安装jmeter (1)官网下载最新版zip包：http://jmeter.apache.org/download_jmeter.cgi(2)解压下载的zip包到自定义路径即可，例如：D:\\Program Files\\jmeter 3、运行jmeter (1)进入jmeter解压路径的\\bin路径下，例如：D:\\Program Files\\jmeter\\apache-jmeter-4.0\\bin(2)双击jmeter.bat即可运行jmeter。 4、安装插件 (1)下载 plugins-manager.jar：http://www.jmeter-plugins.org/get/(2)将下载的jar包放到jmeter路径的\\lib\\ext路径下，例如：D:\\Program Files\\jmeter\\apache-jmeter-4.0\\lib\\ext(3)启动jmeter，菜单栏【选项】会多出一个【Plugins Manager】的选项。(4)点击 【Plugins Manager】选项打开jmeter插件管理。 Installed Plugins：显示已安装的插件。 Available Plugins：显示可安装的插件。 Upgrades：显示可以升级的插件。 (5)通过”勾选/取消勾选”插件，并点击右下角【Apply Changes and Restart JMeter】按钮来卸载、安装、升级插件。 二、jmeter基础原件官方文档介绍 1、测试计划Test Plan 是其它JMeter测试元件的容器，jmeter创建测试的所有内容是于基于一个计划的。 除了测试计划下的元件还有两种控制器。 2、线程用户Threads （Users）是一个虚拟用户组，线程组内线程数量在运行过程中不会发生改变。 (1)thread group(线程组) 1) 名称：可以给线程组设置一个命名。2) 注释：可以对线程组添加备注以标记。3) 在取样器错误后要执行的动作： 继续执行后续的。 启动下一线程组循环。 停止线程。 停止测试。 立刻停止测试。 4) 线程数：即用户数，一个虚拟用户占用一个进程或线程，需要多少用户并发，设置多少虚拟用户数在这里也就是设置多少个线程数。5) Ramp-Up Period(in seconds)准备时长：设置的虚拟用户数需要多长时间全部启动。如果线程数为100，准备时长为10，那么需要10秒钟启动100个线程，也就是每秒钟启动10个线程。6) 循环次数：每个线程发送请求的次数。 如果线程数为20，循环次数为100，那么每个线程发送100次请求。总请求数为20*100=2000 。 如果勾选了“永远”，那么所有线程会一直发送请求，一到选择停止运行脚本。 7) Delay Thread creation until needed：直到需要时延迟线程的创建。8) 调度器：可以设置线程组启动的开始时间和结束时间。实践结论是配置调度器时，需要设置循环次数为永远，防止因循环次数不够而终止压测。 启动时间:测试计划什么时候启动，启动延迟会覆盖它。当启动时间已过，手动运行脚本时也当前时间也会覆盖它(但启动时间页面显示不会变)。 结束时间：测试计划什么时候结束，持续时间会覆盖它。 持续时间（秒）：测试计划持续多长时间，会覆盖结束时间。 启动延迟（秒）：测试计划延迟多长时间启动，会覆盖启动时间。 3、配置元件Config Element 用于提供对静态数据配置的支持。 (1)CSV Data Set Config(csv数据文件设置) 1) 名称：可以给元件一个命名。2) 注释：可以对元件添加备注以标记。3) Filename：所需数据文件的路径。如和脚本同一路径，可直接填写文件名4) File encoding：编码和文件保持一致即可，默认为ANSI。如有中文，建议为UTF-85) Variable Names：引用变量时的变量名，对应数据文件中的每一列，以逗号分隔。如不填写，文件的第一行数据将被读取为变量名6) Delimiter：在.txt、.dat文件中，可以用逗号（,）或者Tab键（\\t）来区分列与列7) Allow quoted data：True时，可以使用双引号来识别逗号或双引号（如数据文件中为 1,2,”3,”4”,5” ，则识别出的为A_1=1，B_1=2，C_1=3,”4”,5）8) Recycle on EOF：到数据文件结尾时是否循环读取。设置为True时，线程数过多，数据文件读取到最后一行时，会再次从第一行开始读取。设置为False，到达文件结尾时如继续读取，则值会默认为，可通过设置jmeter属性csvdataset.eofstring来改变该值。9) Stop thread on EOF：Recycle on EOF设置为False，Stop thread on EOF设置为True，则读取数据文件最后一行后，停止测试，不管还有多少线程组未执行。10) Sharing mode：共享模式。默认在所有线程组中使用，可选择每个线程组单独打开 All threads:文件在所有线程间共享 Current thread group: 每个文件会针对每个线程组打开一次 Current thread: 每个文件会针对每个线程单独打开 Identifier:所有线程共享相同的标识，共享相同的文件。如有４个线程组，测试人员可以使用一个通用ＩＤ，以便在两个或多个线程组之间共享文件。 4、监听器Listener 是用来对测试结果数据进行处理和可视化展示的一系列元件。 (1)View Results in Table(察看结果树) 1) 名称：可以给元件一个命名。2) 注释：可以对元件添加备注以标记。3) 所有数据写入一个文件：提供结果保存功能。保存信息可勾选配置。4) Text下拉列表：用来显示不同的取样器请求，默认Text方式显示。5) 取样器结果：显示取样器运行结果。6) 请求：显示请求表单内容，不同取样器会有不同显示格式。7) 响应数据：显示服务器响应数据，同时还提供查询功能。 (2)Aggregate Report(聚合报告) 1) 名称：可以给元件一个命名。2) 注释：可以对元件添加备注以标记。3) 所有数据写入一个文件：提供结果保存功能。保存信息可勾选配置。4) Label： 请求的名称，就是我们在进行测试的httprequest sampler的名称5) Samples： 总共发给服务器的请求数量6) Average： 单个请求的平均响应时间，单位是毫秒7) Median： 50%的请求的响应时间8) 90%Line： 90%的请求的响应时间9) 95%Line： 95%的请求的响应时间10) 99%Line： 99%的请求的响应时间11) Min： 最小的响应时间12) Max： 最大的响应时间13) Error%： 错误率=错误的请求的数量/请求的总数14) Throughput： 吞吐量即表示每秒完成的请求数15) Received KB/sec： 每秒从服务器端接收到的数据量16) Sent KB/Sec： 每秒从发送到服务器端的数据量 5、定时器Timer 用于操作之间设置等待时间，等待时间是性能测试中常用的控制客户端QPS的手段。 (1)Constant Timer(固定定时器) 1) 名称：可以给元件一个命名。2) 注释：可以对元件添加备注以标记。3) 线程延迟（毫秒）：让每个线程在请求之前按相同的指定时间停顿。需要注意的是，固定定时器的延时不会计入单个sampler的响应时间，但会计入事务控制器的时间。 6、前置处理器Pre Processors 用于在实际的请求发出之前对即将发出的请求进行特殊处理。 (1)User Parameters(用户参数) 1) 名称：可以给元件一个命名。2) 注释：可以对元件添加备注以标记。3) 每次迭代更新一次：如果选中该选项，则参数的值在每个迭代中保持不变，在新的迭代开始时取下一个值。如果取消该选项，则参数值在每个在其作用域内的sampler发出请求时取下一个可用值。4) 添加变量5) 添加用户6) 删除变量7) 删除用户8) UP：向上移动9) down: 向下移动 7、后置处理器Post Processors 用于对Sampler发出请求后得到的服务器响应进行处理。一般用来提取响应中的特定数据。 (1)JSON Extractor(json提取器) 1) 名称：可以给元件一个命名。2) 注释：可以对元件添加备注以标记。3) Apply to：Sampler可能会产生子Sampler，这里需要选择从哪个Sampler中进行提取。 Main sample and sub-samples:作用于父节点的取样器及对应子节点的取样器 Main sample only：仅作用于父节点的取样器 Sub-samples only:仅作用于子节点的取样器 JMeter Variable:作用于jmeter变量(输入框内可输入jmeter的变量名称) 4) Variable Names：变量名。例如:status5) JSON Path Expressions： Json提取表达式。例如:$.status6) Match No. (0 for Random)：当提取有多个结果值时，选择需要的值保存到变量中，默认值为0 0：随机一个 -1：全部值，使用_N 方式保存（N从1开始），比如status_1,status_2… X: 自然数，比如1，返回第X个值（如果X大于返回值的数量，结果会不能获取，最终返回设置的默认值） 7) Compute concatenation var：如果有匹配到多个值，选择此项，会将全部值保存到_ALL，并使用逗号分割每个值。Match No. (0 for Random)需要为-1才有效，不然只能匹配到一个值了。8) Default Value： 缺省值 8、断言Assertions 断言用于检查测试中得到的相应数据等是否符合预期，断言一般用来设置检查点。 (1)Response Assertion(响应断言) 1) 名称：可以给元件一个命名。2) 注释：可以对元件添加备注以标记。3) Apply to：Sampler可能会产生子Sampler，这里需要选择从哪个Sampler中进行提取。 Main sample and sub-samples:作用于父节点的取样器及对应子节点的取样器 Main sample only：仅作用于父节点的取样器 Sub-samples only:仅作用于子节点的取样器 JMeter Variable:作用于jmeter变量(输入框内可输入jmeter的变量名称) 4)要测试的响应字段：要检查的项。 响应报文 Documeng(text)：测试文件 URL样本 响应代码 响应信息 Response Headers:响应头部 Ignore status：忽略返回的响应报文状态码 5) 模式匹配规则： 包括：返回结果包括你指定的内容 匹配：（好像跟Equals查不多，弄不明白有什么区别） Equals：返回结果与你指定结果一致 Substring：返回结果是指定结果的字串 否：不进行匹配 6) 要测试的模式:即填写你指定的结果（可填写多个）,按钮【添加】、【删除】是进行指定内容的管理 9、测试片段Test Fragment 是控制器上的一个种特殊的线程组，它在测试树上与线程组处于一个层级。它与线程组有所不同，因为它不被执行，除非它是一个模块控制器或者是被控制器所引用时才会被执行。 (1)Test Fragment(测试片段) 1) 名称：可以给元件一个命名。2) 注释：可以对元件添加备注以标记。 10、非测试元件Non-Test Elements 提供http镜像服务、http代理服务、属性显示等功能。 1)Property Display(属性显示) 1) 名称：可以给元件一个命名。2) 注释：可以对元件添加备注以标记。3) System：系统变量。4) Jmeter Properties：jmeter变量。 11、取样器Sampler 是测试中向服务器发送请求，记录响应信息，记录响应时间的最小单元。 (1)HTTP Sampler(HTTP取样器) 1) 名称：可以给元件一个命名。2) 注释：可以对元件添加备注以标记。3) 协议：向目标服务器发送http请求时的协议，http/https，大小写不敏感，默认http.4) 服务器名称或IP：http请求发送的目标服务器名称或者IP地址。5) 端口号：目标服务器的端口号，默认值为80，可不填6) 方法：发送http请求的方法 GET：向特定的资源发出请求。 POST：向指定资源提交数据进行处理请求。 HEAD：获得报文首部 PUT：向指定资源位置上传其最新内容。 OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。 TRACE：追踪路径，回显服务器收到的请求，主要用于测试或诊断。 DELETE：请求服务器删除Request-URI所标识的资源。 PATCH：实体中包含一个表，表中说明与该URI所表示的原内容的区别。 7) 路径：目标的URL路径（不包括服务器地址和端口）8) Content encoding：内容的编码方式（Content-Type=application/json;charset=utf-8）9) 自动重定向：发出的http请求得到响应是301/302，jmeter会重定向到新的界面10) 跟随重定向：响应Code是3XX时，自动跳转至目标地址。JMeter会记录重定向过程中的所有请求响应。11) Use keep Alive：jmeter 和目标服务器之间使用 Keep-Alive方式进行HTTP通信（默认选中）。12) Use multipart/from-data for HTTP POST ：当发送HTTP POST 请求时使用。13) browser-compatible headers：浏览器兼容请求头。14) Parameters：xx=xx&amp;xxx=xx格式的参数为GET或者POST请求中，url中带的参数值。 Encode?：参数有“=”、“&amp;”、“？”等特殊符号时选择。 Include Equals：自动添加参数名和值之间的等号。 15) Body Data：json格式的是POST请求中的参数16) Files Upload：发出HTTP请求并获得响应的HTML文件内容后还对该HTML进行Parse，并获取HTML中包含的所有资源（图片、flash等）：（默认不选中）17) Implementation:执行 Java：使用的http是使用的JAVA JVM提供的方法，有相关的限制。 HttpClient4：使用Apache HttpClient 4.1部件 空白：使用HTTP默认请求中的配置或jmeter.properties中jmeter.httpsample中的配置 18) Timeouts：超时 Connect：连接 Response：响应 19) Embedded Resources from HTML Files：解析HTML文件并发送所有资源请求(包括图片，java小程序，JS，CSS等) 从HTML文件获取所有内含的资源 Parallel downloads.Number：并行下载.数量 URLs must match：URL需匹配 20) Source address：IP欺骗，指定请求要用到的本地地址（参数化）。21) Proxy Server：代理相关设置 服务器名称或IP 端口号 用户名 密码 22)Save response as MD5 hash?：在执行时仅记录服务端响应数据的MD5值，而不记录完整的响应数据。在需要进行数据量非常大的测试时，建议选中该项以减少取样器记录响应数据的开销。 12、逻辑控制器Logic Controller 用来控制采样器的执行顺序。分为两类：一种是控制采样器的逻辑执行顺序，如Loop Controller、If Controller等；一种是对采样器进行分组，方便控制的，如Throughput Controller、Transaction Controller等。 (1)Loop Controller(循环控制器) 1) 名称：可以给元件一个命名。2) 注释：可以对元件添加备注以标记。3) Loop Count：循环次数4) Forever：永远循环 (2)ForEach Controller(遍历循环控制器) 1) 名称：可以给元件一个命名。2) 注释：可以对元件添加备注以标记。3) 输入变量前缀：在其中输入需要遍历的用户参数（User Parameter）4) Start index for loop(exclusive）：循环指数开始（唯一）→ 遍历查询的变量范围，开始的值（这里如果不填写，默认从1开始，如果没有1开始的变量，执行时会报错）5) End index for loop(inclusive）：循环指数结束（包含）→ 遍历查询的变量范围，结束的值6) 输出变量名称：将遍历查询到的符合条件的用户参数赋值给输入变量（Vname），然后就可以在控制器下的取样器使用，格式为${输出变量名}7) Add””before number：输入变量名称中是否使用“”进行间隔 (3)Switch Controller(转换控制器) 1) 名称：可以给元件一个命名。2) 注释：可以对元件添加备注以标记。3) Switch value：控制器具体赋值的value值字段。当Value为空时，默认执行第1个子节点元素。 第一种：是数值，Switch控制器下的子节点从0开始计数，通过指定子节点所在的数值来确定执行哪个元素。 第二种：是直接指定子元素的名称，比如采样器的Name来进行匹配。当指定的名称不存在时，不执行任何元素。 (4)While Controller(while条件控制器) 1) 名称：可以给元件一个命名。2) 注释：可以对元件添加备注以标记。3) Condition(function or variable):条件（函数或变量）。需要注意的是：条件是评估两次,一次取样前,一次随机取样。里面可填入判断依据的条件，可能的条件值有： 空白：最后一个示例循环失败时退出循环。 最后一个值：最后一个示例循环失败时退出循环。 如果之前的最后一个示例只是循环失败,不进入循环。 否则：退出时(或不输入)循环条件等于字符串“ 假 ” (5)If Controller(IF控制器) 1) 名称：可以给元件一个命名。2) 注释：可以对元件添加备注以标记。3) Condition(default javascript)（条件（默认JavaScript））:使用JavaScript的函数或变量进行评估判断条件为真或假4) interpret condition as variable expression（条件解释为变量表达式）:如果勾选该项，那么变量表达式会进行求值，并与“ture”或“false”进行比较，而无需使用JavaScript5) evaluate for all children（对所有子条件执行）:如果勾选该项，则该controller在没一个子节点执行时执行一次； (6)Module Controller(模块控制器) 1) 名称：可以给元件一个命名。2) 注释：可以对元件添加备注以标记。3) Find target element(寻找目标元素)：寻找测试计划中需要特定测试的元素，模块；也可理解为该控制器可以控制已经封装好的模块元素。 (7)Simple Controller(简单控制器) 1) 名称：可以给元件一个命名。2) 注释：可以对元件添加备注以标记。 三、原件作用域和顺序1、元件的作用域jmeter中共有8类可被执行的元件（test plan和thread group不属于元件）。其中：sampler（取样器）是不与其他元件发生交互的作用的元件，Logic Controller（逻辑控制器）只对其子节点的sampler有效，而其他元件需要与sampler等元件交互。 1）Config Elements（配置元件）：影响其范围内的所有元件2）Pre-porcessors（前置处理器）：在其作用范围内的每一个sampler元件之前执行3）Timer（定时器）：对其作用范围内的每一个sampler有效4）Post-porcessors（后置处理器）：在其作用范围内的每一个sampler元件之后执行5）Assirtions（断言）：对其作用范围内的每一个sampler元件执行后的结果执行校验6）Listener（监听器）：收集其作用范围内的每一个sampler元件的信息并且呈现出来 在jmeter中，元件的作用域是靠test plan的树形结构中元件的父子关系来确定的，其原则如下： 1） sampler（取样器）不与其他元件相互作用，因此不存在作用域问题2） Logic Controller（逻辑控制器）只对其子节点中的sampler和Logic Controller作用3） 除sampler和Logic Controller外的其他元件，如果是某个sampler的子节点，则该元件仅对其父节点作用4） 除sampler和Logic Controller外的其他元件，如果其父节点不是sampler，则其作用域是该元件父节点下的其他所有后带节点（包括子节点，子节点的子节点等） 2、元件的执行顺序在同一作用域范围内，test plan中的元件按照以下顺序执行： 1） Config Elements（配置元件）2） Pre-porcessors（前置处理器）3） Timer（定时器）4） Sampler（取样器）5） Post-porcessors（后置处理器）（除非Sampler得到的返回结果为空）6） Assirtions（断言）（除非Sampler得到的返回结果为空）7） Listener（监听器）（除非Sampler得到的返回结果为空） PS:Pre-porcessors、Post-porcessors和Assirtions等元件仅对Sampler作用，如在它们作用域内没有任何Sampler，则不会被执行；如果在同一作用域范围内有多个同一类型的元件，则这些元件按照它们在test plan中的上下顺序依次执行。 四、jmeter运行模式1、GUI模式GUI打开已有的jmx文件，点击启动按钮运行 。 2、命令行模式(1)依赖：配置jmeter环境变量（windows下为将${jmeterhome}/bin加入Path变量）。如果未加入环境变量，在执行的时候可以直接给出全路径或在${jmeterhome}/bin下执行。 (2)命令：jmeter -n -t &lt;testplan filename&gt; -l &lt;listener filename&gt; -h 帮助 -&gt; 打印出有用的信息并退出 -n 非 GUI 模式 -&gt; 在非 GUI 模式下运行 JMeter -t 测试文件 -&gt; 要运行的 JMeter 测试脚本文件 -l jtl文件 -&gt; 记录结果的文件 -r 远程执行 -&gt; 启动远程服务 -H 代理主机 -&gt; 设置 JMeter 使用的代理主机 -P 代理端口 -&gt; 设置 JMeter 使用的代理主机的端口号 -j 日志文件-&gt;设置JMeter日志文件的名称 (3)实例： 1JMeter -n -t my_test.jmx -l log.jtl -H my.proxy.server -P 8000 (4)执行步骤：jmeter默认去当前目录寻找脚本文件，并把日志记录在当前目录。比如你在 C:\\tools\\apache-jmeter-4.0\\bin 目录下执行以上命令，jmeter会去该目录下寻找test.jmx脚本并把执行结果放在该目录。如果你的脚本在其他目录，而且想要把执行结果放在另外文件夹，可以使用绝对路径告诉jmeter。 持续更新…","categories":[{"name":"接口测试","slug":"接口测试","permalink":"http://pythonfood.github.io/categories/接口测试/"}],"tags":[{"name":"jmeter","slug":"jmeter","permalink":"http://pythonfood.github.io/tags/jmeter/"}]},{"title":"接口测试-postman","slug":"接口测试-postman","date":"2018-04-01T02:00:00.000Z","updated":"2018-05-11T06:58:28.803Z","comments":true,"path":"2018/04/01/接口测试-postman/","link":"","permalink":"http://pythonfood.github.io/2018/04/01/接口测试-postman/","excerpt":"接口测试postman工具使用笔记。","text":"接口测试postman工具使用笔记。 一、适用范围 PC WAP APP 二、环境准备(1)下载安装:https://www.getpostman.com/apps(2)注册账户 三、发送一条http Get请求(1)GET请求输入URL(可以从fiddler复制)(2)GET请求输入Headers(可以从fiddler复制)(3)点击【Send】可以查看返回信息(4)可以对返回值内容增加校验，GET请求的Tests里设置校验方法和校验字段(5)点击【Send】可以查看返回信息和测试结果(6)可以将以上测试步骤，点击【Save】保存到一个集合(7)可以修改请求的测试参数，点击【Save as】保存到同一个集合(8)以此类推形成一个自动化测试的集合(9)点击该集合的【Run】弹出集合运行界面(10)可以修改循环次数【iterations】、延迟【Delay】等参数(11)点击【Run …】运行脚本，查看测试结果 四、发送一条http Post请求(1)POST请求输入URL(可以从fiddler复制)(2)POST请求输入Headers(可以从fiddler复制)(3)POST请求输入Body(可以从fiddler的WebForms里一项一项复制)(4)点击【Send】可以查看返回信息(5)可以对返回值内容增加校验，POST请求的Tests里设置校验方法和校验字段(6)点击【Send】可以查看返回信息和测试结果(7)可以将以上测试步骤，点击【Save】保存到一个集合(8)可以修改请求的测试参数，点击【Save as】保存到同一个集合(9)以此类推形成一个自动化测试的集合(10)点击该集合的【Run】弹出集合运行界面(11)可以修改循环次数【iterations】、延迟【Delay】等参数(12)点击【Run …】运行脚本，查看测试结果 持续更新…","categories":[{"name":"接口测试","slug":"接口测试","permalink":"http://pythonfood.github.io/categories/接口测试/"}],"tags":[{"name":"postman","slug":"postman","permalink":"http://pythonfood.github.io/tags/postman/"}]},{"title":"接口测试-fiddler","slug":"接口测试-fiddler","date":"2018-04-01T01:00:00.000Z","updated":"2018-05-11T06:58:28.803Z","comments":true,"path":"2018/04/01/接口测试-fiddler/","link":"","permalink":"http://pythonfood.github.io/2018/04/01/接口测试-fiddler/","excerpt":"接口测试fiddler工具使用笔记。","text":"接口测试fiddler工具使用笔记。 一、Fiddler 环境准备(1)官网下载安装:https://www.telerik.com/download/fiddler(2)相关设置:【Tools-options-HTTPS-Connections】,设置好之后退出再启动一次。 二、Fiddler 工作原理 三、Fiddler 基本界面(1)Session部分: #:id Result:服务器返回的状态码 Protocol:协议 Host:发送给服务器的host值 URL: (2)Inspectors:1)Request部分: Headers:头部信息 User-Agent:用户的身份 Referer:请求的上一个请求来源 Host:当前的host TextView: WebForms:请求的参数值 HexView:16进制的view Cookies: Raw:最原始的所有的数据 JSON:json形式的请求 XML:xml形式的请求 2)Response部分: TextView:可以看到整个返回的内容 Raw:返回所有的相关的内容 JSON:返回json形式的数据 XML:返回xml形式的数据 WebView:返回的html页面 ImageView:返回的图片内容 (3)Statistics:静态统计 (4)Composer:构造各种各样的请求发送给服务器 (5)AutoResponder:配置假数据模拟后端服务器返回的数据 四、Fiddler 设置断点修改Request(1)通过工具栏设置断点(缺点是会拦截所有的请求) 1)设置断点【Rules-Automatic Breakpoints-Before Request F11】2)清除请求区域3)浏览器进行百度搜索“fiddler”4)fiddler对应的请求，点击【Response部分-Run to Completion】5)fiddler新弹出的请求应该就是需要改参数的请求6)fiddler需要修改参数的请求，点击【Request部分-WebForms】7)修改对应的参数8)点击【Repose部分-Run to Completion】9)回到浏览器查看请求是否修改成功 (2)通过命令设置断点(可以拦截指定站点) 1)session部分底部输入命令bpu www.baidu.com，其他操作同上。2)清除拦截，输入命令bpu 五、Fiddler 设置断点修改Response(1)通过工具栏设置断点(缺点是会拦截所有的请求) 1)点击设置【Rules-Automatic Breakpoints-After Response Alt+F11】2)清除请求区域3)浏览器进行百度搜索“哈哈”4)fiddler修改Response部分的参数5)点击【Response部分-Run to Completion】6)回到浏览器查看请求是否修改成功 (2)通过命令设置断点(可以拦截指定站点) 1)session部分底部输入命令bpafter www.baidu.com，其他操作同上。2)清除拦截，输入命令bpafter (3)AutoResponder设置 1)浏览器进行百度搜索“哈哈”2)fiddler对应的请求,点击【AutoResponder-Add Rule】3)勾选【Enable reles】【Unmatched requests passthrough】【Enable Latency】4)下边规则改为模糊匹配，例如改为：regex:(?inx)^https://www.baidu.com/s?.+5)下边下拉框返回状态码任意可选，例如选择:404_Plain.dat6)点击【Save】按钮7)回到浏览器重新百度搜索任意字符，看是否返回404ps:可以通过下拉列表的“find a file”自定义规则，文件内容自定义。 六、Fiddler 小工具(1)会话的过滤 1)点击【Filters-Use Filters】2)【No Host Filter】下拉框选择【Show only the following Hosts】3)输入要过滤的站点，例如:www.baidu.com4)点击【Actions-Run Filterset now】5)此时session对话框只显示过滤站点请求 (2)会话的比较下载windiff:https://www.grigsoft.com/download-windiff.htm解压后复制到fiddler安装路径即可 1)选中两个要对比的请求2)右键点击【Compare】3)调起windiff工具进行对比 (3)编码小工具 1)点击【Tools-TextWizard】2)上部分输入原始内容，下部分显示编解码内容3)例如：上面输入(https://www.grigsoft.com/download-windiff.htm) ，下面选择URLEecode,即可看到结果。 七、Fiddler Host设置 1)点击【Tools-HOSTS…】2)勾选对话框顶部【Enable Remapping of requests for one host to a differenthost or IP,overing DNS】3)点击会话框底部【Import Windows Hosts File】，导入系统host4)任意修改host,点击【Save】host即生效5)不使用修改的host,只需要取消勾选对话框顶部【Enable Remapping of requests for one host to a differenthost or IP,overing DNS】 八、Fiddler 构造HTTP请求(1)构造Get请求 1)选择一条Get请求，点击【Inspectors-Headers】2)复制Headers的头部信息，粘贴到【Composer-Parsed】的对话框3)首先删除掉复制信息的“Get”类型4)再剪切复制信息的URL，粘贴到上方的输入框，去掉URL尾部的“HTTP/1.1”协议5)点击【Execute】发送请求6)查看session界面请求是否发送ps:可以任意修改URL进行接口测试 (2)构造Post请求 1)选择一条Post请求，点击【Inspectors-Raw】2)复制所有信息，粘贴到【Composer-Parsed】的对话框，请求方式选择【POST】3)首先删除掉复制信息的“Post”类型4)再剪切复制信息的URL，粘贴到上方的输入框，去掉URL尾部的“HTTP/1.1”协议5)剪切空行以下的request body信息，粘贴到下面的输入框6)点击【Execute】发送请求7)查看session界面请求是否发送ps:可以任意修改URL和request body信息进行接口测试 九、Fiddler 抓取手机包(1)配置Fiddler允许监听https(2)配置Fiddler允许远程连接(3)手机端设置代理服务 1)设置【Tools-Options-HTTPS】2)设置【Tools-Options-Connections】3)手机当前连接wifi里设置代理:主机名填写电脑的ip地址，端口填写88884)手机操作应用，请求就会发送到fiddler,其他操作同PC端操作 持续更新…","categories":[{"name":"接口测试","slug":"接口测试","permalink":"http://pythonfood.github.io/categories/接口测试/"}],"tags":[{"name":"fiddler","slug":"fiddler","permalink":"http://pythonfood.github.io/tags/fiddler/"}]},{"title":"selenium常用API","slug":"selenium常用API","date":"2018-03-01T02:00:00.000Z","updated":"2018-05-11T06:55:16.658Z","comments":true,"path":"2018/03/01/selenium常用API/","link":"","permalink":"http://pythonfood.github.io/2018/03/01/selenium常用API/","excerpt":"selenium常用API笔记。","text":"selenium常用API笔记。 一、浏览器操作(1)浏览器最大化 driver.maximize_window() #浏览器最大化 (2)设置浏览器宽、高 driver.set_window_size(480, 800) #设置浏览器宽、高 (3)浏览器后退 driver.back() #浏览器后退 (4)浏览器前进 driver.forward() #浏览器前进 (5)刷新当前页面 driver.refresh() #刷新当前页面 (6)退出浏览器 driver.quit() #退出浏览器 (7)关闭单个窗口 driver.close() #关闭单个窗口 二、元素定位(1)id定位 find_element_by_id(&quot;kw&quot;) #一般唯一 (2)name定位 find_element_by_name(&quot;wd&quot;) #一般唯一 (3)class_name定位 find_element_by_class_name(&quot;bg s_btn&quot;) #不唯一 (4)tag_name定位 find_element_by_tag_name(&quot;input&quot;) #不唯一 (5)link_text定位 find_element_by_link_text(u&quot;这是一条新闻&quot;) #定位文本链接 (6)partial_link_text定位 find_element_by_partial_link_text(&quot;这是一条新&quot;) #定位可以唯一标识这个文本链接的一部分 (7)xpath定位 1)绝对路径定位 find_element_by_xpath(&quot;/html/body/div[2]/form/span/input&quot;) #从根节点开始绝对路径 2)相对路径定位 find_element_by_xpath(&quot;//input[@id=’input’]&quot;) #通过自身的id 属性定位find_element_by_xpath(&quot;//span[@id=’input-container’]/input&quot;) #通过上一级目录的id 属性定位find_element_by_xpath(&quot;//div[@name=’q’]/form/span[2]/input&quot;) #通过上三级目录的name 属性定位find_element_by_xpath(&quot;//div[@id=’hd’ or @name=’q’]/form/span/input&quot;) #通过布尔逻辑运算 属性定位 (8)css_selector定位 find_element_by_css_selector(&quot;#su&quot;) #通过id属性定位find_element_by_css_selector(&quot;.s_ipt&quot;) #通过class属性定位find_element_by_css_selector(&quot;input&quot;) #通过标签名定位find_element_by_css_selector(&quot;span&gt;input&quot;) #通过父子关系定位find_element_by_css_selector(&quot;input[maxlength=&#39;100&#39;]&quot;) #通过属性定位find_element_by_css_selector(&quot;span.bgs_ipt_wr&gt;input.s_ipt&quot;) #组合定位 (9)用By定位需要使用定位方法时，By可以设置定位策略。使用前导入By模块from selenium.webdriver.common.by import By。 find_element(By.ID,&quot;kw&quot;)find_element(By.NAME,&quot;wd&quot;)find_element(By.CLASS_NAME,&quot;s_ipt&quot;)find_element(By.TAG_NAME,&quot;input&quot;)find_element(By.LINK_TEXT,u&quot;新闻&quot;)find_element(By.PARTIAL_LINK_TEXT,u&quot;新&quot;)find_element(By.XPATH,&quot;//*[@class=&#39;bgs_btn&#39;]&quot;)find_element(By.CSS_SELECTOR,&quot;span.bgs_btn_wr&gt;input#su&quot;) 三、元素操作(1)clear() #清除输入框内容 driver.find_element_by_id(&quot;user_name&quot;).clear() (2)send_keys(“xx”) #输入框里输入xx内容 driver.find_element_by_id(&quot;user_name&quot;).send_keys(&quot;username&quot;) (3)click() #单击一个按钮、连接等 driver.find_element_by_id(&quot;dl_an_submit&quot;).click() (4)submit() #提交表单 driver.find_element_by_id(&quot;dl_an_submit&quot;).submit() (5)size #返回元素的尺寸 size=driver.find_element_by_id(&quot;kw&quot;).size #返回百度输入框的宽高 (6)text #获取元素的文本 text=driver.find_element_by_id(&quot;cp&quot;).text #返回百度页面底部备案信息 (7)get_attribute(name) #获得属性值 attribute=driver.find_element_by_id(&quot;kw&quot;).get_attribute(&#39;type&#39;) #返回元素的属性值，可以是id、name、type 或元素拥有的其它任意属性 (8)is_displayed() #检查该元素是否用户可见 result=driver.find_element_by_id(&quot;kw&quot;).is_displayed() #返回元素的结果是否可见，返回结果为True 或False 四、鼠标事件ActionChains用于生成用户的行为，所有的行为都存储在actionchains对象中。通过perform()执行存储的行为。使用前导入ActionChains模块from selenium.webdriver.common.action_chains import ActionChains。 (1)perform() #顺序执行所有ActionChains中存储的行为 ActionChains(driver).context_click(操作对象).perform() #ActionChains方法的书写格式 (2)context_click() #右击  12right =driver.find_element_by_xpath(&quot;xx&quot;) #定位到要右击的元素ActionChains(driver).context_click(right).perform() #对定位到的元素执行鼠标右键操作 (3)double_click() #双击 12double =driver.find_element_by_xpath(&quot;xxx&quot;) #定位到要双击的元素ActionChains(driver).double_click(double).perform() #对定位到的元素执行鼠标双击操作 (4)drag_and_drop() #鼠标拖放 123element = driver.find_element_by_name(&quot;xxx&quot;) #定位元素的原位置target = driver.find_element_by_name(&quot;xxx&quot;) #定位元素要移动到的目标位置ActionChains(driver).drag_and_drop(element, target).perform() #执行元素的移动操作 (5)move_to_element() #鼠标悬停 12above = driver.find_element_by_xpath(&quot;xxx&quot;) #定位到鼠标移动到上面的元素ActionChains(driver).move_to_element(above).perform() #对定位到的元素执行鼠标移动到上面的操作 (6)click_and_hold() #按下鼠标左键 12left=driver.find_element_by_xpath(&quot;xxx&quot;) #定位到鼠标按下左键的元素ActionChains(driver).click_and_hold(left).perform() #对定位到的元素执行鼠标左键按下的操作 五、键盘事件使用前导入keys模块from selenium.webdriver.common.keys import Keys。 (1)send_keys(Keys.BACK_SPACE) #删除键（BackSpace） (2)send_keys(Keys.SPACE) #空格键(Space) (3)send_keys(Keys.TAB) #制表键(Tab) (4)send_keys(Keys.ESCAPE) #回退键（Esc） (5)send_keys(Keys.ENTER) #回车键（Enter） (6)send_keys(Keys.F5) #刷新建（F5） (7)send_keys(Keys.CONTROL,’a’) #全选（Ctrl+A） (8)send_keys(Keys.CONTROL,’c’) #复制（Ctrl+C） (9)send_keys(Keys.CONTROL,’x’) #剪切（Ctrl+X） (10)send_keys(Keys.CONTROL,’v’) #粘贴（Ctrl+V） 六、获取验证信息(1)获得当前页面title，判断页面跳转是否符合预期 title = driver.title (2)获得当前URL，一般用来测试重定向 url = driver.current_url 七、设置等待时间(1)sleep() #休眠等待sleep()方法以秒为单位，假如休眠时间小于 1 秒，可以用小数表示。使用前导入sleep模块from time import sleep。 sleep(0.5) (2)implicitly_wait() #隐式等待隐式等待是通过一定的时长等待页面所元素加载完成。如果超出了设置的时长元素还没有被加载测抛NoSuchElementException异常。implicitly_wait()默认参数的单位为秒。 driver.implicitly_wait(10) #设置智能等待10秒 (3)WebDriverWait() #显式等待显式等待是等待某个条件成立时继续执行，否则在达到最大时长则抛TimeoutException异常。 WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None)，参数解释如下： driver - WebDriver 的驱动程序(Ie, Firefox, Chrome 或远程) timeout - 最长超时时间，默认以秒为单位 poll_frequency - 休眠时间的间隔（步长）时间，默认为 0.5 秒 ignored_exceptions - 超时后的异常信息，默认情况下抛 NoSuchElementException 异常。 使用前导入WebDriverWait模块from selenium.webdriver.support.ui import WebDriverWait。 WebDriverWai()一般由 unit()或 until_not()方法配合使用，下面是 unit()和 until_not()方法的说明：1)until(method, message=’’)调用该方法提供的驱动程序作为一个参数，直到返回值不为False。 element = WebDriverWait(driver, 10).until(lambda x: x.find_element_by_id(“someId”)) 2)until_not(method, message=’’)调用该方法提供的驱动程序作为一个参数，直到返回值为 False。 is_disappeared = WebDriverWait(driver, 30, 1, (ElementNotVisibleException)).until_not(lambda x: x.find_element_by_id(“someId”).is_displayed()) 八、定位一组对象(1)find_elements 用于获取一组元素: find_elements_by_id(‘xx’)find_elements_by_name(‘xx’)find_elements_by_class_name(‘xx’)find_elements_by_tag_name(‘xx’)find_elements_by_link_text(‘xx’)find_elements_by_partial_link_text(‘xx’)find_elements_by_xpath(‘xx’)find_elements_by_css_selector(‘xx’) (2)可以使用for… in …对这一组元素进行遍历: 12for checkbox in checkboxes: checkbox.click() (3)也可以使用pop（）方法获得这一组元素中的第几个，然后再对该元素进行操作： find_elements_by_id(‘xx’).pop().click() 1234pop（）或pop（-1）#默认获取一组元素中的最后一个pop(0) #默认获取一组元素的第一个元素pop(1) #默认获取一组元素的第二个元素...... #以此类推 九、层级定位经常会有这样的需求：页面上有很多个属性基本相同的元素 ，现在需要具体定位到其中的一个。由于属性基本相当，所以在定位的时候会有些麻烦，这时候就需要用到层级定位。先定位父元素，然后再通过父元素定位子孙元素： 1234#点击 Link1 链接（弹出下拉列表）driver.find_element_by_link_text(&apos;Link1&apos;).click() #在父亲元件下找到 link 为 Action 的子元素menu=driver.find_element_by_id(&apos;dropdown1&apos;).find_element_by_link_text(&apos;Another action&apos;) 十、表单切换在web应用中经常会出现frame/iframe 表单内嵌套的应用，WebDriver只能在一个页面上进行元素识别定位，对于frame/iframe表单内嵌页面上的元素无法直接定位。这时需要通过switch_to.frame()方法将当前定位的主体切换为frame/iframe表单的内嵌页面中。 (1)switch_to_frame()默认可以直接取表单的id或name属性进行切换： driver.switch_to_frame(&quot;if&quot;) #id = “if”driver.switch_to_frame(&quot;nf&quot;) #name = “nf” (2)如果 iframe 没有可用的 id 和 name 可以通过下面的方式进行定位： 1234#先通过xpth定位到iframe xf = driver.find_element_by_xpath(&apos;//*[@class=&quot;if&quot;]&apos;)#再将定位对象传给switch_to_frame()方法 driver.switch_to_frame(xf) (3)如果完成了在当前表单上的操作，跳出当前表单： driver.switch_to.parent_content() #返回到父级表单driver.switch_to.default_conent() #返回到主文档页面 十一、多窗口切换 current_window_handle #获得当前窗口句柄。 window_handles #返回所有窗口的句柄到当前对话。 switch_to.window(窗口句柄) #切换到对应的窗口。 1234567nowhandle=driver.current_window_handle #获得当前窗口句柄。driver.find_element_by_link_text(u&quot;发表话题&quot;).click()time.sleep(3)allhandles=driver.window_handles #返回所有窗口的句柄到当前对话。for handle in allhandles: if(handle!=nowhandle): driver.switch_to.window(handle) #切换到对应的窗口。 十二、警告框处理处理javascript所生成的alert、confirm、prompt，可以使用switch_to_alert()方法定位到alert/confirm/prompt，然后使用text/accept/dismiss/send_keys等方法进行操作： text #返回 alert/confirm/prompt 中的文字信息。 accept #点击确认按钮。 dismiss #点击取消按钮，如果有的话。 send_keys #输入值，这个 alert\\confirm 没有对话框就不能用了，不然会报错。 driver.switch_to_alert().accept() 十三、上传文件(1)查找到input标签，通过send_keys)传入本地文件路径从而模拟上传功能: driver.find_element_by_name(&quot;file&quot;).send_keys(&#39;D:\\\\upload_file.txt&#39;) #查找到input标签，然后send进去 (2)使用AutoIt识别flash控件和windows控件实现自动上传文件 1)下载安装，官方网站：https://www.autoitscript.com/site/2)配置编辑AutoIt。3)os.system(&quot;D:\\\\upfile.exe&quot;) #通过系统调用upfile.exe上传程序 十四、下载文件(1)以FireFox为例，为了让FireFox浏览器能实现文件的载，我们需要通过FirefoxProfile()对其参数做一个设置: browser.download.folderList #设置成0代表下载到浏览器默认下载路径；设置成2则可以保存到指定目录。 browser.download.manager.showWhenStarting #是否显示开始，Ture为显示，Flase为不显示。 browser.download.dir #用于指定你所下载文件的目录。os.getcwd()该函数不需要传递参数，用于返回当前的目录。 browser.helperApps.neverAsk.saveToDisk #指定要下载页面的Content-type值，“application/octet-stream”为文件的类型。HTTP Content-type常用对照表：http://tool.oschina.net/commons (2)这些参数的设置可以通过在Firefox浏览器地址栏输入：about:config 进行设置，如图： (3)浏览器设置代码示例： 12345678910111213#coding=utf-8 from selenium import webdriver import osfp = webdriver.FirefoxProfile()fp.set_preference(&quot;browser.download.folderList&quot;,2) fp.set_preference(&quot;browser.download.manager.showWhenStarting&quot;,False) fp.set_preference(&quot;browser.download.dir&quot;, os.getcwd()) fp.set_preference(&quot;browser.helperApps.neverAsk.saveToDisk&quot;, &quot;application/octet-stream&quot;)driver = webdriver.Firefox(firefox_profile=fp) driver.get(&quot;http://pypi.Python.org/pypi/selenium&quot;) driver.find_element_by_partial_link_text(&quot;selenium-2&quot;).click() 十五、操作Cookiewebdriver操作cookie的方法有： get_cookies() #获得所有cookie信息  get_cookie(name) #返回有特定name值有cookie信息  add_cookie(cookie_dict) #添加cookie，必须有name和value值  delete_cookie(name) #删除特定(部分)的cookie信息  delete_all_cookies() #删除所有cookie信息 (1)先通过get_cookies()来获取当前浏览器的cookie信息。通过打印结果可以看出，cookie 是以字典的形式进行存放的，知道了cookie的存放形式，那么我们就可以按照这种形式向浏览器中写入cookie信息。 123driver.get(&quot;http://www.youdao.com&quot;)cookie= driver.get_cookies() # 获得cookie信息 print cookie #将获得cookie的信息打印 (2)再进行cookie的添加、删除等操作。 12driver.get(&quot;http://www.youdao.com&quot;)driver.add_cookie(&#123;&apos;name&apos;:&apos;key-aaaaaaa&apos;, &apos;value&apos;:&apos;value-bbbbbb&apos;&#125;) #向cookie的name 和value添加会话信息。 十六、调用javascript当webdriver遇到没法完成的操作时，可以考虑调用JavaScript来完成。webdriver提供execute_script()方法用来调用js代码： 123#修改元素的属性js = &apos;document.querySelectorAll(&quot;select&quot;)[0].style.display=&quot;block&quot;;&apos;driver.execute_script(js) 十七、控制浏览器滚动条(1)上下滚动：document.body.scrollTop #网页被卷去的高。置顶设置：scrollTop为0；置底设置：scrollTop大于窗口的高度像素。 12345678#将页面滚动条拖到底部js=&quot;var q=document.documentElement.scrollTop=10000&quot;driver.execute_script(js)time.sleep(3)#将滚动条移动到页面的顶部js1=&quot;var q=document.documentElement.scrollTop=0&quot;driver.execute_script(js1)time.sleep(3) (2)左右滚动：window.scrollTo(左边距,上边距) #指定左右滚动的坐标即可 12js=&quot; window.scrollTo(200,1000);&quot; driver.execute_script(js) 十八、窗口截图Webdriver提供了截图函数get_screenshot_as_file()来截取当前窗口: 123456try: driver.find_element_by_id(&apos;kw_error&apos;).send_key(&apos;selenium&apos;) driver.find_element_by_id(&apos;su&apos;).click() except: driver.get_screenshot_as_file(&quot;D:\\\\baidu_error.jpg&quot;) #截图，保存到指定路径 driver.quit() 十九、获取对象的属性值有时候我们定位页面上的元素发现常用的id、name等属性是相同的。这个时候我们只能通过常规的定位方法定位出一组元素，然后观察通过元素的属性可以定位出单个元素。可使用.get_attribute()方法: 123456# 选择页面上所有的tag name为input的元素inputs = driver.find_elements_by_tag_name(&apos;input&apos;)#然后循环遍历出属性data-node值为594434493的元素，单击勾选for input in inputs: if input.get_attribute(&apos;data-node&apos;) == &apos;594434493&apos;: input.click() 二十、验证码处理(1)去掉验证码。(2)设置万能码。(3)验证码识别技术例如可以通过Python-tesseract来识别图片验证码,能够读取任何常规的图片文件(JPG,GIF,PNG,TIFF 等)。不过，目前市面上的验证码识别技术识别率都不是100% 。(4)记录cookie通过向浏览器中添加cookie可以绕过登录的验证码,这种方式最大的问题是如何从浏览器的Cookie中找到用户名和密码对应的key值，并传传输入对应的登录信息。如果网站登录时根本不将用户名和密码写Cookie，这会存在一定的安全风险。那么这种方式就不起作用了。 12345678#访问xx网站 driver.get(&quot;http://www.xx.cn&quot;)#将用户名密码写入浏览器cookie driver.add_cookie(&#123;&apos;name&apos;:&apos;Login_UserNumber&apos;, &apos;value&apos;:&apos;username&apos;&#125;) driver.add_cookie(&#123;&apos;name&apos;:&apos;Login_Passwd&apos;, &apos;value&apos;:&apos;password&apos;&#125;)#再次访问xx网站，将会自动登录 driver.get(&quot;http://www.xx.cn/&quot;) time.sleep(3) (5)内部提供一个接口获得验证码，然后通过js代码把获取的验证码填写进去： 123#自动获取验证码并填写js=&quot;$.getJSON(&apos;http://xxx.xxx.com/util/getCode.jsonp?callback=?&apos;,function(data)&#123;$(&apos;.imgcode&apos;).val(data.code);&#125;)&quot;driver.execute_script(js) 持续更新…","categories":[{"name":"web测试","slug":"web测试","permalink":"http://pythonfood.github.io/categories/web测试/"}],"tags":[{"name":"selenium","slug":"selenium","permalink":"http://pythonfood.github.io/tags/selenium/"}]},{"title":"selenium安装-windows","slug":"selenium安装-windows","date":"2018-03-01T01:00:00.000Z","updated":"2018-05-11T06:55:16.648Z","comments":true,"path":"2018/03/01/selenium安装-windows/","link":"","permalink":"http://pythonfood.github.io/2018/03/01/selenium安装-windows/","excerpt":"selenium环境搭建的简单步骤：安装Python——安装pip——安装selenium——安装浏览器驱动。","text":"selenium环境搭建的简单步骤：安装Python——安装pip——安装selenium——安装浏览器驱动。 一、安装Python二、安装pip 方法1：自动安装 在第1步安装python时，已经安装了pip。 方法2：手动安装 (1)下载pip压缩包：https://pypi.python.org/pypi/pip#downloads(2)解压后cmd进入解压目录，执行python setup.py install进行安装。 三、安装selenium 方法1：命令行安装 进入cmd输入命令’pip install selenium’。 方法2：下载whl包安装 (1)下载selenium安装包：https://pypi.python.org/pypi/selenium 或 https://www.seleniumhq.org/download/(2)下载完成后，进入cmd输入命令pip install，再直接将文件拖入cmd窗口，回车即可安装。 四、安装浏览器驱动 (1)下载浏览器驱动 不同浏览器需下载不同驱动，不同版本浏览器对应不同版本驱动。这里只给出chrome和firefox的驱动下载地址：1)chrome：http://npm.taobao.org/mirrors/chromedriver 或 http://chromedriver.storage.googleapis.com/index.html2)firefox：https://github.com/mozilla/geckodriver/releases (2)安装浏览器驱动 下载完驱动后解压，将驱动放置在可执行路径下。这里给出三种路径：1)将浏览器驱动放到python的Path路径下。2)将浏览器驱动放到浏览器的Path路径下。3)自定义路径，新建driver文件夹，将驱动放在driver文件下，最后将该路径添加到环境变量中。 五、验证环境（小示例） (1)创建python文件selenium_python.py，内容如下： 123from selenium import webdriverdriver = webdriver.Chrome()driver.get(&apos;http://www.baidu.com/&apos;) (2)cmd执行命令python selenium_python.py。(3)脚本自动执行，结果如下： 持续更新…","categories":[{"name":"web测试","slug":"web测试","permalink":"http://pythonfood.github.io/categories/web测试/"}],"tags":[{"name":"selenium","slug":"selenium","permalink":"http://pythonfood.github.io/tags/selenium/"}]},{"title":"appium键值表","slug":"appium键值表","date":"2018-02-01T04:00:00.000Z","updated":"2018-05-11T06:54:00.686Z","comments":true,"path":"2018/02/01/appium键值表/","link":"","permalink":"http://pythonfood.github.io/2018/02/01/appium键值表/","excerpt":"appium键值表查询。","text":"appium键值表查询。 一、电话键 键名 描述 键值 KEYCODE_CALL 拨号键 5 KEYCODE_ENDCALL 挂机键 6 KEYCODE_HOME 按键Home 3 KEYCODE_MENU 菜单键 82 KEYCODE_BACK 返回键 4 KEYCODE_SEARCH 搜索键 84 KEYCODE_CAMERA 拍照键 27 KEYCODE_FOCUS 拍照对焦键 80 KEYCODE_POWER 电源键 26 KEYCODE_NOTIFICATION 通知键 83 KEYCODE_MUTE 话筒静音键 91 KEYCODE_VOLUME_MUTE 扬声器静音键 164 KEYCODE_VOLUME_UP 音量增加键 24 KEYCODE_VOLUME_DOWN 音量减小键 25 二、控制键 键名 描述 键值 KEYCODE_ENTER 回车键 66 KEYCODE_ESCAPE ESC键 111 KEYCODE_DPAD_CENTER 导航键 确定键 23 KEYCODE_DPAD_UP 导航键 向上 19 KEYCODE_DPAD_DOWN 导航键 向下 20 KEYCODE_DPAD_LEFT 导航键 向左 21 KEYCODE_DPAD_RIGHT 导航键 向右 22 KEYCODE_MOVE_HOME 光标移动到开始键 122 KEYCODE_MOVE_END 光标移动到末尾键 123 KEYCODE_PAGE_UP 向上翻页键 92 KEYCODE_PAGE_DOWN 向下翻页键 93 KEYCODE_DEL 退格键 67 KEYCODE_FORWARD_DEL 删除键 112 KEYCODE_INSERT 插入键 124 KEYCODE_TAB Tab键 61 KEYCODE_NUM_LOCK 小键盘锁 143 KEYCODE_CAPS_LOCK 大写锁定键 115 KEYCODE_BREAK Break/Pause键 121 KEYCODE_SCROLL_LOCK 滚动锁定键 116 KEYCODE_ZOOM_IN 放大键 168 KEYCODE_ZOOM_OUT 缩小键 169 三、组合键 键名 描述 KEYCODE_ALT_LEFT Alt+Left KEYCODE_ALT_RIGHT Alt+Right KEYCODE_CTRL_LEFT Control+Left KEYCODE_CTRL_RIGHT Control+Right KEYCODE_SHIFT_LEFT Shift+Left KEYCODE_SHIFT_RIGHT Shift+Right 四、基本键 键名 描述 键值 KEYCODE_0 按键’0’ 7 KEYCODE_1 按键’1’ 8 KEYCODE_2 按键’2’ 9 KEYCODE_3 按键’3’ 10 KEYCODE_4 按键’4’ 11 KEYCODE_5 按键’5’ 12 KEYCODE_6 按键’6’ 13 KEYCODE_7 按键’7’ 14 KEYCODE_8 按键’8’ 15 KEYCODE_9 按键’9’ 16 KEYCODE_A 按键’A’ 29 KEYCODE_B 按键’B’ 30 KEYCODE_C 按键’C’ 31 KEYCODE_D 按键’D’ 32 KEYCODE_E 按键’E’ 33 KEYCODE_F 按键’F’ 34 KEYCODE_G 按键’G’ 35 KEYCODE_H 按键’H’ 36 KEYCODE_I 按键’I’ 37 KEYCODE_J 按键’J’ 38 KEYCODE_K 按键’K’ 39 KEYCODE_L 按键’L’ 40 KEYCODE_M 按键’M’ 41 KEYCODE_N 按键’N’ 42 KEYCODE_O 按键’O’ 43 KEYCODE_P 按键’P’ 44 KEYCODE_Q 按键’Q’ 45 KEYCODE_R 按键’R’ 46 KEYCODE_S 按键’S’ 47 KEYCODE_T 按键’T’ 48 KEYCODE_U 按键’U’ 49 KEYCODE_V 按键’V’ 50 KEYCODE_W 按键’W’ 51 KEYCODE_X 按键’X’ 52 KEYCODE_Y 按键’Y’ 53 KEYCODE_Z 按键’Z’ 54 五、符号键 键名 描述 KEYCODE_PLUS 按键’+’ KEYCODE_MINUS 按键’-‘ KEYCODE_STAR 按键’*’ KEYCODE_SLASH 按键’/‘ KEYCODE_EQUALS 按键’=’ KEYCODE_AT 按键’@’ KEYCODE_POUND 按键’#’ KEYCODE_APOSTROPHE 按键’’’ (单引号) KEYCODE_BACKSLASH 按键’\\’ KEYCODE_COMMA 按键’,’ KEYCODE_PERIOD 按键’.’ KEYCODE_LEFT_BRACKET 按键’[‘ KEYCODE_RIGHT_BRACKET 按键’]’ KEYCODE_SEMICOLON 按键’;’ KEYCODE_GRAVE 按键’`’ KEYCODE_SPACE 空格键 六、小键盘 键名 描述 KEYCODE_NUMPAD_0 小键盘按键’0’ KEYCODE_NUMPAD_1 小键盘按键’1’ KEYCODE_NUMPAD_2 小键盘按键’2’ KEYCODE_NUMPAD_3 小键盘按键’3’ KEYCODE_NUMPAD_4 小键盘按键’4’ KEYCODE_NUMPAD_5 小键盘按键’5’ KEYCODE_NUMPAD_6 小键盘按键’6’ KEYCODE_NUMPAD_7 小键盘按键’7’ KEYCODE_NUMPAD_8 小键盘按键’8’ KEYCODE_NUMPAD_9 小键盘按键’9’ KEYCODE_NUMPAD_ADD 小键盘按键’+’ KEYCODE_NUMPAD_SUBTRACT 小键盘按键’-‘ KEYCODE_NUMPAD_MULTIPLY 小键盘按键’*’ KEYCODE_NUMPAD_DIVIDE 小键盘按键’/‘ KEYCODE_NUMPAD_EQUALS 小键盘按键’=’ KEYCODE_NUMPAD_COMMA 小键盘按键’,’ KEYCODE_NUMPAD_DOT 小键盘按键’.’ KEYCODE_NUMPAD_LEFT_PAREN 小键盘按键’(‘ KEYCODE_NUMPAD_RIGHT_PAREN 小键盘按键’)’ KEYCODE_NUMPAD_ENTER 小键盘按键回车 七、功能键 键名 描述 KEYCODE_F1 按键F1 KEYCODE_F2 按键F2 KEYCODE_F3 按键F3 KEYCODE_F4 按键F4 KEYCODE_F5 按键F5 KEYCODE_F6 按键F6 KEYCODE_F7 按键F7 KEYCODE_F8 按键F8 KEYCODE_F9 按键F9 KEYCODE_F10 按键F10 KEYCODE_F11 按键F11 KEYCODE_F12 按键F12 八、多媒体键 键名 描述 KEYCODE_MEDIA_PLAY 播放 KEYCODE_MEDIA_STOP 停止 KEYCODE_MEDIA_PAUSE 暂停 KEYCODE_MEDIA_PLAY_PAUSE 播放/暂停 KEYCODE_MEDIA_FAST_FORWARD 快进 KEYCODE_MEDIA_REWIND 快退 KEYCODE_MEDIA_NEXT 下一首 KEYCODE_MEDIA_PREVIOUS 上一首 KEYCODE_MEDIA_CLOSE 关闭 KEYCODE_MEDIA_EJECT 弹出 KEYCODE_MEDIA_RECORD 录音 九、手柄按键 键名 描述 KEYCODE_BUTTON_1 通用游戏手柄按钮 #1 KEYCODE_BUTTON_2 通用游戏手柄按钮 #2 KEYCODE_BUTTON_3 通用游戏手柄按钮 #3 KEYCODE_BUTTON_4 通用游戏手柄按钮 #4 KEYCODE_BUTTON_5 通用游戏手柄按钮 #5 KEYCODE_BUTTON_6 通用游戏手柄按钮 #6 KEYCODE_BUTTON_7 通用游戏手柄按钮 #7 KEYCODE_BUTTON_8 通用游戏手柄按钮 #8 KEYCODE_BUTTON_9 通用游戏手柄按钮 #9 KEYCODE_BUTTON_10 通用游戏手柄按钮 #10 KEYCODE_BUTTON_11 通用游戏手柄按钮 #11 KEYCODE_BUTTON_12 通用游戏手柄按钮 #12 KEYCODE_BUTTON_13 通用游戏手柄按钮 #13 KEYCODE_BUTTON_14 通用游戏手柄按钮 #14 KEYCODE_BUTTON_15 通用游戏手柄按钮 #15 KEYCODE_BUTTON_16 通用游戏手柄按钮 #16 KEYCODE_BUTTON_A 游戏手柄按钮 A KEYCODE_BUTTON_B 游戏手柄按钮 B KEYCODE_BUTTON_C 游戏手柄按钮 C KEYCODE_BUTTON_X 游戏手柄按钮 X KEYCODE_BUTTON_Y 游戏手柄按钮 Y KEYCODE_BUTTON_Z 游戏手柄按钮 Z KEYCODE_BUTTON_L1 游戏手柄按钮 L1 KEYCODE_BUTTON_L2 游戏手柄按钮 L2 KEYCODE_BUTTON_R1 游戏手柄按钮 R1 KEYCODE_BUTTON_R2 游戏手柄按钮 R2 KEYCODE_BUTTON_MODE 游戏手柄按钮 Mode KEYCODE_BUTTON_SELECT 游戏手柄按钮 Select KEYCODE_BUTTON_START 游戏手柄按钮 Start KEYCODE_BUTTON_THUMBL Left Thumb Button KEYCODE_BUTTON_THUMBR Right Thumb Button 持续更新…","categories":[{"name":"app测试","slug":"app测试","permalink":"http://pythonfood.github.io/categories/app测试/"}],"tags":[{"name":"appium","slug":"appium","permalink":"http://pythonfood.github.io/tags/appium/"}]},{"title":"appium常用API","slug":"appium常用API","date":"2018-02-01T03:00:00.000Z","updated":"2018-05-11T06:54:01.436Z","comments":true,"path":"2018/02/01/appium常用API/","link":"","permalink":"http://pythonfood.github.io/2018/02/01/appium常用API/","excerpt":"appium常用API笔记。","text":"appium常用API笔记。 一、元素定位(1)id定位find_element_by_id(“resrouce-id”) driver.find_element_by_id(&#39;com.android.calculator2:id/digit8&#39;) (2)name定位find_element_by_name(“text”) driver.find_element_by_name(&quot;昵称&quot;) (3)class_name定位find_element_by_class_name(“class”) driver.find_element_by_class_name(&quot;android.widget.Button&quot;) (4)accessibility_id定位find_element_by_accessibility_id(“content-desc”) driver.find_element_by_accessibility_id(&quot;delete&quot;) (5)xpath定位find_element_by_xpath(“xpath”) driver.find_element_by_xpath(&quot;//android.widget.Button[@text=&#39;8&#39;]&quot;) (6)uiautomator定位find_element_by_android_uiautomator(uia_string)uiautomator可以针对resourceid、Text、description、class、package、index、instance等进行定位。 1)resourceId方式 driver.find_element_by_android_uiautomator(&#39;new UiSelector().resourceId(&quot;%s&quot;)&#39;) 2)text方式 driver.find_element_by_android_uiautomator(&#39;new UiSelector().text(&quot;%s&quot;)&#39;) 3)description方式 driver.find_element_by_android_uiautomator(&#39;new UiSelector().description(&quot;%s&quot;)&#39;) 4)className方式 driver.find_element_by_android_uiautomator(&#39;new UiSelector().className(&quot;%s&quot;)&#39;) 5)packageName方式 driver.find_element_by_android_uiautomator(&#39;new UiSelector().packageName(&quot;%s&quot;)&#39;) 6)index方式 driver.find_element_by_android_uiautomator(&#39;new UiSelector().index(&quot;%s&quot;)&#39;) 7)instance方式 driver.find_element_by_android_uiautomator(&#39;new UiSelector().instance(&quot;%s&quot;)&#39;) 8)className+index方式 driver.find_element_by_android_uiautomator(&#39;new UiSelector().className(&quot;%s&quot;).childSelector(new UiSelector().index(&quot;%d&quot;))&#39;) 9)伪xpath方法定位 a.通过同级元素定位同级元素 driver.find_element_by_android_uiautomator(‘new UiSelector().text(&quot;Custom View&quot;).fromParent(new UiSelector().text(&quot;Accessibility Service&quot;))‘).click() b.通过父级元素定位子集元素 driver.find_element_by_android_uiautomator(‘new UiSelector().className(&quot;android.widget.ListView&quot;).childSelector(new UiSelector().text(&quot;Custom View&quot;))‘).click() (7)用By定位 By.ID #相当于by_id By.NAME #相当于by_name By.CLASS_NAME #相当于by_class_name By.ACCESSIBILITY_ID #相当于by_accessibility_id By.XPATH #相当于by_xpath find_element(By.ID,&quot;com.android.calculator2:id/digit8&quot;) 二、应用操作(1)安装应用install_app() #安装应用到设备中去。需要apk包的路径。 driver.install_app(&quot;path/to/my.apk&quot;)driver.install_app(&quot;D:\\\\android\\\\apk\\\\ContactManager.apk&quot;) (2)卸载应用remove_app() #从设备中删除一个应用。 driver.remove_app(&quot;com.example.android.apis&quot;) (3)关闭应用close_app() #关闭打开的应用，默认关闭当前打开的应用，所以不需要入参。相当于按home键将应用置于后台，可以通过launch_app()再次启动。 driver.close_app() (4)启动应用launch_app() #该方法需要配合close_app()使用的。 driver.launch_app() (5)检查应用是否安装is_app_installed() #检查应用是否已经安装。需要传参应用包的名字。返回结果为Ture或False。 driver.is_app_installed(&#39;com.example.android.apis&#39;) (6)将应用置于后台background_app() #将当前活跃的应用程序发送到后台。这个方法需要入参，需要指定应用置于后台的时长。 driver.background_app(2) (7)应用重置reset_app() #重置当前被测程序到出始化状态。该方法不需要入参。 driver.reset_app() (8)启动activitystart_activity() #启动一个app或者在当前app中打开一个新的activity，仅适用于android。 driver.start_activity(&#39;com.example.android.apis&#39;, &#39;.Foo&#39;) 三、键盘操作ps：appium键值表(1)send_keys()方法 driver.find_element_by_name(“Name”).send_keys(&quot;jack&quot;) (2)keyevent()方法 `driver.keyevent(4) #点击Android的返回键` (3)press_keycode()方法 driver.press_keycode(3) #点击Android的HOME键 (4)long_press_keycode()方法 driver.long_press_keycode(4) #长按Android的返回键 (5)隐藏键盘 driver.hide_keyboard() #android不需要参数，ios需要传参key_name 四、TouchAction操作使用前导入TouchAction模块from appium.webdriver.common.touch_action import TouchAction(1)点击tap(self,el=None,x=None,y=None,count=1)(2)短按press(self, el=None, x=None, y=None)(3)长按long_press(self, el=None, x=None, y=None, duration=1000(ms))(4)释放release(self)(5)移动到move_to(self,el=None,x=None,y=None)(6)等待wait(self,ms=0)(7)执行perform(self) 12345#关于perform官网给的伪代码中讲TouchAction().tap(el).perform()#与driver.perform(TouchAction().tap(el))#效果一致 (8)多点触控MultiTouch() #多点触控,它只提供了两个方法:一个add()、一个执行perform()。使用前导入MultiAction模块from appium.webdriver.common.multi_action import MultiAction 123456from appium.webdriver.common.touch_action import TouchActionfrom appium.webdriver.common.multi_action import MultiActionaction0 = TouchAction().tap(el1)action1 = TouchAction().tap(el2)MultiTouch().add(action0).add(action1).perform() 五、上下文操作(1)当前会话中的所有上下文，使用后可以识别H5页面的控件driver.contexts 获取的是一个list列表： NATIVE_APP:这个就是native，也就是原生的 WEBVIEW_com.xxxx :这个就是webview (2)当前会话的当前上下文driver.current_context(3)切换上下文driver.switch_to.context(&quot;content_str&quot;) 1)切换到webview 方法一：driver.switch_to.context(&#39;webview的context&#39;)方法二：driver.switch_to.context(contexts[1]) #从contexts列表里取第二个参数 2)切回native 方法一：driver.switch_to.context(&quot;NATIVE_APP&quot;) #这个NATIVE_APP是固定的参数方法二：driver.switch_to.context(contexts[0]) #从contexts列表里取第一个参数 (4)应用的字符串driver.app_strings 六、屏幕操作(1)点击1)click() driver.find_element_by_id(&quot;com.wuba.zhuanzhuan:id/ae8&quot;).click() 2)driver.tap() driver.tap([(216,1776)],200) (2)滑动driver.swipe(x1, y1, x2, y2,duration) #从坐标(x1,x2)滑动到坐标(x2,y2)，duration非必填项，滑动时间 一个向上下左右滑动的方法封装：1234567891011121314151617181920212223242526272829303132333435363738#获得屏幕大小宽和高def getSize(driver): x = driver.get_window_size()[&apos;width&apos;] y = driver.get_window_size()[&apos;height&apos;] return (x, y)#屏幕向上滑动def swipeUp(driver,t=1000): l = getSize(driver) x1 = int(l[0] * 0.5) #x坐标 y1 = int(l[1] * 0.75) #起始y坐标 y2 = int(l[1] * 0.25) #终点y坐标 driver.swipe(x1, y1, x1, y2,t)#屏幕向下滑动def swipeDown(driver,t=1000): l = getSize(driver) x1 = int(l[0] * 0.5) #x坐标 y1 = int(l[1] * 0.25) #起始y坐标 y2 = int(l[1] * 0.75) #终点y坐标 driver.swipe(x1, y1, x1, y2,t)#屏幕向左滑动def swipLeft(driver,t): l=getSize(driver) x1=int(l[0]*0.75) y1=int(l[1]*0.5) x2=int(l[0]*0.05) driver.swipe(x1,y1,x2,y1,t)#屏幕向右滑动def swipRight(driver,t=1000): l=getSize(driver) x1=int(l[0]*0.05) y1=int(l[1]*0.5) x2=int(l[0]*0.75) driver.swipe(x1,y1,x2,y1,t) #调用向下滑动的方法swipeDown(driver) (3)滚动driver.scroll(origin_el,destination_el) (4)拖动driver.drag_and_drop(el1,el2) (5)快速滑动driver.flick(start_x, start_y, end_x, end_y) (6)缩小driver.pinch(element) (7)放大driver.zoom(element) (8)锁屏driver.lock() #android不需要传参，ios可以传参锁屏多少秒 (9)截屏get_screenshot_as_file() driver.get_screenshot_as_file(&#39;../screenshot/foo.png&#39;)#保存的图片路径和名称 (10)屏幕旋转rotate(ScreenOrientation orientation) landscape：限制界面为横屏，旋转屏幕也不会改变当前状态。 portrait：限制界面为竖屏，旋转屏幕也不会改变当前状态。 sensor:根据传感器定位方向，旋转手机90度，180,270,360，界面都会发生变化。 sensorLandscape：（横屏的旋转，不会出现竖屏的现象）根据传感器定位方向，旋转手机180度界面旋转。一般横屏游戏会是这个属性。 sensorPortrait：（竖屏的旋转，不会出现横屏的现象）根据传感器定位方向，旋转手机180度界面会旋转。 unspecified：由系统选择显示方向，不同的设备可能会有所不同。（旋转手机，界面会跟着旋转） user: 用户当前的首选方向。 nosensor：不由传感器确定方向。旋转设备的时候，界面不会跟着旋转。初始界面方向由系统提供。 (11)获取当前屏幕的方向get_orientation() 七、网络设置(1)返回网络类型数值driver.network_connection (2)网络设置driver.setNetworkConnection(bitmask掩码)使用前导入ConnectionType模块from appium.webdriver.connectiontype import ConnectionType driver.set_network_connection(2)driver.set_network_connection(ConnectionType.WIFI_ONLY) 网络的bitmask掩码如下： 值 (别名) 数据连接 Wifi连接 飞行模式 0 (NO_CONNECTION) 0 0 0 1 (AIRPLANE_MODE) 0 0 1 2 (WIFI_ONLY) 0 1 0 4 (DATA_ONLY) 1 0 0 6 (ALL_NETWORK_ON) 1 1 0 八、位置设置(1)打开定位设置driver.toggle_location_services() (2)设置设备的经纬度driver.set_location(latitude纬度，longitude经度，altitude海拔高度) 九、文件操作(1)把本地文件push到设备上。push_file() 123data = &quot;some data for the file&quot;path = &quot;/data/local/tmp/file.txt&quot;driver.push_file(path, data.encode(&apos;base64&apos;)) (2)将设备上的文件pull到本地硬盘上pull_file() driver.pull_file(&#39;Library/AddressBook/AddressBook.sqlitedb&#39;) (3)将设备上的文件夹pull到本地硬盘上，一般远程文件为/data/local/tmp下的文件。pull_folder() 十、activity操作(1)启动activitydriver.start_activity() (2)获取当前activitydriver.current_activity 12activity = self.driver.current_activity print(u&quot;当前的activity是:&quot;, activity) (3)等待activity启动直到x秒超时，每隔y秒扫描一次driver.wait_activity(activity, x, y) (4)检查是否存在某个activity(未找到则返回异常）driver.find_element_by_id(activity) ps:查看包名和activity的方法： 123456# 1)启动应用，输入命令，查看adb shell dumpsys window | findstr mCurrentFocus # 2)启动应用，输入命令，查看adb shell dumpsys activity activities# 3)有安装包，cmd输入命令，查看aapt dump badging &lt;file_path.apk&gt; 十一、其他操作(1)打开通知栏driver.open_notifications() (2)摇一摇手机driver.shake() (3)获取控件各种属性get_attribute()可获取的字符串类型： name(返回content-desc或text) text(返回text) className(返回class，只有API=&gt;18才能支持) resourceId(返回resource-id，只有API=&gt;18才能支持) …uiautomator获得的属性 driver.find_element_by_id().get_attribute(name) (4)返回元素是否选择element.is_slected() (5)返回元素是否可用element.is_enabled() (6)返回元素的文本值element.text() (7)清除输入的内容element.clear() (8)获取元素的大小driver.element.size new_size[“height”] = size[“height”] new_size[“width”] = size[“width”] (9)获取元素左上角的坐标driver.element.location 1234#返回element的x坐标, int类型driver.element.location.get(&apos;x&apos;)#返回element的y坐标, int类型driver.element.location.get(&apos;y&apos;) 十二、unittest断言在unittest单元测试框架中，TestCase类提供了一些方法来检查并报告故障：(1)assertEqual(first, second, msg=None)#判断first和second的值是否相等，如果不相等则测试失败，msg用于定义失败后所抛出的异常信息。(2)assertNotEqual(first, second, msg=None)#测试first和second不相等，如果相等，则测试失败。(3)assertTure(expr,msg=None)(4)assertFalse(expr,msg=None)#测试expr为Ture（或为False）(5)assertIs(first, second, msg=None)(6)assertIsNot(first, second, msg=None)#测试的first和second是（或不是）相同的对象。(7)assertIsNone(expr, msg=None)(8)assertIsNotNone(expr, msg=None)#测试expr是（或不是）为None(9)assertIn(first, second, msg=None)(10)assertNotIn(first, second, msg=None)#测试first是（或不是）在second中。second包含是否包含first。 十三、脚本设计原则(1)LOVE原则(NativeApp)： 1)Locate定位元素2)Operate操作元素3)Verify验证结果4)Exception异常处理 (2)S-LOVE原则(HybridApp)： 1)Switch切换上下文2)Locate定位元素3)Operate操作元素4)Verify验证结果5)Exception异常处理 持续更新…","categories":[{"name":"app测试","slug":"app测试","permalink":"http://pythonfood.github.io/categories/app测试/"}],"tags":[{"name":"appium","slug":"appium","permalink":"http://pythonfood.github.io/tags/appium/"}]},{"title":"appium DesiredCapabilities","slug":"appium-DesiredCapabilities","date":"2018-02-01T02:00:00.000Z","updated":"2018-05-11T06:54:01.436Z","comments":true,"path":"2018/02/01/appium-DesiredCapabilities/","link":"","permalink":"http://pythonfood.github.io/2018/02/01/appium-DesiredCapabilities/","excerpt":"Appium Desired Capabilities 详解。","text":"Appium Desired Capabilities 详解。 一、基本参数 关键字 描述 实例 automationName 自动化测试引擎 Appium或 Selendroid platformName 手机操作系统 iOS, Android, 或 FirefoxOS platformVersion 手机操作系统版本 如： 7.1, 4.4；ios的 9.0 deviceName 手机或模拟器设备名称 android的忽略，ios如iPhone Simulator app .ipa .apk文件路径 比如/abs/path/to/my.apk或http://myapp.com/app.ipa browserName 启动手机浏览器 iOS如:Safari，Android如:Chrome,Chromium,Browser newCommandTimeout 设置命令超时时间，单位：秒。 比如 60 autoLaunch Appium是否需要自动安装和启动应用。默认值true true, false language (Sim/Emu-only) 设定模拟器 ( simulator / emulator ) 的语言。 如： fr locale (Sim/Emu-only) 设定模拟器 ( simulator / emulator ) 的区域设置。 如： fr_CA udid ios真机的唯一设备标识 如： 1ae203187fc012g orientation 设置横屏或竖屏 LANDSCAPE (横向) 或 PORTRAIT (纵向) autoWebview 直接转换到 WebView 上下文。 默认值 false、 true, false noReset 不要在会话前重置应用状态。默认值false。 true, false fullReset (iOS) 删除整个模拟器目录。(Android)通过卸载默认值 false true, false 二、android特有 关键字 描述 实例 appActivity 启动app包,一般点开头 如：.MainActivity, .Settings appPackage Android应用的包名 比如com.example.android.myApp appWaitActivity 等待启动的Activity名称 SplashActivity deviceReadyTimeout 设置超时时间 5 androidCoverage 用于执行测试的 instrumentation类 com.my.Pkg/com.my.Pkg.instrumentation.MyInstrumentation enablePerformanceLogging (仅适用于 Chrome 和 webview) 开启 Chromedriver 的性能日志。(默认 false) true, false androidDeviceReadyTimeout 等待设备在启动应用后超时时间，单位秒 如 30 androidDeviceSocket 开发工具的 socket 名称。Chromedriver 把它作为开发者工具来进行连接。 如 chrome_devtools_remote avd 需要启动的 AVD (安卓模拟器设备) 名称。 如 api19 avdLaunchTimeout 以毫秒为单位，等待 AVD 启动并连接到 ADB的超时时间。(默认值 120000) 300000 avdReadyTimeout 以毫秒为单位，等待 AVD 完成启动动画的超时时间。(默认值 120000) 300000 avdArgs 启动 AVD 时需要加入的额外的参数。 如 -netfast useKeystore 使用一个自定义的 keystore 来对 apk 进行重签名。默认值 false true or false keystorePath 自定义keystore路径。默认~/.android/debug.keystore 如 /path/to.keystore keystorePassword 自定义 keystore 的密码。 如 foo keyAlias key 的别名 如 androiddebugkey keyPassword key 的密码 如 foo chromedriverExecutable webdriver可执行文件的绝对路径 应该用它代替Appium 自带的 webdriver) /abs/path/to/webdriver autoWebviewTimeout 毫秒为单位，Webview上下文激活的时间。默认2000 如 4 intentAction 用于启动activity的intent action。(默认值 android.intent.action.MAIN) 如 android.intent.action.MAIN, android.intent.action.VIEW intentCategory 用于启动 activity 的 intent category。 (默认值 android.intent.category.LAUNCHER) 如 android.intent.category.LAUNCHER, android.intent.category.APP_CONTACTS intentFlags 用于启动activity的标识(flags) (默认值 0x10200000) 如 0x10200000 optionalIntentArguments 用于启动 activity 的额外 intent 参数。请查看 Intent 参数 如 –esn , –ez dontStopAppOnReset 在使用 adb 启动应用时不要停止被测应用的进程。默认值： false true 或 false unicodeKeyboard 使用 Unicode 输入法。默认值 false true 或 false resetKeyboard 重置输入法到原有状态，默认值 false true 或 false noSign 跳过检查和对应用进行 debug 签名的步骤。默认值 false true 或 false ignoreUnimportantViews 调用 uiautomator 的函数这个关键字能加快测试执行的速度。默认值 false true 或 false disableAndroidWatchers 关闭 android 监测应用无响ANR和崩溃crash的监视器默认值： false。 true 或者 false chromeOptions 允许传入 chrome driver 使用的 chromeOptions 参数。 chromeOptions: {args: [‘–disable-popup-blocking‘]} 三、ios特有 关键字 描述 实例 calendarFormat (Sim-only) 为iOS的模拟器设置日历格式 如 gregorian (公历) bundleId 被测应用的bundle ID，真机上执行测试时，你可以不提供 app 关键字，但你必须提供udid 如 io.appium.TestApp udid 连接真机的唯一设备编号 ( Unique device identifier ) 如 1ae203187fc012g launchTimeout 以毫秒为单位，在Appium运行失败之前设置一个等待 instruments的时间 比如： 20000 locationServicesEnabled (Sim-only) 强制打开或关闭定位服务。默认值是保持当前模拟器的设定 true 或 false locationServicesAuthorized 使用这个关键字时，你同时需要使用 bundleId 关键字来发送你的应用的 bundle ID。 true 或者 false autoAcceptAlerts 当 iOS 的个人信息访问警告 (如 位置、联系人、图片) 出现时，自动选择接受( Accept )。默认值 false。 true 或者 false autoDismissAlerts 当 iOS 的个人信息访问警告 (如 位置、联系人、图片) 出现时，自动选择不接受( Dismiss )。默认值 false。 true 或者 false nativeInstrumentsLib 使用原生 intruments 库 (即关闭 instruments-without-delay ) true 或者 false nativeWebTap (Sim-only) 在Safari中允许”真实的”，默认值： false。注意：取决于 viewport 大小/比例， 点击操作不一定能精确地点中对应的元素。 true 或者 false safariInitialUrl (Sim-only) (&gt;= 8.1) Safari 的初始地址。默认值是一个本地的欢迎页面 例如： https://www.github.com safariAllowPopups (Sim-only) 允许 javascript 在 Safari 中创建新窗口。默认保持模拟器当前设置。 true 或者 false safariIgnoreFraudWarning (Sim-only) 阻止 Safari 显示此网站可能存在风险的警告。默认保持浏览器当前设置。 true 或者 false safariOpenLinksInBackground (Sim-only) Safari 是否允许链接在新窗口打开。默认保持浏览器当前设置。 true 或者 false keepKeyChains (Sim-only) 当 Appium 会话开始/结束时是否保留存放密码存放记录 (keychains) (库(Library)/钥匙串(Keychains)) true 或者 false localizableStringsDir 从哪里查找本地化字符串。默认值 en.lproj en.lproj processArguments 通过 instruments 传递到 AUT 的参数 如 -myflag interKeyDelay 以毫秒为单位，按下每一个按键之间的延迟时间。 如 100 showIOSLog 是否在 Appium 的日志中显示设备的日志。默认值 false true 或者 false sendKeyStrategy 输入文字到文字框的策略。模拟器默认值：oneByOne (一个接着一个) 。真实设备默认值：grouped (分组输入) oneByOne, grouped 或 setValue screenshotWaitTimeout 以秒为单位，生成屏幕截图的最长等待时间。默认值： 10。 如 5 waitForAppScript 用于判断 “应用是否被启动” 的 iOS 自动化脚本代码。默认情况下系统等待直到页面内容非空。结果必须是布尔类型。 例如 true;, target.elements().length &gt; 0;, $.delay(5000); true; 四、小示例 1234567891011from appium import webdriverdesired_caps=&#123;&#125;desired_caps[&apos;platformName&apos;]=&apos;Android&apos;desired_caps[&apos;platformVersion&apos;]=&apos;5.1.1&apos;desired_caps[&apos;deviceName&apos;]=&apos;172.16.10.26:5555&apos;desired_caps[&apos;appPackage&apos;]=&apos;com.peng.cloudp.tv&apos;desired_caps[&apos;appActivity&apos;]=&apos;..activity.StartPageActivity&apos;desired_caps[&apos;unicodeKeyboard&apos;]=&apos;true&apos;desired_caps[&apos;resetKeyboard&apos;]=&apos;true&apos;driver = webdriver.Remote(&apos;http://127.0.0.1:4723/wd/hub&apos;, desired_caps)","categories":[{"name":"app测试","slug":"app测试","permalink":"http://pythonfood.github.io/categories/app测试/"}],"tags":[{"name":"appium","slug":"appium","permalink":"http://pythonfood.github.io/tags/appium/"}]},{"title":"appium安装-windows","slug":"appium安装-windows","date":"2018-02-01T01:00:00.000Z","updated":"2018-05-11T06:54:01.426Z","comments":true,"path":"2018/02/01/appium安装-windows/","link":"","permalink":"http://pythonfood.github.io/2018/02/01/appium安装-windows/","excerpt":"appium环境搭建的简单步骤：安装jdk——安装android sdk——安装python——安装node.js——安装appium server——安装appium python客户端。","text":"appium环境搭建的简单步骤：安装jdk——安装android sdk——安装python——安装node.js——安装appium server——安装appium python客户端。 一、安装jdk (1)下载jdk 官网地址：http://www.oracle.com/technetwork/java/javase/downloads/index.html (2)安装jdk 根据提示安装，安装路径自定义：D:\\Program Files\\Java\\jdk1.7.0_80 (3)配置java环境变量 1)系统变量→新建JAVA_HOME变量→变量值：D:\\Program Files\\Java\\jdk1.7.0_802)系统变量→新建CLASSPATH变量→变量值：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar3)系统变量→编辑Path变量→增加：;%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin; (4)验证环境 cmd输入java -version命令查看java版本。 二、安装android sdk (1)下载android sdk 可以直接下载adt：http://tools.android-studio.org/index.php/adt-bundle-plugin (2)安装android sdk 将adt压缩包解压到自定义路径：D:\\Program Files\\adt-bundle-windows-x86-20130917 (3)配置android环境变量 1)系统变量→新建ANDROID_HOME变量→变量值：D:\\Program Files\\adt-bundle-windows-x86-20130917\\sdk2)系统变量→编辑Path变量→增加：;%ANDROID_HOME%\\tools;%ANDROID_HOME%\\platform-tools; (4)验证环境 cmd输入adb命令查看adb版本。 三、安装Python四、安装node.js (1)下载node.js 官网地址：https://nodejs.org/en/download/ (2)安装node.js 根据提示安装，安装路径自定义，自动添加PATH环境变量。 (3)验证环境 cmd输入node -v命令查看node版本。 五、安装appium server 方法1：npm安装 (1)cmd输入npm install -g appium命令等待安装完成。（可能会被墙）(2)cmd输入npm install -g appium-doctor命令安装Appium-doctor。(3)cmd输入appium-doctor命令看到’All Checks were successful’则环境搭建成功。 方法2：下载安装 (1)下载地址：http://appium.io/ 或 https://bitbucket.org/appium/appium.app/downloads/(2)根据提示安装，安装路径自定义，自动添加PATH环境变量：;D:\\Program Files\\Appium\\node_modules\\.bin;(3)打开Appium图标验证安装成功。 ps：appiun的server已经很久没有更新了，目前appium-desktop来继续他的使命。 六、安装appium python客户端 方法1：pip安装 cmd输入pip install Appium-Python-Client命令等待安装完成。 方法2：下载源码安装 (1)下载地址：https://pypi.python.org/pypi/Appium-Python-Client(2)解压后，cmd输入cd Appium-Python-Client-X.X命令进入目录。(3)cmd输入python setup.py install命令进行安装。 七、验证环境(小示例) (1)启动服务 1)连接手机。2)cmd输入appium命令启动服务。3)打印日志如下图，则服务启动成功： (2)代码示例 12345678910111213141516171819202122232425262728293031# -*- coding: utf-8 -*-from appium import webdriverfrom time import sleepimport unittestclass CalTest(unittest.TestCase): def setUp(self): desired_caps=&#123;&#125; desired_caps[&apos;platformName&apos;]=&apos;Android&apos; desired_caps[&apos;platformVersion&apos;]=&apos;5.0.2&apos; desired_caps[&apos;deviceName&apos;]=&apos;1ae7be68&apos; desired_caps[&apos;appPackage&apos;]=&apos;com.android.calculator2&apos; desired_caps[&apos;appActivity&apos;]=&apos;.Calculator&apos; self.driver=webdriver.Remote(&apos;http://localhost:4723/wd/hub&apos;,desired_caps) def tearDown(self): self.driver.quit() def test_add(self): driver.find_element_by_name(&quot;8&quot;).click() driver.find_element_by_id(&apos;digit7&apos;).click() driver.find_element_by_id(&apos;plus&apos;).click() driver.find_element_by_id(&apos;digit3&apos;).click() driver.find_element_by_id(&apos;equal&apos;).click() sleep(3) driver.find_element_by_id(&apos;clear&apos;).click()if __name__ == &apos;__main__&apos;: suite = unittest.TestLoader().loadTestsFromTestCase(CalTest) unittest.TextTestRunner(verbosity=2).run(suite) (3)执行脚本 持续更新…","categories":[{"name":"app测试","slug":"app测试","permalink":"http://pythonfood.github.io/categories/app测试/"}],"tags":[{"name":"appium","slug":"appium","permalink":"http://pythonfood.github.io/tags/appium/"}]},{"title":"安卓专项测试-流量","slug":"安卓专项测试-流量","date":"2018-01-01T06:00:00.000Z","updated":"2018-05-11T06:51:29.842Z","comments":true,"path":"2018/01/01/安卓专项测试-流量/","link":"","permalink":"http://pythonfood.github.io/2018/01/01/安卓专项测试-流量/","excerpt":"python脚本实现安卓app的流量消耗测试。","text":"python脚本实现安卓app的流量消耗测试。 一、用到的adb命令(1)获取进程ID指令：adb shell &quot;ps | grep packagename&quot;(2)获取进程ID流量：adb shell cat /proc/pid/net/dev 二、脚本实现策略(1)设定一个场景，测试一段时间(此处最好再写一个自动化测试的脚本)。(2)记录网卡eth0和eth1的Recevice和Transmit值，取本次流量值和上次流量值之差为所消耗的流量。 三、测试数据分析(1)不同版本之间对比(2)竞品之间对比 四、代码实现示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#!/usr/bin/env python3#coding=utf-8import osimport timeimport csv#控制类class Controller(object): def __init__(self,count): self.counter = count self.allData = [(&apos;timestamp&apos;,&apos;traffic&apos;)] #单次获取流量值 def traffic(self): cmd = &apos;adb shell &quot;ps | grep com.android.browser&quot;&apos; #截取进程id pid = os.popen(cmd).readlines()[0].split(&apos; &apos;)[5] #获取进程id所使用的流量 traffic = os.popen(&apos;adb shell cat /proc/&apos;+pid+&apos;/net/dev&apos;) for line in traffic: if &apos;eth0&apos; in line: #将所有空行换成&apos;#&apos; line = &apos;#&apos;.join(line.split()) recevice0 = line.split(&apos;#&apos;)[1] transmit0 = line.split(&apos;#&apos;)[9] elif &apos;eth1&apos; in line: #将所有空行换成&apos;#&apos; line = &apos;#&apos;.join(line.split()) recevice1 = line.split(&apos;#&apos;)[1] transmit1 = line.split(&apos;#&apos;)[9] #计算流量总和 alltraffic = int(recevice0)+int(transmit0)+int(recevice1)+int(transmit1) #流量总和按KB计算 alltraffic = alltraffic/1024 currenttime = self.getCurrentTime() self.allData.append((currenttime,alltraffic)) #多次获取流量值 def run(self): while self.counter&gt;0: self.traffic() self.counter = self.counter-1 time.sleep(5) #获取当前时间戳 def getCurrentTime(self): currentTime = time.strftime(&apos;%Y-%m-%d_%H:%M:%S&apos;, time.localtime()) return currentTime #数据存储 def SavaDataToCsv(self): with open(&apos;traffic.csv&apos;, &apos;w&apos;, newline=&apos;&apos;) as csvfile: writer = csv.writer(csvfile) writer.writerows(self.allData) if __name__ == &apos;__main__&apos;: controller = Controller(5) controller.run() controller.SavaDataToCsv() 五、测试结果示例 持续更新…","categories":[{"name":"app测试","slug":"app测试","permalink":"http://pythonfood.github.io/categories/app测试/"}],"tags":[{"name":"安卓性能","slug":"安卓性能","permalink":"http://pythonfood.github.io/tags/安卓性能/"}]},{"title":"安卓专项测试-电量","slug":"安卓专项测试-电量","date":"2018-01-01T05:00:00.000Z","updated":"2018-05-11T06:52:03.073Z","comments":true,"path":"2018/01/01/安卓专项测试-电量/","link":"","permalink":"http://pythonfood.github.io/2018/01/01/安卓专项测试-电量/","excerpt":"python脚本实现安卓app的电量消耗测试。","text":"python脚本实现安卓app的电量消耗测试。 一、用到的adb命令(1)获取电量信息：adb shell dumpsys battery(2)切换非充电状态：adb shell dumpsys battery set status 1 二、脚本实现策略(1)设定一个场景，测试一段时间(此处最好再写一个自动化测试的脚本)。(2)记录电量level值，取最后一次和第一次电量差值，获取消耗的电量值。 三、测试数据分析(1)不同版本之间对比(2)竞品之间对比 四、代码实现示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/usr/bin/env python3#coding=utf-8import osimport timeimport csv#控制类class Controller(object): def __init__(self,count): self.counter = count self.allData = [(&apos;timestamp&apos;,&apos;power&apos;)] #单次获取电量值 def power(self): #获取电量状态 powerStatus = os.popen(&apos;adb shell dumpsys battery&apos;) for line in powerStatus: if &apos;level&apos; in line: power = line.split(&apos;:&apos;)[1].strip(&apos;\\n&apos;) currenttime = self.getCurrentTime() self.allData.append((currenttime,power)) #多次获取电量值 def run(self): os.popen(&apos;adb shell dumpsys battery set status 1&apos;) while self.counter&gt;0: self.power() self.counter = self.counter-1 time.sleep(5) #获取当前时间 戳 def getCurrentTime(self): currentTime = time.strftime(&apos;%Y-%m-%d_%H:%M:%S&apos;, time.localtime()) return currentTime #数据存储 def SavaDataToCsv(self): with open(&apos;power.csv&apos;, &apos;w&apos;, newline=&apos;&apos;) as csvfile: writer = csv.writer(csvfile) writer.writerows(self.allData) if __name__ == &apos;__main__&apos;: controller = Controller(5) controller.run() controller.SavaDataToCsv() 五、测试结果示例 持续更新…","categories":[{"name":"app测试","slug":"app测试","permalink":"http://pythonfood.github.io/categories/app测试/"}],"tags":[{"name":"安卓性能","slug":"安卓性能","permalink":"http://pythonfood.github.io/tags/安卓性能/"}]},{"title":"安卓专项测试-内存","slug":"安卓专项测试-内存","date":"2018-01-01T04:00:00.000Z","updated":"2018-05-11T06:52:03.073Z","comments":true,"path":"2018/01/01/安卓专项测试-内存/","link":"","permalink":"http://pythonfood.github.io/2018/01/01/安卓专项测试-内存/","excerpt":"python脚本实现安卓app的内存状态测试。","text":"python脚本实现安卓app的内存状态测试。 一、用到的adb命令(1)adb shell top -d 刷新时间 &gt; meminfo VSS - 虚拟耗用内存 RSS - 实际使用物理内存 (2)cat meminfo | grep com.android.browser 二、脚本实现策略(1)打开app进行测试(此处最好再写一个自动化测试的脚本)。(2)执行adb shell top -d 1 &gt; D:\\adt-workspace\\appMemInfo\\memInfo，打印内存信息。(3)执行脚本读取内存信息，保存到csv文件。 三、测试数据分析曲线图分析：查看内存是否是一味上涨的趋势，不会回收或者部分回收。 四、代码实现示例 123456789101112131415161718192021222324252627282930313233343536373839#!/usr/bin/env python3#coding=utf-8import csv#控制类class Controller(object): def __init__(self): self.allData = [(&apos;id&apos;, &apos;VSS&apos;, &apos;RSS&apos;)] #读取数据文件 def readFile(self): with open(&apos;meminfo&apos;, &apos;r&apos;, ) as memfile: meminfo = memfile.readlines() print(meminfo) return meminfo #分析数据 def analyzeData(self): meminfo = self.readFile() i=0 for line in meminfo: if &apos;com.android.browser&apos; in line: line = &apos;#&apos;.join(line.split()) print(line) vss = line.split(&apos;#&apos;)[5].strip(&apos;K&apos;) rss = line.split(&apos;#&apos;)[6].strip(&apos;K&apos;) self.allData.append((i, vss, rss)) i=i+1 #存取数据 def saveDataToCsv(self): with open(&apos;meminfo.csv&apos;, &apos;w&apos;, newline=&apos;&apos;) as csvfile: writer = csv.writer(csvfile) writer.writerows(self.allData) if __name__ == &apos;__main__&apos;: controller = Controller() controller.analyzeData() controller.saveDataToCsv() 五、测试结果示例 持续更新…","categories":[{"name":"app测试","slug":"app测试","permalink":"http://pythonfood.github.io/categories/app测试/"}],"tags":[{"name":"安卓性能","slug":"安卓性能","permalink":"http://pythonfood.github.io/tags/安卓性能/"}]},{"title":"安卓专项测试-cpu","slug":"安卓专项测试-cpu","date":"2018-01-01T03:00:00.000Z","updated":"2018-05-11T06:52:03.063Z","comments":true,"path":"2018/01/01/安卓专项测试-cpu/","link":"","permalink":"http://pythonfood.github.io/2018/01/01/安卓专项测试-cpu/","excerpt":"python脚本实现安卓app的cpu使用率测试。","text":"python脚本实现安卓app的cpu使用率测试。 一、用到的adb命令adb shell &quot;dumpsys cpuinfo | grep packagename&quot; 二、脚本实现策略(1)打开app进行测试(此处最好再写一个自动化测试的脚本)。(2)执行脚本定时获取CPU使用状态。 三、测试数据分析曲线图分析：cpu使用率如果保持恒定并合理则正常；如果随着使用cpu使用率持续上升，接近100%可能存在问题。 四、代码实现示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!/usr/bin/env python3#coding=utf-8import osimport timeimport csv #控制类class Controller(object): def __init__(self,count): self.counter = count self.allData = [(&apos;timestamp&apos;,&apos;cpustatus&apos;)] #单次查看CPU状态״̬ def CpuStatus(self): cmd = &apos;adb shell &quot;dumpsys cpuinfo | grep com.android.calculator2&quot;&apos; cpustatus = os.popen(cmd).readlines() for line in cpustatus: cpuvalue = line.split(&apos;%&apos;)[0].strip() break currenttime = self.GetCurrentTime() self.allData.append((currenttime, cpuvalue)) #多次查看CPU状态 def run(self): while self.counter&gt;0: self.CpuStatus() self.counter = self.counter-1 time.sleep(3) #获取当前时间戳 def GetCurrentTime(self): #时间格式如果写成%Y-%m-%d %H:%M:%S，写入csv时会被自定义格式隐藏秒 currentTime = time.strftime(&apos;%Y-%m-%d_%H:%M:%S&apos;, time.localtime()) return currentTime #数据存储 def SaveDataToCSV(self): with open(&apos;cpuStatus.csv&apos;, &apos;w&apos;, newline=&apos;&apos;) as csvfile: writer = csv.writer(csvfile) writer.writerows(self.allData) if __name__ == &apos;__main__&apos;: controller = Controller(10) controller.run() controller.SaveDataToCSV() 五、测试结果示例 持续更新…","categories":[{"name":"app测试","slug":"app测试","permalink":"http://pythonfood.github.io/categories/app测试/"}],"tags":[{"name":"安卓性能","slug":"安卓性能","permalink":"http://pythonfood.github.io/tags/安卓性能/"}]},{"title":"安卓专项测试-启动时间","slug":"安卓专项测试-启动时间","date":"2018-01-01T02:00:00.000Z","updated":"2018-05-11T06:52:03.063Z","comments":true,"path":"2018/01/01/安卓专项测试-启动时间/","link":"","permalink":"http://pythonfood.github.io/2018/01/01/安卓专项测试-启动时间/","excerpt":"python脚本实现安卓app的启动时间测试。","text":"python脚本实现安卓app的启动时间测试。 一、用到的adb命令(1)查看activity： adb shell dumpsys window | findstr mCurrentFocusadb shell dumpsys activity activities (2)启动app： adb shell am start -W -n package/activity (3)停止app： adb shell am force-stop package (4)home退出app： adb shell input keyevent 3 二、脚本实现策略策略一：获取命令执行时间，作为启动时间参考值，比较好实现。策略二：在命令前后加上时间戳，以差值作为参考值，比较准确。 三、测试数据分析一般剔除第一次数据，取剩余次数数据进行分析，因为第一次往往不准确。(1)均值。(2)曲线的波动范围。(3)不同版本对比。(4)和竞品对比。 四、代码实现示例(1)冷启动 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#!/usr/bin/env python3#coding=utf-8import osimport timeimport csv#app类class App(object): def __init__(self): self.content = &apos;&apos; self.startTime = 0 #启动app def LaunchApp(self): cmd = &apos;adb shell am start -W -n com.android.calculator2/com.android.calculator2.Calculator&apos; self.content = os.popen(cmd) #停止app def StopApp(self): #冷启动时强制退出 cmd = &apos;adb shell am force-stop com.android.calculator2&apos; os.popen(cmd) #获取启动时间 def GetLaunchedTime(self): for line in self.content.readlines(): if &apos;ThisTime&apos; in line: #split(&apos;:&apos;)[1]截取启动时间；strip(&apos;\\n&apos;)去掉换行符 self.startTime = line.split(&apos;:&apos;)[1].strip(&apos;\\n&apos;) break return self.startTime#控制类class Controller(object): def __init__(self,count): self.app = App() self.counter = count self.allData = [(&apos;timestamp&apos;,&apos;elapsedtime&apos;)] #单次启动和停止 def LaunchAndStop(self): self.app.LaunchApp() elapsedtime = self.app.GetLaunchedTime() time.sleep(1) self.app.StopApp() currenttime = self.GetCurrentTime() time.sleep(1) self.allData.append((currenttime,elapsedtime)) #多次执行启动和停止 def run(self): while self.counter&gt;0: self.LaunchAndStop() self.counter = self.counter-1 #获取当前时间戳 def GetCurrentTime(self): #时间格式如果写成%Y-%m-%d %H:%M:%S，写入csv时会被自定义格式隐藏秒 currentTime = time.strftime(&apos;%Y-%m-%d_%H:%M:%S&apos;, time.localtime()) return currentTime #数据存储 def SaveDataToCSV(self): csvfile=open(&apos;coldStartTime.csv&apos;, &apos;w&apos;, newline=&apos;&apos;) writer = csv.writer(csvfile) writer.writerows(self.allData) csvfile.close() if __name__ == &apos;__main__&apos;: controller = Controller(10) controller.run() controller.SaveDataToCSV() (2)热启动 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#!/usr/bin/env python3#coding=utf-8import osimport timeimport csv#app类class App(object): def __init__(self): self.content = &apos;&apos; self.startTime = 0 #启动app def LaunchApp(self): cmd = &apos;adb shell am start -W -n com.android.calculator2/com.android.calculator2.Calculator&apos; self.content = os.popen(cmd) #停止app def StopApp(self): #热启动时home键退出 cmd = &apos;adb shell input keyevent 3&apos; os.popen(cmd) #获取启动时间 def GetLaunchedTime(self): for line in self.content.readlines(): if &apos;ThisTime&apos; in line: #split(&apos;:&apos;)[1]截取启动时间；strip(&apos;\\n&apos;)去掉换行符 self.startTime = line.split(&apos;:&apos;)[1].strip(&apos;\\n&apos;) break return self.startTime#控制类class Controller(object): def __init__(self,count): self.app = App() self.counter = count self.allData = [(&apos;timestamp&apos;,&apos;elapsedtime&apos;)] #单次启动和停止 def LaunchAndStop(self): self.app.LaunchApp() elapsedtime = self.app.GetLaunchedTime() time.sleep(1) self.app.StopApp() currenttime = self.GetCurrentTime() time.sleep(1) self.allData.append((currenttime,elapsedtime)) #多次执行启动和停止 def run(self): while self.counter&gt;0: self.LaunchAndStop() self.counter = self.counter-1 #获取当前时间戳 def GetCurrentTime(self): #时间格式如果写成%Y-%m-%d %H:%M:%S，写入csv时会被自定义格式隐藏秒 currentTime = time.strftime(&apos;%Y-%m-%d_%H:%M:%S&apos;, time.localtime()) return currentTime #数据存储 def SaveDataToCSV(self): with open(&apos;hotStartTime.csv&apos;, &apos;w&apos;, newline=&apos;&apos;) as csvfile: writer = csv.writer(csvfile) writer.writerows(self.allData) if __name__ == &apos;__main__&apos;: controller = Controller(10) controller.run() controller.SaveDataToCSV() 五、测试结果示例(1)冷启动 (2)热启动 持续更新…","categories":[{"name":"app测试","slug":"app测试","permalink":"http://pythonfood.github.io/categories/app测试/"}],"tags":[{"name":"安卓性能","slug":"安卓性能","permalink":"http://pythonfood.github.io/tags/安卓性能/"}]},{"title":"安卓专项测试","slug":"安卓专项测试","date":"2018-01-01T01:00:00.000Z","updated":"2018-05-11T06:52:03.053Z","comments":true,"path":"2018/01/01/安卓专项测试/","link":"","permalink":"http://pythonfood.github.io/2018/01/01/安卓专项测试/","excerpt":"安卓专项测试主要包括：响应时间、cpu、内存、电量、流量、FPS、过度渲染。","text":"安卓专项测试主要包括：响应时间、cpu、内存、电量、流量、FPS、过度渲染。 一、响应时间 1.安装：普通安装、覆盖安装2.启动：冷启动、热启动 (1)adb命令：adb logcat、adb shell am start、adb shell screenrecord等。 小示例：1)adb shell screenrecord /sdcard/demo.mp42)adb pull /sdcard/demo.mp4 d:\\record3)用按帧播放的视频软件播放分析，比如KMplayer。 (2)代码里打点（埋点）。(3)高速相机。(4)秒表。(5)第三方工具或云测平台。 3.跳转：页面之间、控件之间 二、cpu 1.活动状态2.静默状态 (1)第三方工具：腾讯GT、网易Emmagee、阿里易测等。（小白首选）。(2)dumpsys命令：adb shell dumpsys cpuinfo | grep {PackageName}。(3)top命令：adb shell top | grep {PackageName}。 小示例：1)adb shell2)top | grep com.peng.cloudp.tv 第一列PID:进度ID第二列PR:优先级第三列CPU:瞬时CPU占用率第四列进程状态:R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程第五列THR:当前应用所用的线程数第六列VSS:虚拟消耗内存第七列RSS:实际使用物理内存第八列UID:进程所有者的用户ID第九列PR:进程名称 三、内存 1.命令查看内存数据 (1)adb shell dumpsys meminfo {PackageName}查看内存是否是一味上涨的趋势，不会回收或者部分回收。(2)/system/build.prop 查看每个应用分配的最高内存值。adb shell procrank (没有可以从网上下载procrank文件)。 PID:进程IDVSS:虚拟消耗内存RSS:实际使用物理内存，是共享内存+私有内存。PSS:占用私有内存加上平均分配的的共享内存。USS:私有内存，如果应用终止了，这部分内存会释放。如果这个值超过应用被分配的最大值，就会闪退。 2.Memory Monitor查看内存风险3.MAT分析内存泄漏4.Zombie辅助检查内存占用 四、电量 1.待机：无网络待机、wifi待机、3G待机等。2.活动状态：不断地进行某些场景操作、看视频、灭屏下载、唤醒等。3.静默状态：打开app后不操作，后台运行。 (1)通过硬件测试：耗电量测试仪、腾讯的电量宝等(2)通过adb shell dumpsys batterystats命令。（android5.0以上使用）(3)第三方工具或云测平台。(4)android自带的电量统计。 五、流量 1.活动状态2.静默状态 (1)通过Tcpdump抓包，然后用Wireshark分析。如果想更自动化，可以用FildderCore二次开发。(2)查看Linux流量统计文件。 小示例：1)ps | grep com.peng.cloudp.tv （获取的pid为9696）2)cat /proc/9696/status （通过pid值获取uid为10035）3)cat /proc/uid_stat/10035/tcp_snd （通过uid获取发送的流量byte,为15584）4)cat /proc/uid_stat/10035/tcp_rcv （通过uid获取接收的流量byte,为16778） (3)利用类似DDMS的工具查看流量。（小白首选）(4)通过Android API 的 TrafficStats类来统计。(5)第三方工具或云测平台。 六、FPS 1.adb shell dumpsys gfxinfo 小示例：1)adb shell dumpsys gfxinfo com.peng.cloudp.tv &gt; com.peng.cloudp.tv.txt2)抓取数据后用表格进行分析 2.monitor.bat进行测试 3.打开【设置-开发者选项-GPU呈现模式分析-在屏幕上显示为条形图】，开启后点击应用，可以看到条形图。 测试应用流畅度：(1)条形图高于绿线，说明出现卡顿(2)条形图低于绿线，说明比较流畅 七、过度渲染 1.打开【设置-开发者选项-调试GPU过度绘制-显示过度绘制区域】，开启后点击应用，可以看到各种颜色的区域。 颜色的标识：(1)蓝色1x过度绘制(2)绿色2x过度绘制(3)淡红色3x过度绘制(4)红色超过4x过度绘制 2.颜色越浅越好:蓝-绿-淡红-红。最理想的是一个像素只绘制一次，合格的页面是白色、蓝色为主，绿色以上区域不能超过整个的三分之一。 验收标准：(1)控制过度绘制为2x(2)不允许存在4x过度绘制(3)不允许存在面积超过屏幕1/4区域的3x过度绘制（淡红色区域） 持续更新…","categories":[{"name":"app测试","slug":"app测试","permalink":"http://pythonfood.github.io/categories/app测试/"}],"tags":[{"name":"安卓性能","slug":"安卓性能","permalink":"http://pythonfood.github.io/tags/安卓性能/"}]},{"title":"python虚拟环境","slug":"python虚拟环境","date":"2017-12-30T11:00:00.000Z","updated":"2018-07-19T02:13:48.567Z","comments":true,"path":"2017/12/30/python虚拟环境/","link":"","permalink":"http://pythonfood.github.io/2017/12/30/python虚拟环境/","excerpt":"人生苦短，我用python。","text":"人生苦短，我用python。 一、virtualenv模块官方文档：https://virtualenv.pypa.io/en/stable/ 1、安装模块 cmd输入命令： pip install virtualenv 测试安装： virtualenv --version 2、创建虚拟环境(1)为项目搭建创建虚拟环境: 进入项目： cd my_project 创建虚拟环境： virtualenv my_venv linux指定Python解释器： virtualenv -p /usr/bin/python3 my_venv (2)激活和停止虚拟环境： 1)linux下： 激活虚拟环境： source my_venv/bin/activate 停止虚拟环境： .my_venv/bin/deactivate 2)windows下： 首先进入Scripts路径：\\my_venv&gt; cd Scripts 激活虚拟环境：\\my_venv\\Scripts&gt; activate.bat 停止虚拟环境：\\my_venv\\Scripts&gt; deactivate.bat (3)删除虚拟环境： 要删除一个虚拟环境，只需删除它的文件夹。执行：rm -rf my_venv (4)其他操作： 查看当前安装版本： pip freeze 将包依赖信息保存在requirements文件： pip freeze &gt; requirements.txt 3、virtualenvwrapper鉴于virtualenv不便于对虚拟环境集中管理，所以推荐直接使用virtualenvwrapper。 virtualenvwrapper提供了一系列命令使得和虚拟环境工作变得便利。它把你所有的虚拟环境都放在一个地方。 (1)安装(前提virtualenv已安装): 1)linux下： 安装： pip install virtualenvwrapper 设置环境变量： export WORKON_HOME=~/Envs 创建虚拟环境管理目录： mkdir -p $WORKON_HOME virtualenvwrapper.sh路径： find / -name virtualenvwrapper.sh 激活virtualenvwrapper.sh： source virtualenvwrapper.sh路径 2)windows下： 安装：pip install virtualenvwrapper-win 配置环境变量：WORKON_HOME = D:\\virtualenv (2)虚拟环境 创建虚拟环境：mkvirtualenv venv 查看所有虚拟环境: workon 切换到虚拟环境： workon venv 退出虚拟环境：deactivate 删除虚拟环境：rmvirtualenv venv 持续更新…","categories":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/tags/python/"}]},{"title":"python可执行程序","slug":"python可执行程序","date":"2017-12-30T10:30:00.000Z","updated":"2018-05-21T07:12:38.032Z","comments":true,"path":"2017/12/30/python可执行程序/","link":"","permalink":"http://pythonfood.github.io/2017/12/30/python可执行程序/","excerpt":"人生苦短，我用python。","text":"人生苦短，我用python。 一、pyinstaller模块1、安装模块 cmd输入命令pip installer pyinstaller即可。pip会自动安装这个第三方包需要的依赖模块，比如pypiwin32这个依赖。 2、打包过程 (1)新建项目路径，路径自定义。(2)将打包文件复制到项目路径下。(3)打开cmd窗口，cd到项目路径。(4)执行命令pyinstaller -F filename.pyps:将需要的第三方库也复制到路径下，不过site-packages目录下的都可以自动识别。 3、详细参数 -F, –onefile 产生一个文件用于部署，只生成一个可执行文件。 -D, –onedir 产生一个目录用于部署 (默认)。 -K, –tk 在部署时包含 TCL/TK。 -c, –nowindowed,–console 使用控制台子系统执行，无界面(默认)(只对Windows有效)。 -w, –windowed,–noconsole 使用Windows子系统执行，当程序启动的时候不会打开命令行，需要有界面(只对Windows有效)。 -p DIR, –path=DIR 设置导入路径(和使用PYTHONPATH效果相似)，可以用路径分割符(Windows使用分号,Linux使用冒号)分割，指定多个目录。也可以使用多个-p参数来设置多个导入路径。 -n NAME, –name=NAME 可选的项目(产生的spec的)名字.如果省略,第一个脚本的主文件名将作为spec的名字。 -i file.ico, –icon=&lt;FILE.ICO&gt; 将file.ico添加为可执行文件的资源(只对Windows系统有效)。 –icon=&lt;FILE.EXE,N&gt; 将file.exe的第n个图标添加为可执行文件的资源(只对Windows系统有效)。 -v FILE, –version=FILE 将verfile作为可执行文件的版本资源(只对Windows系统有效)。 -a, –ascii 不包含编码，在支持Unicode的python版本上默认包含所有的编码。 -d, –debug 产生debug版本的可执行文件。 -s, –strip 可执行文件和共享库将run through strip，注意Cygwin的strip往往使普通的win32 Dll无法使用。 -X, –upx 如果有UPX安装(执行Configure.py时检测)，会压缩执行文件(Windows系统中的DLL也会)。 -o DIR, –out=DIR 指定spec文件的生成目录，如果没有指定，而且当前目录是PyInstaller的根目录,会自动创建一个用于输出(spec和生成的可执行文件)的目录。如果没有指定,而当前目录不是PyInstaller的根目录,则会输出到当前的目录下。 PS:详细参数见官网https://pyinstaller.readthedocs.io/en/v3.3.1/usage.html 持续更新…","categories":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/tags/python/"}]},{"title":"python内置函数","slug":"python内置函数","date":"2017-12-30T10:00:00.000Z","updated":"2018-05-11T06:46:37.065Z","comments":true,"path":"2017/12/30/python内置函数/","link":"","permalink":"http://pythonfood.github.io/2017/12/30/python内置函数/","excerpt":"人生苦短，我用python。","text":"人生苦短，我用python。 python内置函数 Built-in Functions abs() dict() help() min() setattr() all() dir() hex() next() slice() any() divmod() id() object() sorted() ascii() enumerate() input() oct() staticmethod() bin() eval() int() open() str() bool() exec() isinstance() ord() sum() bytearray() filter() issubclass() pow() super() bytes() float() iter() print() tuple() callable() format() len() property() type() chr() frozenset() list() range() vars() classmethod() getattr() locals() repr() zip() compile() globals() map() reversed() __import__() complex() hasattr() max() round() delattr() hash() memoryview() set() abs()获取绝对值 123456789&gt;&gt;&gt; abs(-10)10&gt;&gt;&gt; abs(10)10&gt;&gt;&gt; abs(0)0&gt;&gt;&gt; a = -10&gt;&gt;&gt; a.__abs__()10 all()接受一个迭代器，如果迭代器的所有元素都为真，那么返回True，否则返回False 123456789&gt;&gt;&gt; tmp_1 = [&apos;python&apos;,123]&gt;&gt;&gt; all(tmp_1)True&gt;&gt;&gt; tmp_2 = []&gt;&gt;&gt; all(tmp_2)True&gt;&gt;&gt; tmp_3 = [0]&gt;&gt;&gt; all(tmp_3)False any()接受一个迭代器，如果迭代器里有一个元素为真，那么返回True,否则返回False ascii()调用对象的__repr__()方法，获得该方法的返回值 bin()接收一个十进制，转换成二进制 oct()接收一个十进制，转换成八进制 hex()接收一个十进制，转换成十六进制 bool()测试一个对象是True还是False bytes()将一个字符串转换成字节类型 12345678&gt;&gt;&gt; s = &apos;python&apos;&gt;&gt;&gt; x = bytes(s, encoding=&apos;utf-8&apos;)&gt;&gt;&gt; xb&apos;python&apos;&gt;&gt;&gt; a = &apos;王&apos;&gt;&gt;&gt; s = bytes(a, encoding=&apos;utf-8&apos;)&gt;&gt;&gt; sb&apos;\\xe7\\x8e\\x8b&apos; str()将字符类型/数值类型等转换为字符串类型 1234&gt;&gt;&gt; str(b&apos;\\xe7\\x8e\\x8b&apos;, encoding=&apos;utf-8&apos;) # 字节转换为字符串&apos;王&apos;&gt;&gt;&gt; str(1) # 整数转换为字符串&apos;1&apos; challable()判断对象是否可以被调用，能被调用的对象就是一个callables对象，比如函数和带有__call__()的实例 12345678&gt;&gt;&gt; callable(max)True&gt;&gt;&gt; callable([1, 2, 3])False&gt;&gt;&gt; callable(None)False&gt;&gt;&gt; callable(&apos;str&apos;)False char()数字转字母，查看十进制数对应的ASCII字符 1234567&gt;&gt;&gt; chr(-1)Traceback (most recent call last): File &quot;&lt;pyshell#26&gt;&quot;, line 1, in &lt;module&gt; chr(-1)ValueError: chr() arg not in range(0x110000)&gt;&gt;&gt; chr(0)&apos;\\x00&apos; ord()字母转数字，查看某个ASCII对应的十进制数 1234&gt;&gt;&gt; ord(&apos;\\x00&apos;)0&gt;&gt;&gt; ord(&apos;7&apos;)55 classmethod()用来指定一个方法为类的方法，由类直接调用执行，只有一个cls参数,执行雷的方法时，自动将调用该方法的类赋值给cls.没有此参数指定的类的方法为实例方法 123456789101112class Province: country = &quot;中国&quot; def __init__(self, name): self.name = name @classmethod def show(cls): # 类方法，由类调用，最少要有一个参数cls，调用的时候这个参数不用传值，自动将类名赋值给cls print(cls) # 调用方法Province.show() complie()将字符串编译成python能识别或可以执行的代码，也可以将文字读成字符串再编译 1234567891011compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1)将source编译为代码或者AST对象。代码对象能过通过exec语句来执行或者eval()进行求值。参数source：字符串或者AST（abstract syntax trees）对象。参数filename：代码文件名称，如果不是从文件读取代码则传递一些可辨认的值。参数model：指定编译代码的种类。可以指定&apos;exec&apos;, &apos;eval&apos;, &apos;single&apos;。参数flag和dont_inherit：这两个参数为可选参数。&gt;&gt;&gt; s = &quot;print(&apos;helloworld&apos;)&quot;&gt;&gt;&gt; r = compile(s, &quot;&lt;string&gt;&quot;, &quot;exec&quot;)&gt;&gt;&gt; r&lt;code object &lt;module&gt; at 0x000001C648038390, file &quot;&lt;string&gt;&quot;, line 1&gt; complex() 123创建一个值为real + imag * j的复数或者转化一个字符串或数为复数。如果第一个参数是字符串，则不需要指定第二个参数参数real：int，long，float或字符串。参数imag：int，long，float。 delattr()删除对象的属性 dict()创建数据字典 123456789&gt;&gt;&gt; a = dict() 空字典&gt;&gt;&gt; a&#123;&#125;&gt;&gt;&gt; b = dict(one = 1, two =2)&gt;&gt;&gt; b&#123;&apos;one&apos;: 1, &apos;two&apos;: 2&#125;&gt;&gt;&gt; c = dict(&#123;&apos;one&apos;:1 ,&apos;two&apos;:2&#125;)&gt;&gt;&gt; c&#123;&apos;one&apos;: 1, &apos;two&apos;: 2&#125; dir()不带参数时返回当前范围内的变量，方法和定义的类型列表，带参数时返回参数的属性，方法列表 1234&gt;&gt;&gt; dir()[&apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos;, &apos;li&apos;, &apos;li1&apos;, &apos;li2&apos;, &apos;li_1&apos;]&gt;&gt;&gt; dir(list)[&apos;__add__&apos;, &apos;__class__&apos;, &apos;__contains__&apos;, &apos;__delattr__&apos;, &apos;__delitem__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__getitem__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__iadd__&apos;, &apos;__imul__&apos;, &apos;__init__&apos;, &apos;__iter__&apos;, &apos;__le__&apos;, &apos;__len__&apos;, &apos;__lt__&apos;, &apos;__mul__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__reversed__&apos;, &apos;__rmul__&apos;, &apos;__setattr__&apos;, &apos;__setitem__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;append&apos;, &apos;clear&apos;, &apos;copy&apos;, &apos;count&apos;, &apos;extend&apos;, &apos;index&apos;, &apos;insert&apos;, &apos;pop&apos;, &apos;remove&apos;, &apos;reverse&apos;, &apos;sort&apos;] divmod()分别取商和余数 12&gt;&gt;&gt; divmod(20,6)(3, 2) enumerate()返回一个可以枚举的对象，该对象的next()方法将返回一个元组 12345678&gt;&gt;&gt; test = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]&gt;&gt;&gt; for k,v in enumerate(test): print(k,v) # 输出结果： 0 a1 b2 c eval()将字符串str当成有效的表达式来求值并返回计算结果 12345&gt;&gt;&gt; s = &quot;1+2*3&quot;&gt;&gt;&gt; type(s)&lt;class &apos;str&apos;&gt;&gt;&gt;&gt; eval(s)7 exec()执行字符串或complie方法编译过的字符串，没有返回值 filter()过滤器，构造一个序列，等价于[ item for item in iterables if function(item)]，在函数中设定过滤条件，逐一循环迭代器中的元素，将返回值为True时的元素留下，形成一个filter类型数据 1234567filter(function, iterable)参数function：返回值为True或False的函数，可以为None。参数iterable：序列或可迭代对象。&gt;&gt;&gt; def bigerthan5(x):... return x &gt; 5&gt;&gt;&gt; filter(bigerthan5, [3, 4, 5, 6, 7, 8])[6, 7, 8] float()讲一个字符串或整数转换为浮点数 1234567891011&gt;&gt;&gt; float()0.0&gt;&gt;&gt; float(&apos;123&apos;)123.0&gt;&gt;&gt; float(1)1.0&gt;&gt;&gt; float(&apos;a&apos;)Traceback (most recent call last): File &quot;&lt;pyshell#45&gt;&quot;, line 1, in &lt;module&gt; float(&apos;a&apos;)ValueError: could not convert string to float: &apos;a&apos; format()格式化输出字符串，format(value, format_spec)实质上是调用了value的__format__(format_spec)方法 12&gt;&gt;&gt; &quot;I am &#123;0&#125;, I like &#123;1&#125;!&quot;.format(&quot;wang&quot;, &quot;moon&quot;) &apos;I am wang, I like moon!&apos; frozenset()创建一个不可修改的集合 1234frozenset([iterable])set和frozenset最本质的区别是前者是可变的，后者是不可变的。当集合对象会被改变时（例如删除，添加元素），只能使用set，一般来说使用fronzet的地方都可以使用set。参数iterable：可迭代对象。 getattr()获取对象的属性 123456789101112131415161718192021getattr(object, name [, defalut])获取对象object名为name的特性，如果object不包含名为name的特性，将会抛出AttributeError异常；如果不包含名为name的特性且提供default参数，将返回default。参数object：对象参数name：对象的特性名参数default：缺省返回值&gt;&gt;&gt; append = getattr(list, &apos;append&apos;)&gt;&gt;&gt; append&lt;method &apos;append&apos; of &apos;list&apos; objects&gt;&gt;&gt;&gt; mylist = [3, 4, 5]&gt;&gt;&gt; append(mylist, 6)&gt;&gt;&gt; mylist[3, 4, 5, 6]&gt;&gt;&gt; method = getattr(list, &apos;add&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: type object &apos;list&apos; has no attribute &apos;add&apos;&gt;&gt;&gt; method = getattr(list, &apos;add&apos;, &apos;NoMethod&apos;)&gt;&gt;&gt; method&apos;NoMethod&apos; globals()返回一个描述当前全局变量的字典 123&gt;&gt;&gt; a = 1&gt;&gt;&gt; globals()&#123;&apos;__loader__&apos;: &lt;class &apos;_frozen_importlib.BuiltinImporter&apos;&gt;, &apos;a&apos;: 1, &apos;__builtins__&apos;: &lt;module &apos;builtins&apos; (built-in)&gt;, &apos;__doc__&apos;: None, &apos;__name__&apos;: &apos;__main__&apos;, &apos;__package__&apos;: None, &apos;__spec__&apos;: None&#125; hasattr() 12345678hasattr(object，name)判断对象object是否包含名为name的特性（hasattr是通过调用getattr(object，name)）是否抛出异常来实现的。参数object：对象参数name：特性名称&gt;&gt;&gt; hasattr(list, &apos;append&apos;)True&gt;&gt;&gt; hasattr(list, &apos;add&apos;)False hash()哈希值 123hash(object)如果对象object为哈希表类型，返回对象object的哈希值。哈希值为整数，在字典查找中，哈希值用于快递比价字典的键。两个数值如果相等，则哈希值也相等。 help()返回对象的帮助文档 1调用内建的帮助系统，如果不包含参数，交互式帮助系统将在控制台启动。如果参数为字串，则可以是模块，类，方法等名称，并且帮助页面将会在控制台打印。参数也可以为任意对象 id()返回对象的内存地址 123&gt;&gt;&gt; a = 1&gt;&gt;&gt; id(a)1588522800 input()获取用户输入内容 12345num = input(&quot;请输入一个数字：&quot;)# 用户输入3print(num)# 输出结果3 int()将一个字符串或数值转换为一个普通整数 1234567int([x[,radix]])如果参数是字符串，那么它可能包含符号和小数点。参数radix表示转换的基数（默认是10进制）。它可以是[2,36]范围内的值，或者0。如果是0，系统将根据字符串内容来解析。如果提供了参数radix，但参数x并不是一个字符串，将抛出TypeError异常；否则，参数x必须是数值（普通整数，长整数，浮点数）。通过舍去小数点来转换浮点数。如果超出了普通整数的表示范围，一个长整数被返回。如果没有提供参数，函数返回0。 isinstance()检查对象是否是类的对象，返回True或False 123456isinstance(obj, cls)检查obj是否是类cls的对象, 返回True 或 Falseclass Foo(object): passobj = Foo()isinstance(obj, Foo) issubclass()检查一个类是否是另一个类的子类。返回True或False 12345678910issubclass(sub, super)检查sub类是否是super类的派生类（子类）。返回True 或 False class Foo(object): pass class Bar(Foo): pass issubclass(Bar, Foo) iter() 123456iter(o[, sentinel])返回一个iterator对象。该函数对于第一个参数的解析依赖于第二个参数。如果没有提供第二个参数，参数o必须是一个集合对象，支持遍历功能（__iter__()方法）或支持序列功能（__getitem__()方法），参数为整数，从零开始。如果不支持这两种功能，将处罚TypeError异常。如果提供了第二个参数，参数o必须是一个可调用对象。在这种情况下创建一个iterator对象，每次调用iterator的next()方法来无参数的调用o，如果返回值等于参数sentinel，触发StopIteration异常，否则将返回该值。 len()返回对象长度，参数可以是序列类型（字符串，元组或列表）或映射类型（如字典） list()列表构造函数 1234list([iterable])list的构造函数。参数iterable是可选的，它可以是序列，支持编译的容器对象，或iterator对象。该函数创建一个元素值，顺序与参数iterable一致的列表。如果参数iterable是一个列表，将创建列表的一个拷贝并返回，就像语句iterables[:]。 locals()打印当前可用的局部变量的字典 123不要修改locals()返回的字典中的内容；改变可能不会影响解析器对局部变量的使用。在函数体内调用locals()，返回的是自由变量。修改自由变量不会影响解析器对变量的使用。不能在类区域内返回自由变量。 map() 1234567891011121314151617map(function, iterable,...)对于参数iterable中的每个元素都应用fuction函数，并将结果作为列表返回。如果有多个iterable参数，那么fuction函数必须接收多个参数，这些iterable中相同索引处的元素将并行的作为function函数的参数。如果一个iterable中元素的个数比其他少，那么将用None来扩展改iterable使元素个数一致。如果有多个iterable且function为None，map()将返回由元组组成的列表，每个元组包含所有iterable中对应索引处值。参数iterable必须是一个序列或任何可遍历对象，函数返回的往往是一个列表(list)。 li = [1,2,3]data = map(lambda x :x*100,li)print(type(data))data = list(data)print(data) 运行结果： &lt;class &apos;map&apos;&gt;[100, 200, 300] max()返回给定元素里最大值 12345max(iterable [,args...][, key])如果只提供iterable参数，函数返回可遍历对象（如：字符串，元组或列表）中最大的非空元素。如果提供多个参数，那么返回值最大的那个参数。可选参数key是单参数的排序函数。如果提供key参数，必须是以命名的形式，如：max(a, b, c, key = fun) meoryview()查看内存地址 min()返回给定元素里最小值 12345min(iterable [,args...][, key])如果只提供iterable参数，函数返回可遍历对象（如：字符串，元组或列表）中最小的非空元素。如果提供多个参数，那么返回值最小的那个参数。可选参数key是单参数的排序函数。如果提供key参数，必须是以命名的形式，如：max(a, b, c, key = fun) next()返回一个可迭代数据结构（如列表）中的下一项 object() 12获取一个新的，无特性(geatureless)对象。Object是所有类的基类。它提供的方法将在所有的类型实例中共享。该函数时2.2.版本新增，2.3版本之后，该函数不接受任何参数。 open()打开文件 12345678910open(filename [, mode [, bufsize]])打开一个文件，返回一个file对象。 如果文件无法打开，将处罚IOError异常。应该使用open()来代替直接使用file类型的构造函数打开文件。参数filename表示将要被打开的文件的路径字符串；参数mode表示打开的模式，最常用的模式有：&apos;r&apos;表示读文本，&apos;w&apos;表示写文本文件，&apos;a&apos;表示在文件中追加。Mode的默认值是&apos;r&apos;。当操作的是二进制文件时，只要在模式值上添加&apos;b&apos;。这样提高了程序的可移植性。可选参数bufsize定义了文件缓冲区的大小。0表示不缓冲；1表示行缓冲；任何其他正数表示使用该大小的缓冲区；负数表示使用系统默认缓冲区大小，对于tty设备它往往是行缓冲，而对于其他文件往往完全缓冲。如果参数值被省却。使用系统默认值。 pow()幂函数 12345r = pow(2, 10) # 2的10次方print(r) # 输出1024 print()输出函数 1234python2中的print语句被python3中的print()函数取代。如何限制print的默认换行： 1. python2版本下，在print输出的最后加一个逗号&apos;,&apos;2. python3.4以后，print(value, ...,sep=&apos;&apos;,end=&apos;\\n&apos;,file=sys.stdout,flush=False),将end设为空即可。 property()获取对象的所有属性 range()根据需要生成一个指定范围的数字，可以提供你需要的控制来迭代指定的次数 1234567用于创建包含连续算术值的列表(list)。常用于for循环。参数必须是普通整数。参数step默认值为1，参数start的默认值为0。全参数调用该函数将返回一个普通整数列表。step 可以是正整数或者负整数。不可以为0，否则将处罚ValueError异常。range(3)代表0,1,2.等价于range(0,3)&gt;&gt;&gt; range(0,10,2) #第一个参数是起始数，第二个是终止数(不包含这个)，第三个数步数&gt;&gt;&gt;[0,2,4,6,8] repr()将任意值转换为字符串，供计时器读取的形式 1234repr(object)返回一个对象的字符串表示。有时可以使用这个函数来访问操作。对于许多类型来说，repr()尝试返回一个字符串，eval()方法可以使用该字符串产生对象；否则用尖括号括起来的，包含类名称和其他二外信息的字符串被返回。 reversed()反转，逆序对象 123reversed(seq)返回一个逆序的iterator对象。参数seq必须是一个包含__reversed__()方法的对象或支持序列操作(__len__()和__getitem__())该函数是2.4中新增的 round()四舍五入 1234567round(x [, n])对参数x的第n+1位小数进行四舍五入，返回一个小数位数为n的浮点数。参数n的默认值是0。结果是一个浮点数。如round(0.5)结果为1.0&gt;&gt;&gt; round(4,6)4&gt;&gt;&gt; round(5,6)5 set()class set([iterable]) 返回一个新的set对象，可以选择从iterable取得的元素，set是一个内置的类 setattr()与getattr()相对应，setattr(object,name,value) 参数是一个对象，一个字符串和一个任意值。字符串可以命名现有属性或新属性。如果对象允许，该函数将赋值给该属性 1setattr(x, &apos;foobar&apos;, 123) 相当于x.foobar = 123 slice()切片功能, slice(start, stop[, step]) sorted()排序 12345678910111213141516&gt;&gt;&gt; sorted([36,6,-12,9,-22]) 列表排序[-22, -12, 6, 9, 36]&gt;&gt;&gt; sorted([36,6,-12,9,-22],key=abs) 高阶函数，以绝对值大小排序[6, 9, -12, -22, 36]&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;]) 字符串排序，按照ASCII的大小排序[&apos;Credit&apos;, &apos;Zoo&apos;, &apos;about&apos;, &apos;bob&apos;]如果需要排序的是一个元组，则需要使用参数key，也就是关键字。&gt;&gt;&gt; a = [(&apos;b&apos;,2), (&apos;a&apos;,1), (&apos;c&apos;,0)]&gt;&gt;&gt; list(sorted(a,key=lambda x:x[1])) 按照元组第二个元素排序[(&apos;c&apos;, 0), (&apos;a&apos;, 1), (&apos;b&apos;, 2)]&gt;&gt;&gt; list(sorted(a,key=lambda x:x[0])) 按照元组第一个元素排序[(&apos;a&apos;, 1), (&apos;b&apos;, 2), (&apos;c&apos;, 0)]&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;],key=str.lower) 忽略大小写排序[&apos;about&apos;, &apos;bob&apos;, &apos;Credit&apos;, &apos;Zoo&apos;] &gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;],key=str.lower,reverse=True) 反向排序[&apos;Zoo&apos;, &apos;Credit&apos;, &apos;bob&apos;, &apos;about&apos;] staticmethod()在类中定义一个静态方法的函数，通常@staticmethod 下面接一个函数，如此使用 str()字符串构造函数 sum()求和 super()调用父类的方法 tuple()元组构造函数 type()显示对象所属的类型 vars()vars([object]) 使用__dict__属性返回模块，类，实例或任何其他对象的__dict__属性 zip()将对象逐一配对，相当于制作一个迭代器，用于聚合每个迭代的元素。zip(*iterables) 12345678st_1 = [1,2,3]list_2 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]s = zip(list_1,list_2)print(list(s)) 运行结果： [(1, &apos;a&apos;), (2, &apos;b&apos;), (3, &apos;c&apos;)] __import__() 1该函数由import 语句调用，它可以被替换（导入builtins模块和分配给builtins.__import__）来改变import语句的语义，但是并不建议如此使用。 持续更新…","categories":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/tags/python/"}]},{"title":"pythonXML解析","slug":"pythonXML解析","date":"2017-12-30T09:30:00.000Z","updated":"2018-05-11T06:46:21.314Z","comments":true,"path":"2017/12/30/pythonXML解析/","link":"","permalink":"http://pythonfood.github.io/2017/12/30/pythonXML解析/","excerpt":"人生苦短，我用python。","text":"人生苦短，我用python。 一、XMLXML 指可扩展标记语言（eXtensible Markup Language），标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言。 常见的XML编程接口有DOM和SAX，这两种接口处理XML文件的方式不同，使用场合也不同。 python有三种方法解析XML：SAX(simple API for XML )，DOM(Document Object Model)，ElementTree。 后面用到的XML实例文件movies.xml内容如下：123456789101112131415161718192021222324252627282930313233&lt;collection shelf=&quot;New Arrivals&quot;&gt;&lt;movie title=&quot;Enemy Behind&quot;&gt; &lt;type&gt;War, Thriller&lt;/type&gt; &lt;format&gt;DVD&lt;/format&gt; &lt;year&gt;2003&lt;/year&gt; &lt;rating&gt;PG&lt;/rating&gt; &lt;stars&gt;10&lt;/stars&gt; &lt;description&gt;Talk about a US-Japan war&lt;/description&gt;&lt;/movie&gt;&lt;movie title=&quot;Transformers&quot;&gt; &lt;type&gt;Anime, Science Fiction&lt;/type&gt; &lt;format&gt;DVD&lt;/format&gt; &lt;year&gt;1989&lt;/year&gt; &lt;rating&gt;R&lt;/rating&gt; &lt;stars&gt;8&lt;/stars&gt; &lt;description&gt;A schientific fiction&lt;/description&gt;&lt;/movie&gt; &lt;movie title=&quot;Trigun&quot;&gt; &lt;type&gt;Anime, Action&lt;/type&gt; &lt;format&gt;DVD&lt;/format&gt; &lt;episodes&gt;4&lt;/episodes&gt; &lt;rating&gt;PG&lt;/rating&gt; &lt;stars&gt;10&lt;/stars&gt; &lt;description&gt;Vash the Stampede!&lt;/description&gt;&lt;/movie&gt;&lt;movie title=&quot;Ishtar&quot;&gt; &lt;type&gt;Comedy&lt;/type&gt; &lt;format&gt;VHS&lt;/format&gt; &lt;rating&gt;PG&lt;/rating&gt; &lt;stars&gt;2&lt;/stars&gt; &lt;description&gt;Viewable boredom&lt;/description&gt;&lt;/movie&gt;&lt;/collection&gt; 1、SAXSAX是流模式，边读边解析，占用内存小，解析快，缺点是我们需要自己处理事件。 SAX解析XML文档牵涉到两个部分:解析器和事件处理器。 解析器：负责读取XML文档,并向事件处理器发送事件,如元素开始跟元素结束事件; 事件处理器：则负责对事件作出相应,对传递的XML数据进行处理。 (1)ContentHandler类方法介绍1)characters(content)方法调用时机： 从行开始，遇到标签之前，存在字符，content的值为这些字符串。 从一个标签，遇到下一个标签之前， 存在字符，content的值为这些字符串。 从一个标签，遇到行结束符之前，存在字符，content的值为这些字符串。 2)startDocument()方法文档启动的时候调用。 3)endDocument()方法解析器到达文档结尾时调用。 4)startElement(name, attrs)方法遇到XML开始标签时调用，name是标签的名字，attrs是标签的属性值字典。 5)endElement(name)方法遇到XML结束标签时调用。 (2)make_parser方法创建一个新的解析器对象并返回。xml.sax.make_parser( [parser_list] ) parser_list : 可选参数，解析器列表 (3)parser方法创建一个SAX解析器并解析xml文档：xml.sax.parse( xmlfile, contenthandler[, errorhandler]) xmlfile : xml文件名 contenthandler : 必须是一个ContentHandler的对象 errorhandler : 如果指定该参数，errorhandler必须是一个SAX ErrorHandler对象 (4)parseString方法创建一个XML解析器并解析xml字符串：xml.sax.parseString(xmlstring, contenthandler[, errorhandler]) xmlstring : xml字符串 contenthandler : 必须是一个ContentHandler的对象 errorhandler : 如果指定该参数，errorhandler必须是一个SAX ErrorHandler对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import xml.saxclass MovieHandler( xml.sax.ContentHandler ): def __init__(self): self.CurrentData = &quot;&quot; self.type = &quot;&quot; self.format = &quot;&quot; self.year = &quot;&quot; self.rating = &quot;&quot; self.stars = &quot;&quot; self.description = &quot;&quot; # 元素开始调用 def startElement(self, tag, attributes): self.CurrentData = tag if tag == &quot;movie&quot;: print (&quot;*****Movie*****&quot;) title = attributes[&quot;title&quot;] print (&quot;Title:&quot;, title) # 元素结束调用 def endElement(self, tag): if self.CurrentData == &quot;type&quot;: print (&quot;Type:&quot;, self.type) elif self.CurrentData == &quot;format&quot;: print (&quot;Format:&quot;, self.format) elif self.CurrentData == &quot;year&quot;: print (&quot;Year:&quot;, self.year) elif self.CurrentData == &quot;rating&quot;: print (&quot;Rating:&quot;, self.rating) elif self.CurrentData == &quot;stars&quot;: print (&quot;Stars:&quot;, self.stars) elif self.CurrentData == &quot;description&quot;: print (&quot;Description:&quot;, self.description) self.CurrentData = &quot;&quot; # 读取字符时调用 def characters(self, content): if self.CurrentData == &quot;type&quot;: self.type = content elif self.CurrentData == &quot;format&quot;: self.format = content elif self.CurrentData == &quot;year&quot;: self.year = content elif self.CurrentData == &quot;rating&quot;: self.rating = content elif self.CurrentData == &quot;stars&quot;: self.stars = content elif self.CurrentData == &quot;description&quot;: self.description = content if ( __name__ == &quot;__main__&quot;): # 创建一个 XMLReader parser = xml.sax.make_parser() # turn off namepsaces parser.setFeature(xml.sax.handler.feature_namespaces, 0) # 重写 ContextHandler Handler = MovieHandler() parser.setContentHandler( Handler ) parser.parse(&quot;movies.xml&quot;) 2、DOMDOM会把整个XML读入内存，解析为树，因此占用内存大，解析慢，优点是可以任意遍历树的节点。 一个 DOM 的解析器在解析一个 XML 文档时，一次性读取整个文档，把文档中所有元素保存在内存中的一个树结构里，之后你可以利用DOM 提供的不同的函数来读取或修改文档的内容和结构，也可以把修改过的内容写入xml文件。 1234567891011121314151617181920212223242526from xml.dom.minidom import parseimport xml.dom.minidom# 使用minidom解析器打开 XML 文档DOMTree = xml.dom.minidom.parse(&quot;movies.xml&quot;)collection = DOMTree.documentElementif collection.hasAttribute(&quot;shelf&quot;): print (&quot;Root element : %s&quot; % collection.getAttribute(&quot;shelf&quot;))# 在集合中获取所有电影movies = collection.getElementsByTagName(&quot;movie&quot;)# 打印每部电影的详细信息for movie in movies: print (&quot;*****Movie*****&quot;) if movie.hasAttribute(&quot;title&quot;): print (&quot;Title: %s&quot; % movie.getAttribute(&quot;title&quot;)) type = movie.getElementsByTagName(&apos;type&apos;)[0] print (&quot;Type: %s&quot; % type.childNodes[0].data) format = movie.getElementsByTagName(&apos;format&apos;)[0] print (&quot;Format: %s&quot; % format.childNodes[0].data) rating = movie.getElementsByTagName(&apos;rating&apos;)[0] print (&quot;Rating: %s&quot; % rating.childNodes[0].data) description = movie.getElementsByTagName(&apos;description&apos;)[0] print (&quot;Description: %s&quot; % description.childNodes[0].data) 3、ElementTree与DOM相比，ET的速度更快，API使用更直接、方便。与SAX相比，ET.iterparse函数同样提供了按需解析的功能，不会一次性在内存中读入整个文档。ET的性能与SAX模块大致相仿，但是它的API更加高层次，用户使用起来更加便捷。 12345678910111213141516171819202122232425262728293031323334353637383940414243from xml.etree.ElementTree import parsef = open(r&quot;C:\\PlatformConfigure\\Configure\\VideoStreamingServerConfigure.xml&quot;)et = parse(f)root = et.getroot() # 获取根节点print(root)# 第一种遍历根节点的子元素（该方法要取消了，不推荐使用）childs = root.getchildren()for child in childs: print(child.tag)# 第二种遍历根节点的子元素for child in root: print(child.tag)# 查找当前节点的子元素print(root.find(&apos;LocalIP&apos;)) # 查找到第一个‘LocalIP’的元素print(root.findall(&apos;LocalIP&apos;)) # 查找到所有标签是‘LocalIP’的元素，得到的是一个列表print(root.iterfind(&apos;LocalIP&apos;)) # 查找到所有标签是‘LocalIP’的元素，得到的是迭代对象for e in root.iterfind(&apos;LocalIP&apos;): print(e.tag)# 列出所有节点元素for e in root.iter(): print(e.tag)# 查找指定标签的元素节点print(root.iter(&apos;LocalIP&apos;))# 查找孙子节点print(root.findall(&apos;connstr/*&apos;))print(root.findall(&apos;.//host&apos;)) # 查找任意层次下的指定节点元素print(root.findall(&apos;.//host/..&apos;)) # 查找任意层次下的指定节点元素的父元素print(root.findall(&apos;LocalIP[@age]&apos;)) # 查找包含age属性的LocalIP节点元素print(root.findall(&apos;LocalIP[@age=&quot;18&quot;]&apos;)) # 查找包含age属性值=18的LocalIP节点元素print(root.findall(&apos;connstr[host]&apos;)) # 查找包含host节点的connstr节点元素for host in root.findall(&apos;.//host&apos;): # 输出节点的值 print(host.text) 持续更新…","categories":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/tags/python/"}]},{"title":"pythonJSON解析","slug":"pythonJSON解析","date":"2017-12-30T09:00:00.000Z","updated":"2018-05-11T06:46:06.374Z","comments":true,"path":"2017/12/30/pythonJSON解析/","link":"","permalink":"http://pythonfood.github.io/2017/12/30/pythonJSON解析/","excerpt":"人生苦短，我用python。","text":"人生苦短，我用python。 一、json模块JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于ECMAScript的一个子集。 Python3 中可以使用json模块来对JSON数据进行编解码，它主要包含以下四个函数： json.dumps() ：将python数据对象转换为JSON格式的字符串 json.loads() ：将JSON编码的字符串转换为python的数据结构 json.dump() ：将python数据对象以JSON格式数据流的形式写入到文件 json.load() ：解析包含JSON编码的字符串的文件为python数据对象 Python编码为JSON类型转换对应表： Python JSON dict object list, tuple array str string int, float, int- &amp; float-derived Enums number True true False false None null JSON解码为Python类型转换对应表： JSON Python object dict array list string str number (int) int number (real) float true True false False null None 1、json.dumps()json.dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw) obj :python数据对象 skipkeys :当值为True时，若键不是以下类型（str, int, float, bool, None），则会略过，而不是触发错误 ensure_ascii :当值为True时，输出时会自动转义所有非ASCII字符 allow_nan :当值为True时，会将超过浮点数取值范围的数值自动对应于JAVASCRIPT的(NaN, Infinity, -Infinity)，否则会引发错误 sort_keys :当值为True时，输出结果会按键值排序 12345678910111213141516import json py_data = &#123; &apos;no&apos; : 1, &apos;name&apos; : &apos;baidu&apos;, &apos;url&apos; : &apos;http://www.baidu.com&apos;&#125;json_str = json.dumps(py_data)print (&quot;Python原始数据：&quot;, repr(py_data))print (&quot;JSON对象：&quot;, json_str)#输出结果：#Python原始数据： &#123;&apos;url&apos;: &apos;http://www.baidu.com&apos;, &apos;no&apos;: 1, &apos;name&apos;: &apos;baidu&apos;&#125;#JSON对象： &#123;&quot;url&quot;: &quot;http://www.baidu.com&quot;, &quot;no&quot;: 1, &quot;name&quot;: &quot;baidu&quot;&#125; 2、json.loads()json.loads(s, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw) s :包含JSON的字符串、字节以及字节数组 object_hook :将传入的字典解析后，再调用用户定义的钩子函数，最终返回钩子函数的返回值 1234567891011121314151617import jsonpy_data1 = &#123; &apos;no&apos; : 1, &apos;name&apos; : &apos;baidu&apos;, &apos;url&apos; : &apos;http://www.baidu.com&apos;&#125;json_str = json.dumps(py_data1)py_data2 = json.loads(json_str)print(&quot;py_data2[name]:&quot;, py_data2[&apos;name&apos;])print(&quot;py_data2[url]:&quot;, py_data2[&apos;url&apos;])#输出结果：#py_data2[&apos;name&apos;]: baidu#py_data2[&apos;url&apos;]: http://www.baidu.com 3、json.dump() 12345import json#Python数据对象以JSON格式写入文件with open(&apos;data.json&apos;, &apos;w&apos;) as f: json.dump(data, f) 4、json.load() 12345import json#读取JSON编码文件解析为Python数据with open(&apos;data.json&apos;, &apos;r&apos;) as f: data = json.load(f) 持续更新…","categories":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/tags/python/"}]},{"title":"python网络请求","slug":"python网络请求","date":"2017-12-30T08:30:00.000Z","updated":"2018-05-11T06:45:50.644Z","comments":true,"path":"2017/12/30/python网络请求/","link":"","permalink":"http://pythonfood.github.io/2017/12/30/python网络请求/","excerpt":"人生苦短，我用python。","text":"人生苦短，我用python。 一、requests模块使用前需安装requests库pip install requests。 requests库的七个主要方法： 方法 解释 requests.request() 构造一个请求，支持以下各种方法 requests.get() 获取html的主要方法 requests.head() 获取html头部信息的主要方法 requests.post() 向html网页提交post请求的方法 requests.put() 向html网页提交put请求的方法 requests.patch() 向html提交局部修改的请求 requests.delete() 向html提交删除请求 requests.request(method，url,**kwargs)构造一个服务器请求request： method: “GET”、”POST”、”HEAD”、”PUT”、”PATCH”、”DELETE” url: 请求的网址 **kwargs: 控制访问的参数 params：字典或字节序列， 作为参数增加到url中,使用这个参数可以把一些键值对以?key1=value1&amp;key2=value2的模式增加到url中例如：kv = {‘key1: ’ values’, ‘key2’: ‘values’}r = requests.request(‘GET’, ‘http:www.python123.io/ws’, params=kw) data：字典，字节序或文件对象，重点作为向服务器提供或提交资源是提交，，作为request的内容，与params不同的是，data提交的数据并不放在url链接里， 而是放在url链接对应位置的地方作为数据来存储。，它也可以接受一个字符串对象。 json：json格式的数据， json合适在相关的html，http相关的web开发中非常常见， 也是http最经常使用的数据格式， 他是作为内容部分可以向服务器提交。例如：kv = {”key1’: ‘value1’}r = requests.request(‘POST’, ‘http://python123.io/ws‘, json=kv) headers：字典是http的相关语，对应了向某个url访问时所发起的http的头i字段， 可以用这个字段来定义http的访问的http头，可以用来模拟任何我们想模拟的浏览器来对url发起访问。例子： hd = {‘user-agent’: ‘Chrome/10’}r = requests.request(‘POST’, ‘http://python123.io/ws‘, headers=hd) cookies：字典或CookieJar，指的是从http中解析cookie auth：元组，用来支持http认证功能 files：字典， 是用来向服务器传输文件时使用的字段。例子：fs = {‘files’: open(‘data.txt’, ‘rb’)}r = requests.request(‘POST’, ‘http://python123.io/ws‘, files=fs) timeout: 用于设定超时时间， 单位为秒，当发起一个get请求时可以设置一个timeout时间， 如果在timeout时间内请求内容没有返回， 将产生一个timeout的异常。 proxies：字典， 用来设置访问代理服务器。 allow_redirects: 开关， 表示是否允许对url进行重定向， 默认为True。 stream: 开关， 指是否对获取内容进行立即下载， 默认为True。 verify：开关， 用于认证SSL证书， 默认为True。 cert： 用于设置保存本地SSL证书路径 返回一个包含服务器资源的response对象，具有以下属性和方法： 属性 说明 r.status_code http请求的返回状态，若为200则表示请求成功。 r.text http响应内容的字符串形式，即返回的页面内容 r.encoding 从http header 中猜测的相应内容编码方式 r.apparent_encoding 从内容中分析出的响应内容编码方式（备选编码方式） r.content http响应内容的二进制形式 r.raw 返回原始响应体，使用r.raw.read()读取 r.headers 以字典对象存储服务器响应头，但是这个字典比较特殊，字典键不区分大小写，若键不存在则返回None r.json() Requests中内置的JSON解码器 r.raise_for_status() 失败请求(非200响应)抛出异常 1、发送请求 12345678910111213141516171819import requests#1.发送get请求res = requests.get(&quot;http://httpbin.org/get&quot;)#2.发送post请求res = requests.post(&quot;http://httpbin.org/post&quot;, data=&#123;&quot;key&quot;:&quot;value&quot;,...&#125;)#3.发送head请求res = requests.head(&quot;http://httpbin.org/get&quot;)#4.发送put请求res = requests.put(&quot;http://httpbin.org/put&quot;,data=&#123;&quot;key&quot;:&quot;value&quot;, ...&#125;)#5.发送delete请求res = requests.delete(&quot;http://httpbin.org/delete&quot;)#6.发送patch请求res = requests.patch(&quot;http://httpbin.org/get&quot;) 2、构造请求参数(1)get请求参数 12345678910import requestsdef function(): #1.请求参数 payload = &#123;&apos;key1&apos;:&apos;value1&apos;, &apos;key2&apos;:&apos;value2&apos;, &apos;key3&apos;:[&apos;value3&apos;,&apos;value4&apos;]&#125; #注意:请求值可以传入列表 #2.拼接url= http://httpbin.org/get?key1=value1&amp;key2=value2&amp;key3=value3&amp;key3=value4 res = requests.get(&quot;http://httpbin.org/get&quot;, params=payload) #注意：参数是params print(res.text) (2)post请求表单 12345678910111213import requestsdef function(): #1.表单数据 payload1 = &#123;&apos;key1&apos;:&apos;value1&apos;,&apos;key2&apos;:&apos;key2&apos;&#125; #注意：一键单值用字典 payload2 = &#123;(&apos;key1&apos;, &apos;value1&apos;), (&apos;key1&apos;, &apos;value2&apos;)&#125; #注意：一键多值用元组 #2.拼接url res1 = requests.post(&quot;http://httpbin.org/post&quot;,data=payload1) #注意：参数是data res2 = requests.post(&quot;http://httpbin.org/post&quot;,data=payload2) print(res1.text) print(res2.text) (3)post请求json 1234567def function(): #1.post提交json对象数据 payload = &#123;&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;&#125; #2.拼接url res = requests.post(&quot;http://httpbin.org/post&quot;,data=json.dumps(payload))# 方式一 res = requests.post(&quot;http://httpbin.org/post&quot;,json=payload)# 方式二 (4)构造请求头headers 123456789def function: #1.构造请求头 headers = &#123;&apos;user-agent&apos;:&apos;my-app/0.0.1&apos;&#125; #2.定义url url = &quot;https://api.github.com/some/endpoint&quot; #3.拼接url res = requests.get(url, headers=headers) (5)构造cookies请求 123456789def function(): #1.构造cookies cookies = dict(sessionId=&apos;Jsession3123131&apos;) #2.定义url url = &quot;http://httpbin.org/cookies&quot; #3.拼接url res = requests.get(url, cookies=cookies) (6)构造请求超时设置 1234def function() ## 设置请求超时：0.1秒没响应就请求超时失败 requests.get(&apos;http://github.com&apos;,timeout=0.1) (7)基本身份认证(HTTP Basic Auth) 12345678import requestsfrom requests.auth import HTTPBasicAuth#身份验证 r = requests.get(&apos;https://httpbin.org/hidden-basic-auth/user/passwd&apos;, auth=HTTPBasicAuth(&apos;user&apos;, &apos;passwd&apos;))# r = requests.get(&apos;https://httpbin.org/hidden-basic-auth/user/passwd&apos;, auth=(&apos;user&apos;, &apos;passwd&apos;)) # 简写print(r.json()) 3、响应内容 12345678910111213141516171819202122232425262728293031import requestsdef function() #发送请求 url = &quot;https://api.github.com/some/endpoint&quot; payload = &#123;&apos;key1&apos;:&apos;value1&apos;,&apos;key2&apos;:&apos;key2&apos;&#125; headers = &#123;&apos;user-agent&apos;:&apos;my-app/0.0.1&apos;&#125; cookies = dict(sessionId=&apos;Jsession3123131&apos;) res = requests.post(url,data=payload,headers=headers,cookies=cookies) #文本数据信息，大部分情况使用这个方法 text = res.text #原始二进制响应数据 content = res.content # json响应数据，通常我们使用json模块来处理 json_data = res.json() # 响应状态码 status_code= res.status_code # 响应头 headers = res.headers # 响应cookies cookies = res.cookies #使用响应对象的history方法来追踪重定向 res.history 二、urllib模块python内置http请求库urllib： urllib.request：用于访问和读取URLS urllib.error：包括了所有urllib.request导致的异常 urllib.parse：用于解析URLS urllib.robotparser：用于解析robots.txt文件（网络蜘蛛） 1、urllib.request(1)基本方法urllib.request.urlopen(url, data=None, [timeout, ]*, cafile=None, capath=None, cadefault=False, context=None) url: 需要打开的网址 data：Post提交的数据 timeout：设置网站的访问超时时间 urlopen返回对象提供方法： geturl()：返回请求的url，通常用于确定是否遵循重定向。 info()：返回HTTPMessage对象，表示远程服务器返回的头信息 getcode()：返回Http状态码。如果是http请求，200请求成功完成;404网址未找到 read() , readline() ,readlines() ：返回页面元素 fileno() , close() ：对HTTPResponse类型数据进行操作，这些方法的使用方式与文件对象完全一样 12345678from urllib import request page = request.urlopen(&quot;http://www.baidu.com/&quot;) print(page.info()) print(page.getURL()) print(page.getcode()) print(page.read()) (2)设置代理urllib.request.build_opener([handler, …])urllib.request.install_opener(opener) 做爬虫的时候，多都会用到代理IP的，步骤如下：1）利用urllib.request.ProxyHandler准备代理IP或者请求头。2）利用urllib.request.build_opener()封装代理IP或请求头。3）利用urllib.request.instanll_opener()安装成全局。4）利用urllib.request.urlopen访问网页。 123456789from urllib import request proxy_support = request.ProxyHandler(&#123;&apos;sock5&apos;: &apos;localhost:1080&apos;&#125;) opener = request.build_opener(proxy_support) request.install_opener(opener) a = request.urlopen(&quot;http://www.baidu.com/ &quot;).read().decode(&quot;utf8&quot;) print(a) (3)使用Requesturllib.request.Request(url, data=None, headers={}, method=None)使用request()来包装请求，再通过urlopen()获取页面。 12345678910111213from urllib import request url = r&apos;http://www.lagou.com/zhaopin/Python/?labelWords=label&apos; headers = &#123; &apos;User-Agent&apos;: r&apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) &apos; r&apos;Chrome/45.0.2454.85 Safari/537.36 115Browser/6.0.3&apos;, &apos;Referer&apos;: r&apos;http://www.lagou.com/zhaopin/Python/?labelWords=label&apos;, &apos;Connection&apos;: &apos;keep-alive&apos; &#125; req = request.Request(url, headers=headers) page = request.urlopen(req).read() page = page.decode(&apos;utf-8&apos;) 2、urllib.error常见的由urllib.request导致的异常: error.URLError: 是OSError的一个子类,URLError可能产生的原因: 网络无连接，即本机无法上网 连接不到特定的服务器 服务器不存在 error.HTTPError: 是URLError的一个子类,对于不能处理对象response的状态码，urlopen会产生一个HTTPError 101： 转换协议 在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。 102：继续处理 由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。 200：请求成功 处理方式：获得响应的内容，进行处理 201：请求完成，结果是创建了新资源。新创建资源的URI可在响应的实体中得到 处理方式：爬虫中不会遇到 202：请求被接受，但处理尚未完成 处理方式：阻塞等待 204：服务器端已经实现了请求，但是没有返回新的信 息。如果客户是用户代理，则无须为此更新自身的文档视图。 处理方式：丢弃 300：该状态码不被HTTP/1.0的应用程序直接使用， 只是作为3XX类型回应的默认解释。存在多个可用的被请求资源。 处理方式：若程序中能够处理，则进行进一步处理，如果程序中不能处理，则丢弃 301：请求到的资源都会分配一个永久的URL，这样就可以在将来通过该URL来访问此资源 处理方式：重定向到分配的URL 302：请求到的资源在一个不同的URL处临时保存 处理方式：重定向到临时的URL 304：请求的资源未更新 处理方式：丢弃 400：非法请求 处理方式：丢弃 401：未授权 处理方式：丢弃 403：禁止 处理方式：丢弃 404：没有找到 处理方式：丢弃 500：服务器内部错误 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。 501：服务器无法识别 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。 502：错误网关 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。 503：服务出错 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。 12345678910111213141516from urllib import requestfrom urllib import errorif __name__ == &quot;__main__&quot;: #一个不存在的连接 url = &quot;http://www.test1.com/test2.html&quot; req = request.Request(url) try: responese = request.urlopen(req) # html = responese.read() #想用HTTPError和URLError一起捕获异常,需要将HTTPError放在URLError的前面 except error.HTTPError as e: print(e.code) except error.URLError as e: print(e.reason) 3、urllib.parse(1)urllib.parse.urlparse(urlstring, scheme=”, allow_fragments=True)用于将一个URL解析成六个部分，返回一个元组，URL的格式为：scheme://netloc/path;parameters?query#fragment 以下为返回的元组元素： 元素 编号 值 值不存在时默认值 scheme 0 请求 一定存在 netloc 1 网址 空字符串 path 2 分层路径 空字符串 params 3 参数 空字符串 query 4 查询组件 空字符串 fragment 5 标识符 空字符串 username 用户名 None password 密码 None hostname 主机名 None port 端口号 None 1234567from urllib import parseo = parse.urlparse(&apos;http://www.cwi.nl:80/%7Eguido/Python.html&apos;)print(o)#对应结果：ParseResult(scheme=&apos;http&apos;, netloc=&apos;www.cwi.nl:80&apos;, path=&apos;/%7Eguido/Python.html&apos;, params=&apos;&apos;, query=&apos;&apos;, fragment=&apos;&apos;) (2)urllib.parse.urljoin(base, url, allow_fragments=True)用于将一个基本的URL和其他的URL组装成成一个完成的URL。 1234567from urllib import parsea=arse.urljoin(&apos;http://www.cwi.nl/%7Eguido/Python.html&apos;, &apos;FAQ.html&apos;)print(a)#对应结果:http://www.cwi.nl/%7Eguido/FAQ.html (3)urllib.parse.urlencode(query, doseq=False, safe=&#39;&#39;, encoding=None, errors=None)urlencode()主要作用就是将url附上要提交的数据。 1234567891011from urllib import parsedata = &#123; &apos;first&apos;: &apos;true&apos;, &apos;pn&apos;: 1, &apos;kd&apos;: &apos;Python&apos; &#125; data = parse.urlencode(data).encode(&apos;utf-8&apos;)#经过urlencode()转换后的data数据为?first=true?pn=1?kd=Python#最后提交的url为http://www.lagou.com/jobs/positionAjax.json?first=true?pn=1?kd=Python 4、urllib.robotparserrobotparser为robots.txt文件实现了一个解释器，可以用来读取robots文本的格式和内容，用函数方法检查给定的User-Agent是否可以访问相应的网站资源。如果要编写一个网络蜘蛛，这个模块可以限制一些蜘蛛抓取无用的或者重复的信息，避免蜘蛛掉入动态asp/php网页程序的死循环中。 简单的来说，robots.txt文件是每个网站都应该有的，指引蜘蛛抓取和禁止抓取的一个文本格式的文件，一些合法的蜘蛛或者叫爬虫，都是遵守这个规则的，可以控制他们的访问。 5、GET请求 12345678910111213import urllib.request import urllib.parse data = &#123;&#125; data[&apos;word&apos;] = &apos;python3&apos; url_values = urllib.parse.urlencode(data) url = &quot;http://www.baidu.com/s?&quot; full_url = url + url_values data = urllib.request.urlopen(full_url).read() z_data = data.decode(&apos;UTF-8&apos;) print(z_data) 6、POST数据urllib.request.urlopen(url, data=None, [timeout, ]*, cafile=None, capath=None, cadefault=False, context=None)urlopen()的data参数默认为None，当data参数不为空的时候，urlopen()提交方式为Post。 12345678910111213141516171819202122import urllib.request import urllib.parseurl = r&apos;http://www.lagou.com/jobs/positionAjax.json?&apos; headers = &#123; &apos;User-Agent&apos;: r&apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) &apos; r&apos;Chrome/45.0.2454.85 Safari/537.36 115Browser/6.0.3&apos;, &apos;Referer&apos;: r&apos;http://www.lagou.com/zhaopin/Python/?labelWords=label&apos;, &apos;Connection&apos;: &apos;keep-alive&apos; &#125; data = &#123; &apos;first&apos;: &apos;true&apos;, &apos;pn&apos;: 1, &apos;kd&apos;: &apos;Python&apos; &#125; data = parse.urlencode(data).encode(&apos;utf-8&apos;) #Post的数据必须是bytes或者iterable of bytes，不能是str，因此需要进行encode()编码req = request.Request(url, headers=headers, data=data) page = request.urlopen(req).read() page = page.decode(&apos;utf-8&apos;) print(page) 持续更新…","categories":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/tags/python/"}]},{"title":"python数据库","slug":"python数据库","date":"2017-12-30T08:00:00.000Z","updated":"2018-05-16T06:24:56.962Z","comments":true,"path":"2017/12/30/python数据库/","link":"","permalink":"http://pythonfood.github.io/2017/12/30/python数据库/","excerpt":"人生苦短，我用python。","text":"人生苦短，我用python。 一、pymysql模块PyMySQL是在Python3.x版本中用于连接MySQL服务器的一个库。 1、pymysql安装(1)pip命令安装 pip install PyMySQL (2)git命令下载安装 123$ git clone https://github.com/PyMySQL/PyMySQL$ cd PyMySQL/$ python3 setup.py install (3)curl命令制定版本号 123$ curl -L https://github.com/PyMySQL/PyMySQL/tarball/pymysql-X.X | tar xz$ cd PyMySQL* # 安装完可以删除PyMySQL*目录$ python3 setup.py install 2、数据库连接使用数据库之前确保创建了数据库testdb，用户名”root”，密码”123456”。 123456789101112131415161718import pymysql#1.使用connect()方法连接数据库db = pymysql.connect(host=&apos;localhost&apos;,port=3306,user=&apos;root&apos;,password=&apos;123456&apos;,database=&apos;testdb&apos;,charset=&apos;utf8&apos;)#2.使用cursor()方法创建游标对象cursor = db.cursor()#3.使用execute()方法执行SQL语句cursor.execute(&apos;SELECT VERSION()&apos;)#4.使用fetchone()方法获取表单数据data = cursor.fetchone()print(&quot;Database version : s%&quot; % data)#5.使用close()方法关闭数据库连接db.close() 3、创建数据库表execute()方法执行sql语句为数据库创建表。 123456789101112131415161718192021import pymysql#1.使用connect()方法连接数据库db = pymysql.connect(host=&apos;localhost&apos;,port=3306,user=&apos;root&apos;,password=&apos;123456&apos;,database=&apos;testdb&apos;,charset=&apos;utf8&apos;)#2.使用cursor()方法创建游标对象cursor = db.cursor()#3.如果user表已经存在，先删除cursor.execute(&quot;DROP TABLE IF EXISTS user&quot;)#4.使用预处理语句创建user表sql = &quot;&quot;&quot;CREATE TABLE user( NAME CHAR(20) NOT NULL, AGE INT, SEX CHAR(1), INCOME FLOAT)&quot;&quot;&quot;cursor.execute(sql)#5.使用close()方法关闭数据库连接db.close() 4、数据库插入操作 123456789101112131415161718192021import pymysql#1.使用connect()方法连接数据库db = pymsql.connect(host=&apos;localhost&apos;,port=3306,user=&apos;root&apos;,password=&apos;123456&apos;,database=&apos;testdb&apos;,charset=&apos;utf8&apos;)#2.使用cursor()方法创建游标对象cursor = db.cursor()#3.sql插入语句sql = &quot;&quot;&quot;INSERT INTO user(NAME,AGE,SEX,INCOME) VALUES(&apos;Jac&apos;,&apos;20&apos;,&apos;M&apos;,2000)&quot;&quot;&quot; #4.执行sql插入操作try: cursor.execute(sql) db.commit() #注意：提交到数据库执行except: db.rollback() #注意：如果发生错误则回滚#5.使用close()方法关闭数据库连接 db.close() ps:可以使用变量向SQL语句中传递参数 12345user_id = &quot;test1&quot;password = &quot;123456&quot;con.execute(&apos;insert into Login values(&quot;%s&quot;, &quot;%s&quot;)&apos; % \\ (user_id, password)) 5、数据库删除操作 1234567891011121314151617181920import pymysql#1.使用connect()方法连接数据库db = pymsql.connect(host=&apos;localhost&apos;,port=3306,user=&apos;root&apos;,password=&apos;123456&apos;,database=&apos;testdb&apos;,charset=&apos;utf8&apos;)#2.使用cursor()方法创建游标对象cursor = db.cursor()#3.sql删除语句sql = &quot;DELETE FROM user WHERE AGE &gt; &apos;%d&apos;&quot; % (20)#4.执行sql删除操作try: cursor.execute(sql) db.commit() #注意：提交到数据库执行except: db.rollback() #注意：如果发生错误则回滚#5.使用close()方法关闭数据库连接 db.close() 6、数据库更新操作 1234567891011121314151617181920import pymysql#1.使用connect()方法连接数据库db = pymysql.connect(host=&apos;localhost&apos;,port=3306,user=&apos;root&apos;,password=&apos;123456&apos;,database=&apos;testdb&apos;,charset=&apos;utf8&apos;)#2.使用cursor()方法创建游标对象cursor = db.cursor()#3.sql删除语句sql = &quot;UPDATE user SET AGE = AGE + 1 WHERE SEX = &apos;%c&apos;&quot; % (&apos;W&apos;)#4.执行sql删除操作try: cursor.execute(sql) db.commit() #注意：提交到数据库执行except: db.rollback() #注意：如果发生错误则回滚 #5.使用close()方法关闭数据库连接 db.close() 7、数据库查询操作使用fetchone()方法获取单条数据, 使用fetchall()方法获取多条数据。 fetchone(): 该方法获取下一个查询结果集。结果集是一个对象。 fetchall(): 接收全部的返回结果行。 rowcount: 这是一个只读属性，并返回执行execute()方法后影响的行数。 12345678910111213141516171819202122232425262728import pymysql#1.使用connect()方法连接数据库db = pymysql.connect(host=&apos;localhost&apos;,port=3306,user=&apos;root&apos;,password=&apos;123456&apos;,database=&apos;testdb&apos;,charset=&apos;utf8&apos;)#2.使用cursor()方法创建游标对象cursor = db.cursor()#3.sql查询语句sql = &quot;SELECT * FROM user \\ WHERE INCOME &gt; &apos;%d&apos;&quot; % (1000)#4.执行sql查询操作 try: cursor.execute(sql) results = cursor.fetchall() #查询所有记录列表 for row in results: name = row[0] age = row[1] sex = row[2] income = row[3] print(&quot;name=%s,age=%s,sex=%s,income=%d&quot; % \\ (name, age, sex, income)) #打印结果except: print(&apos;Error: unable to fetch data&apos;) #5.使用close()方法关闭数据库连接 db.close() 8、执行事务事务机制可以确保数据一致性。 事务具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。 原子性（atomicity）：一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。 一致性（consistency）：事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。 隔离性（isolation）：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性（durability）：持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。 Python DB API 2.0的事务提供了两个方法commit()或rollback()。 123456sql = &quot;DELETE FROM user WHERE INCOME &gt; &apos;%d&apos;&quot; % (1000)try: cursor.execute(sql) # 执行SQL语句 db.commit()# commit() # 方法游标的所有更新操作except: db.rollback() # rollback() # 方法回滚当前游标的所有操作 9、错误处理 异常 描述 Warning 当有严重警告时触发，例如插入数据是被截断等等。必须是 StandardError 的子类。 Error 警告以外所有其他错误类。必须是 StandardError 的子类。 InterfaceError 当有数据库接口模块本身的错误（而不是数据库的错误）发生时触发。 必须是Error的子类。 DatabaseError 和数据库有关的错误发生时触发。 必须是Error的子类。 DataError 当有数据处理时的错误发生时触发，例如：除零错误，数据超范围等等。 必须是DatabaseError的子类。 OperationalError 指非用户控制的，而是操作数据库时发生的错误。例如：连接意外断开、 数据库名未找到、事务处理失败、内存分配错误等等操作数据库是发生的错误。 必须是DatabaseError的子类。 IntegrityError 完整性相关的错误，例如外键检查失败等。必须是DatabaseError子类。 InternalError 数据库的内部错误，例如游标（cursor）失效了、事务同步失败等等。 必须是DatabaseError子类。 ProgrammingError 程序错误，例如数据表（table）没找到或已存在、SQL语句语法错误、 参数数量错误等等。必须是DatabaseError的子类。 NotSupportedError 不支持错误，指使用了数据库不支持的函数或API等。例如在连接对象上 使用.rollback()函数，然而数据库并不支持事务或者事务已关闭。 必须是DatabaseError的子类。 二、sqlite3模块SQLite是C写的一种嵌入式数据库，它的数据库就是一个文件，体积很小，经常被集成到各种应用程序中。Python内置SQLite3，使用SQLite不需要安装任何东西，直接使用。 创建数据库的连接，如果数据库不存在，连接对象会自动创建数据库文件；如果数据库存在，则连接对象直接打开该数据库文件。连接对象可以是硬盘上面的数据库文件，也可以是建立在内存中的： 创建在硬盘上面： conn = sqlite3.connect(&#39;c:\\\\test\\\\test.db&#39;) 创建在内存上面： conn = sqlite3.connect(&#39;&quot;memory:&#39;) 其中conn对象是数据库链接对象，具有以下操作： cursor() : 创建一个游标 commit() : 事务提交 rollback() : 事务回滚 close() : 关闭数据库链接 创建了一个游标对象 ：cu = conn.cursor()，具有以下具体操作： execute() : 执行一条sql语句 executemany() : 执行多条sql语句 close() : 游标关闭 fetchone() : 从结果中取出一条记录 fetchmany() : 从结果中取出多条记录 fetchall() : 从结果中取出所有记录 scroll() : 游标滚动 12345678910111213141516171819202122232425import sqlite3 #创建数据库 conn = sqlite3.connect(&apos;test.db&apos;) #创建游标 cur = conn.cursor() #创建数据表cur.execute(&apos;create table t(id int,v varchar(20));&apos;); #数据库操作cur.execute(&quot;insert into t values(%d,&apos;%s&apos;)&quot; % (1,&apos;xxx&apos;)) cur.execute(&quot;insert into t values(%d,&apos;%s&apos;)&quot; % (2,&apos;yyy&apos;)) cur.execute(&quot;update t set v = &apos;%s&apos; where id = %d&quot; % (&apos;zzz&apos;,2)) cur.execute(&quot;select * from t;&quot;) #打印结果 results = cur.fetchall() for row in results: print(row) #事务提交conn.commit() #关闭游标 cur.close() #关闭数据库连接 conn.close() 持续更新…","categories":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/tags/python/"}]},{"title":"python发送邮件","slug":"python发送邮件","date":"2017-12-30T07:30:00.000Z","updated":"2018-05-11T06:45:18.563Z","comments":true,"path":"2017/12/30/python发送邮件/","link":"","permalink":"http://pythonfood.github.io/2017/12/30/python发送邮件/","excerpt":"人生苦短，我用python。","text":"人生苦短，我用python。 一、email模块SMTP是发送邮件的协议，Python对SMTP支持有email和smtplib两个模块，email负责构造邮件，smtplib负责发送邮件。 email.header.Header(s=None, charset=None, maxlinelen=None, header_name=None, continuation_ws=&#39; &#39;, errors=&#39;strict&#39;)：邮件头 s：标头的值，也就是对应From、To、Subject的值。 charset：字符集格式，默认是ASCII，但是一般指定UTF-8格式以兼容更多字符。 header_name: 标头名，就是From、To、Subject、Time等； email.mime.base.MIMEBase(_maintype, _subtype, **_params)：这是MIME的一个基类。一般不需要在使用时创建实例。 _maintype：是内容类型,如text或者image。 _subtype：是内容的minor type类型，如plain或者gif。 **_params：是一个字典，直接传递给Message.add_header()。 email.mime.multipart.MIMEMultipart([_subtype[, boundary[, _subparts[, _params]]]]：MIMEBase的一个子类,多个MIME对象的集合。 _subtype：默认值为mixed。 boundary：是MIMEMultipart的边界,默认边界是可数的。 email.mime.APPLICATION.MIMEApplication(_data[, _subtype[, _encoder[, **_params]]])：MIMEMultipart的一个子类。 email.mime.audio. MIMEAudio(_audiodata[, _subtype[, _encoder[, **_params]]])：MIME音频对象。 email.mime.image.MIMEImage(_imagedata[, _subtype[, _encoder[, **_params]]])：MIME二进制文件对象。 email.mime.text.MIMEText(_text[,_subtype[,_charset]])：MIME文本对象。 _text：是邮件内容, _subtype：邮件类型,可以是text/plain(普通文本邮件),html/plain(html邮件)。 charset：编码,可以是gb2312等等。 email.mime.message.MIMEMessage(_msg[, _subtype])：具体的一个message实例。 msg=mail.Message.Message() # 一个实例 msg[&#39;from&#39;]=&#39;me@xxx.com&#39; # 自己的邮件地址 msg[&#39;to&#39;]=&#39;friend@xxx.com&#39; # 发送到哪里 msg[&#39;date&#39;]=&#39;2012-3-16&#39; # 时间日期 msg[&#39;subject&#39;]=&#39;helloworld&#39; # 邮件主题 二、smtplib模块SMTP是发送邮件的协议，Python对SMTP支持有email和smtplib两个模块，email负责构造邮件，smtplib负责发送邮件。 smtplib.SMTP([host[, port[, local_hostname[, timeout]]]])：SMTP类构造函数,表示与SMTP服务器之间的连接,通过这个连接可以向smtp服务器发送指令,执行相关操作(如:登陆、发送邮件)。所有参数都是可选的。 host：smtp服务器主机名 port：smtp服务的端口,默认是25;如果在创建SMTP对象的时候提供了这两个参数,在初始化的时候会自动调用connect方法去连接服务器。 smtplib.SMTP提供的方法: SMTP.set_debuglevel(level)：设置是否为调试模式。默认为False,即非调试模式,表示不输出任何调试信息。 SMTP.connect([host[, port]])：连接到指定的smtp服务器。参数分别表示smpt主机和端口。注意: 也可以在host参数中指定端口号(如:smpt.yeah.net:25),这样就没必要给出port参数。 SMTP.docmd(cmd[, argstring])：向smtp服务器发送指令。可选参数argstring表示指令的参数。 SMTP.helo([hostname])：使用”helo”指令向服务器确认身份。相当于告诉smtp服务器“我是谁”。 SMTP.has_extn(name)：判断指定名称在服务器邮件列表中是否存在。出于安全考虑,smtp服务器往往屏蔽了该指令。 SMTP.verify(address)：判断指定邮件地址是否在服务器中存在。出于安全考虑,smtp服务器往往屏蔽了该指令。 SMTP.login(user, password)：登陆到smtp服务器。现在几乎所有的smtp服务器,都必须在验证用户信息合法之后才允许发送邮件。 SMTP.sendmail(from_addr, to_addrs, msg[, mail_options, rcpt_options])：发送邮件。这里要注意一下第三个参数,msg是字符串,表示邮件。我们知道邮件一般由标题,发信人,收件人,邮件内容,附件等构成,发送邮件的时候,要注意msg的格式。这个格式就是smtp协议中定义的格式。 SMTP.quit()：断开与smtp服务器的连接,相当于发送”quit”指令。(很多程序中都用到了smtp.close()) 三、发送邮件1、发送文本邮件 12345678910111213141516171819202122232425from email.header import Headerfrom email.mime.text import MIMETextimport smtplib#一.构建邮件内容信息message = MIMEText(&apos;邮件正文测试...此处省略一万字&apos;, &apos;plain&apos;, &apos;utf-8&apos;) #1.邮件正文，plain表示普通文本message[&apos;Subject&apos;] = Header(&apos;邮件标题测试&apos;, &apos;utf-8&apos;) #2.邮件标题，中文用Header编码message[&apos;From&apos;] = Header(&apos;发件人的名称测试&apos;, &apos;utf-8&apos;) #3.发件人名称message[&apos;To&apos;] = Header(&apos;收件人名称测试&apos;, &apos;utf-8&apos;) #4.收件人名称#二.定义邮件服务器信息mail_host = &apos;smpt.xxx.com&apos; #1.邮件服务器mail_user = &apos;username&apos; #2.登录服务器的用户名mail_pass = &apos;password&apos; #3.登录服务器的密码#三.定义发件人和收件人sender = &apos;me@163.com&apos; #1.发件人邮箱receivers = [&apos;friend@126.com&apos;] #2.收件人邮箱，注意可以是列表#四.邮件服务器发送邮件smtp_server = smtplib.SMTP() #1.声明邮件服务器smtp_server.connect(mail_host, 25) #2.连接服务器，端口25smtp_server.login(mail_user, mail_pass) #3.登录服务器smtp_server.sendmail(sender, receivers, message.as_string()) #4.服务器发送邮件smtp_server.quit() #5.退出服务器 2、发送html邮件 123456789101112131415161718192021222324252627282930from email.header import Headerfrom email.mime.text import MIMETextimport smtplib#一.构建邮件内容信息#定义html格式内容msg_html = &quot;&quot;&quot;&lt;p&gt;邮件正文测试...此处省略一万字&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.baidu.com&quot;&gt;点击进入百度&lt;/a&gt;&lt;/p&gt;&quot;&quot;&quot;message = MIMEText(msg_html, &apos;html&apos;, &apos;utf-8&apos;) #1.邮件正文，html表示html格式message[&apos;Subject&apos;] = Header(&apos;邮件标题测试&apos;, &apos;utf-8&apos;) #2.邮件标题，中文用Header编码message[&apos;From&apos;] = Header(&apos;发件人的名称测试&apos;, &apos;utf-8&apos;) #3.发件人名称message[&apos;To&apos;] = Header(&apos;收件人名称测试&apos;, &apos;utf-8&apos;) #4.收件人名称#二.定义邮件服务器信息mail_host = &apos;smpt.xxx.com&apos; #1.邮件服务器mail_user = &apos;username&apos; #2.登录服务器的用户名mail_pass = &apos;password&apos; #3.登录服务器的密码#三.定义发件人和收件人邮箱sender = &apos;me@163.com&apos; #1.发件人邮箱receivers = [&apos;friend@126.com&apos;] #2.收件人邮箱，注意可以是列表#四.邮件服务器发送邮件smtp_server = smtplib.SMTP() #1.声明邮件服务器smtp_server.connect(mail_host, 25) #2.连接服务器，端口25smtp_server.login(mail_user, mail_pass) #3.登录服务器smtp_server.sendmail(sender, receivers, message.as_string()) #4.服务器发送邮件smtp_server.quit() #5.退出服务器 3、发送带附件邮件 1234567891011121314151617181920212223242526272829303132333435from email.header import Headerfrom email.mime.text import MIMETextfrom email.mime.multipart import MIMEMultipartimport smtplib#一.构建带附件的实例message = MIMEMultipart() #1.带附件实例message[&apos;Subject&apos;] = Header(&apos;邮件标题测试&apos;, &apos;utf-8&apos;) #2.邮件标题，中文用Header编码message[&apos;From&apos;] = Header(&apos;发件人的名称测试&apos;, &apos;utf-8&apos;) #3.发件人名称message[&apos;To&apos;] = Header(&apos;收件人名称测试&apos;, &apos;utf-8&apos;) #4.收件人名称#二、增加邮件正文内容message.attach(MIMEText(&apos;邮件正文测试...此处省略一万字&apos;, &apos;plain&apos;, &apos;utf-8&apos;)) #1.邮件正文，plain表示普通文本#三、添加附件with open(&apos;/Users/tester/Downloads/test.xlsx&apos;, &apos;rb&apos;) as xlsxpart: #1.用with打开，防止不能关闭文件 att = MIMEText(xlsxpart.read(), &apos;base64&apos;, &apos;utf-8&apos;) #2.定义附件 att.add_header(&apos;Content-Disposition&apos;, &apos;attachment&apos;, filename=&apos;test.xlsx&apos;) #3.添加必要的头信息 message.attach(att) #4.添加附件#四.定义邮件服务器信息mail_host = &apos;smpt.xxx.com&apos; #1.邮件服务器mail_user = &apos;username&apos; #2.登录服务器的用户名mail_pass = &apos;password&apos; #3.登录服务器的密码#五.定义发件人和收件人sender = &apos;me@163.com&apos; #1.发件人邮箱receivers = [&apos;friend@126.com&apos;] #2.收件人邮箱，注意可以是列表#六.邮件服务器发送邮件smtp_server = smtplib.SMTP() #1.声明邮件服务器smtp_server.connect(mail_host, 25) #2.连接服务器，端口25smtp_server.login(mail_user, mail_pass) #3.登录服务器smtp_server.sendmail(sender, receivers, message.as_string()) #4.服务器发送邮件smtp_server.quit() #5.退出服务器 4、发送带图片邮件按照发送附件的方式，先把邮件作为附件添加进去，然后，在HTML中通过引用src=&quot;cid:0&quot;就可以把附件作为图片嵌入了。如果有多个图片，给它们依次编号，然后引用不同的cid:x即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from email.header import Headerfrom email.mime.text import MIMETextfrom email.mime.image import MIMEImagefrom email.mime.multipart import MIMEMultipartimport smtplib#一.构建带附件的实例msgroot = MIMEMultipart(&apos;relate&apos;) #1.带附件实例,relate可以存储图片msgroot[&apos;Subject&apos;] = Header(&apos;邮件标题测试&apos;, &apos;utf-8&apos;) #2.邮件标题，中文用Header编码msgroot[&apos;From&apos;] = Header(&apos;发件人的名称测试&apos;, &apos;utf-8&apos;) #3.发件人名称msgroot[&apos;To&apos;] = Header(&apos;收件人名称测试&apos;, &apos;utf-8&apos;) #4.收件人名称#二、构建超文本实例msgAlternative = MIMEMultipart(&apos;alternative&apos;) #1.arternative邮件可以同时存在纯文本和超文本内容msgRoot.attach(msgAlternative) #2.添加到附件实例#三、超文本实例添加html内容#html内容，图片cid定义image1msg_html = &quot;&quot;&quot;&lt;p&gt;邮件正文测试...此处省略一万字&lt;/p&gt;&lt;p&gt;图片展示:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;cid:image1&quot;&gt;&lt;/p&gt;&quot;&quot;&quot;msgAlternative.attach(MIMEText(msg_html, &apos;html&apos;, &apos;utf-8&apos;)) #添加html内容到超文本实例#四、附件实例添加邮件正文内容msgRoot.attach(MIMEText(&apos;邮件正文测试...此处省略一万字&apos;, &apos;plain&apos;, &apos;utf-8&apos;)) #1.邮件正文，plain表示普通文本#五、添加图片附件with open(&apos;/Users/tester/Downloads/test.png&apos;, &apos;rb&apos;) as imagepart: #1.用with打开，防止不能关闭文件 att = MIMEImage(imagepart.read(), &apos;base64&apos;, &apos;utf-8&apos;) #2.定义附件 att.add_header(&apos;Content-Disposition&apos;, &apos;attachment&apos;, filename=&apos;test.png&apos;) #3.添加必要的头信息 att.add_header(&apos;Content-ID&apos;, &apos;&lt;image1&gt;&apos;) #4.头信息添加图片cid msgRoot.attach(att) #5.添加附件#六.定义邮件服务器信息mail_host = &apos;smpt.xxx.com&apos; #1.邮件服务器mail_user = &apos;username&apos; #2.登录服务器的用户名mail_pass = &apos;password&apos; #3.登录服务器的密码#七.定义发件人和收件人sender = &apos;me@163.com&apos; #1.发件人邮箱receivers = [&apos;friend@126.com&apos;] #2.收件人邮箱，注意可以是列表#八.邮件服务器发送邮件smtp_server = smtplib.SMTP() #1.声明邮件服务器smtp_server.connect(mail_host, 25) #2.连接服务器，端口25smtp_server.login(mail_user, mail_pass) #3.登录服务器smtp_server.sendmail(sender, receivers, msgRoot.as_string()) #4.服务器发送邮件smtp_server.quit() #5.退出服务器 持续更新…","categories":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/tags/python/"}]},{"title":"python多进程","slug":"python多进程","date":"2017-12-30T07:00:00.000Z","updated":"2018-05-11T06:45:00.092Z","comments":true,"path":"2017/12/30/python多进程/","link":"","permalink":"http://pythonfood.github.io/2017/12/30/python多进程/","excerpt":"人生苦短，我用python。","text":"人生苦短，我用python。 一、进程 定义方面：进程是程序在某个数据集合上的一次运行活动；线程是进程中的一个执行路径。 角色方面：在支持线程机制的系统中，进程是系统资源分配的单位，线程是系统调度的单位。 资源共享方面：进程之间不能共享资源，而线程共享所在进程的地址空间和其它资源。同时线程还有自己的栈和栈指针，程序计数器等寄存器。 独立性方面：进程有自己独立的地址空间，而线程没有，线程必须依赖于进程而存在。 二、multiprocessing模块multiprocessing模块用来开启子进程，并在子进程中执行我们定制的任务（比如函数），该模块与多线程模块threading的编程接口类似。 multiprocessing模块的功能众多：支持子进程、通信和共享数据、执行不同形式的同步，提供了Process、Queue、Pipe、Lock等组件。 需要再次强调的一点是：与线程不同，进程没有任何共享状态，进程修改的数据，改动仅限于该进程内。 1、Process类Process类用来描述一个进程对象。创建子进程的时候，只需要传入一个执行函数和函数的参数即可完成Process实例的创建。Process([group [, target [, name [, args [, kwargs]]]]]) 参数介绍： group：参数未使用，值始终为None target：表示调用对象，即子进程要执行的任务 args：表示调用对象的位置参数元组，args=(1,2,’hexin’,) kwargs：表示调用对象的字典,kwargs={‘name’:’hexin’,’age’:18} name：为子进程的名称 方法介绍 p.start()：启动进程，并调用该子进程中的p.run() p.run():进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法 p.terminate():强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁 p.is_alive():如果p仍然运行，返回True p.join([timeout]):主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程 属性介绍 p.daemon：默认值为False，如果设为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须在p.start()之前设置 p.name: 进程的名称 p.pid：进程的pid p.exitcode: 进程在运行时为None、如果为–N，表示被信号N结束(了解即可) p.authkey: 进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可） 2、创建进程(1)用multiprocessing.multiprocessing直接创建进程 1234567891011121314151617181920import timeimport randomfrom multiprocessing import Processdef hello(name): print(&apos;%s hello&apos; %name) time.sleep(random.randrange(1,5)) print(&apos;%s bye end&apos; %name)if __name__ == &apos;__main__&apos;: p1=Process(target=hello,args=(&apos;e&apos;,)) p2=Process(target=hello,args=(&apos;a&apos;,)) p3=Process(target=hello,args=(&apos;w&apos;,)) p4=Process(target=hello,args=(&apos;y&apos;,)) p1.start() p2.start() p3.start() p4.start() print(&apos;主线程&apos;) (2)通过继承multiprocessing.multiprocessing类来创建线程 1234567891011121314151617181920212223242526mport timeimport randomfrom multiprocessing import Processclass Hello(Process): def __init__(self,name): super().__init__() self.name=name def run(self): print(&apos;%s hello&apos; %self.name) time.sleep(random.randrange(1,5)) print(&apos;%s bye&apos; %self.name)if __name__ == &apos;__main__&apos;: p1=Hello(&apos;e&apos;) p2=Hello(&apos;a&apos;) p3=Hello(&apos;w&apos;) p4=Hello(&apos;y&apos;) p1.start() #start会自动调用run p2.start() p3.start() p4.start() print(&apos;主线程&apos;) 三、进程同步进程之间数据不共享,但是共享同一套文件系统,所以访问同一个文件,或同一个打印终端,是没有问题的。 用文件共享数据，加锁的是为了保证多个进程修改同一块数据时，同一时间只能有一个修改，即串行的修改，牺牲了速度而保证了数据安全。 multiprocessing.Lock 123456789101112131415161718192021222324252627282930313233343536#文件当做数据库，模拟抢票（Lock互斥锁）#文件db的内容为：&#123;&quot;count&quot;:2&#125;#注意一定要用双引号，不然json无法识别from multiprocessing import Process,Lockimport jsonimport timeimport randomimport osdef work(filename,lock): #买票 # lock.acquire() with lock: with open(filename,encoding=&apos;utf-8&apos;) as f: dic=json.loads(f.read()) # print(&apos;剩余票数: %s&apos; % dic[&apos;count&apos;]) if dic[&apos;count&apos;] &gt; 0: dic[&apos;count&apos;]-=1 time.sleep(random.randint(1,3)) #模拟网络延迟 with open(filename,&apos;w&apos;,encoding=&apos;utf-8&apos;) as f: f.write(json.dumps(dic)) print(&apos;%s 购票成功&apos; %os.getpid()) else: print(&apos;%s 购票失败&apos; %os.getpid()) # lock.release()if __name__ == &apos;__main__&apos;: lock=Lock() p_l=[] for i in range(10): p=Process(target=work,args=(&apos;db&apos;,lock)) p_l.append(p) p.start() for p in p_l: p.join() print(&apos;主线程&apos;) 四、进程池Pool可以提供指定数量的进程供用户使用，默认是CPU核数。当有新的请求提交到Poll的时候，如果池子没有满，会创建一个进程来执行，否则就会让该请求等待。Pool([numprocess [,initializer [, initargs]]]) 参数介绍： numprocess: 要创建的进程数，如果省略，将默认使用cpu_count()的值 initializer：是每个工作进程启动时要执行的可调用对象，默认为None initargs：是要传给initializer的参数组 方法介绍： p.apply(func [, args [, kwargs]]):在一个池工作进程中执行func(args,*kwargs),然后返回结果。需要强调的是：此操作并不会在所有池工作进程中并执行func函数。如果要通过不同参数并发地执行func函数，必须从不同线程调用p.apply()函数或者使用p.apply_async() p.apply_async(func [, args [, kwargs]]):在一个池工作进程中执行func(args,*kwargs),然后返回结果。此方法的结果是AsyncResult类的实例，callback是可调用对象，接收输入参数。当func的结果变为可用时，将理解传递给callback。callback禁止执行任何阻塞操作，否则将接收其他异步操作中的结果。 p.close():关闭进程池，防止进一步操作。如果所有操作持续挂起，它们将在工作进程终止前完成 P.jion():等待所有工作进程退出。此方法只能在close（）或teminate()之后调用 方法apply_async()和map_async（）的返回值是AsyncResul的实例obj。实例具有以下方法: obj.get():返回结果，如果有必要则等待结果到达。timeout是可选的。如果在指定时间内还没有到达，将引发一场。如果远程操作中引发了异常，它将在调用此方法时再次被引发。 obj.ready():如果调用完成，返回True obj.successful():如果调用完成且没有引发异常，返回True，如果在结果就绪之前调用此方法，引发异常 obj.wait([timeout]):等待结果变为可用。 obj.terminate()：立即终止所有工作进程，同时不执行任何清理或结束任何挂起工作。如果p被垃圾回收，将自动调用此函数 1234567891011121314151617181920212223242526from multiprocessing import Poolimport timedef work(n): print(&apos;开工啦...&apos;) time.sleep(3) return n**2if __name__ == &apos;__main__&apos;: q=Pool() res_l=[] for i in range(3) #异步apply_async用法：如果使用异步提交的任务，主进程需要使用jion，等待进程池内任务都处理完，然后可以用get收集结果，否则，主进程结束，进程池可能还没来得及执行，也就跟着一起结束了 res=q.apply_async(work,args=(i,)) res_l.append(res) q.close() q.join() #join在close之后调用 for i in res_l: print(i.get()) #同步apply用法：主进程一直等apply提交的任务结束后才继续执行后续代码 # res=q.apply(work,args=(i,)) # print(res) 五、子进程很多时候，子进程并不是自身，而是一个外部进程。我们创建了子进程后，还需要控制子进程的输入和输出。subprocess模块可以让我们非常方便地启动一个子进程，然后控制其输入和输出。 123456#Python代码中运行命令nslookup www.python.orgimport subprocessprint(&apos;$ nslookup www.python.org&apos;)r = subprocess.call([&apos;nslookup&apos;, &apos;www.python.org&apos;])print(&apos;Exit code:&apos;, r) 如果子进程还需要输入，则可以通过communicate()方法输入： 1234567import subprocessprint(&apos;$ nslookup&apos;)p = subprocess.Popen([&apos;nslookup&apos;], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)output, err = p.communicate(b&apos;set q=mx\\npython.org\\nexit\\n&apos;)print(output.decode(&apos;utf-8&apos;))print(&apos;Exit code:&apos;, p.returncode) 六、进程间通信Process之间肯定是需要通信的，Python的multiprocessing模块包装了底层的机制，提供了Queue、Pipes等多种方式来交换数据。Queue([maxsize]):创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。 maxsize:是队列中允许最大项数，省略则无大小限制。 q.put()方法用以插入数据到队列中 put方法还有两个可选参数：blocked和timeout。如果blocked为True（默认值），并且timeout为正值，该方法会阻塞timeout指定的时间，直到该队列有剩余的空间。如果超时，会抛出Queue.Full异常。如果blocked为False，但该Queue已满，会立即抛出Queue.Full异常。 q.get()方法可以从队列读取并且删除一个元素。 get方法有两个可选参数：blocked和timeout。如果blocked为True（默认值），并且timeout为正值，那么在等待时间内没有取到任何元素，会抛出Queue.Empty异常。如果blocked为False，有两种情况存在，如果Queue有一个值可用，则立即返回该值，否则，如果队列为空，则立即抛出Queue.Empty异常. q.get_nowait():同q.get(False) q.put_nowait():同q.put(False) q.empty():调用此方法时q为空则返回True，该结果不可靠，比如在返回True的过程中，如果队列中又加入了项目。 q.full()：调用此方法时q已满则返回True，该结果不可靠，比如在返回True的过程中，如果队列中的项目被取走。 q.qsize():返回队列中目前项目的正确数量，结果也不可靠，理由同q.empty()和q.full()一样 12345678910111213141516171819202122232425262728from multiprocessing import Process,Queueimport time,random,osdef consumer(q): while True: time.sleep(random.randint(1,3)) res=q.get() if res is None:break print(&apos;\\033[45m消费者拿到了：%s\\033[0m&apos; %res)def producer(seq,q): for item in seq: time.sleep(random.randint(1,3)) print(&apos;\\033[46m生产者生产了：%s\\033[0m&apos; %item) q.put(item)if __name__ == &apos;__main__&apos;: q=Queue() c=Process(target=consumer,args=(q,)) c.start() producer((&apos;包子%s&apos; %i for i in range(5)),q) q.put(None) c.join() print(&apos;主线程&apos;) 持续更新…","categories":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/tags/python/"}]},{"title":"python多线程","slug":"python多线程","date":"2017-12-30T06:30:00.000Z","updated":"2018-05-11T06:44:46.562Z","comments":true,"path":"2017/12/30/python多线程/","link":"","permalink":"http://pythonfood.github.io/2017/12/30/python多线程/","excerpt":"人生苦短，我用python。","text":"人生苦短，我用python。 一、线程线程是CPU分配资源的基本单位。但一个程序开始运行，这个程序就变成了一个进程，而一个进程相当于一个或者多个线程。当没有多线程编程时，一个进程也是一个主线程，但有多线程编程时，一个进程包含多个线程，包括主线程。使用线程可以实现程序的并发。 Python3通过两个标准库_thread和threading提供对线程的支持:(1)_thread提供了低级别的、原始的线程以及一个简单的锁，它相比于threading模块的功能还是比较有限的。(2)threading模块除了包含_thread 模块中的所有方法外，还提供的其他方法： threading.currentThread(): 返回当前的线程变量。 threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。 threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法: run(): 用以表示线程活动的方法。 start():启动线程活动。 join([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。 isAlive(): 返回线程是否活动的。 getName(): 返回线程名。 setName(): 设置线程名。 二、_thread模块函数式：调用_thread模块中的start_new_thread()函数来产生新线程。_thread.start_new_thread ( function, args[, kwargs] ) function - 线程函数。 args - 传递给线程函数的参数,他必须是个tuple类型。 kwargs - 可选参数。 1234567891011121314151617181920import _threadimport time# 为线程定义一个函数def print_time(threadName, delay): count = 0 while count &lt; 5: time.sleep(delay) count += 1 print(&apos;s%: s%&apos; % (threadName, time.ctime(time.time())))# 创建两个线程try: _thread.start_new_thread(print_time, (&apos;thread-1&apos;, 2)) _thread.start_new_thread(print_time, (&apos;thread-2&apos;, 4))except: print(&apos;E：无法启动线程&apos;) while 1： pass 三、threading模块1、用threading.Thread直接在线程中运行函数 12345678910111213141516171819202122import threadingimport time# 为线程定义一个函数def print_time(threadName, delay): count = 0 while count &lt; 5: time.sleep(delay) count += 1 print(&apos;s%: s%&apos; % (threadName, time.ctime(time.time())))# 创建两个线程 t1 = threading.Thread(target=print_time, args=(&apos;thread-1&apos;,&apos;2&apos;)) t2 = threading.Thread(target=print_time, args=(&apos;thread-2&apos;,&apos;4&apos;)) #调用start()，运行线程t1.start() t2.start()调用join()的线程，主线程等待线程结束才继续执行t1.join()t2.join() 2、通过继承threading.Thread类来创建线程 1234567891011121314151617181920212223import threadingimport time#继承threading.Thread类class MyThread(threading.Thread): def __init__(self,name): super().__init__() self.name = name def run(self): time.sleep(2) print(&apos;s% say hello&apos; % self.name) if __name__ == &apos;__main__&apos;: #创建线程 t1 = MyThread(&apos;t1&apos;) t2 = MyThread(&apos;t2&apos;) #启动线程 t1.start() t2.start() t1.join() t2.join() 四、线程同步使用Thread对象的Lock()和Rlock()可以实现简单的线程同步，这两个对象都有acquire()方法和release()方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到acquire()和release()方法之间。 123456789101112131415161718192021222324252627282930313233343536373839404142import threadingimport timeclass myThread (threading.Thread): def __init__(self, threadID, name, counter): threading.Thread.__init__(self) self.threadID = threadID self.name = name self.counter = counter def run(self): print (&quot;开启线程： &quot; + self.name) # 获取锁，用于线程同步 threadLock.acquire() print_time(self.name, self.counter, 3) # 释放锁，开启下一个线程 threadLock.release()def print_time(threadName, delay, counter): while counter: time.sleep(delay) print (&quot;%s: %s&quot; % (threadName, time.ctime(time.time()))) counter -= 1threadLock = threading.Lock()threads = []# 创建新线程thread1 = myThread(1, &quot;Thread-1&quot;, 1)thread2 = myThread(2, &quot;Thread-2&quot;, 2)# 开启新线程thread1.start()thread2.start()# 添加线程到线程列表threads.append(thread1)threads.append(thread2)# 等待所有线程完成for t in threads: t.join()print (&quot;退出主线程&quot;) 死锁：是指两个或两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。上面的例子如果使用RLock代替Lock，则不会发生死锁。 五、全局解释器锁Python GIL(Global Interpreter Lock)如果使用多核CPU，在Cpython解释器中，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。 GIL是Python解释器设计的历史遗留问题，通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。所以，在Python中，可以使用多线程，但不要指望能有效利用多核。如果一定要通过多线程利用多核，那只能通过C扩展来实现，不过这样就失去了Python简单易用的特点。不过，也不用过于担心，Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。 面向I/O的（会调用内建的操作系统C代码的）程序来说，GIL会在这个I/O调用之前被释放，以允许其他线程在这个线程等待I/O的时候运行。如果某线程并未使用很多I/O操作，它会在自己的时间片内一直占用处理器和GIL。也就是说，I/O密集型的Python程序比计算密集型的Python程序更能充分利用多线程的好处。 1、i/o密集型多线程用于IO密集型，如socket，爬虫，web。 123456789101112131415161718192021from threading import Threadfrom multiprocessing import Processimport timeimport osdef work(): time.sleep(2) #模拟I/O操作，可以打开一个文件来测试I/O,与sleep是一个效果 print(os.getpid())if __name__ == &apos;__main__&apos;: t_l=[] start_time=time.time() for i in range(1000): t=Thread(target=work) #耗时大概为2秒 # t=Process(target=work) #耗时大概为25秒,创建进程的开销远高于线程，而且对于I/O密集型，多cpu根本不管用 t_l.append(t) t.start() for t in t_l: t.join() stop_time=time.time() print(&apos;run time is %s&apos; %(stop_time-start_time)) 2、cpu密集型多进程用于计算密集型，如金融分析，视频解码。 123456789101112131415161718192021222324252627282930313233from threading import Threadfrom multiprocessing import Processimport osimport timedef work(): res=0 for i in range(1000000): res+=iif __name__ == &apos;__main__&apos;: t_l=[] start_time=time.time() for i in range(300): # t=Thread(target=work) #多线程49.64094281196594 t=Process(target=work) #多进程11.664679050445557 t_l.append(t) t.start() for i in t_l: i.join() stop_time=time.time() print(&apos;run time is %s&apos; %(stop_time-start_time)) print(&apos;主线程&apos;)# run time is 49.64094281196594# 主线程# run time is 11.664679050445557# 主线程 六、线程优先级队列Queue模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列 PriorityQueue。 这些队列都实现了锁原语，能够在多线程中直接使用，可以使用队列来实现线程间的同步。 Queue模块中的常用方法: Queue.qsize() 返回队列的大小 Queue.empty() 如果队列为空，返回True,反之False Queue.full() 如果队列满了，返回True,反之False Queue.full 与 maxsize 大小对应 Queue.get([block[, timeout]])获取队列，timeout等待时间 Queue.get_nowait() 相当Queue.get(False) Queue.put(item) 写入队列，timeout等待时间 Queue.put_nowait(item) 相当Queue.put(item, False) Queue.task_done() 在完成一项工作之后，Queue.task_done()函数向任务已经完成的队列发送一个信号 Queue.join() 实际上意味着等到队列为空，再执行别的操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import queueimport threadingimport timeexitFlag = 0class myThread (threading.Thread): def __init__(self, threadID, name, q): threading.Thread.__init__(self) self.threadID = threadID self.name = name self.q = q def run(self): print (&quot;开启线程：&quot; + self.name) process_data(self.name, self.q) print (&quot;退出线程：&quot; + self.name)def process_data(threadName, q): while not exitFlag: queueLock.acquire() if not workQueue.empty(): data = q.get() queueLock.release() print (&quot;%s processing %s&quot; % (threadName, data)) else: queueLock.release() time.sleep(1)threadList = [&quot;Thread-1&quot;, &quot;Thread-2&quot;, &quot;Thread-3&quot;]nameList = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;, &quot;Five&quot;]queueLock = threading.Lock()workQueue = queue.Queue(10)threads = []threadID = 1# 创建新线程for tName in threadList: thread = myThread(threadID, tName, workQueue) thread.start() threads.append(thread) threadID += 1# 填充队列queueLock.acquire()for word in nameList: workQueue.put(word)queueLock.release()# 等待队列清空while not workQueue.empty(): pass# 通知线程是时候退出exitFlag = 1# 等待所有线程完成for t in threads: t.join()print (&quot;退出主线程&quot;) 持续更新…","categories":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/tags/python/"}]},{"title":"python正则表达式","slug":"python正则表达式","date":"2017-12-30T06:00:00.000Z","updated":"2018-05-11T06:44:26.531Z","comments":true,"path":"2017/12/30/python正则表达式/","link":"","permalink":"http://pythonfood.github.io/2017/12/30/python正则表达式/","excerpt":"人生苦短，我用python。","text":"人生苦短，我用python。 一、正则表达式正则就是用一些具有特殊含义的符号组合到一起（称为正则表达式）来描述字符或者字符串的方法。或者说：正则就是用来描述一类事物的规则。（在Python中）它内嵌在Python中，并通过 re 模块实现。正则表达式模式被编译成一系列的字节码，然后由用 C 编写的匹配引擎执行。 常用的正则表达式： 语法 描述 一般字符 匹配自身 ^ 匹配字符串的开头 $ 匹配字符串的末尾。 . 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 […] 用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’ [^…] 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。 re* 匹配0个或多个的表达式。 re+ 匹配1个或多个的表达式。 re? 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式 re{ n} 匹配n个前面表达式。例如，”o{2}”不能匹配”Bob”中的”o”，但是能匹配”food”中的两个o。 re{ n,} 精确匹配n个前面表达式。例如，”o{2,}”不能匹配”Bob”中的”o”，但能匹配”foooood”中的所有o。”o{1,}”等价于”o+”。”o{0,}”则等价于”o*”。 re{ n, m} 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式 a&#124;b 匹配a或b (re) G匹配括号内的表达式，也表示一个组 (?imx) 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。 (?-imx) 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。 (?: re) 类似 (…), 但是不表示一个组 (?imx: re) 在括号中使用i, m, 或 x 可选标志 (?-imx: re) 在括号中不使用i, m, 或 x 可选标志 (?#…) 注释. (?= re) 前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。 (?! re) 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功。 (?&gt; re) 匹配的独立模式，省去回溯。 \\w 匹配数字字母下划线 \\W 匹配非数字字母下划线 \\s 匹配任意空白字符，等价于 [\\t\\n\\r\\f]。 \\S 匹配任意非空字符 \\d 匹配任意数字，等价于 [0-9]。 \\D 匹配任意非数字 \\A 匹配字符串开始 \\Z 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。 \\z 匹配字符串结束 \\G 匹配最后匹配完成的位置。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \\B 匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \\n, \\t, 等。 匹配一个换行符。匹配一个制表符, 等 \\1…\\9 匹配第n个分组的内容。 \\10 匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。 二、re模块Python通过re模块提供对正则表达式的支持。使用re的一般步骤是先将正则表达式的字符串形式编译为Pattern实例，然后使用Pattern实例处理文本并获得匹配结果（一个Match实例），最后使用Match实例获得信息，进行其他的操作。 1、re.match()re.match()尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。re.match(pattern, string, flags=0) pattern #匹配的正则表达式 string #要匹配的字符串。 flags #标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等 123import reprint(re.match(&apos;www&apos;, &apos;www.baidu.com&apos;)) # 在起始位置匹配print(re.match(&apos;com&apos;, &apos;www.baidu.com&apos;)) # 不在起始位置匹配,返回None 可以使用group(num)或groups()匹配对象函数来获取匹配表达式: group(num=0) #匹配的整个表达式的字符串，group()可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。 groups() #返回一个包含所有小组字符串的元组，从1到所含的小组号。 123456789import re m = re.match(r&apos;^(\\d&#123;3&#125;)-(\\d&#123;3,8&#125;)$&apos;, &apos;010-12345&apos;)print(m.group(0)) #group(0)返回的是原始字符串print(m.group(1)) #group(1)返回的是第一个子串print(m.group(2)) #group(2)返回的是第二个子串t = re.match(r&apos;^(0[0-9]|1[0-9]|2[0-3]|[0-9])\\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$&apos;, &apos;19:05:30&apos;)t.groups() #返回包含所有子串的元组 2、re.search()re.search()扫描整个字符串并返回第一个成功的匹配。re.search(pattern, string, flags=0) pattern #匹配的正则表达式 string #要匹配的字符串。 flags #标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等 1234import re print(re.search(&apos;www&apos;, &apos;www.baidu.com&apos;)) # 在起始位置匹配print(re.search(&apos;com&apos;, &apos;www.baidu.com&apos;)) # 不在起始位置匹配,也能匹配 同样可以使用group(num)或groups()匹配对象函数来获取匹配表达式: group(num=0) #匹配的整个表达式的字符串，group()可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。 groups() #返回一个包含所有小组字符串的元组，从1到所含的小组号。 3、re.split()re.split()方法按照能够匹配的子串将字符串分割后返回列表。re.split(pattern, string[, maxsplit=0, flags=0]) pattern #匹配的正则表达式 string #要匹配的字符串。 maxsplit #分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。 flags #标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 1234import rere.split(r&apos;\\s+&apos;, &apos;a b c&apos;) #连续的空格也可以识别，然后分割返回[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]re.split(r&apos;[\\s\\,\\;]+&apos;, &apos;a,b;; c d&apos;) #返回[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;] 4、re.sub()re.sub()用于替换字符串中的匹配项。re.sub(pattern, repl, string, count=0) pattern #正则中的模式字符串。 repl #替换的字符串，也可为一个函数。 string #要被查找替换的原始字符串。 count #模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。 1234567891011import re phone = &quot;2004-959-559 # 这是一个电话号码&quot; # 删除注释num = re.sub(r&apos;#.*$&apos;, &quot;&quot;, phone)print (&quot;电话号码 : &quot;, num) # 移除非数字的内容num = re.sub(r&apos;\\D&apos;, &quot;&quot;, phone)print (&quot;电话号码 : &quot;, num) sub()中的repl参数传入函数： 123456789import re # 将匹配的数字乘于 2def double(matched): value = int(matched.group(&apos;value&apos;)) return str(value * 2) s = &apos;A23G4HFD567&apos;print(re.sub(&apos;(?P&lt;value&gt;\\d+)&apos;, double, s)) 5、re.compile()re.compile()函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。re.compile(pattern[, flags]) pattern #一个字符串形式的正则表达式 flags #可选，表示匹配模式，比如忽略大小写，多行模式等 1234567891011import repattern = re.compile(r&apos;\\d+&apos;) # 用于匹配至少一个数字m = pattern.match(&apos;one12twothree34four&apos;) # 查找头部，没有匹配print(m)m = pattern.match(&apos;one12twothree34four&apos;, 2, 10) # 从&apos;e&apos;的位置开始匹配，没有匹配print(m)m = pattern.match(&apos;one12twothree34four&apos;, 3, 10) # 从&apos;1&apos;的位置开始匹配，正好匹配print(m) # 返回一个 Match 对象 6、re.findall()re.findall()在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。注意： match()和search()是匹配一次，findall()匹配所有。findall(string[, pos[, endpos]]) string #待匹配的字符串。 pos #可选参数，指定字符串的起始位置，默认为 0。 endpos #可选参数，指定字符串的结束位置，默认为字符串的长度。 123456789import re pattern = re.compile(r&apos;\\d+&apos;) # 查找数字result1 = pattern.findall(&apos;faf9 985 4da7 f9g&apos;)print(result1)result2 = pattern.findall(&apos;faf9 985 4da7 f9g&apos;, 2, 10)print(result2) 7、re.finditer()re.finditer()在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。re.finditer(pattern, string, flags=0) pattern #匹配的正则表达式 string #要匹配的字符串。 flags #标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 12345import re it = re.finditer(r&quot;\\d+&quot;,&quot;12a32bc43jf3&quot;) for match in it: print (match.group()) 8、正则表达式修饰符正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志： 修饰符 描述 re.I 使匹配对大小写不敏感 re.L 做本地化识别（locale-aware）匹配 re.M 多行匹配，影响 ^ 和 $ re.S 使 . 匹配包括换行在内的所有字符 re.U 根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B. re.X 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 12345import repattern = re.compile(r&apos;([a-z]+) ([a-z]+)&apos;, re.I) # re.I 表示忽略大小写m = pattern.match(&apos;Hello World Wide Web&apos;)print(m) 三、正则表达式实例 实例 描述 python 匹配 “python” [Pp]ython 匹配 “Python” 或 “python” rub[ye] 匹配 “ruby” 或 “rube” [aeiou] 匹配中括号内的任意一个字母 [0-9] 匹配任何数字。类似于 [0123456789] [a-z] 匹配任何小写字母 [A-Z] 匹配任何大写字母 [a-zA-Z0-9] 匹配任何字母及数字 [^aeiou] 除了aeiou字母以外的所有字符 [^0-9] 匹配除了数字外的字符 . 匹配除 “\\n” 之外的任何单个字符。要匹配包括 ‘\\n’ 在内的任何字符，请使用象 ‘[.\\n]’ 的模式。 \\d 匹配一个数字字符。等价于 [0-9]。 \\D 匹配一个非数字字符。等价于 [^0-9]。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\w 匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。 \\W 匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’。 持续更新…","categories":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/tags/python/"}]},{"title":"python文件目录","slug":"python文件目录","date":"2017-12-30T05:30:00.000Z","updated":"2018-05-11T06:44:12.321Z","comments":true,"path":"2017/12/30/python文件目录/","link":"","permalink":"http://pythonfood.github.io/2017/12/30/python文件目录/","excerpt":"人生苦短，我用python。","text":"人生苦短，我用python。 一、os模块os模块是与操作系统交互的一个接口。 1、os模块函数 os.access(path, mode) # 检验权限模式 os.chdir(path) # 改变当前工作目录 os.chflags(path, flags) # 设置路径的标记为数字标记。 os.chmod(path, mode) # 更改权限 os.chown(path, uid, gid) # 更改文件所有者 os.chroot(path) # 改变当前进程的根目录 os.close(fd) # 关闭文件描述符 fd os.closerange(fd_low, fd_high) # 关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略 os.curdir # 返回当前目录：（’.’） os.dup(fd) # 复制文件描述符 fd os.dup2(fd, fd2) # 将一个文件描述符 fd 复制到另一个 fd2 os.environ # 获取系统环境变量 os.fchdir(fd) # 通过文件描述符改变当前工作目录 os.fchmod(fd, mode) # 改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。 os.fchown(fd, uid, gid) # 修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。 os.fdatasync(fd) # 强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。 os.fdopen(fd[, mode[, bufsize]]) # 通过文件描述符 fd 创建一个文件对象，并返回这个文件对象 os.fpathconf(fd, name) # 返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。 os.fstat(fd) # 返回文件描述符fd的状态，像stat()。 os.fstatvfs(fd) # 返回包含文件描述符fd的文件的文件系统的信息，像 statvfs() os.fsync(fd) # 强制将文件描述符为fd的文件写入硬盘。 os.ftruncate(fd, length) # 裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。 os.getcwd() # 返回当前工作目录 os.getcwdu() # 返回一个当前工作目录的Unicode对象 os.isatty(fd) # 如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。 os.lchflags(path, flags) # 设置路径的标记为数字标记，类似 chflags()，但是没有软链接 os.lchmod(path, mode) # 修改连接文件权限 os.lchown(path, uid, gid) # 更改文件所有者，类似 chown，但是不追踪链接。 os.link(src, dst) # 创建硬链接，名为参数 dst，指向参数 src os.listdir(path) # 返回path指定的文件夹包含的文件或文件夹的名字的列表。 os.lseek(fd, pos, how) # 设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效 os.lstat(path) # 像stat(),但是没有软链接 os.linesep # 当前平台使用的行终止符，win下为”\\t\\n”,Linux下为”\\n” os.major(device) # 从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。 os.makedev(major, minor) # 以major和minor设备号组成一个原始设备号 os.makedirs(path[, mode]) # 递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。 os.minor(device) # 从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。 os.mkdir(path[, mode]) # 以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。 os.mkfifo(path[, mode]) # 创建命名管道，mode 为数字，默认为 0666 (八进制) os.mknod(filename[, mode=0600, device]) # 创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。 os.open(file, flags[, mode]) # 打开一个文件，并且设置需要的打开选项，mode参数是可选的 os.openpty() # 打开一个新的伪终端对。返回 pty 和 tty的文件描述符。 os.pathconf(path, name) # 返回相关文件的系统配置信息。 os.pathsep # 用于分割文件路径的字符串 os.pardir # 获取当前目录的父目录字符串名：(‘..’) os.pipe() # 创建一个管道. 返回一对文件描述符(r, w) 分别为读和写 os.popen(command[, mode[, bufsize]]) # 从一个 command 打开一个管道 os.path.abspath(path) # 返回path规范化的绝对路径 os.path.split(path) # 将path分割成目录和文件名二元组返回 os.path.dirname(path) # 返回path的目录。其实就是os.path.split(path)的第一个元素 os.path.basename(path) # 返回path最后的文件名。如何path以／或\\结尾，那么就会返回空值。即os.path.split(path)的第二个元素 os.path.exists(path) # 如果path存在，返回True；如果path不存在，返回False os.path.isabs(path) # 如果path是绝对路径，返回True os.path.isfile(path) # 如果path是一个存在的文件，返回True。否则返回False os.path.isdir(path) # 如果path是一个存在的目录，则返回True。否则返回False os.path.join(path1[, path2[, ...]]) # 将多个路径组合后返回，第一个绝对路径之前的参数将被忽略 os.path.getatime(path) # 返回path所指向的文件或者目录的最后存取时间 os.path.getmtime(path) # 返回path所指向的文件或者目录的最后修改时间 os.name # 字符串指示当前使用平台。win-&gt;’nt’; Linux-&gt;’posix’ os.read(fd, n) # 从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。 os.readlink(path) # 返回软链接所指向的文件 os.remove(path) # 删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。 os.removedirs(path) # 递归删除目录。若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推 os.rename(src, dst) # 重命名文件或目录，从 src 到 dst os.renames(old, new) # 递归地对目录进行更名，也可以对文件进行更名。 os.rmdir(path) # 删除path指定的空目录，如果目录非空，则抛出一个OSError异常。 os.sep # 操作系统特定的路径分隔符，win下为”\\“,Linux下为”/“ os.stat(path) # 获取path指定的路径的信息，功能等同于C API中的stat()系统调用。 os.stat_float_times([newvalue]) # 决定stat_result是否以float对象显示时间戳 os.statvfs(path) # 获取指定路径的文件系统统计信息 os.symlink(src, dst) # 创建一个软链接 os.system(&quot;bash command&quot;) # 运行shell命令，直接显示 os.tcgetpgrp(fd) # 返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组 os.tcsetpgrp(fd, pg) # 设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。 os.tempnam([dir[, prefix]]) # 返回唯一的路径名用于创建临时文件。 os.tmpfile() # 返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。 os.tmpnam() # 为创建一个临时文件返回一个唯一的路径 os.ttyname(fd) # 返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。 os.unlink(path) # 删除文件路径 os.utime(path, times) # 返回指定的path文件的访问和修改的时间。 os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]]) # 输出在文件夹中的文件名通过在树中游走，向上或者向下。 os.write(fd, str) # 写入字符串到文件描述符 fd中. 返回实际写入的字符串长度 2、os小示例 12345678910111213141516171819202122232425import os# 查看当前目录的绝对路径:os.path.abspath(&apos;.&apos;)# 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:os.path.join(&apos;/Users/michael&apos;,&apos;testdir&apos;)# 然后创建一个目录:os.mkdir(&apos;/Users/michael/testdir&apos;)# 删掉一个目录:os.rmdir(&apos;/Users/michael/testdir&apos;)#拆分路径os.path.split(&apos;/Users/michael/testdir/file.txt&apos;)#拆分路径直接得到扩展名os.path.splitext(&apos;/path/to/file.txt&apos;)#对文件重命名os.rename(&apos;test.txt&apos;, &apos;test.py&apos;)#删除文件os.remove(&apos;test.py&apos;) 二、shutil模块高级的文件、文件夹、压缩包处理模块。 1、shutil模块函数 shutil.copyfileobj(fsrc, fdst[, length]) #将文件内容拷贝到另一个文件中 shutil.copyfile(src, dst) #拷贝文件，目标文件无需存在 shutil.copymode(src, dst) #仅拷贝权限。内容、组、用户均不变，目标文件必须存在 shutil.copystat(src, dst) #仅拷贝状态的信息，包括：mode bits, atime, mtime, flags，目标文件必须存在 shutil.copy(src, dst) #拷贝文件和权限 shutil.copy2(src, dst) #拷贝文件和状态信息 shutil.ignore_patterns(*patterns) #排除目标 shutil.copytree(src, dst, symlinks=False, ignore=None) #递归的去拷贝文件夹 shutil.rmtree(path[, ignore_errors[, onerror]]) #递归的去删除文件 shutil.move(src, dst) #递归的去移动文件，它类似mv命令，其实就是重命名。 shutil.make_archive(base_name, format,...) #创建压缩包并返回文件路径，例如：zip、tar 2、shutil小示例 123456789import shutilshutil.copyfile(&apos;f1.log&apos;, &apos;f2.log&apos;) #将源的内容复制给目标，如果没有权限写目标文件则产生IoErrorshutil.copy(&apos;f1.log&apos;, &apos;f2.log&apos;) #文件复制,复制 + 重命名shutil.copytree(&apos;folder1&apos;, &apos;folder2&apos;, ignore=shutil.ignore_patterns(&apos;*.pyc&apos;, &apos;tmp*&apos;)) #目标目录不能存在，注意对folder2目录父级目录要有可写权限，ignore的意思是排除shutil.make_archive(&quot;data_bak&quot;, &apos;gztar&apos;, root_dir=&apos;/data&apos;) #将 /data 下的文件打包放置当前程序目录 三、glob模块glob模块提供了一个函数用于从目录通配符搜索中生成文件列表glob.glob() 123&gt;&gt;&gt; import glob&gt;&gt;&gt; glob.glob(&apos;E:/test/*/*.py&apos;)[&apos;primes.py&apos;, &apos;random.py&apos;, &apos;quote.py&apos;] 持续更新…","categories":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/tags/python/"}]},{"title":"python日期时间","slug":"python日期时间","date":"2017-12-30T05:00:00.000Z","updated":"2018-05-11T06:43:48.490Z","comments":true,"path":"2017/12/30/python日期时间/","link":"","permalink":"http://pythonfood.github.io/2017/12/30/python日期时间/","excerpt":"人生苦短，我用python。","text":"人生苦短，我用python。 一、time模块time提供的功能是更加接近于操作系统层面的。需要注意的是在该模块中的大多数函数是调用了所在平台C library的同名函数， 所以要特别注意有些函数是平台相关的，可能会在不同的平台有不同的效果。另外一点是，由于是基于Unix Timestamp，所以其所能表述的日期范围被限定在1970-2038之间，如果你写的代码需要处理在前面所述范围之外的日期，那可能需要考虑使用datetime模块更好。 1、结构化时间时间元组用一个元组装起来的9组数字处理时间，也就是结构化时间(struct_time)。time.localtime()例如：(tm_year=2017, tm_mon=6, tm_mday=5, tm_hour=20, tm_min=57, tm_sec=51, tm_wday=0, tm_yday=156, tm_isdst=0) 序号 属性 值 0 tm_year 2008 1 tm_mon 1到12 2 tm_mday 1到31 3 tm_hour 0到23 4 tm_min 0到59 5 tm_sec 0到61(60或61是闰秒) 6 tm_wday 0到6(0是周一) 7 tm_yday 一年中的第几天，1到366 8 tm_isdst 是否为夏令时，值有：1(夏令时)、0(不是夏令时)、-1(未知)，默认-1 2、时间戳时间戳(timestamp)：时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量。time.time()例如：1496667277.8989 3、格式化时间格式化的时间字符串(Format String)。time.strftime()例如：2017-06-05 20:55:48 python中时间日期格式化符号： %y 两位数的年份表示（00-99） %Y 四位数的年份表示（000-9999） %m 月份（01-12） %d 月内中的一天（0-31） %H 24小时制小时数（0-23） %I 12小时制小时数（01-12） %M 分钟数（00=59） %S 秒（00-59） %a 本地简化星期名称 %A 本地完整星期名称 %b 本地简化的月份名称 %B 本地完整的月份名称 %c 本地相应的日期表示和时间表示 %j 年内的一天（001-366） %p 本地A.M.或P.M.的等价符 %U 一年中的星期数（00-53）星期天为星期的开始 %w 星期（0-6），星期天为星期的开始 %W 一年中的星期数（00-53）星期一为星期的开始 %x 本地相应的日期表示 %X 本地相应的时间表示 %Z 当前时区的名称 %% %号本身 4、时间格式转换(1)时间戳——&gt;时间元组 time.localtime() time.gmtime() 12345import timeprint(time.time()) # 获得时间戳print(time.localtime(time.time())) # 时间戳转换为时间元组print(time.gmtime(time.time())) # 时间戳转换为格林威治天文时间下的时间元组 (2)时间元组——&gt;时间戳 time.mktime() 12345import timet = (2017, 6, 5, 22, 3, 38, 1, 48, 0) # 时间元组secs = time.mktime( t ) # 时间元组转换为时间戳print (&quot;time.mktime(t) : %f&quot; % secs) (3)时间元组——&gt;格式化时间 time.strftime() time.asctime() time.ctime() 12345678910import time# 时间元组格式化成2016-03-20 11:45:39形式print (time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime()))# 时间元组格式化为&quot;Tue Dec 11 18:07:14 2008&quot;形式print (time.asctime(time.localtime()))# 时间元组格式化为&quot;Tue Dec 11 18:07:14 2008&quot;形式print (time.ctime()) (4)格式化时间——&gt;时间元组 time.strptime() 123import time# fmt的格式时间字符串解析为时间元组print (time.strptime(&quot;30 Nov 00&quot;, &quot;%d %b %y&quot;)) (5)时间戳&lt;——&gt;格式化时间时间戳和格式化时间相互转换，需要先转换为时间元组，再进行转换。 12345#时间戳格式化localtime = time.asctime( time.localtime(time.time()) )#fmt格式时间转换为时间戳secs = time.mktime(time.strptime(&quot;30 Nov 00&quot;, &quot;%d %b %y&quot;)) 5、time模块函数 函数 描述 time.altzone 返回格林威治西部的夏令时地区的偏移秒数。如果该地区在格林威治东部会返回负值（如西欧，包括英国）。对夏令时启用地区才能使用。 time.asctime([tupletime]) 接受时间元组并返回一个可读的形式为”Tue Dec 11 18:07:14 2008”（2008年12月11日 周二18时07分14秒）的24个字符的字符串。 time.clock() 用以浮点数计算的秒数返回当前的CPU时间。用来衡量不同程序的耗时，比time.time()更有用。 time.ctime([secs]) 作用相当于asctime(localtime(secs))，未给参数相当于asctime() time.gmtime([secs]) 接收时间辍（1970纪元后经过的浮点秒数）并返回格林威治天文时间下的时间元组t。注：t.tm_isdst始终为0 time.localtime([secs] 接收时间辍（1970纪元后经过的浮点秒数）并返回当地时间下的时间元组t（t.tm_isdst可取0或1，取决于当地当时是不是夏令时）。 time.mktime(tupletime) 接受时间元组并返回时间辍（1970纪元后经过的浮点秒数）。 time.sleep(secs) 推迟调用线程的运行，secs指秒数。 time.strftime(fmt[,tupletime]) 接收以时间元组，并返回以可读字符串表示的当地时间，格式由fmt决定。 time.strptime(str,fmt=’%a %b %d %H:%M:%S %Y’) 根据fmt的格式把一个时间字符串解析为时间元组。 time.time( ) 返回当前时间的时间戳（1970纪元后经过的浮点秒数）。 time.tzset() 根据环境变量TZ重新初始化时间相关设置。 time.timezone 属性time.timezone是当地时区（未启动夏令时）距离格林威治的偏移秒数（&gt;0，美洲;&lt;=0大部分欧洲，亚洲，非洲）。 time.tzname 属性time.tzname包含一对根据情况的不同而不同的字符串，分别是带夏令时的本地时区名称，和不带的。 二、datetime模块datetime基于time进行了封装，提供了更多实用的函数。 1、获取当前时间datetime.now() 1234from datetime import datetimenow = datetime.now() # 获取当前datetimeprint(now) 2、获取指定日期时间直接用参数构造一个datetime： 123from datetime import datetimedt = datetime(2017, 4, 19, 12, 20) # 用指定日期时间创建datetimeprint(dt) 3、时间格式转换(1)datetime——&gt;timestamptimestamp() 1234from datetime import datetimedt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetimedt.timestamp() # 把datetime转换为timestamp (2)timestamp——&gt;datetimedatetime.fromtimestamp()datetime.utcfromtimestamp() 12345from datetime import datetimet = 1429417200.0print(datetime.fromtimestamp(t)) # timestamp转换为本地时间print(datetime.utcfromtimestamp(t)) # timestamp转换为UTC时间 (3)str——&gt;datetimedatetime.strptime() 1234from datetime import datetimecday = datetime.strptime(&apos;2015-6-1 18:19:59&apos;, &apos;%Y-%m-%d %H:%M:%S&apos;) # str转换为datetimeprint(cday) (4)datetime——&gt;strstrftime() 1234from datetime import datetimenow = datetime.now()print(now.strftime(&apos;%a, %b %d %H:%M&apos;)) # datetime转换为str 4、datetime加减+或-timedelta() 123456from datetime import datetime, timedeltanow = datetime.now()now + timedelta(hours=10) #加10小时now - timedelta(days=1) #减1天now + timedelta(days=2, hours=12) #加2天12小时 5、本地时间转换为UTC时间一个datetime类型有一个时区属性tzinfo，但是默认为None，所以无法区分这个datetime到底是哪个时区，除非强行给datetime设置一个时区： 12345from datetime import datetime,timedelta,timezonetz_utc_8 = timezone(timedelta(hours=8)) # 创建时区UTC+8:00now = datetime.now()dt = now.replace(tzinfo=tz_utc_8) # 强制设置为UTC+8:00 6、时区转换可以先通过utcnow()拿到当前的UTC时间，再通过astimezone()转换为任意时区的时间： 12345678910from datetime import datetime,timedelta,timezone# 拿到UTC时间，并强制设置时区为UTC+0:00utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)# astimezone()将转换时区为北京时间bj_dt = utc_dt.astimezone(timezone(timedelta(hours=8)))#astimezone()将bj_dt转换时区为东京时间tokyo_dt = bj_dt.astimezone(timezone(timedelta(hours=9))) 三、calendar模块Calendar的函数都是日历相关的，例如打印某月的字符月历。 1、获取某月日历calendar.month() 1234import calendarcal = calendar.month(2017, 1)print(cal) 2、calendar模块函数 函数 描述 calendar.calendar(year,w=2,l=1,c=6) 返回一个多行字符串格式的year年年历，3个月一行，间隔距离为c。 每日宽度间隔为w字符。每行长度为21 W+18+2 C。l是每星期行数。 calendar.firstweekday( ) 返回当前每周起始日期的设置。默认情况下，首次载入caendar模块时返回0，即星期一。 calendar.isleap(year) 是闰年返回True，否则为false。 calendar.leapdays(y1,y2) 返回在Y1，Y2两年之间的闰年总数。 calendar.month(year,month,w=2,l=1) 返回一个多行字符串格式的year年month月日历，两行标题，一周一行。每日宽度间隔为w字符。每行的长度为7* w+6。l是每星期的行数。 calendar.monthcalendar(year,month) 返回一个整数的单层嵌套列表。每个子列表装载代表一个星期的整数。Year年month月外的日期都设为0;范围内的日子都由该月第几日表示，从1开始。 calendar.monthrange(year,month) 返回两个整数。第一个是该月的星期几的日期码，第二个是该月的日期码。日从0（星期一）到6（星期日）;月从1到12。 calendar.prcal(year,w=2,l=1,c=6) 相当于 print calendar.calendar(year,w,l,c). calendar.prmonth(year,month,w=2,l=1) 相当于 print calendar.calendar（year，w，l，c）。 calendar.setfirstweekday(weekday) 设置每周的起始日期码。0（星期一）到6（星期日）。 calendar.timegm(tupletime) 和time.gmtime相反：接受一个时间元组形式，返回该时刻的时间辍（1970纪元后经过的浮点秒数）。 calendar.weekday(year,month,day) 返回给定日期的日期码。0（星期一）到6（星期日）。月份为 1（一月） 到 12（12月）。 持续更新…","categories":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/tags/python/"}]},{"title":"python文件操作","slug":"python文件操作","date":"2017-12-30T04:30:00.000Z","updated":"2018-05-11T06:43:32.830Z","comments":true,"path":"2017/12/30/python文件操作/","link":"","permalink":"http://pythonfood.github.io/2017/12/30/python文件操作/","excerpt":"人生苦短，我用python。","text":"人生苦短，我用python。 一、file对象操作文件首先要创建file对象，file对象使用open()函数来创建。 1、读取创建(1)读取文本文件，UTF-8编码：f = open(&#39;/Users/michael/test.txt&#39;, &#39;r&#39;) (2)读取二进制文件，比如图片、视频等用rb模式打开文件:f = open(&#39;/Users/michael/test.jpg&#39;, &#39;rb&#39;) (3)读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数:f = open(&#39;/Users/michael/gbk.txt&#39;, &#39;r&#39;, encoding=&#39;gbk&#39;) (4)有些编码不规范的文件,遇到编码错误,最简单的方式是直接忽略(errors参数)：f = open(&#39;/Users/michael/gbk.txt&#39;, &#39;r&#39;, encoding=&#39;gbk&#39;, errors=&#39;ignore&#39;) 2、写入创建(1)写入文本文件，UTF-8编码：file = open(&#39;/Users/michael/test.txt&#39;, &#39;w&#39;) (2)写入二进制文件：f = open(&#39;/Users/michael/test.jpg&#39;, &#39;wb&#39;) (3)写入特定编码的文本文件，请给open()函数传入encoding参数:f = open(&#39;/Users/michael/gbk.txt&#39;, &#39;w&#39;, encoding=&#39;gbk&#39;) (4)在文本末尾追加写入，需要传入a参数(append)：file = open(&#39;/Users/michael/test.txt&#39;, &#39;w&#39;, &#39;a&#39;) 二、读文件创建file对象后，就可以调取read()方法进行读取内容了。 1、read(size)从文件读取指定的字节数，如果未给定或为负则读取所有：line = f.read() #一次性全部读取line = f.read(10) #一次读取10个字节，即5汉字 2、readline(size)读取整行，包括 “\\n” 字符：line = f.readline() #一次性读取一整行line = f.readline(5) #读取一行中的前5个字节 3、readlines(sizeint)读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区：lines = f.readlines() #一次性读取所有行，返回列表 三、写文件创建file对象后，也可以调取write()方法进行写入内容了。 1、write(str)将字符串写入文件，没有返回值。f.write(&#39;hello world&#39;) #向文件写入 2、writelines(sequence)向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。seq = [&quot;hello\\n&quot;, &quot;world\\n&quot;]f.writelines(seq) #向文件写入列表，并换行 四、关闭文件文件使用完毕后必须关闭，关闭后文件不能再进行读写操作。 1、close()f.close()由于文件读写时都有可能产生IOError，一旦出错后面的f.close()就不会调用,我们可以使用try...finally来实现 123456try: f = open(&apos;/path/to/file&apos;, &apos;r&apos;) print(f.read())finally: if f: f.close() 2、with…as…Python引入了with语句来自动帮我们调用close()方法： 12with open(&apos;/Users/michael/test.txt&apos;, &apos;w&apos;) as f: f.write(&apos;Hello, world!&apos;) 五、其他操作1、file.flush()刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。 2、file.next()返回文件下一行。 3、file.tell()返回文件当前位置。 4、file.seek(offset[, whence])设置文件当前位置。offset：开始的偏移量，也就是代表需要移动偏移的字节数。whence：默认值为0，表示要从哪个位置开始偏移，0代表从文件开头开始算起，1代表从当前位置开始算起，2代表从文件末尾算起。 5、file.truncate(size)从文件的首行首字符开始截断，截断文件为size个字符，无size表示从当前位置截断；截断之后V后面的所有字符被删除，其中Widnows系统下的换行代表2个字符大小。 6、file.isatty()如果文件连接到一个终端设备返回 True，否则返回 False。 7、file.fileno()返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。 持续更新…","categories":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/tags/python/"}]},{"title":"python错误异常","slug":"python错误异常","date":"2017-12-30T04:00:00.000Z","updated":"2018-05-11T06:43:15.719Z","comments":true,"path":"2017/12/30/python错误异常/","link":"","permalink":"http://pythonfood.github.io/2017/12/30/python错误异常/","excerpt":"人生苦短，我用python。","text":"人生苦短，我用python。 一、错误和异常1、BaseExceptionBaseException: 所有错误异常的基类 KeyboardInterrupt : 用户中断执行 SystemExit : 解释器请求推出 GeneratorExit : 生成器(generator)发生异常来通知退出 Exception : 常规错误的基类 2、ExceptionException: 常规错误异常的基类 StopIteration : 迭代器没有更多的值 StandardError : 所有的内建标准异常的基类 ArithmeticError : 所有数值计算错误的基类 FloatingPointError : 浮点计算错误 OverflowError : 数值运算超出最大限制 ZeroDivisionError : 除(或取模)零 (所有数据类型) AssertionError : 断言语句失败 AttributeError : 对象没有这个属性 EOFError : 没有内建输入,到达EOF 标记 EnvironmentError : 操作系统错误的基类 IOError : 输入/输出操作失败 OSError : 操作系统错误 WindowsError : 系统调用失败 ImportError : 导入模块/对象失败 LookupError : 无效数据查询的基类 IndexError : 序列中没有此索引(index) KeyError : 映射中没有这个键 MemoryError : 内存溢出错误(对于Python 解释器不是致命的) NameError : 未声明/初始化对象 (没有属性) UnboundLocalError : 访问未初始化的本地变量 ReferenceError : 弱引用(Weak reference)试图访问已经垃圾回收了的对象 RuntimeError : 一般的运行时错误 NotImplementedError : 尚未实现的方法 SyntaxError : Python 语法错误 IndentationError : 缩进错误 TabError : Tab 和空格混用 SystemError : 一般的解释器系统错误 TypeError : 对类型无效的操作 ValueError : 传入无效的参数 UnicodeError : Unicode 相关的错误 UnicodeDecodeError : Unicode 解码时的错误 UnicodeEncodeError : Unicode 编码时错误 UnicodeTranslateError : Unicode 转换时错误 Warning : 警告的基类 DeprecationWarning : 关于被弃用的特征的警告 FutureWarning : 关于构造将来语义会有改变的警告 OverflowWarning : 旧的关于自动提升为长整型(long)的警告 PendingDeprecationWarning : 关于特性将会被废弃的警告 RuntimeWarning : 可疑的运行时行为(runtime behavior)的警告 SyntaxWarning : 可疑的语法的警告 UserWarning : 用户代码生成的警告 3、继承关系错误异常继承关系 二、异常处理1234567891011121314try: #需要监测的代码 ...except exception1: #捕获一个异常 ...except (exception2, exception3): #同时处理多个异常，写在元组里 ...except exception4 as e4: #给异常取别名 ...except: #最后一个except可以忽略异常的名称，它将被当作通配符使用 ...else: #可选的else必须放在所有的except之后，将在try没有发生任何异常时执行 ...finally: #不管try里面有没有发生异常，finally都会执行 ... 12345678910def divide(x, y): try: result = x / y except ZeroDivisionError: print(&quot;division by zero!&quot;) else: print(&quot;result is&quot;, result) finally: print(&quot;executing finally clause&quot;)divide(2, 1) 三、抛出异常raise语句抛出一个指定的异常。 12345try: raise NameError(&apos;HiThere&apos;)except NameError: print(&apos;An exception flew by!&apos;) raise 四、自定义异常你可以通过创建一个新的exception类来拥有自己的异常。异常应该继承自Exception类，或者直接继承，或者间接继承，例如: 12345678910&gt;&gt;&gt; class MyError(Exception): def __init__(self, value): self.value = value def __str__(self): return repr(self.value) &gt;&gt;&gt; try: raise MyError(2*2) except MyError as e: print(&apos;My exception occurred, value:&apos;, e.value) 当创建一个模块有可能抛出多种不同的异常时，一种通常的做法是为这个包建立一个基础异常类，然后基于这个基础类为不同的错误情况创建不同的子类: 123456789101112131415161718192021222324252627282930class Error(Exception): &quot;&quot;&quot;Base class for exceptions in this module.&quot;&quot;&quot; passclass InputError(Error): &quot;&quot;&quot;Exception raised for errors in the input. Attributes: expression -- input expression in which the error occurred message -- explanation of the error &quot;&quot;&quot; def __init__(self, expression, message): self.expression = expression self.message = messageclass TransitionError(Error): &quot;&quot;&quot;Raised when an operation attempts a state transition that&apos;s not allowed. Attributes: previous -- state at beginning of transition next -- attempted new state message -- explanation of why the specific transition is not allowed &quot;&quot;&quot; def __init__(self, previous, next, message): self.previous = previous self.next = next self.message = message 五、清理行为1、定义清理行为try语句有一个可选的finally子句，它定义了无论在任何情况下都会执行的清理行为: 1234try: raise KeyboardInterruptfinally: print(&apos;Goodbye, world!&apos;) 2、预定义清理行为一些对象定义了标准的清理行为，无论系统是否成功的使用了它，一旦不需要它了，那么这个标准的清理行为就会执行。with语句就可以保证诸如文件之类的对象在使用完之后一定会正确的执行他的清理方法: 123with open(&quot;myfile.txt&quot;) as f: for line in f: print(line, end=&quot;&quot;) 六、调试1、print()用print()把可能有问题的变量打印出来看看，用print()最大的坏处是将来还得删掉它，想想程序里到处都是print()，运行结果也会包含很多垃圾信息。 2、assert如果断言失败，assert语句本身就会抛出AssertionError。 1234def foo(s): n = int(s) assert n != 0, &apos;n is zero!&apos; return 10 / n 程序中如果到处充斥着assert，和print()相比也好不到哪去。不过，启动Python解释器时可以用-O参数来关闭assertpython -O err.py 3、logginglogging不会抛出错误，而且可以输出到文件，推荐使用。允许指定记录信息的级别:debug、info、warning、error。 12345678# err.pyimport logging #使用前导入包logging.basicConfig(level=logging.INFO) #配置打印信息级别s = &apos;0&apos;n = int(s)logging.info(&apos;n = %d&apos; % n) #记录要打印的信息print(10 / n) 4、pdb(1)启动Python的调试器pdb，让程序以单步方式运行：python -m pdb err.py(2)pdb定位到下一步要执行的代码，输入命令l来查看代码。(3)输入命令n可以单步执行代码。(4)任何时候都可以输入命令p 变量名来查看变量。(5)输入命令q结束调试，退出程序。 5、pdb.set_trace()只需要import pdb，然后在可能出错的地方放一个pdb.set_trace()，就可以设置一个断点，用命令p查看变量，用命令c继续运行: 1234567# err.pyimport pdbs = &apos;0&apos;n = int(s)pdb.set_trace() # 运行到这里会自动暂停print(10 / n) 6、IDE如果要比较爽地设置断点、单步执行，就需要一个支持调试功能的IDE 持续更新…","categories":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/tags/python/"}]},{"title":"python模块和包","slug":"python模块和包","date":"2017-12-30T03:30:00.000Z","updated":"2018-05-11T06:42:56.929Z","comments":true,"path":"2017/12/30/python模块和包/","link":"","permalink":"http://pythonfood.github.io/2017/12/30/python模块和包/","excerpt":"人生苦短，我用python。","text":"人生苦短，我用python。 一、模块模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。 模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用python标准库的方法。 模块能定义函数，类和变量，模块里也能包含可执行的代码。 1234567891011121314#新建模块文件modle_1.py，内容如下：def p_func(arg): print(&apos;hello&apos;,arg) return#新建主模块文件main.py，内容如下：from modle_1 import p_func #导入模块modle_1中的p_func函数if __name__ == &quot;__main__&quot;: #判断是否为主程序执行口 p_func(&apos;python&apos;)#output：hello python ps：自己创建模块时要注意命名，不能和Python自带的模块名称冲突。例如，系统自带了sys模块，自己的模块就不可命名为sys.py，否则将无法导入系统自带的sys模块。 二、模块引入1、importimport module1[, module2[,... moduleN] 123import sys #导入模块sys.path.append(&apos;&apos;) #调用模块里的方法 2、from…importfrom modname import name1[, name2[, ... nameN]] 123from fibo import fib, fib2 #导入模块里的函数fib(500) # 直接使用函数 3、from…import *from modname import *这样会把模块中的所有内容导入到当前命名空间，一般不建议使用，消耗内存空间，也容易出现未预知的问题。 三、搜索路径1、python解析器对模块位置的搜索顺序是： 当前目录 shell变量PYTHONPATH下的每个目录 python模块路径目录 2、添加搜索路径方法一：直接修改sys.path，运行结束后失效。12import syssys.path.append(&apos;&apos;) 方法二：设置环境变量PYTHONPATH，一般不推荐。set PYTHONPATH =/usr/local/lib/python 四、作用域1、正常变量正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等。 2、特殊变量类似__xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途，我们自己的变量一般不要用这种变量名。比如：__name__属性，个模块都有一个__name__属性，当其值是’__main__‘时，表明该模块自身在运行，否则是被引入。 3、私有变量类似_xxx和__xxx这样的变量是私有变量，（private）函数和变量“不应该”被直接引用。 ps：内置的函数dir(模块名)可以找到模块内定义的所有名称。以一个字符串列表的形式返回。 五、包目录只有包含一个__init__.py文件，才会被认作是一个包。模块用来组织python代码，包用来组织模块。 1、包的导入(1)import 12345#只导入一个包里面的特定模块import sound.effects.echo #访问时必须使用全名sound.effects.echo.echofilter(input, output, delay=0.7, atten=4) (2)from…import1)导入子模块 12345#导入子模块from sound.effects import echo#访问不需要那些冗长的前缀echo.echofilter(input, output, delay=0.7, atten=4) 2)直接导入一个函数或者变量 12345#导入一个函数from sound.effects.echo import echofilter#直接访问函数echofilter(input, output, delay=0.7, atten=4) (3)from…import *这个方法在 Windows平台上工作的就不是非常好，因为Windows是一个大小写不区分的系统。如果非要使用，请使用下面的方法： 1)在file:sounds/effects/__init__.py中包含如下代码__all__ = [&quot;echo&quot;, &quot;surround&quot;, &quot;reverse&quot;]。2)使用from sound.effects import *这种用法时，你只会导入包里面这三个子模块。 六、python标准库python标准库： 1.介绍2.内置函数3.内置常量3.1、所加入的常量site模块 4.内置类型 4.1、真值检验4.2、布尔运算 ： and，or，not4.3、比较4.4、数字类型 ： int，float，complex4.5、迭代器类型4.6、序列类型 ： list，tuple，range4.7、文本序列类型 ： str4.8、二进制序列类型： bytes，bytearray，memoryview4.9、设置类型 ： set，frozenset4.10、映射类型 ： dict4.11、上下文管理器类型4.12、其他内置类型4.13、特殊属性 5.内置异常 5.1、基类5.2、具体异常5.3、警告5.4、异常层次结构 6.文本处理服务 6.1、string ： 公共字符串操作6.2、re ： 正则表达式操作6.3、difflib ： 帮助计算增量6.4、textwrap ： 文本包装和填充6.5、unicodedata ： Unicode数据库6.6、stringprep ： 互联网字符串准备6.7、readline ： GNU readline界面6.8、rlcompleter ： GNU readline的完成功能 7.二进制数据服务 7.1、struct ： 将字节解释为打包二进制数据7.2、codecs ： 编解码器注册表和基类 8.数据类型 8.1、datetime ： 基本日期和时间类型8.2、calendar ： 日历相关功能8.3、collections ： 容器数据类型8.4、collections.abc ： 容器的抽象基类8.5、heapq ： 堆队列算法8.6、bisect ： 数组二分法8.7、array ： 数值的有效数组8.8、weakref ： 弱参考8.9、types ： 动态类型创建和内置类型的名称8.10、copy ： 浅和深复制操作8.11、pprint ： 数据漂亮的打印机8.12、reprlib： 替代repr()实施8.13、enum ： 支持枚举 9.数值和数学模块 9.1、numbers ： 数值抽象基类9.2、math ： 数学函数9.3、cmath ： 复数的数学函数9.4、decimal ： 十进制定点和浮点运算9.5、fractions ： 有理数9.6、random ： 生成伪随机数9.7、statistics ： 数学统计功能 10.功能编程模块 10.1、itertools ： 为高效循环创建迭代器的函数10.2、functools ： 对可调用对象的高阶函数和操作10.3、operator ： 标准操作符作为函数 11.文件和目录访问 11.1、pathlib ： 面向对象的文件系统路径11.2、os.path ： 公共路径名操作11.3、fileinput ： 从多个输入流的线路迭代11.4、stat： 解释stat()结果11.5、filecmp ： 文件和目录比较11.6、tempfile ： 生成临时文件和目录11.7、glob ： Unix样式的路径名模式扩展11.8、fnmatch ： Unix文件名模式匹配11.9、linecache ： 随机访问文本行11.10、shutil ： 高级文件操作11.11、macpath ： Mac OS 9路径处理功能 12.数据持久性12.1、pickle ： Python对象序列化12.2、copyreg ： 注册pickle支持功能12.3、shelve ： Python对象持久化12.4、marshal ： 内部Python对象序列化12.5、dbm ： 接口到Unix“数据库”12.6、sqlite3 ： SQLite数据库的DB：API 2.0接口 13.数据压缩和归档 13.1、zlib ： 压缩与gzip兼容13.2、gzip ： 支持gzip文件13.3、bz2 ：支持的bzip2压缩13.4、lzma ： 使用LZMA算法的压缩13.5、zipfile ： 使用ZIP存档13.6、tarfile ： 读取和写入tar存档文件 14.文件格式 14.1、csv ： CSV文件读写14.2、configparser ： 配置文件解析器14.3、netrc ： netrc文件处理14.4、xdrlib ： 编码和解码XDR数据14.5、plistlib： 生成和解析Mac OS X .plist文件 15.加密服务 15.1、hashlib ： 安全散列和消息摘要15.2、hmac ： 消息认证的键控散列15.3、secrets ： 生成安全的随机数以管理秘密 16.通用操作系统服务 16.1、os ： 其他操作系统接口16.2、io ： 用于处理流的核心工具16.3、time ： 时间访问和转换16.4、argparse ： 解析器，用于命令行选项，参数和子命令16.5、getopt ： 命令行选项的C样式解析器16.6、logging ： Python的日志记录工具16.7、logging.config ： 日志配置16.8、logging.handlers ： 日志处理程序16.9、getpass ： 便携式密码输入16.10、curses ： 字符单元显示的终端处理16.11、curses.textpad ： curses程序的文本输入小部件16.12、curses.ascii ： ASCII字符的实用程序16.13、curses.panel ： 诅咒的面板栈扩展16.14、platform ： 访问底层平台的标识数据16.15、errno ： 标准errno系统符号16.16、ctypes ： Python的外部函数库 17.并发执行 17.1、threading ： 基于线程的并行性17.2、multiprocessing ： 基于进程的并行性17.3、concurrent ： 并发包17.4、concurrent.futures ： 启动并行任务17.5、subprocess ： 子过程管理17.6、sched ： 事件调度器17.7、queue ： 同步队列类17.8、dummy_threading： threading模块的插入式更换17.9、_thread ： 低级线程API17.10、_dummy_thread： _thread模块的插入式更换 18.进程间通信和网络 18.1、socket ： 低级网络接口18.2、ssl ： 套接字对象的TLS / SSL包装器18.3、select ： 等待I / O完成18.4、selectors ： 高级I / O复用18.5、asyncio ： 异步I / O，事件循环，协同程序和任务18.6、asyncore ： 异步套接字处理程序18.7、asynchat ： 异步套接字命令/响应处理程序18.8、signal ： 为异步事件设置处理程序18.9、mmap ： 内存映射文件支持 19.互联网数据处理 19.1、email ： 电子邮件和MIME处理包19.2、json ： JSON编码器和解码器19.3、mailcap ： Mailcap文件处理19.4、mailbox ： 处理各种格式的邮箱19.5、mimetypes ： 将文件名映射到MIME类型19.6、base64 ： Base16，Base32，Base64，Base85数据编码19.7、binhex ： 编码和解码binhex4文件19.8、binascii ： 在二进制和ASCII之间转换19.9、quopri ： 编码和解码MIME引用的可打印数据19.10、uu ： 编码和解码uuencode文件 20.HTML与XML 20.1、html ： 超文本标记语言支持20.2、html.parser ： 简单的HTML和XHTML解析器20.3、html.entities ： HTML一般实体的定义20.4、xml ： XML处理模块20.5、xml.etree.ElementTree ： ElementTree XML API20.6、xml.dom ： 文档对象模型API20.7、xml.dom.minidom ： 小DOM实现20.8、xml.dom.pulldom ： 支持构建部分DOM树20.9、xml.sax ： 支持SAX2解析器20.10、xml.sax.handler ： SAX处理程序的基类20.11、xml.sax.saxutils ： SAX实用程序20.12、xml.sax.xmlreader ： XML解析器的接口20.13、xml.parsers.expat ： 快速XML解析使用Expat 21.互联网协议和支持 21.1、webbrowser ： 方便的Web浏览器控制器21.2、cgi ： 公共网关接口支持21.3、cgitb ： CGI脚本的跟踪管理器21.4、wsgiref ： WSGI实用程序和参考实现21.5、urllib ： URL处理模块21.6、urllib.request ： 用于打开网址的可扩展库21.7、urllib.response ： urllib使用的响应类21.8、urllib.parse ： 将URL解析到组件中21.9、urllib.error ： 由urllib.request引发的异常类21.10、urllib.robotparser ： 解析器，用于robots.txt21.11、http ： HTTP模块21.12、http.client ： HTTP协议客户端21.13、ftplib ： FTP协议客户端21.14、poplib ： POP3协议客户端21.15、imaplib ： IMAP4协议客户端21.16、nntplib ： NNTP协议客户端21.17、smtplib ： SMTP协议客户端21.18 smtpd ： SMTP服务器21.19、telnetlib ： Telnet客户端21.20、uuid ： 根据RFC 4122的UUID对象21.21、socketserver ： 网络服务器的框架21.22、http.server ： HTTP服务器21.23、http.cookies ： HTTP状态管理21.24、http.cookiejar ： HTTP客户端的Cookie处理21.25、xmlrpc ： XMLRPC服务器和客户端模块21.26、xmlrpc.client ： XML：RPC客户端访问21.27、xmlrpc.server ： 基本XML：RPC服务器21.28、ipaddress ： IPv4 / IPv6操作库 22.多媒体服务 22.1、audioop ： 处理原始音频数据22.2、aifc ： 读写AIFF和AIFC文件22.3、sunau ： 读写Sun AU文件22.4、wave ： 读写WAV文件22.5、chunk ： 读取IFF分块数据22.6、colorsys ： 颜色系统之间的转换22.7、imghdr ： 确定图像的类型22.8、sndhdr ： 确定声音文件的类型22.9、ossaudiodev ： 访问与OSS兼容的音频设备 23.国际化 23.1、gettext ： 多语言国际化服务23.2、locale ： 国际化服务 24.方案框架 24.1、turtle ： 海龟图形24.2、cmd ： 支持面向行的命令解释器24.3、shlex ： 简单的词汇分析 25.Tk的图形用户接口 25.1、tkinter ： Tcl / Tk的Python接口25.2、tkinter.ttk ： Tk主题小部件25.3、tkinter.tix ： Tk的扩展小部件25.4、tkinter.scrolledtext ： 滚动文本小部件25.5、闲25.6、其他图形用户界面包 26.开发工具 26.1、typing ： 支持类型提示26.2、pydoc ： 文档生成器和在线帮助系统26.3、doctest ： 测试交互式Python示例26.4、unittest ： 单元测试框架26.5、unittest.mock ： 模拟对象库26.6、unittest.mock： 入门26.7、2to3 ： 自动化Python 2到3代码翻译26.8、test ： Python的回归测试包26.9、test.support ： Python测试套件的实用程序 27.调试和分析 27.1、bdb ： 调试器框架27.2、faulthandler ： 转储Python回溯27.3、pdb ： Python调试器27.4、Python分析器27.5、timeit ： 测量小代码片段的执行时间27.6、trace ： 跟踪或跟踪Python语句执行27.7、tracemalloc ： 跟踪内存分配 28.软件包装和分发 28.1、distutils ： 构建和安装Python模块28.2、ensurepip： 引导安装pip程序28.3、venv ： 创建虚拟环境28.4、zipapp ： 管理可执行的python zip档案 29.Python运行时服务 29.1、sys ： 系统特定的参数和功能29.2、sysconfig ： 提供对Python的配置信息的访问29.3、builtins ： 内置对象29.4、__main__ ： 顶级脚本环境29.5、warnings ： 警告控制29.6、contextlib： 用于with语句上下文的实用程序29.7、abc ： 抽象基类29.8、atexit ： 退出处理程序29.9、traceback ： 打印或检索堆栈跟踪29.10、__future__ ： 未来语句定义29.11、gc ： 垃圾收集器接口29.12、inspect ： 检查活对象29.13、site ： 站点特定的配置钩子29.14、fpectl ： 浮点异常控制 30.自定义Python解释器 30.1、code ： 解释器基类30.2、codeop ： 编译Python代码 31.导入模块 31.1、zipimport ： 从Zip档案导入模块31.2、pkgutil ： 软件包扩展实用程序31.3、modulefinder ： 查找脚本使用的模块31.4、runpy ： 定位和执行Python模块31.5、importlib： 实施import 32.Python语言服务 32.1、parser ： 访问Python解析树32.2、ast ： 抽象语法树32.3、symtable ： 访问编译器的符号表32.4、symbol ： 用于Python解析树的常量32.5、token ： 用于Python解析树的常量32.6、keyword ： 测试Python关键字32.7、tokenize ： Tokenizer的Python源代码32.8、tabnanny ： 检测模糊缩进32.9、pyclbr ： Python类浏览器支持32.10、py_compile ： 编译Python源文件32.11、compileall ： 字节编译Python库32.12、dis ： Python字节码的反汇编32.13、pickletools ： 工具的腌菜开发商 33.其他 33.1、formatter ： 通用输出格式 34.MS Windows特定服务 34.1、msilib ： 读取和写入Microsoft Installer文件34.2、msvcrt ： 从MS VC ++运行时的有用的例程34.3、winreg ： Windows注册表访问34.4、winsound ： Windows的声音播放界面 35.Unix特定服务 35.1、posix ： 常见的POSIX系统调用35.2、pwd ： 密码数据库35.3、spwd ： shadow密码数据库35.4、grp ： 组数据库35.5、crypt ： 检查Unix密码的功能35.6、termios ： POSIX样式tty控件35.7、tty ： 端子控制功能35.8、pty ： 伪终端实用程序35.9、fcntl ： fcntl和ioctl系统调用35.10、pipes ： 外壳管道接口35.11、resource ： 资源使用信息35.12、nis ： Sun的NIS接口（黄页）35.13、syslog ： Unix系统日志库例程 36.取代模块 36.1、optparse ： 解析器，用于命令行选项36.2、imp ： 访问import内部 37.未记录的模块 37.1、平台特定模块 持续更新…","categories":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/tags/python/"}]},{"title":"python类和对象","slug":"python类和对象","date":"2017-12-30T03:00:00.000Z","updated":"2018-05-11T06:42:38.979Z","comments":true,"path":"2017/12/30/python类和对象/","link":"","permalink":"http://pythonfood.github.io/2017/12/30/python类和对象/","excerpt":"人生苦短，我用python。","text":"人生苦短，我用python。 一、基本概念 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 实例变量：定义在方法中的变量，只作用于当前实例的类。 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。 方法：类中定义的函数。 实例化：创建一个类的实例，类的具体对象。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 封装：将数据与方法放在一个类中就构成了封装。通俗的讲是指隐藏对象的属性和实现细节。 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。 多态：Pyhon不支持多态并且也用不到多态，多态的概念是应用于Java和C#这一类强类型语言中，而Python崇尚“鸭子类型”。 二、类的结构1、类和对象 123456789101112#类定义class MyClass: i = 12345 def f(self): return &apos;hello world&apos; # 类对象x = MyClass() # 访问类的属性和方法print(&quot;MyClass 类的属性 i 为：&quot;, x.i)print(&quot;MyClass 类的方法 f 输出为：&quot;, x.f()) 2、__init__()方法类的实例化操作会自动调用__init__()方法（构造方法），进行初始化。 1234567class Complex: def __init__(self, realpart, imagpart): self.r = realpart self.i = imagpart x = Complex(3.0, -4.5)print(x.r, x.i) 3、self参数self代表类的实例，而非类。 类的方法与普通的函数只有一个特别的区别：它们必须有一个额外的第一个参数名称self。 1234567class Test: def prt(self): print(self) #self代表的是类的实例，代表当前对象的地址 print(self.__class__) # self.class 则指向类 t = Test()t.prt() 4、类的方法def关键字来定义一个方法。 1234567891011121314151617181920#类定义class people: #定义基本属性 name = &apos;&apos; age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w #定义类的方法 def speak(self): print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age)) # 实例化类p = people(&apos;dada&apos;,10,30)p.speak() 三、类的继承1、单继承class DerivedClassName(BaseClassName): #基类与派生类定义在一个作用域内class DerivedClassName(modname.BaseClassName): #基类定义在另一个模块中 12345678910111213141516171819202122232425262728#类定义class people: #定义基本属性 name = &apos;&apos; age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age)) #单继承示例class student(people): grade = &apos;&apos; def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade)) s = student(&apos;ken&apos;,10,60,3)s.speak() 2、多继承class DerivedClassName(Base1, Base2, Base3):注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#类定义class people: #定义基本属性 name = &apos;&apos; age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age)) #单继承示例class student(people): grade = &apos;&apos; def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade)) #另一个类，多重继承之前的准备class speaker(): topic = &apos;&apos; name = &apos;&apos; def __init__(self,n,t): self.name = n self.topic = t def speak(self): print(&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;%(self.name,self.topic)) #多重继承class sample(speaker,student): a =&apos;&apos; def __init__(self,n,a,w,g,t): student.__init__(self,n,a,w,g) speaker.__init__(self,n,t) test = sample(&quot;Tim&quot;,25,80,4,&quot;Python&quot;)test.speak() #方法名同，默认调用的是在括号中排前地父类的方法 3、方法重写如果父类方法的功能不能满足子类的需求，可以在子类重写父类的方法。 1234567891011class Parent: # 定义父类 def myMethod(self): print (&apos;调用父类方法&apos;) class Child(Parent): # 定义子类 def myMethod(self): print (&apos;调用子类方法&apos;) c = Child() # 子类实例c.myMethod() # 子类调用重写方法super(Child,c).myMethod() #用子类对象调用父类已被覆盖的方法 ps：super() 函数是用于调用父类(超类)的一个方法。 四、类属性与方法1、属性与方法 类的私有属性__private_attrs：两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。 类的私有方法__private_method()：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类地外部调用。在类内部的方法中使用时 self.__private_method()。 类的属性attrs：公开变量。 类的方法method()：公开方法。类方法必须包含参数self，self的名字并不是规定死的，也可以使用this，但是最好还是按照约定是用self。 1234567891011121314151617181920class Site: def __init__(self, name, url): self.name = name # public self.__url = url # private def who(self): print(&apos;name : &apos;, self.name) print(&apos;url : &apos;, self.__url) def __foo(self): # 私有方法 print(&apos;这是私有方法&apos;) def foo(self): # 公共方法 print(&apos;这是公共方法&apos;) self.__foo() x = Site(&apos;baidu&apos;, &apos;www.baidu.com&apos;)x.who() # 正常输出x.foo() # 正常输出x.__foo() # 报错 2、特殊的类属性 类名.__name__ #类的名字(字符串) 类名.__doc__ #类的文档字符串 类名.__base__ #类的第一个父类(在讲继承时会讲) 类名.__bases__ #类所有父类构成的元组(在讲继承时会讲) 类名.__dict__ #类的字典属性 类名.__module__ #类定义所在的模块 类名.__class__ #实例对应的类(仅新式类中) 我们定义的类的属性到底存到哪里了？有两种方式查看：方法一： dir(类名)查出的是一个名字列表方法二： 类名.__dict__查出的是一个字典，key为属性名，value为属性值 3、类的专有方法 __init__() #构造函数，在生成对象时调用 __del__() #析构函数，释放对象时使用 __repr__() #打印，转换 __setitem__() #按照索引赋值 __getitem__() #按照索引获取值 __len__() #获得长度 __cmp__() #比较运算 __call__() #函数调用 __add__() #加运算 __sub__() #减运算 __mul__() #乘运算 __div__() #除运算 __mod__() #求余运算 __pow__() #乘方 持续更新…","categories":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/tags/python/"}]},{"title":"python函数","slug":"python函数","date":"2017-12-30T02:30:00.000Z","updated":"2018-05-22T07:16:25.686Z","comments":true,"path":"2017/12/30/python函数/","link":"","permalink":"http://pythonfood.github.io/2017/12/30/python函数/","excerpt":"人生苦短，我用python。","text":"人生苦短，我用python。 一、基本概念1、定义函数12def 函数名（参数列表）: 函数体 12def area(width, height): return width * height 2、调用函数12方式一：函数名（参数列表）方式二：变量名 = 函数名 123456789#调用方式1def printme( str ): print (str); return;printme(&quot;我要调用函数!&quot;)#调用方式2pr = printmepr(&quot;我要调用函数!&quot;) 3、参数传递(1)可更改(mutable)与不可更改(immutable)对象：在python中，numbers,strings,tuples,是不可更改的对象，而list,dict等则是可以修改的对象。 传不可变对象：传递的只是不可变对象的值，没有影响不可变对象本身。 传可变对象：可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。 (2)参数： 必需参数 默认参数 可变参数 关键字参数 1)必选参数必选参数就是在调用函数的时候要传入数量一致的参数。 12def add(x, y): print x + y 2)默认参数默认参数是指在定义函数的时候提供一些默认值，如果在调用函数的时候没有传递该参数，则自动使用默认值，否则使用传递时该参数的值。 12def add(x, y, z=1): #默认参数要放在所有必选参数的后面,默认参数应该使用不可变对象。 print x + y + z 3)可变参数可变参数允许你将不定数量的参数传递给函数。 12345678def printinfo( arg1, *vartuple ): print (arg1) for var in vartuple: print (var) return;printinfo( 10 );printinfo( 70, 60, 50 ); 4)关键字参数而关键字参数则允许你将不定长度的键值对, 作为参数传递给一个函数。 1234567891011def sum(**kwargs): sum = 0 for k, v in kwargs.items(): sum += v return sum dict1 = &#123;&apos;x&apos;: 1&#125;sum(**dict1) dict2 = &#123;&apos;x&apos;: 2, &apos;y&apos;: 6&#125; sum(**dict2) 5)参数组合它们在使用的时候是有顺序的，依次是必选参数、默认参数、可变参数、关键字参数。 123456def func(x, y, z=0, *args, **kwargs): print(&apos;x =&apos;, x) print(&apos;y =&apos;, y) print(&apos;z =&apos;, z) print(&apos;args =&apos;, args) print(&apos;kwargs =&apos;, kwargs) 4、return语句return [表达式] 语句用于退出函数，选择性地向调用方返回一个tuple表达式。 (1)返回一个值12345def sum( arg1, arg2 ): total = arg1 + arg2 return total total = sum( 10, 20 ) (2)返回多个值1234567import mathdef move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny x, y = move(100, 100, 60, math.pi / 6) 二、变量作用域1、变量作用域以 L –&gt; E –&gt; G –&gt;B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。 L （Local） 局部作用域 E （Enclosing） 闭包函数外的函数中 G （Global） 全局作用域 B （Built-in） 内建作用域 1234567x = int(2.9) # 内建作用域 g_count = 0 # 全局作用域def outer(): o_count = 1 # 闭包函数外的函数中 def inner(): i_count = 2 # 局部作用域 2、作用域引入Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问 3、global和nonlocal关键字(1)当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字了1234567num = 1def fun1(): global num # 需要使用 global 关键字声明 print(num) num = 123 print(num)fun1() (2)如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要nonlocal关键字了123456789def outer(): num = 10 def inner(): nonlocal num # nonlocal关键字声明 num = 100 print(num) inner() print(num)outer() 三、匿名函数使用lambda来创建匿名函数。lambda [arg1 [,arg2,.....argn]]:expression12sum = lambda arg1, arg2: arg1 + arg2print (sum( 10, 20 )) python中有几个定义好的全局函数方便使用：map、filter、reduce。1234567891011121314from functools import reduce foo = [2, 18, 9, 22, 17, 24, 8, 12, 27]# map 遍历序列，对序列中每个元素进行操作，最终获取新的序列。print (list(map(lambda x: x * 2 + 10, foo)))# [14, 46, 28, 54, 44, 58, 26, 34, 64]# filter 对于序列中的元素进行筛选，最终获取符合条件的序列。print (list(filter(lambda x: x % 3 == 0, foo)))# [18, 9, 24, 12, 27] # reduce 对于序列内所有元素进行累计操作print (reduce(lambda x, y: x + y, foo))# 139 持续更新…","categories":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/tags/python/"}]},{"title":"python条件循环","slug":"python条件循环","date":"2017-12-30T02:00:00.000Z","updated":"2018-05-11T06:42:05.728Z","comments":true,"path":"2017/12/30/python条件循环/","link":"","permalink":"http://pythonfood.github.io/2017/12/30/python条件循环/","excerpt":"人生苦短，我用python。","text":"人生苦短，我用python。 一、if语句1、if语句的一般形式。123456if condition_1: statement_block_1elif condition_2: statement_block_2else: statement_block_3 12345678910age = int(input(&quot;请输入你家狗狗的年龄: &quot;))if age &lt; 0: print(&quot;你是在逗我吧!&quot;)elif age == 1: print(&quot;相当于 14 岁的人。&quot;)elif age == 2: print(&quot;相当于 22 岁的人。&quot;)else: human = 22 + (age -2)*5 print(&quot;对应人类年龄: &quot;, human) 2、if嵌套123456789101112if 表达式1: 语句 if 表达式2: 语句 elif 表达式3: 语句 else: 语句elif 表达式4: 语句else: 语句 1234567891011num=int(input(&quot;输入一个数字：&quot;))if num%2==0: if num%3==0: print (&quot;你输入的数字可以整除 2 和 3&quot;) else: print (&quot;你输入的数字可以整除 2，但不能整除 3&quot;)else: if num%3==0: print (&quot;你输入的数字可以整除 3，但不能整除 2&quot;) else: print (&quot;你输入的数字不能整除 2 和 3&quot;) 3、if中常用的操作运算符 操作符 描述 &lt; 小于 &lt;= 小于或等于 &gt; 大于 &gt;= 大于或等于 == 等于，比较对象是否相等 != 不等于 4、if条件表达式（三目操作符）X if C else Ysmaller = x if x&lt;y else y 二、while循环1、while语句的一般形式。12while 判断条件： 语句 1234567n = 100sum = 0counter = 1while counter &lt;= n: sum = sum + counter counter += 1print(&quot;1 到 %d 之和为: %d&quot; % (n,sum)) 2、while … else … 在条件语句为false时执行else的语句块。 123456count = 0while count &lt; 5: print (count, &quot; 小于 5&quot;) count = count + 1else: print (count, &quot; 大于或等于 5&quot;) 三、for循环1、for循环的一般格式。1234for &lt;variable&gt; in &lt;sequence&gt;: &lt;statements&gt;else: &lt;statements&gt; 123languages = [&quot;C&quot;, &quot;C++&quot;, &quot;Perl&quot;, &quot;Python&quot;] for x in languages: print (x) 2、for … else … 在条件语句为false时执行else的语句块。break语句会跳过else。 3、range()函数(1)range生成数列。12for i in range(5): print(i) (2)range指定区间的值。12for i in range(5,9) : print(i) (3)range指定步长。12for i in range(0, 10, 3) : print(i) (4)range指定负数12for i in range(-10, -100, -30) : print(i) (5)range()和len()函数以遍历一个序列的索引。123a = [&apos;Google&apos;, &apos;Baidu&apos;, &apos;Runoob&apos;, &apos;Taobao&apos;, &apos;QQ&apos;]for i in range(len(a)): print(i, a[i]) (6)range()函数来创建一个列表。1list(range(5)) 四、循环控制1、break语句可以跳出for和while的循环体，停止整个循环。 2、continue语句跳过本次循环，进入到下一次循环。 3、pass语句是空语句，是为了保持程序结构的完整性。 持续更新…","categories":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/tags/python/"}]},{"title":"python运算符","slug":"python运算符","date":"2017-12-30T01:30:00.000Z","updated":"2018-05-11T06:41:40.507Z","comments":true,"path":"2017/12/30/python运算符/","link":"","permalink":"http://pythonfood.github.io/2017/12/30/python运算符/","excerpt":"人生苦短，我用python。","text":"人生苦短，我用python。 一、算术运算符以下假设变量a为10，变量b为21： 运算符 描述 实例 + 加 - 两个对象相加 a + b 输出结果 31 - 减 - 得到负数或是一个数减去另一个数 a - b 输出结果 -11 * 乘 - 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 210 / 除 - x 除以 y b / a 输出结果 2.1 % 取模 - 返回除法的余数 b % a 输出结果 1 ** 幂 - 返回x的y次幂 a**b 为10的21次方 // 取整除 - 返回商的整数部分 9//2 输出结果 4 , 9.0//2.0 输出结果 4.0 二、比较运算符以下假设变量a为10，变量b为20： 运算符 描述 实例 == 等于 - 比较对象是否相等 (a == b) 返回 False。 != 不等于 - 比较两个对象是否不相等 (a != b) 返回 True。 &gt; 大于 - 返回x是否大于y (a &gt; b) 返回 False。 &lt; 小于 - 返回x是否小于y。 (a &lt; b) 返回 True。 &gt;= 大于等于 - 返回x是否大于等于y。 (a &gt;= b) 返回 False。 &lt;= 小于等于 - 返回x是否小于等于y。 (a &lt;= b) 返回 True。 ps:所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。 三、赋值运算符以下假设变量a为10，变量b为20： 运算符 描述 实例 = 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c *= a 等效于 c = c * a /= 除法赋值运算符 c /= a 等效于 c = c / a %= 取模赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c **= a 等效于 c = c ** a //= 取整除赋值运算符 c //= a 等效于 c = c // a 四、逻辑运算符以下假设变量 a 为 10, b为 20: 运算符 逻辑表达式 描述 实例 and x and y 布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False 五、位运算符下表中变量 a 为 60，b 为 13二进制格式如下：a = 0011 1100 b = 0000 1101 运算符 描述 实例 &amp; 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 (a &amp; b) 输出结果 12 ，二进制解释： 0000 1100 &#124; 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 (a &#124; b) 输出结果 61 ，二进制解释： 0011 1101 ^ 按位异或运算符：当两对应的二进位相异时，结果为1 (a ^ b) 输出结果 49 ，二进制解释： 0011 0001 ~ 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。~x 类似于 -x-1 (~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。 &lt;&lt; 左移动运算符：运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。 a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000 &gt;&gt; 右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数 a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111 六、成员运算符Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False。 x 在 y 序列中 , 如果 x 在 y 序列中返回 True。 not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 七、身份运算符身份运算符用于比较两个对象的存储单元。 运算符 描述 实例 is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。 ps:id()函数用于获取对象内存地址。 is 与 == 区别：is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。 八、运算符优先级以下表格列出了从最高到最低优先级的所有运算符： 运算符 描述 ** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) * / % // 乘，除，取模和取整除 + - 加法减法 &gt;&gt; &lt;&lt; 右移，左移运算符 &amp; 位 ‘AND’ ^ &#124; 位运算符 &lt;= &lt; &gt; &gt;= 比较运算符 &lt;&gt; == != 等于运算符 = %= /= //= -= += = *= 赋值运算符 is is not 身份运算符 in not in 成员运算符 not or and 逻辑运算符 持续更新…","categories":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/tags/python/"}]},{"title":"python数据类型","slug":"python数据类型","date":"2017-12-30T01:00:00.000Z","updated":"2018-05-11T06:41:15.366Z","comments":true,"path":"2017/12/30/python数据类型/","link":"","permalink":"http://pythonfood.github.io/2017/12/30/python数据类型/","excerpt":"人生苦短，我用python。","text":"人生苦短，我用python。 一、Number 数字1、Python3支持int、float、bool（True/False）、complex（复数）。a, b, c, d = 20, 5.5, True, 4+3j2、type() 查询变量所指的对象类型，不会认为子类是一种父类类型。print(type(a))3、isinstance() 查询变量所指的对象类型，会认为子类是一种父类类型。isinstance(a, int)4、del语句删除一些对象引用。del var_a, var_b5、不同类型的数混合运算时会将整数转换为浮点数。3 * 3.75 / 1.5 数字类型转换 int(x) #将x转换为一个整数。 float(x) #将x转换到一个浮点数。 complex(x) #将x转换到一个复数，实数部分为 x，虚数部分为 0。 complex(x, y) #将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。 数学函数 函数 返回值 ( 描述 ) abs(x) 返回数字的绝对值，如abs(-10) 返回 10 ceil(x) 返回数字的上入整数，如math.ceil(4.1) 返回 5 cmp(x, y) 如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。 Python 3 已废弃 。使用 使用 (x&gt;y)-(x&lt;y) 替换。 exp(x) 返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045 fabs(x) 返回数字的绝对值，如math.fabs(-10) 返回10.0 floor(x) 返回数字的下舍整数，如math.floor(4.9)返回 4 log(x) 如math.log(math.e)返回1.0,math.log(100,10)返回2.0 log10(x) 返回以10为基数的x的对数，如math.log10(100)返回 2.0 max(x1, x2,…) 返回给定参数的最大值，参数可以为序列。 min(x1, x2,…) 返回给定参数的最小值，参数可以为序列。 modf(x) 返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。 pow(x, y) x**y 运算后的值。 round(x [,n]) 返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。 sqrt(x) 返回数字x的平方根。 随机数函数 函数 描述 choice(seq) 从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。 randrange([start,] stop [,step]) 从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值为1 random() 随机生成下一个实数，它在[0,1)范围内。 seed([x]) 改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。 shuffle(lst) 将序列的所有元素随机排序 uniform(x, y) 随机生成下一个实数，它在[x,y]范围内。 三角函数 函数 描述 acos(x) 返回x的反余弦弧度值。 asin(x) 返回x的反正弦弧度值。 atan(x) 返回x的反正切弧度值。 atan2(y, x) 返回给定的 X 及 Y 坐标值的反正切值。 cos(x) 返回x的弧度的余弦值。 hypot(x, y) 返回欧几里德范数 sqrt(xx + yy)。 sin(x) 返回的x弧度的正弦值。 tan(x) 返回x弧度的正切值。 degrees(x) 将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0 radians(x) 将角度转换为弧度 二、String ‘字符串’1、字符串用单引号’或双引号”括起来。str = &#39;pythonfood&#39;2、Python中的字符串不能改变。print (str)3、使用反斜杠\\转义特殊字符print(&#39;pytho\\nfoob&#39;)4、使用r表示原始字符串print(r&#39;pytho\\nfoob&#39;)5、用+运算符连接字符串print (str + &quot;TEST&quot;)6、用*运算符重复字符串 print (str * 2)7、截取变量[头下标:尾下标]print (str[2:5]) #截取从第三个开始到第五个的字符8、字符串更新可以截取字符串的一部分并与其他字段拼接var1 = &#39;Hello World!&#39;var1 = var1[:6] + &#39;Runoob!&#39;9、python三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。12345para_str = &quot;&quot;&quot;这是一个多行字符串的实例多行字符串可以使用制表符TAB ( \\t )。也可以使用换行符 [ \\n ]。&quot;&quot;&quot; 10、Unicode字符串的语法是在字符串前面加上前缀u。在Python3中所有的字符串都是Unicode字符串。 转义字符 转义字符 描述 \\(在行尾时) 续行符 \\\\ 反斜杠符号 \\’ 单引号 \\” 双引号 \\a 响铃 \\b 退格(Backspace) \\e 转义 \\000 空 \\n 换行 \\v 纵向制表符 \\t 横向制表符 \\r 回车 \\f 换页 \\oyy 八进制数，yy代表的字符，例如：\\o12代表换行 \\xyy 十六进制数，yy代表的字符，例如：\\x0a代表换行 \\other 其它的字符以普通格式输出 字符串运算符 操作符 描述 实例 + 字符串连接 a + b 输出结果： HelloPython * 重复输出字符串 a*2 输出结果：HelloHello [] 通过索引获取字符串中字符 a[1] 输出结果 e [ : ] 截取字符串中的一部分 a[1:4] 输出结果 ell in 成员运算符 - 如果字符串中包含给定的字符返回 True ‘H’ in a 输出结果 1 not in 成员运算符 - 如果字符串中不包含给定的字符返回 True ‘M’ not in a 输出结果 1 r/R 原始字符串 - 原始字符串除在字符串的第一个引号前加上字母 r（可以大小写）以外，与普通字符串有着几乎完全相同的语法。 print( r’\\n’ )print( R’\\n’ ) % 格式字符串 请看下一节内容。 字符串格式化print (&quot;我叫 %s 今年 %d 岁!&quot; % (&#39;小明&#39;, 10)) （1）字符串格式化符号 符号 描述 %c 格式化字符及其ASCII码 %s 格式化字符串 %d 格式化整数 %u 格式化无符号整型 %o 格式化无符号八进制数 %x 格式化无符号十六进制数 %X 格式化无符号十六进制数（大写） %f 格式化浮点数字，可指定小数点后的精度 %e 用科学计数法格式化浮点数 %E 作用同%e，用科学计数法格式化浮点数 %g %f和%e的简写 %G %f 和 %E 的简写 %p 用十六进制数格式化变量的地址 （2）格式化操作符辅助指令可以用如下的方式，对格式进行进一步的控制：%[(name)][flags][width].[precision]typecode (name)为命名 flags可以有+,-,’ ‘或0。+表示右对齐。-表示左对齐。’ ‘为一个空格，表示在正数的左侧填充一个空格，从而与负数对齐。0表示使用0填充。例如：print(“%04d” % 5) width表示显示宽度 precision表示小数点后精度。例如：print(“%6.3f” % 2.3) width, precision为两个整数。我们可以利用，来动态代入这两个量。例如：print(“%.f” % (4, 1.2)) 符号 描述 * 定义宽度或者小数点精度 - 用做左对齐 + 在正数前面显示加号( + ) 在正数前面显示空格 # 在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’) 0 显示的数字前面填充’0’而不是默认的空格 % ‘%%’输出一个单一的’%’ (var) 映射变量(字典参数) m.n. m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话) （3）format() 格式化函数 1)不设置指定位置，按默认顺序 &quot;{} {}&quot;.format(&quot;hello&quot;, &quot;world&quot;) 2)设置指定位置 &quot;{0} {1}&quot;.format(&quot;hello&quot;, &quot;world&quot;)&quot;{1} {0} {1}&quot;.format(&quot;hello&quot;, &quot;world&quot;) 3)设置参数 print(&quot;网站名：{name}, 地址 {url}&quot;.format(name=&quot;百度&quot;, url=&quot;www.baidu.com&quot;)) 4)通过字典设置参数 site = {&quot;name&quot;: &quot;百度&quot;, &quot;url&quot;: &quot;www.baidu.com&quot;}print(“网站名：{name}, 地址 {url}”.format(**site)) 5)通过列表索引设置参数 my_list = [&#39;百度&#39;, &#39;www.baidu.com&#39;]print(&quot;网站名：{0[0]}, 地址 {0[1]}&quot;.format(my_list)) # “0” 是必须的 6)可以向 str.format()传入对象 12345class AssignValue(object): def __init__(self, value): self.value = valuemy_value = AssignValue(6)print(&apos;value 为: &#123;0.value&#125;&apos;.format(my_value)) # &quot;0&quot; 是可选的 7)str.format() 格式化数字 print(&quot;{:.2f}&quot;.format(3.1415926)) 1234^, &lt;, &gt; 分别是居中、左对齐、右对齐，后面带宽度。 : 号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。+号表示在正数前显示 +，负数前显示 -；（空格）表示在正数前加空格。b、d、o、x 分别是二进制、十进制、八进制、十六进制。 字符串内建函数 方法 描述 capitalize() 将字符串的第一个字符转换为大写 center(width, fillchar) 返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。 count(str, beg= 0,end=len(string)) 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数 bytes.decode(encoding=”utf-8”, errors=”strict”) Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。 encode(encoding=’UTF-8’,errors=’strict’) 以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’ endswith(suffix, beg=0, end=len(string)) 检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False. expandtabs(tabsize=8) 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。 find(str, beg=0 end=len(string)) 检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1 index(str, beg=0, end=len(string)) 跟find()方法一样，只不过如果str不在字符串中会报一个异常. isalnum() 如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True,否则返回 False isalpha() 如果字符串至少有一个字符并且所有字符都是字母则返回 True, 否则返回 False isdigit() 如果字符串只包含数字则返回 True 否则返回 False.. islower() 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False isnumeric() 如果字符串中只包含数字字符，则返回 True，否则返回 False isspace() 如果字符串中只包含空白，则返回 True，否则返回 False. istitle() 如果字符串是标题化的(见 title())则返回 True，否则返回 False isupper() 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False join(seq) 以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串 len(string) 返回字符串长度 ljust(width[, fillchar]) 返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。 lower() 转换字符串中所有大写字符为小写. lstrip() 截掉字符串左边的空格或指定字符。 maketrans() 创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。 max(str) 返回字符串 str 中最大的字母。 min(str) 返回字符串 str 中最小的字母。 replace(old, new [, max]) 把旧字符串中的 str1 替换成 str2,如果 max 指定，则替换不超过 max 次。 rfind(str, beg=0,end=len(string)) 类似于 find()函数，不过是从右边开始查找. rindex( str, beg=0, end=len(string)) 类似于 index()，不过是从右边开始. rjust(width,[, fillchar]) 返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串 rstrip() 删除字符串字符串末尾的空格. split(str=””, num=string.count(str)) num=string.count(str)) 以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num 个子字符串 splitlines([keepends]) 按照行(‘\\r’, ‘\\r\\n’, \\n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。 startswith(str, beg=0,end=len(string)) 检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。 strip([chars]) 在字符串上执行 lstrip()和 rstrip() swapcase() 将字符串中大写转换为小写，小写转换为大写 title() 返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle()) translate(table, deletechars=””) 根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中 upper() 转换字符串中的小写字母为大写 zfill (width) 返回长度为 width 的字符串，原字符串右对齐，前面填充0 isdecimal() 检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。 三、List [列表]1、List写在方括号之间，元素用逗号隔开。list = [ &#39;abcd&#39;, 786 , 2.23, &#39;baidu&#39;, 70.2 ]2、和字符串一样，list可以被索引和切片。print (list[0])print (list[1:3])3、加号（+）是列表连接运算符。tinylist = [123, &#39;baidu&#39;]print (list + tinylist)4、星号（*）是重复操作。tinylist = [123, &#39;baidu&#39;]print (tinylist*2)5、List中的元素是可以改变的。6、更新列表list = [&#39;Google&#39;, &#39;baidu&#39;, 2000]list[1] = &#39;firefox&#39;7、删除列表元素dellist = [&#39;Google&#39;, &#39;baidu&#39;, 2000]del list[2] 列表操作符 Python表达式 结果 描述 len([1, 2, 3]) 3 长度 [1, 2, 3] + [4, 5, 6] [1, 2, 3, 4, 5, 6] 组合 [‘Hi!’] * 4 [‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’] 重复 3 in [1, 2, 3] TRUE 元素是否存在于列表中 for x in [1, 2, 3]: print(x, end=” “) 1 2 3 迭代 列表函数 函数 描述 len(list) 列表元素个数 max(list) 返回列表元素最大值 min(list) 返回列表元素最小值 list(seq) 将元组转换为列表 列表方法 方法 描述 list.append(obj) 在列表末尾添加新的对象 list.count(obj) 统计某个元素在列表中出现的次数 list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） list.index(obj) 从列表中找出某个值第一个匹配项的索引位置 list.insert(index, obj) 将对象插入列表 list.pop(obj=list[-1]) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 list.remove(obj) 移除列表中某个值的第一个匹配项 list.reverse() 反向列表中元素 list.sort([func]) 对原列表进行排序 list.clear() 清空列表 list.copy() 复制列表 四、Tuple（元组,）1、元组写在小括号()里，元素之间用逗号隔开。tuple = (&#39;abcd&#39;, 786 , 2.23, &#39;baidu&#39;, 70.2)2、与字符串一样，元组的元素不能修改。3、元组也可以被索引和切片。print (tuple[0])print (tuple[1:3])4、注意构造包含0或1个元素的元组的特殊语法规则。tup1 = ()tup2 = (20,)5、加号（+）是列表连接运算符。tinytuple = (123, &#39;baidu&#39;)print (tuple + tinytuple)6、星号（*）是重复操作。tinytuple = [123, &#39;baidu&#39;]print (tinytuple*2)7、修改元组元组中的元素值是不允许修改的，但我们可以对元组进行连接组合：tup1 = (12, 34.56)tup2 = (&#39;abc&#39;, &#39;xyz&#39;)tup3 = tup1 + tup28、删除元组元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组：tup = (&#39;Google&#39;, &#39;Runoob&#39;, 1997, 2000)del tup 元组运算符 Python表达式 结果 描述 len((1, 2, 3)) 3 计算元素个数 (1, 2, 3) + (4, 5, 6) (1, 2, 3, 4, 5, 6) 连接 (‘Hi!’,) * 4 (‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’) 复制 3 in (1, 2, 3) TRUE 元素是否存在 for x in (1, 2, 3): print x, 1 2 3 迭代 元组内置函数 函数 描述 len(tuple) 计算元组元素个数。 max(tuple) 返回元组中元素最大值。 min(tuple) 返回元组中元素最小值。 tuple(seq) 将列表转换为元组。 五、Dictionary {‘字’:’典’}1、字典是一种映射类型，字典用”{ }”标识，它是一个无序的键(key) : 值(value)对集合。tinydict = {&#39;name&#39;: &#39;baidu&#39;,&#39;code&#39;:1, &#39;site&#39;: &#39;www.baidu.com&#39;}2、键(key)必须使用不可变类型，如字符串，数字或元组。3、在同一个字典中，键(key)必须是唯一的。4、创建空字典使用 { }。5、构造函数 dict()可以直接从键值对序列中构建字典。dict([(&#39;baidu&#39;, 1), (&#39;Google&#39;, 2), (&#39;Taobao&#39;, 3)])6、访问字典里的值。dict = {&#39;Name&#39;: &#39;baidu&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;}print ( dict[&#39;Name&#39;])7、修改字典。dict = {&#39;Name&#39;:&#39;baidu&#39;,&#39;Age&#39;:&#39;7&#39;,&#39;Class&#39;:&#39;First&#39;}dict[&#39;Name&#39;] = &#39;google&#39; #更新信息dict[&#39;School&#39;] = &#39;QingHua&#39; #增加信息8、删除字典元素。dict = {&#39;Name&#39;:&#39;baidu&#39;,&#39;Age&#39;:&#39;7&#39;,&#39;Class&#39;:&#39;First&#39;}del dict[&#39;Name&#39;] #删除元素dict.clear() #清空字典del dict #删除字典 字典内置函数 函数 描述 len(dict) 计算字典元素个数，即键的总数。 str(dict) 输出字典，以可打印的字符串表示。 type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。 字典内置方法 方法 描述 radiansdict.clear() 删除字典内所有元素 radiansdict.copy() 返回一个字典的浅复制 radiansdict.fromkeys() 创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值 radiansdict.get(key, default=None) 返回指定键的值，如果值不在字典中返回default值 key in dict 如果键在字典dict里返回true，否则返回false radiansdict.items() 以列表返回可遍历的(键, 值) 元组数组 radiansdict.keys() 以列表返回一个字典所有的键 radiansdict.setdefault(key, default=None) 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default radiansdict.update(dict2) 把字典dict2的键/值对更新到dict里 radiansdict.values() 以列表返回字典中的所有值 pop(key[,default]) 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。 popitem() 随机返回并删除字典中的一对键和值(一般删除末尾对)。 六、Set {集合}1、集合（set）是一个无序不重复元素的序列。student = {&#39;Tom&#39;, &#39;Jim&#39;, &#39;Mary&#39;, &#39;Tom&#39;, &#39;Jack&#39;, &#39;Rose&#39;}print(student) # 重复的元素被自动去掉2、可以使用大括号{ }或者set()函数创建集合。parame = {value01,value02,...}set(value)3、创建一个空集合必须用set()，而不是{ }，因为 { } 是用来创建一个空字典。set() python数据类型转换 函数 描述 int(x [,base]) 将x转换为一个整数 float(x) 将x转换到一个浮点数 complex(real [,imag]) 创建一个复数 str(x) 将对象 x 转换为字符串 repr(x) 将对象 x 转换为表达式字符串 eval(str) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s) 将序列 s 转换为一个元组 list(s) 将序列 s 转换为一个列表 set(s) 转换为可变集合 dict(d) 创建一个字典。d 必须是一个序列 (key,value)元组。 frozenset(s) 转换为不可变集合 chr(x) 将一个整数转换为一个字符 ord(x) 将一个字符转换为它的整数值 hex(x) 将一个整数转换为一个十六进制字符串 oct(x) 将一个整数转换为一个八进制字符串 持续更新…","categories":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/tags/python/"}]},{"title":"python初探","slug":"python初探","date":"2017-12-30T00:30:00.000Z","updated":"2018-05-11T06:40:59.676Z","comments":true,"path":"2017/12/30/python初探/","link":"","permalink":"http://pythonfood.github.io/2017/12/30/python初探/","excerpt":"人生苦短，我用python。","text":"人生苦短，我用python。 一、查看版本python -V 二、注释#!/usr/bin/python3 # -*- coding: utf-8 -*- # 第一个注释 # 第二个注释 &apos;&apos;&apos; 第三注释 第四注释 &apos;&apos;&apos; &quot;&quot;&quot; 第五注释 第六注释 &quot;&quot;&quot; 三、标识符第一个字符必须是字母表中字母或下划线&apos;_&apos;。 标识符的其他的部分有字母、数字和下划线组成。 标识符对大小写敏感。 四、保留字&gt;&gt;&gt; import keyword &gt;&gt;&gt; keyword.kwlist [&apos;False&apos;, &apos;None&apos;, &apos;True&apos;, &apos;and&apos;, &apos;as&apos;, &apos;assert&apos;, &apos;break&apos;, &apos;class&apos;, &apos;continue&apos;, &apos;def&apos;, &apos;del&apos;, &apos;elif&apos;, &apos;else&apos;, &apos;except&apos;, &apos;finally&apos;, &apos;for&apos;, &apos;from&apos;, &apos;global&apos;, &apos;if&apos;, &apos;import&apos;, &apos;in&apos;, &apos;is&apos;, &apos;lambda&apos;, &apos;nonlocal&apos;, &apos;not&apos;, &apos;or&apos;, &apos;pass&apos;, &apos;raise&apos;, &apos;return&apos;, &apos;try&apos;, &apos;while&apos;, &apos;with&apos;, &apos;yield&apos;] 五、输入输出print(&apos;hello world&apos;，end=&apos;,&apos;) #关键字end可以用于将结果输出到同一行，或者在输出的末尾添加不同的字符 input(&apos;\\n\\n按下 enter 键后退出&apos;) 持续更新…","categories":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/tags/python/"}]},{"title":"python安装-windows","slug":"python安装-windows","date":"2017-12-30T00:00:00.000Z","updated":"2018-05-11T06:40:38.715Z","comments":true,"path":"2017/12/30/python安装-windows/","link":"","permalink":"http://pythonfood.github.io/2017/12/30/python安装-windows/","excerpt":"人生苦短，我用python。","text":"人生苦短，我用python。 一、下载安装包进入python官网，下载最新python安装包。 二、自定义安装下载完成后进行安装，安装时选自定义安装（customize installation）。ps:最好勾选Add python 3.6 to path，如果未勾选，需手动配置环境变量 三、 完成安装一路勾选全部选项，自定义安装路径，完成安装后点击close退出。ps:记得勾选pip安装选项，便于后续安装其他库 四、验证环境进入cmd，输入python，测试是否安装成功。 持续更新…","categories":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://pythonfood.github.io/tags/python/"}]},{"title":"adb","slug":"adb","date":"2017-12-29T06:00:00.000Z","updated":"2018-05-11T06:39:23.423Z","comments":true,"path":"2017/12/29/adb/","link":"","permalink":"http://pythonfood.github.io/2017/12/29/adb/","excerpt":"adb常用命令笔记。","text":"adb常用命令笔记。 一、adb简介adb（Android debug bridge），意为调试Android设备的桥梁。主要存放在sdk安装目录下的platform-tools文件夹中。可以管理、调试Emulator(模拟机)或Device(安卓真机)。adb是一个C/S架构的应用程序,由三部分组成： adb client：adb 客户端，在PC上运行。 adb server：adb 服务端，在PC上运行。 adb daemon：adbd 守护进程，在Emulator或Device上运行。 1、adb server与adb client的连接当adb server启动时，会绑定到本地的5037（tcp）端口，通过此端口监听从adb client发来的信息。 2、adb server与adb daemon的连接adb server与Emulator(或Device)连接时使用两个(一组)端口进行： 一个奇数的5555，先建立adb server与adbd的连接通信。 一个为偶数的5554，再建立与Emulator(或Device)的交互连接。 ps:adb server通过扫描5555—5585之间的奇数端口搜索adb daemon，进行adb连接；而用相应的偶数端口(奇数端口号-1，如5555对应5554)进行Emulator或Device实例的连接。也正因为每个设备都分一组两个端口，所以adb连接手机的最大数量为16。 3、adb连接逻辑图 4、adb架构图 二、adb安装(1)下载adb安装包：http://adbshell.com/downloads(2)将安装包解压到电脑自定义路径下。(3)配置系统环境变量，例如：D:\\Program Files\\adb(4)测试是否安装成功，cmd输入命令adb查看adb版本。 三、adb基本用法1、adb命令的基本语法adb [-d|-e|-s &lt;serialNumber&gt;] &lt;command&gt; -d 指定当前唯一通过 USB 连接的 Android 设备为命令目标 -e 指定当前唯一运行的模拟器为命令目标 -s &lt;serialNumber&gt; 指定相应serialNumber号的设备/模拟器为命令目标 1234567# 查看serialNumber$ adb devicesList of devices attachedcf264b8f deviceemulator-5554 device10.129.164.6:5555 device 2、启动/停止adb serveradb start-server：启动 adb serveradb kill-server：停止 adb server 3、指定adb server网络端口adb -P &lt;port&gt; start-server # 默认端口为5037 4、查看 adb 版本adb version 5、root权限adb root ：获取root权限adb unroot ： 解除root权限 四、设备连接管理1、查询已连接设备/模拟器adb devices输出格式为 [serialNumber] [state]。serialNumber即常说的SN，state 有如下几种： offline：表示设备未连接成功或无响应。 device：设备已连接。注意这个状态并不能标识 Android 系统已经完全启动和可操作，在设备启动过程中设备实例就可连接到 adb，但启动完毕后系统才处于可操作状态。 no device：没有设备/模拟器连接。 2、连接设备的几种方式(1)USB连接 1)硬件状态正常：包括Android设备处于正常开机状态，USB连接线和各种接口完好。2)设备的开发者选项和USB调试模式已开启：「设置」-「开发者选项」-「Android 调试」。3)设备驱动状态正常：在Linux和Mac OS X下没问题，在Windows下可能需要安装驱动。4)通过USB线连接好电脑和设备后检查状态：adb devices。 (2)无线连接(需要借助USB线) 1)将Android设备与电脑连接到同一个局域网：比如连到同一个 WiFi。2)将设备与电脑通过USB线连接：确保连接成功，可运行adb devices查看。3)让设备在5555端口监听TCP/IP连接：adb tcpip 5555。4)断开USB连接。5)查看设备的IP地址：「设置」-「关于手机」-「状态信息」-「IP地址」；也可以在第4)步前使用命令adb shell ifconfig | grep Mask查看。6)通过IP地址连接设备：adb connect &lt;device-ip-address&gt;7)查看连接状态：adb devices。 (3)无线连接(无需借助USB线) 1)开启root权限：可以借助root应用。2)在Android设备上安装一个终端模拟器：提供一个终端模拟器下载地址https://jackpal.github.io/Android-Terminal-Emulator/3)将Android设备与电脑连接到同一个局域网：比如连到同一个WiFi。4)打开Android设备上的终端模拟器，在里面依次运行命令：su setprop service.adb.tcp.port 55555)查看设备的IP地址：「设置」-「关于手机」-「状态信息」-「IP地址」；也可以使用命令adb shell ifconfig | grep Mask查看。6)通过IP地址连接设备：adb connect &lt;device-ip-address&gt;ps：有的设备，比如小米 5S + MIUI 8.0 + Android 6.0.1 MXB48T，可能在第6)步之前需要重启adbd服务，在设备的终端模拟器上运行：restart adbd，如果restart无效，可以尝试以下命令：stop adbd start adbd 五、应用管理1、查看应用列表adb shell pm list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [--user USER_ID] [FILTER] 无：所有应用 -f：显示应用关联的 apk 文件 -d：只显示 disabled 的应用 -e：只显示 enabled 的应用 -s：只显示系统应用 -3：只显示第三方应用 -i：显示应用的 installer -u：包含已卸载应用 FILTER：包名包含 FILTER字符串 12345adb shell pm list packages #全部应用adb shell pm list packages -s #系统应用adb shell pm list packages -3 #第三方应用adb shell pm list packages test #包含字符串的应用adb shell pm list packages | grep test #grep过滤包含字符串的应用 2、安装APKadb install [-lrtsdg] &lt;path_to_apk&gt; -l：将应用安装到保护目录 /mnt/asec -r：允许覆盖安装 -t：允许安装AndroidManifest.xml里application指定android:testOnly=”true”的应用 -s：将应用安装到 sdcard -d：允许降级覆盖安装 -g：授予所有运行时权限 ps：adb install实际上分三步完成(必要时可以手动分步执行安装过程)： push apk 文件到 /data/local/tmp。 调用 pm install 安装。 删除 /data/local/tmp 下的对应 apk 文件。 3、卸载APKadb uninstall [-k] &lt;packagename&gt; -k：卸载应用但保留数据和缓存目录。 也可以直接删除： 123adb shellcd data/apprm &lt;packagename&gt; 4、清除应用数据与缓存adb shell pm clear &lt;packagename&gt; 1adb shell pm clear com.test.mobile 5、查看前台Activityadb shell dumpsys activity activities | grep mFocusedActivity 6、查看正在运行的Servicesadb shell dumpsys activity services [&lt;packagename&gt;]输出中包含很多信息，包括 Activity Resolver Table、Registered ContentProviders、包名、userId、安装后的文件资源代码等路径、版本信息、权限信息和授予状态、签名版本信息等。 7、查看应用安装路径adb shell pm path &lt;PACKAGE&gt; 六、应用交互应用交互主要是使用 am &lt;command&gt;: start [options] &lt;INTENT&gt;：启动 指定的 Activity startservice [options] &lt;INTENT&gt;：启动 指定的 Service broadcast [options] &lt;INTENT&gt;：发送 指定的广播 force-stop &lt;packagename&gt;：停止 相关的进程 stopservice &lt;INTENT&gt;：停止Service kill &lt;PACKAGE&gt;：杀指定后台进程 kill-all：杀所有后台进程 hang：系统卡住 restart：重启 bug-report：创建bugreport dumpheap &lt;pid&gt; &lt;file&gt;：进程pid的堆信息输出到file send-trim-memory &lt;pid&gt;&lt;level&gt;：收紧进程的内存 monitor：监控 参数很灵活，和写Android程序时代码里的Intent相对应： -a &lt;ACTION&gt;：指定Intent action， 比如 android.intent.action.VIEW -n &lt;COMPONENT&gt;：指定完整组件名，用于明确指定启动哪个Activity，如 com.example.app/.ExampleActivity -d &lt;DATA_URI&gt;：指定Intent data URI -t &lt;MIME_TYPE&gt;：指定Intent MIME Type -c &lt;CATEGORY&gt;：指定Intent category，比如 android.intent.category.APP_CONTACTS -p &lt;PACKAGE&gt;：指定包名，实现原理Intent.setPackage() -f &lt;FLAGS&gt;：添加flags，实现原理Intent.setFlags(int )，紧接着的参数必须是int型 里还能带数据，就像写代码时的 Bundle 一样： --esn &lt;EXTRA_KEY&gt;：null 值（只有 key 名） -e | --es &lt;EXTRA_KEY&gt; &lt;EXTRA_STRING_VALUE&gt; --ez &lt;EXTRA_KEY&gt; &lt;EXTRA_BOOLEAN_VALUE&gt;：boolean 值 --ei &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;：integer 值 --el &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;：long 值 --ef &lt;EXTRA_KEY&gt; &lt;EXTRA_FLOAT_VALUE&gt;：float 值 --eu &lt;EXTRA_KEY&gt; &lt;EXTRA_URI_VALUE&gt;：URI --ecn &lt;EXTRA_KEY&gt; &lt;EXTRA_COMPONENT_NAME_VALUE&gt;：component name --eia &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;[,&lt;EXTRA_INT_VALUE...]：integer 数组 --ela &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;[,&lt;EXTRA_LONG_VALUE...]：long 数组 1、启动Activityadb shell am start [options] &lt;INTENT&gt; -D: 允许调试功能 -W: 等待app启动完成，获得启动时间 -R &lt;COUNT&gt;: 重复启动Activity COUNT次 -S: 启动activity之前，先调用forceStopPackage()方法强制停止app –opengl-trace: 运行获取OpenGL函数的trace –user &lt;USER_ID&gt; | current: 指定用户来运行App,默认为当前用户 –start-profiler &lt;FILE&gt;: 启动profiler，并将结果发送到 -P &lt;FILE&gt;: 类似 –start-profiler，不同的是当app进入idle状态，则停止profiling –sampling INTERVAL: 设置profiler 取样时间间隔，单位ms 12adb shell am start -n com.tencent.mm/.ui.LauncherUIadb shell am start -n -W com.tencent.mm/.ui.LauncherUI 2、启动Serviceadb shell am startservice [options] &lt;INTENT&gt; 1adb shell am startservice -n com.tencent.mm/.plugin.accountsync.model.AccountAuthenticatorService 3、停止Serviceadb shell am stopservice [options] &lt;INTENT&gt; 4、发送广播adb shell am broadcast [options] &lt;INTENT&gt; 1adb shell am broadcast -a android.intent.action.BOOT_COMPLETED 既能发送系统预定义的广播，也能发送自定义广播。如下是部分系统预定义广播及正常触发时机： android.net.conn.CONNECTIVITY_CHANGE：网络连接发生变化 android.intent.action.SCREEN_ON：屏幕点亮 android.intent.action.SCREEN_OFF：屏幕熄灭 android.intent.action.BATTERY_LOW：电量低，会弹出电量低提示框 android.intent.action.BATTERY_OKAY：电量恢复了 android.intent.action.BOOT_COMPLETED：设备启动完毕 android.intent.action.DEVICE_STORAGE_LOW：存储空间过低 android.intent.action.DEVICE_STORAGE_OK：存储空间恢复 android.intent.action.PACKAGE_ADDED：安装了新的应用 android.net.wifi.STATE_CHANGE：WiFi连接状态发生变化 android.net.wifi.WIFI_STATE_CHANGED：WiFi 状态变为启用/关闭/正在启动/正在关闭/未知 android.intent.action.BATTERY_CHANGED：电池电量发生变化 android.intent.action.INPUT_METHOD_CHANGED：系统输入法发生变化 android.intent.action.ACTION_POWER_CONNECTED：外部电源连接 android.intent.action.ACTION_POWER_DISCONNECTED：外部电源断开连接 android.intent.action.DREAMING_STARTED：系统开始休眠 android.intent.action.DREAMING_STOPPED：系统停止休眠 android.intent.action.WALLPAPER_CHANGED：壁纸发生变化 android.intent.action.HEADSET_PLUG：插入耳机 android.intent.action.MEDIA_UNMOUNTED：卸载外部介质 android.intent.action.MEDIA_MOUNTED：挂载外部介质 android.os.action.POWER_SAVE_MODE_CHANGED：省电模式开启 5、强制停止应用adb shell am force-stop &lt;packagename&gt; 1adb shell am force-stop com.test.mobile 6、收紧内存adb shell am send-trim-memory &lt;pid&gt; &lt;level&gt; pid: 进程 ID level: HIDDEN、RUNNING_MODERATE、BACKGROUND、 RUNNING_LOW、MODERATE、RUNNING_CRITICAL、COMPLETE 1adb shell am send-trim-memory 12345 RUNNING_LOW 七、文件管理1、复制设备里的文件到电脑adb pull &lt;设备里的文件路径&gt; [电脑上的目录] 12adb pull /sdcard/sr.mp4 ~/tmp/#ps：设备上的文件路径可能需要root权限才能访问，如果你的设备已经root过，可以先使用 adb shell 和 su 命令在 adb shell 里获取 root 权限后，先 cp /path/on/device /sdcard/filename 将文件复制到 sdcard，然后 adb pull /sdcard/filename /path/on/pc 2、复制电脑里的文件到设备adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt; 12adb push ~/sr.mp4 /sdcard/#ps：设备上的文件路径普通权限可能无法直接写入，如果你的设备已经 root 过，可以先 adb push /path/on/pc /sdcard/filename，然后 adb shell 和 su 在 adb shell 里获取 root 权限后，cp /sdcard/filename /path/on/device 八、查看日志1、查看日志[adb] logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ...(1)选项解析: -s: 设置输出日志的标签, 只显示该标签的日志; -f: 将日志输出到文件, 默认输出到标准输出流中, -f 参数执行不成功; -r: 按照每千字节输出日志, 需要 -f 参数, 不过这个命令没有执行成功; -n: 设置日志输出的最大数目, 需要 -r 参数, 这个执行 感觉 跟 adb logcat 效果一样; -v: 设置日志的输出格式, 注意只能设置一项; -c: 清空所有的日志缓存信息; -d: 将缓存的日志输出到屏幕上, 并且不会阻塞; -t: 输出最近的几行日志, 输出完退出, 不阻塞; -g: 查看日志缓冲区信息; -b: 加载一个日志缓冲区, 默认是 main, 下面详解; -B: 以二进制形式输出日志; (2)过滤项解析，格式 : [:priority] , 标签:日志等级, 默认的日志过滤项是 ” *:I ” 。 V: Verbose (明细); D: Debug (调试); I: Info (信息); W: Warn (警告); E: Error (错误); F: Fatal (严重错误); S: Silent(Super all output) (最高的优先级, 可能不会记载东西); 1234567891011121314151617181920212223242526adb logcat -d -f /sdcard/log.txt #日志写入sdcardadb logcat ActivityManager:I MyApp:D *:S # 按tag和级别过滤日志adb logcat -c #清空日志adb logcat -v time &gt; C:\\Users\\test\\Desktop\\log.txt #日志写入电脑# 设置日志的输出格式:#brief格式(是默认的日志格式): 【优先级 / 标签 (进程ID) : 日志信息】adb logcat -v brief #process格式 : 【优先级 (进程ID) : 日志信息】adb logcat -v process#tag格式 : 【优先级 / 标签 : 日志信息】adb logcat -v tag#thread格式 : 【优先级 ( 进程ID : 线程ID) 标签 : 日志内容】adb logcat -v thread # raw格式 : 只输出日志信息, 不附加任何其他信息adb logcat -v raw #time格式 : 【日期 时间 优先级 / 标签 (进程ID) : 进程名称 : 日志信息】adb logcat -v time #long格式: 【[日期 时间 进程ID : 线程ID 优先级 / 标签] 日志信息】adb logcat -v long 2、内核日志adb shell dmesg 九、查看设备信息1、查看屏幕分辨率adb shell wm size 12345adb shell wm size#输出信息Physical size: 1080x1920 #屏幕分辨率原本是 1080px * 1920pxOverride size: 480x1024 #当前被修改为 480px * 1024px，如果未修改过则不显示 2、查看屏幕密度adb shell wm density 12345adb shell wm density#输出信息Physical density: 480 #屏幕密度原来是 480dpiOverride density: 160 #当前被修改为 160dpi，如果未修改过则不显示 3、查看显示屏参数adb shell dumpsys window displays 12345678adb shell dumpsys window displays#输出信息WINDOW MANAGER DISPLAY CONTENTS (dumpsys window displays) Display: mDisplayId=0 init=1080x1920 420dpi cur=1080x1920 app=1080x1794 rng=1080x1017-1810x1731 deferred=false layoutNeeded=false#mDisplayId 为 显示屏编号，init 是初始分辨率和屏幕密度，app 的高度比 init 里的要小，表示屏幕底部有虚拟按键，高度为 1920 - 1794 = 126px 合 42dp 4、查看电池状况adb shell dumpsys batteryadb shell dumpsys batterystats 5、查看CPU信息adb shell cat /proc/cpuinfoadb shell dumpsys cpuinfo | grep {PackageName}adb shell top | grep {PackageName} 6、查看内存信息adb shell cat /proc/meminfoadb shell dumpsys meminfo {PackageName}adb shell top -d 刷新时间| grep {PackageName} 7、查看流量信息adb shell cat /proc/pid/net/dev 8、查看FPSadb shell dumpsys gfxinfo 1adb shell dumpsys gfxinfo com.peng.cloudp.tv &gt; test.txt #抓取数据后用表格进行分析 9、查看型号adb shell getprop ro.product.model 10、查看android_idadb shell settings get secure android_id 11、查看IMEI(1)Android 4.4及以下版本可通过如下命令获取IMEI：adb shell dumpsys iphonesubinfo(2)Android 5.0及以上版本通过其它方式获取了(需要 root 权限)： 123adb shellsuservice call iphonesubinfo 1 12、查看安卓系统版本adb shell getprop ro.build.version.release 13、查看IP地址adb shell ifconfig | grep Mask有的设备上这个命令没有输出，如果设备连着 WiFi，可以使用如下命令来查看局域网 IP：adb shell ifconfig wlan0如果以上命令仍然不能得到期望的信息，可以试试以下命令:adb shell netcfg 14、查看Mac地址adb shell cat /sys/class/net/wlan0/address这查看的是局域网 Mac 地址，移动网络或其它连接的信息可以通过adb shell netcfg 15、更多硬件与系统属性adb shell cat /system/build.prop ro.build.version.sdk：SDK 版本 ro.build.version.release：Android 系统版本 ro.build.version.security_patch：Android 安全补丁程序级别 ro.product.model：型号 ro.product.brand：品牌 ro.product.name：设备名 ro.product.board：处理器型号 ro.product.cpu.abilist：CPU 支持的 abi 列表[节注一] persist.sys.isUsbOtgEnabled：是否支持 OTG dalvik.vm.heapsize：每个应用程序的内存上限 ro.sf.lcd_density：屏幕密度 输出里还包括一些其它有用的信息，它们也可通过 adb shell getprop &lt;属性名&gt; 命令单独查看。 16、查看连接过的WiFi密码adb shellsucat /data/misc/wifi/*.confps:需要root权限 17、获取连接到的设备的序列号adb get-serialno 18、获取设备的连接状态adb -s {serialno} get-stat 19、等待设备连接成功adb wait-for-device 十、修改设置1、修改分辨率adb shell wm size 480x1024恢复原分辨率命令：adb shell wm size reset 2、修改屏幕密度adb shell wm density 160恢复原屏幕密度命令：adb shell wm density reset 3、修改显示区域adb shell wm overscan 0,0,0,200四个数字分别表示距离左、上、右、下边缘的留白像素，以上命令表示将屏幕底部 200px 留白。恢复原显示区域命令：adb shell wm overscan reset 4、关闭USB调试模式adb shell settings put global adb_enabled 0ps：用命令恢复不了了，关闭了USB调试，adb就连接不 Android设备了。 5、状态栏和导航栏的显示隐藏adb shell settings put global policy_control &lt;key-values&gt;key: immersive.full：同时隐藏 immersive.status：隐藏状态栏 immersive.navigation：隐藏导航栏 immersive.preconfirms：? value: apps：所有应用 *：所有界面 packagename：指定应用 -packagename：排除指定应用 12adb shell settings put global policy_control immersive.full=*adb shell settings put global policy_control immersive.status=com.package1,com.package2:immersive.navigation=apps,-com.package3 6、设置系统日期和时间ps:需要root权限adb shellsu(1)先设置系统的时区配置 cat /data/property/persist.sys.timezone：查看当前时区配置文件 setprop persist.sys.timezone GMT：修改属性 (2)设置修改当前系统时间 date -s &quot;yyyymmdd.[[[hh]mm]ss]&quot; System/bin/date -s &quot;yyyymmdd.[[[hh]mm]ss]&quot; (3)查看是否生效date 1234date -s &quot;20151116.120000&quot; date#输出：Mon Nov 16 12:00:02 CST 2015 十一、设备控制1、屏幕截图adb exec-out screencap -p &gt; sc.png -p：指定保存文件为 png 格式 -d display-id：指定截图的显示屏编号（有多显示屏的情况下） 以上命令需要新版本adb，老版本请使用下边命令：adb shell screencap -p /sdcard/sc.pngadb pull /sdcard/sc.png 2、录制屏幕adb shell screenrecord /sdcard/test.mp4 --size WIDTHxHEIGHT：视频的尺寸，比如 1280x720，默认是屏幕分辨率。 --bit-rate RATE：视频的比特率，默认是 4Mbps。 --time-limit TIME：录制时长，单位秒。 --verbose：输出更多信息 需要停止时按 Ctrl-C，默认录制时间和最长录制时间都是 180 秒。如果需要导出到电脑：adb pull /sdcard/test.mp4 3、重启设备adb reboot 4、设备关机adb shutdown 5、开启/关闭wifi adb shell svc wifi enable：开启wifi adb shell svc wifi disable：关闭wifips：需要root权限 6、模拟按键/输入adb shell input [&lt;source&gt;] &lt;command&gt; [&lt;arg&gt;...]The sources are: mouse keyboard joystick touchnavigation touchpad trackball stylus dpad gesture touchscreen gamepad The commands and default sources are: text (Default: touchscreen) keyevent [–longpress] … (Default: keyboard) tap (Default: touchscreen) swipe [duration(ms)] (Default: touchscreen) press (Default: trackball) roll (Default: trackball) ps：常用keycode键值表 1234567891011121314151617181920212223242526272829303132333435#输入文本adb shell input text hello#滑动屏幕adb shell input swipe 300 1000 300 500#点击屏幕adb shell input touchscreen tap 300 1000#熄灭屏幕adb shell input keyevent 223#点亮屏幕adb shell input keyevent 224#电源键adb shell input keyevent 26#菜单键adb shell input keyevent 82#HOME键adb shell input keyevent 3#返回键adb shell input keyevent 4#增加音量adb shell input keyevent 24#降低音量adb shell input keyevent 25#静音adb shell input keyevent 164 十二、挂载分区1、简写命令adb remountadb shell mount -o remount /system 2、mount命令详解mount [-r] [-w] [-o options] [-t type] device directory -t vfstype：指定文件系统的类型，通常不必指定。mount 会自动选择正确的类型。常用类型有： 光盘或光盘镜像：iso9660 DOS fat16文件系统：msdos Windows 9x fat32文件系统：vfat Windows NT ntfs文件系统：ntfs Mount Windows文件网络共享：smbfs UNIX(LINUX) 文件网络共享：nfs -o options：主要用来描述设备或档案的挂接方式。常用的参数有： loop：用来把一个文件当成硬盘分区挂接上系统 ro：采用只读方式挂接设备 rw：采用读写方式挂接设备 iocharset：指定访问文件系统所用字符集 device：要挂接(mount)的设备。 dir：设备在系统上的挂接点(mount point)。 123456789101112131415# 需要root权限adb shellsu# 查看当前分区挂载情况mount # 找到/system的那一行#/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0# 重新挂载mount -o remount,rw /dev/block/mtdblock0 /system#如果需要改回去romount -o remount,ro /dev/block/mtdblock0 /system 十三、刷机相关1、从Recovery重启到Androidadb reboot 2、重启到Recovery模式(卡刷)adb recovery 3、重启到Fastboot模式(线刷)adb reboot bootloader 4、通过sideload更新系统(属于卡刷)(1)重启到 Recovery 模式。adb reboot recovery(2)在设备的Recovery界面上操作进入Apply update-Apply from ADB。ps：不同的 Recovery 菜单可能与此有差异，有的是一级菜单就有 Apply update from ADB。(3)通过 adb 上传和更新系统。adb sideload &lt;path-to-update.zip&gt; 持续更新…","categories":[{"name":"app测试","slug":"app测试","permalink":"http://pythonfood.github.io/categories/app测试/"}],"tags":[{"name":"adb","slug":"adb","permalink":"http://pythonfood.github.io/tags/adb/"}]},{"title":"linux","slug":"linux","date":"2017-12-29T04:00:00.000Z","updated":"2018-05-11T06:38:52.973Z","comments":true,"path":"2017/12/29/linux/","link":"","permalink":"http://pythonfood.github.io/2017/12/29/linux/","excerpt":"linux常用命令笔记。","text":"linux常用命令笔记。 一、系统安装进入各版本linux官网下载安装： CentOS：https://www.centos.org/download/ Ubuntu：https://www.ubuntu.com/download 二、目录结构命令窗口输入命令：ls /查看根目录结构： /bin：bin是Binary的缩写, 这个目录存放着最经常使用的命令。 /boot：这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。 /dev ：dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。 /etc：这个目录用来存放所有的系统管理所需要的配置文件和子目录。 /home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 /lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 /mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。 /opt：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 /proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all /tmp：这个目录是用来存放一些临时文件的。 /usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。 /usr/bin：系统用户使用的应用程序。 /usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src：内核源代码默认的放置目录。 /var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 三、启动过程Linux系统的启动过程可以分为5个阶段： 内核的引导 运行init 系统初始化 建立终端 用户登录系统 1、内核的引导当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。操作系统接管硬件以后，首先读入/boot目录下的内核文件。BIOS自检——&gt;操作系统——&gt;/boot——&gt; 2、运行initinit 进程是系统所有进程的起点，init 程序首先是需要读取配置文件/etc/inittab。许多程序需要开机启动,它们在Windows叫做”服务”(service)，在Linux就叫做”守护进程”(daemon)。init进程的一大任务，就是去运行这些开机启动的程序。Linux允许为不同的场合，分配不同的开机启动程序，这就叫做”运行级别”（runlevel）。也就是说，启动时根据”运行级别”，确定要运行哪些程序。BIOS自检——&gt;操作系统——&gt;/boot——&gt;/init——&gt;运行级别——&gt; Linux系统有7个运行级别(runlevel)： 运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动 运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆 运行级别2：多用户状态(没有NFS) 运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式 运行级别4：系统未使用，保留 运行级别5：X11控制台，登陆后进入图形GUI模式 运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动 3、系统初始化在init的配置文件中有这么一行：si::sysinit:/etc/rc.d/rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作。它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。BIOS自检——&gt;操作系统——&gt;/boot——&gt;/init——&gt;运行级别——&gt;/etc/init.d——&gt; 4、建立终端rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。init接下来会打开6个终端，以便用户登录系统。在inittab中的以下6行就是定义了6个终端： 1:2345:respawn:/sbin/mingetty tty1 2:2345:respawn:/sbin/mingetty tty2 3:2345:respawn:/sbin/mingetty tty3 4:2345:respawn:/sbin/mingetty tty4 5:2345:respawn:/sbin/mingetty tty5 6:2345:respawn:/sbin/mingetty tty6 从上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。同时它会显示一个文本登录界面。 BIOS自检——&gt;操作系统——&gt;/boot——&gt;/init——&gt;运行级别——&gt;/etc/init.d——&gt;建立终端——&gt; 5、用户登录系统一般来说，用户的登录方式有三种： 命令行登录 ssh登录 图形界面登录 BIOS自检——&gt;操作系统——&gt;/boot——&gt;/init——&gt;运行级别——&gt;/etc/init.d——&gt;建立终端——&gt;用户登录——&gt; 图形模式与文字模式的切换：1)Linux预设提供了六个命令窗口终端机让我们来登录。默认我们登录的就是第一个窗口，也就是tty1。按下Ctrl + Alt + F1 ~ F6来切换tty1,tty2 … tty6。2)如果安装了图形界面，默认情况下是进入图形界面的，此时按Ctrl + Alt + F1 ~ F6来进入一个命令窗口界面。进入命令窗口界面后再返回图形界面只要按下Ctrl + Alt + F7就回来了。3)如果在vmware虚拟机，命令窗口切换的快捷键为Alt + Space + F1~F6。如果在图形界面下请按Alt + Shift + Ctrl + F1~F6切换至命令窗口。BIOS自检——&gt;操作系统——&gt;/boot——&gt;/init——&gt;运行级别——&gt;/etc/init.d——&gt;建立终端——&gt;用户登录——&gt;Login shell 6、Linux关机正确的关机流程为：sync &gt; shutdown &gt; reboot &gt; halt 1234567891011121314sync # 将数据由内存同步到硬盘中。shutdown -h now # 立刻关机halt # 立刻关机poweroff # 立刻关机init 0 # 立刻关机shutdown –h 10 ‘This server will shutdown after 10 mins’ # 这个命令会显示在登陆用户的当前屏幕中，计算机将在10分钟后关机。shutdown -h 20:25 # 系统会在今天20:25关机shutdown -h +10 # 十分钟后关机shutdown -r now # 立刻重启reboot # 立刻重启init 6 # 立刻重启shutdown -r +10 #十分钟后重启 四、远程登录Linux系统中是通过ssh服务实现的远程登录功能，默认ssh服务端口号为22。1、SSH登录SSH(Secure Shell)：安全协议外壳。是建立在应用层和传输层基础上的安全协议。(1)Window系统上Linux远程登录客户端有SecureCRT、Putty、XShel、SSH Secure Shell等。客户端输入：Host Name( or IP address)、Port、用户名、密码等，就可以远程登录。(2)终端利用ssh登录远程服务器: 12345yum install ssh # 安装sshservice sshd start # 启动sshssh -p 50022 root@127.0.0.1 # 登录远程服务器#输入密码：root@127.0.0.1: #此处输入密码即可登录 五、文件目录1、文件属性(1)文件基本属性使用ll或ls –l命令来显示一个文件的属性以及文件所属的用户和组: 12345ls -l# total 64# dr-xr-xr-x 2 root root 4096 Dec 14 2012 bin# ... 文件的属性由左边第一部分的10个字符来确定,从左至右用0-9这些数字来表示:0-123-456-789 第0位：文件类型 第1-3位：属主(owner,该文件的所有者)拥有该文件的权限 第4-6位：属组(group,所有者的同组用户)拥有该文件的权限 第7-9位：其他用户(others)拥有该文件的权限 其中，第0位文件类型： d：则是目录 -：则是文件 l：则表示为链接文档(link file) b：则表示为装置文件里面的可供储存的接口设备(可随机存取装置) c：则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。 其中，权限表示： 第1、4、7位：表示读权限，用”r”字符表示读权限；用”-“字符表示没有读权限 第2、5、8位：表示写权限，用”w”字符表示写权限，用”-“字符表示没有写权限 第3、6、9位：表示可执行权限，用”x”字符表示执行权限，用”-“字符表示没有执行权限。 (2)chgrp更改文件属组chgrp [-R] 属组名 文件名 -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。 (3)chown更改文件属主，也可以同时更改文件属组chown [-R] 属主名 文件名chown [-R] 属主名:属组名 文件名 12chown bin install.logchown root:root install.log (4)chmod更改文件9个属性1)符号类型改变文件权限chmod {u属主|g属组|o其他人|a所有人} {+加入|-除去|=设置} {r|w|x} 文件或目录 12chmod u=rwx,g=rx,o=rx install.log chmod a-x install.log # 全部人除去可执行权限 2)数字类型改变文件权限chmod [-R] xyz 文件或目录 xyz : 是数字类型的权限属性，为rwx属性数值的相加 -R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更 1chmod 777 install.log # 所有人设置可读可写可执行 2、目录跳转(1)ls列出目录ls [目录名称] a ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来 -d ：仅列出目录本身，而不是列出目录内的文件数据 -l ：长数据串列出，包含文件的属性与权限等等数据 1ls -al ~ (2)cd切换目录cd [相对路径或绝对路径] 123456cd # 进入用户主目录cd ~ # 进入用户主目录cd - # 返回进入此目录之前所在的目录cd .. # 返回上级目录cd ../.. # 返回上两级目录cd ./test/ # 相对路径切换到test目录 (3)pwd显示当前目录pwd [-P] -P：显示出确实的路径，而非使用连结(link)路径 12pwdpwd -P 3、文件目录的创建删除(1)mkdir创建新目录mkdir [-mp] 目录名称 -m：配置文件的权限 -p：直接将所需要的目录(包含上一级目录)递归创建起来 123mkdir testmkdir -m 711 testmkdir -p test1/test2/test3/test4 (2)rmdir删除空目录rmdir [-p] 目录名称 -p：连同上一级『空的』目录也一起删除 12rmdir testrmdir -p test1/test2/test3/test4 (3)rm移除文件或目录rm [-fir] 文件或目录 -f ：就是force的意思，忽略不存在的文件，不会出现警告信息! -i ：互动模式，在删除前会询问使用者是否动作 -r ：递归删除！最常用在目录的删除了！这是非常危险的选项！！！ 1rm -i install.log (4)touch创建新的空文件touch [选项] 文件名 -a：或–time=atime或–time=access或–time=use 只更改存取时间 -c：或–no-create 不建立任何文件 -d：&lt;时间日期&gt; 使用指定的日期时间，而非现在的时间 -f：此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题 -m：或–time=mtime或–time=modify 只更该变动时间 -r：&lt;参考文件或目录&gt; 把指定文件或目录的日期时间，统统设成和参考文件或目录的日期时间相同 -t：&lt;日期时间&gt; 使用指定的日期时间，而非现在的时间 12touch ott.txt # 创建新的空文件touch ott.txt # 文件存在，更新文件当前时间戳 4、文件目录的复制移动(1)cp复制文件或目录cp [选项] 源文件 目标文件 -a：相当於 -pdr 的意思，至於pdr请参考下列说明 -d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身 -f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次 -i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行 -l：进行硬式连结(hard link)的连结档创建，而非复制文件本身 -p：连同文件的属性一起复制过去，而非使用默认属性(备份常用) -r：递归持续复制，用於目录的复制行为 -s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件 -u：若 destination 比 source 旧才升级 destination ！ 12cp ~/.bashrc /tmp/bashrccp -i ~/.bashrc /tmp/bashrc (2)mv移动文件与目录，或修改名称mv [选项] 源文件 目标文件 -f：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖； -i：若目标文件(destination)已经存在时，就会询问是否覆盖！ -u：若目标文件已经存在，且source比较新，才会升级(update) 12mv /usr/men/* . # /usr/men/所有文件移到当前目录,“.”表示当前目录mv test newtest # 重命名 5、文件内容显示(1)cat由第一行开始显示文件内容cat [-AbEnTv] 文件名 -A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已 -b ：列出行号，仅针对非空白行做行号显示，空白行不标行号 -E ：将结尾的断行字节 $ 显示出来 -n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同 -T ：将 [tab] 按键以 ^I 显示出来 -v ：列出一些看不出来的特殊字符 1cat /etc/issue (2)tac由最后一行开始显示文件内容tac 文件名 1tac /etc/issue (3)nl显示行号和内容nl [-bnw] 文件 -b：指定行号指定的方式，主要有两种： -b a：表示不论是否为空行，也同样列出行号(类似 cat -n -b t：如果有空行，空的那一行不要列出行号(默认值) -n：列出行号表示的方法，主要有三种： -n ln：行号在荧幕的最左方显示； -n rn：行号在自己栏位的最右方显示，且不加 0 -n rz：行号在自己栏位的最右方显示，且加 0 -w：行号栏位的占用的位数 1nl /etc/issue (4)more一页一页翻动more [选项] 文件名 -&lt;数字&gt;：指定每屏显示的行数； -d：显示“[press space to continue,’q’ to quit.]”和“[Press ‘h’ for instructions]”； -c：不进行滚屏操作。每次刷新这个屏幕； -s：将多个空行压缩成一行显示； -u：禁止下划线； +&lt;数字&gt;：从指定数字的行开始显示。 在more这个运行过程中，有几个按键可以按： 按Space键：显示文本的下一屏内容 按Enier键：只显示文本的下一行内容 /字串：代表在这个显示的内容当中，向下搜寻“字串”这个关键字 :f：立刻显示出档名以及目前显示的行数 按H键：显示帮助屏，该屏上有相关的帮助信息 按B键：显示上一屏内容，不过这动作只对文件有用，对管线无用 按Q键：退出more命令。 1more -dc file (5)less一页一页翻动,可以向前翻页less [选项] 文件名 -e：文件内容显示完毕后，自动退出； -f：强制显示文件； -g：不加亮显示搜索到的所有关键词，仅显示当前显示的关键字，以提高显示速度； -l：搜索时忽略大小写的差异； -N：每一行行首显示行号； -s：将连续多个空行压缩成一行显示； -S：在单行显示较长的内容，而不换行显示； -x&lt;数字&gt;：将TAB字符显示为指定个数的空格字符。 在less这个运行过程中，有几个按键可以按： 空白键：向下翻动一页； [pagedown]：向下翻动一页； [pageup]：向上翻动一页； /字串：向下搜寻『字串』的功能； ?字串：向上搜寻『字串』的功能； n：重复前一个搜寻 (与 / 或 ? 有关！) N：反向的重复前一个搜寻 (与 / 或 ? 有关！) q：离开 less 这个程序； 1less /etc/man.config (6)head读取文件前几行head [选项] 文件名 -n&lt;数字&gt;：指定显示头部内容的行数； -c&lt;字符数&gt;：指定显示头部内容的字符数； -v：总是显示文件名的头信息； -q：不显示文件名的头信息。 1head -n 20 /etc/man.config (7)tail读取文件后几行tail [选项] 文件名 -n&lt;数字&gt;：指定显示后面内容的行数； -f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测 1tail -n 20 /etc/man.config 6、文件搜索(1)find在指定目录下查找文件find 目录名称 [选项] -amin&lt;分钟&gt;：查找在指定时间曾被存取过的文件或目录，单位以分钟计算 -anewer&lt;参考文件或目录&gt;：查找其存取时间较指定文件或目录的存取时间更接近现在的文件或目录 -atime：查找在指定时间曾被存取过的文件或目录，单位以24小时计算 -cmin&lt;分钟&gt;：查找在指定时间之时被更改过的文件或目录 -cnewer&lt;参考文件或目录&gt;查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录 -ctime：查找在指定时间之时被更改的文件或目录，单位以24小时计算 -daystart：从本日开始计算时间 -depth：从指定目录下最深层的子目录开始查找 -expty：寻找文件大小为0 Byte的文件，或目录下没有任何子目录或文件的空目录 -exec&lt;执行指令&gt;：假设find指令的回传值为True，就执行该指令 -false：将find指令的回传值皆设为False； -fls&lt;列表文件&gt;：此参数的效果和指定“-ls”参数类似，但会把结果保存为指定的列表文件 -follow：排除符号连接 -fprint&lt;列表文件&gt;：此参数的效果和指定“-print”参数类似，但会把结果保存成指定的列表文件 -fprint0&lt;列表文件&gt;：此参数的效果和指定“-print0”参数类似，但会把结果保存成指定的列表文件 -fprintf&lt;列表文件&gt;&lt;输出格式&gt;：此参数的效果和指定“-printf”参数类似，但会把结果保存成指定的列表文件 -fstype&lt;文件系统类型&gt;：只寻找该文件系统类型下的文件或目录 -gid&lt;群组识别码&gt;：查找符合指定之群组识别码的文件或目录 -group&lt;群组名称&gt;：查找符合指定之群组名称的文件或目录 -help或——help：在线帮助 -ilname&lt;范本样式&gt;：此参数的效果和指定“-lname”参数类似，但忽略字符大小写的差别 -iname&lt;范本样式&gt;：此参数的效果和指定“-name”参数类似，但忽略字符大小写的差别 -inum：查找符合指定的inode编号的文件或目录 -ipath&lt;范本样式&gt;：此参数的效果和指定“-path”参数类似，但忽略字符大小写的差别 -iregex&lt;范本样式&gt;：此参数的效果和指定“-regexe”参数类似，但忽略字符大小写的差别 -links&lt;连接数目&gt;：查找符合指定的硬连接数目的文件或目录 -iname&lt;范本样式&gt;：指定字符串作为寻找符号连接的范本样式 -ls：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出 -maxdepth&lt;目录层级&gt;：设置最大目录层级 -mindepth&lt;目录层级&gt;：设置最小目录层级 -mmin&lt;分钟&gt;：查找在指定时间曾被更改过的文件或目录，单位以分钟计算 -mount：此参数的效果和指定“-xdev”相同 -mtime：查找在指定时间曾被更改过的文件或目录，单位以24小时计算 -name&lt;范本样式&gt;：指定字符串作为寻找文件或目录的范本样式 -newer&lt;参考文件或目录&gt;：查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录 -nogroup：找出不属于本地主机群组识别码的文件或目录 -noleaf：不去考虑目录至少需拥有两个硬连接存在 -nouser：找出不属于本地主机用户识别码的文件或目录 -ok&lt;执行指令&gt;：此参数的效果和指定“-exec”类似，但在执行指令之前会先询问用户，若回答“y”或“Y”，则放弃执行命令 -path&lt;范本样式&gt;：指定字符串作为寻找目录的范本样式 -perm&lt;权限数值&gt;：查找符合指定的权限数值的文件或目录 -print：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为每列一个名称，每个名称前皆有“./”字符串 -print0：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为全部的名称皆在同一行 -printf&lt;输出格式&gt;：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式可以自行指定 -prune：不寻找字符串作为寻找文件或目录的范本样式 -regex&lt;范本样式&gt;：指定字符串作为寻找文件或目录的范本样式 -size&lt;文件大小&gt;：b块（512字节）、c字节 、w字（2字节）、k千字节、M兆字节、G吉字节 -true：将find指令的回传值皆设为True -typ&lt;文件类型&gt;：f普通文件、l符号连接 、d目录 、c字符设备 、b块设备 、s套接字 、p Fifo -uid&lt;用户识别码&gt;：查找符合指定的用户识别码的文件或目录 -used&lt;日数&gt;：查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以日计算 -user&lt;拥有者名称&gt;：查找符和指定的拥有者名称的文件或目录 -version或——version：显示版本信息 -xdev：将范围局限在先行的文件系统中 -xtype&lt;文件类型&gt;：此参数的效果和指定“-type”参数类似，差别在于它针对符号连接检查 12345find . # 查找当前路径find /home -name &quot;*.txt&quot; # 匹配文件名find /usr/ -path &quot;*local*&quot; # 匹配路径find . -type f -atime -7 # 查找近7天find test3 -size +100c # 查找大于100字符 (2)全面搜索正则表达式grep match_pattern file_namegrep &quot;match_pattern&quot; file_1 file_2 file_3 ... -a：不要忽略二进制数据 -A&lt;显示列数&gt;：除了显示符合范本样式的那一行之外，并显示该行之后的内容 -b：在显示符合范本样式的那一行之外，并显示该行之前的内容 -c：计算符合范本样式的列数 -C&lt;显示列数&gt;或-&lt;显示列数&gt;：除了显示符合范本样式的那一列之外，并显示该列之前后的内容 -d&lt;进行动作&gt;：当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作 -e&lt;范本样式&gt;：指定字符串作为查找文件内容的范本样式 -E：将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式 -f&lt;范本文件&gt;：指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式 -F：将范本样式视为固定字符串的列表 -G：将范本样式视为普通的表示法来使用 -h：在显示符合范本样式的那一列之前，不标示该列所属的文件名称 -H：在显示符合范本样式的那一列之前，标示该列的文件名称 -i：忽略字符大小写的差别 -l：列出文件内容符合指定的范本样式的文件名称 -L：列出文件内容不符合指定的范本样式的文件名称 -n：在显示符合范本样式的那一列之前，标示出该列的编号 -q：不显示任何信息 -R/-r：此参数的效果和指定“-d recurse”参数相同 -s：不显示错误信息 -v：反转查找 -w：只显示全字符合的列 -x：只显示全列符合的列 -y：此参数效果跟“-i”相同 -o：只输出文件中匹配到的部分 12345grep -E &quot;[1-9]+&quot;grep &quot;text&quot; -n file_namecat file_name | grep &quot;text&quot; -ngrep -l &quot;text&quot; file1 file2 file3 # 多文件搜索grep &quot;text&quot; . -r -n # 递归搜索 7、文件连接(1)ln文件连接ln [选项] 源文件 目标文件 -b或–backup：删除，覆盖目标文件之前的备份 -d或-F或——directory：建立目录的硬连接 -f或——force：强行建立文件或目录的连接，不论文件或目录是否存在 -i或——interactive：覆盖既有文件之前先询问用户 -n或–no-dereference：把符号连接的目的目录视为一般文件 -s或——symbolic：对源文件建立符号连接，而非硬连接 -S&lt;字尾备份字符串&gt;或–suffix=&lt;字尾备份字符串&gt;：用”-b”参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，预设的备份字符串是符号“~”，用户可通过“-S”参数来改变它 -v或——verbose：显示指令执行过程 -V&lt;备份方式&gt;或–version-control=&lt;备份方式&gt;：用“-b”参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，这个字符串不仅可用“-S”参数变更，当使用“-V”参数&lt;备份方式&gt;指定不同备份方式时，也会产生不同字尾的备份字符串 12ln ott.txt /cache/test21/ott1.txt # 硬连接，绝对路径，相当于copy备份ln -s ott.txt /cache/test21/ott1.txt # 软连接，绝对路径，相当于快捷方式 六、文件压缩1、tar打包tar [选项] 文件或目录 -A或–catenate：新增文件到以存在的备份文件 -B：设置区块大小 -c或–create：建立新的备份文件 -C &lt;目录&gt;：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项 -d：记录文件的差别 -x或–extract或–get：从备份文件中还原文件 -t或–list：列出备份文件的内容 -z或–gzip或–ungzip：通过gzip指令处理备份文件 -Z或–compress或–uncompress：通过compress指令处理备份文件 -f&lt;备份文件&gt;或–file=&lt;备份文件&gt;：指定备份文件 -v或–verbose：显示指令执行过程 -r：添加文件到已经压缩的文件 -u：添加改变了和现有的文件到已经存在的压缩文件 -j：支持bzip2解压文件 -v：显示操作过程 -l：文件系统边界设置 -k：保留原有文件不覆盖 -m：保留文件不被覆盖 -w：确认压缩文件的正确性 -p或–same-permissions：用原来的文件权限还原文件 -P或–absolute-names：文件名使用绝对名称，不移除文件名称前的“/”号 -N &lt;日期格式&gt; 或 –newer=&lt;日期时间&gt;：只将较指定日期更新的文件保存到备份文件里 –exclude=&lt;范本样式&gt;：排除符合范本样式的文件 12345tar -cvf log.tar log2012.log # 仅打包，不压缩tar -zcvf log.tar.gz log2012.log # 打包后，以 gzip 压缩 tar -jcvf log.tar.bz2 log2012.log # 打包后，以 bzip2 压缩 tar -zxvf /opt/soft/test/log.tar.gz # 解压缩tar -ztvf log.tar.gz # 查阅tar包内文件 2、gzip压缩gzip [选项] 文件或目录 -a或——ascii：使用ASCII文字模式 -d或–decompress或—-uncompress：解开压缩文件 -f或——force：强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接 -h或——help：在线帮助 -l或——list：列出压缩文件的相关信息 -L或——license：显示版本与版权信息 -n或–no-name：压缩文件时，不保存原来的文件名称及时间戳记 -N或——name：压缩文件时，保存原来的文件名称及时间戳记 -q或——quiet：不显示警告信息 -r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理 -S或&lt;压缩字尾字符串&gt;或—-suffix&lt;压缩字尾字符串&gt;：更改压缩字尾字符串 -t或——test：测试压缩文件是否正确无误 -v或——verbose：显示指令执行过程 -V或——version：显示版本信息 -&lt;压缩效率&gt;：压缩效率是一个介于1~9的数值，预设值为“6”，指定愈大的数值，压缩效率就会愈高 –best：此参数的效果和指定“-9”参数相同 –fast：此参数的效果和指定“-1”参数相同 123456gzip * # 把test目录下的每个文件压缩成.gz文件gzip -dv * 把上例中每个压缩的文件解压，并列出详细的信息 gzip -l * 把1例中每个压缩的文件解压，并列出详细的信息gzip -r log.tar # 压缩一个tar备份文件，此时压缩文件的扩展名为.tar.gzgzip -rv test # 递归的压缩目录 gzip -dr test # 递归地解压目录 七、用户管理1、用户账号的管理用户账号的管理工作主要涉及到用户账号的添加、修改和删除。添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。刚添加的账号是被锁定的，无法使用。(1)添加新用户账号增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。useradd [选项] 用户名 -c comment：指定一段注释性描述 -d 目录：指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录 -g 用户组：指定用户所属的用户组 -G 用户组，用户组：指定用户所属的附加组 -s Shell文件 指定用户的登录Shell -u 用户号：指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号 1useradd –d /usr/tester -s /bin/sh -g group –G adm,root tester #新建一个用户tester，同时新建主目录，该用户的登录Shell是/bin/sh，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。 (2)删除用户账号删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。userdel [选项] 用户名 -r：把用户的主目录一起删除 1userdel -r tester (3)修改用户账号usermod [选项] 用户名 -c comment：指定一段注释性描述 -d 目录：指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录 -g 用户组：指定用户所属的用户组 -G 用户组，用户组：指定用户所属的附加组 -s Shell文件 指定用户的登录Shell -u 用户号：指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号 -l 新用户名：指定一个新的账号，即将原来的用户名改为新的用户名 1usermod -s /bin/ksh -d /home/z –g developer tester (4)用户口令管理用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。passwd [选项] 用户名 -l：锁定口令，即禁用账号 -u：口令解锁 -d：使账号无口令 -f：强迫用户下次登录时修改口令 12345678910#普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令passwd Old password:****** New password:******* Re-enter new password:*******#超级用户为用户指定口令时，就不需要知道原口令passwd tester New password:******* Re-enter new password:******* 2、用户组的管理用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。(1)增加新的用户组groupadd [选项] 用户组 -g GID：指定新用户组的组标识号（GID） -o：一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同 12groupadd group1 # 增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1groupadd -g 101 group2 # 增加了一个新组group2，同时指定新组的组标识号是101 (2)删除用户组groupdel 用户组 1groupdel group1 (3)修改用户组groupmod [选项] 用户组 -g GID：为用户组指定新的组标识号 -o：与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同 -n 新用户组：将用户组的名字改为新名字 1groupmod –g 10000 -n group3 group2 # 将组group2的标识号改为10000，组名修改为group3 (4)切换用户组newgrp root 3、与用户账号有关的系统文件(1)/etc/passwd文件每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell 123456789101112131415161718192021cat /etc/passwdroot:x:0:0:Superuser:/:daemon:x:1:1:System daemons:/etc:bin:x:2:2:Owner of system commands:/bin:sys:x:3:3:Owner of system files:/usr/sys:adm:x:4:4:System accounting:/usr/adm:uucp:x:5:5:UUCP administrator:/usr/lib/uucp:auth:x:7:21:Authentication administrator:/tcb/files/auth:cron:x:9:16:Cron daemon:/usr/spool/cron:listen:x:37:4:Network daemon:/usr/net/nls:lp:x:71:18:Printer administrator:/usr/spool/lp:sam:x:200:50:Sam san:/usr/sam:/bin/sh#系统中有一类用户称为伪用户（psuedo users）#bin 拥有可执行的用户命令文件 #sys 拥有系统文件 #adm 拥有帐户文件 #uucp UUCP使用 #lp lp或lpd子系统使用 #nobody NFS使用 (2)/etc/shadow文件由于/etc/passwd文件是所有用户都可读的,因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在/etc/shadow文件。 有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志 1234567891011121314＃ cat /etc/shadowroot:Dnakfw28zf38w:8764:0:168:7:::daemon:*::0:0::::bin:*::0:0::::sys:*::0:0::::adm:*::0:0::::uucp:*::0:0::::nuucp:*::0:0::::auth:*::0:0::::cron:*::0:0::::listen:*::0:0::::lp:*::0:0::::sam:EkdiSECLWPdSa:9740:0:0:::: (3)/etc/group文件组名:口令:组标识号:组内用户列表 1234567root::0:rootbin::2:root,binsys::3:root,uucpadm::4:root,admdaemon::5:root,daemonlp::7:root,lpusers::20:root,sam 八、磁盘管理1、df检查文件系统的磁盘空间占用情况利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。df [-ahikHTm] [目录或文件名] -a：列出所有的文件系统，包括系统特有的 /proc 等文件系统 -k：以 KBytes 的容量显示各文件系统 -m：以 MBytes 的容量显示各文件系统 -h：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示 -H：以 M=1000K 取代 M=1024K 的进位方式 -T：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出 -i：不用硬盘容量，而以 inode 的数量来显示 123456[root@www ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/hdc2 9.5G 3.7G 5.4G 41% //dev/hdc3 4.8G 139M 4.4G 4% /home/dev/hdc1 99M 11M 83M 12% /boottmpfs 363M 0 363M 0% /dev/shm 2、du对文件和目录磁盘使用的空间的查看du [-ahskm] 文件或目录名称 -a：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已 -h：以人们较易读的容量格式 (G/M) 显示 -s：列出总量而已，而不列出每个各别的目录占用容量 -S：不包括子目录下的总计，与 -s 有点差别 -k：以 KBytes 列出容量显示 -m：以 MBytes 列出容量显示 12345678[root@www ~]# du -a12 ./install.log.syslog &lt;==有文件的列表了8 ./.bash_logout8 ./test48 ./test2....中间省略....12 ./.gconfd220 . 3、fdisk磁盘分区表操作工具fdisk [-l] 装置名称 -l ：输出后面接的装置所有的分区内容。若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。 1234567891011121314151617181920212223242526[root@www ~]# df / #仅找出磁盘文件名而已Filesystem 1K-blocks Used Available Use% Mounted on/dev/hdc2 9920624 3823168 5585388 41% /[root@www ~]# fdisk /dev/hdc #注意不要加上数字！...Command (m for help): # 等待你的输入！Command (m for help): m #输入 m 后，就会看到底下这些命令介绍Command action a toggle a bootable flag b edit bsd disklabel c toggle the dos compatibility flag d delete a partition #删除一个partition l list known partition types m print this menu n add a new partition #新增一个partition o create a new empty DOS partition table p print the partition table #在屏幕上显示分割表 q quit without saving changes #不储存离开fdisk程序 s create a new empty Sun disklabel t change a partition&apos;s system id u change display/entry units v verify the partition table w write table to disk and exit #将刚刚的动作写入分割表 x extra functionality (experts only) 4、 mkfs磁盘格式化mkfs [-t 文件系统格式] 装置文件名 -t ：可以接文件系统格式，例如 ext3, ext2, vfat 等(系统有支持才会生效) 1234567891011121314151617181920212223[root@www ~]# mkfs -t ext3 /dev/hdc6mke2fs 1.39 (29-May-2006)Filesystem label= #这里指的是分割槽的名称(label)OS type: LinuxBlock size=4096 (log=2) #block 的大小配置为 4K Fragment size=4096 (log=2)251392 inodes, 502023 blocks #由此配置决定的inode/block数量25101 blocks (5.00%) reserved for the super userFirst data block=0Maximum filesystem blocks=51589939216 block groups32768 blocks per group, 32768 fragments per group15712 inodes per groupSuperblock backups stored on blocks: 32768, 98304, 163840, 229376, 294912Writing inode tables: doneCreating journal (8192 blocks): done #有日志记录Writing superblocks and filesystem accounting information: doneThis filesystem will be automatically checked every 34 mounts or180 days, whichever comes first. Use tune2fs -c or -i to override.# 这样就创建起来我们所需要的 Ext3 文件系统了！简单明了！ 5、磁盘挂载和卸载(1)mount挂载磁盘mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点 1mount -t ios9660 /dev/cdrom /mnt/cdrom #将光盘设备挂载到/mnt/cdrom (2)umount卸载磁盘umount [-fn] 装置文件名或挂载点 -f：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下 -n：不升级 /etc/mtab 情况下卸除 1umount /mnt/cdrom 九、进程管理1、ps查看进程ps [选项] -a：显示所有终端机下执行的程序，除了阶段作业领导者之外。 a：显示现行终端机下的所有程序，包括其他用户的程序。 -A：显示所有程序。 -c：显示CLS和PRI栏位。 c：列出程序时，显示每个程序真正的指令名称，而不包含路径，选项或常驻服务的标示。 -C&lt;指令名称&gt;：指定执行指令的名称，并列出该指令的程序的状况。 -d：显示所有程序，但不包括阶段作业领导者的程序。 -e：此选项的效果和指定”A”选项相同。 e：列出程序时，显示每个程序所使用的环境变量。 -f：显示UID,PPIP,C与STIME栏位。 f：用ASCII字符显示树状结构，表达程序间的相互关系。 -g&lt;群组名称&gt;：此选项的效果和指定”-G”选项相同，当亦能使用阶段作业领导者的名称来指定。 g：显示现行终端机下的所有程序，包括群组领导者的程序。 -G&lt;群组识别码&gt;：列出属于该群组的程序的状况，也可使用群组名称来指定。 h：不显示标题列。 -H：显示树状结构，表示程序间的相互关系。 -j或j：采用工作控制的格式显示程序状况。 -l或l：采用详细的格式来显示程序状况。 L：列出栏位的相关信息。 -m或m：显示所有的执行绪。 n：以数字来表示USER和WCHAN栏位。 -N：显示所有的程序，除了执行ps指令终端机下的程序之外。 -p&lt;程序识别码&gt;：指定程序识别码，并列出该程序的状况。 p&lt;程序识别码&gt;：此选项的效果和指定”-p”选项相同，只在列表格式方面稍有差异。 r：只列出现行终端机正在执行中的程序。 -s&lt;阶段作业&gt;：指定阶段作业的程序识别码，并列出隶属该阶段作业的程序的状况。 s：采用程序信号的格式显示程序状况。 S：列出程序时，包括已中断的子程序资料。 -t&lt;终端机编号&gt;：指定终端机编号，并列出属于该终端机的程序的状况。 t&lt;终端机编号&gt;：此选项的效果和指定”-t”选项相同，只在列表格式方面稍有差异。 -T：显示现行终端机下的所有程序。 -u&lt;用户识别码&gt;：此选项的效果和指定”-U”选项相同。 u：以用户为主的格式来显示程序状况。 -U&lt;用户识别码&gt;：列出属于该用户的程序的状况，也可使用用户名称来指定。 U&lt;用户名称&gt;：列出属于该用户的程序的状况。 v：采用虚拟内存的格式显示程序状况。 -V或V：显示版本信息。 -w或w：采用宽阔的格式来显示程序状况。 x：显示所有程序，不以终端机来区分。 X：采用旧式的Linux i386登陆格式显示程序状况。 -y：配合选项”-l”使用时，不显示F(flag)栏位，并以RSS栏位取代ADDR栏位 。 -&lt;程序识别码&gt;：此选项的效果和指定”p”选项相同。 –cols&lt;每列字符数&gt;：设置每列的最大字符数。 –columns&lt;每列字符数&gt;：此选项的效果和指定”–cols”选项相同。 –cumulative：此选项的效果和指定”S”选项相同。 –deselect：此选项的效果和指定”-N”选项相同。 –forest：此选项的效果和指定”f”选项相同。 –headers：重复显示标题列。 –help：在线帮助。 –info：显示排错信息。 –lines&lt;显示列数&gt;：设置显示画面的列数。 –no-headers：此选项的效果和指定”h”选项相同，只在列表格式方面稍有差异。 –group&lt;群组名称&gt;：此选项的效果和指定”-G”选项相同。 –Group&lt;群组识别码&gt;：此选项的效果和指定”-G”选项相同。 –pid&lt;程序识别码&gt;：此选项的效果和指定”-p”选项相同。 –rows&lt;显示列数&gt;：此选项的效果和指定”–lines”选项相同。 –sid&lt;阶段作业&gt;：此选项的效果和指定”-s”选项相同。 –tty&lt;终端机编号&gt;：此选项的效果和指定”-t”选项相同。 –user&lt;用户名称&gt;：此选项的效果和指定”-U”选项相同。 –User&lt;用户识别码&gt;：此选项的效果和指定”-U”选项相同。 –version：此选项的效果和指定”-V”选项相同。 –widty&lt;每列字符数&gt;：此选项的效果和指定”-cols”选项相同。 12ps -a #列出所有进程ps -ef | grep xxx #列出所需进程 2、kill终止进程kill [选项] 进程或作业识别号 -a：当处理当前进程时，不限制命令名和进程号的对应关系 -l &lt;信息编号&gt;：若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称 -p：指定kill 命令只打印相关进程的进程号，而不发送任何信号 -s &lt;信息名称或编号&gt;：指定要送出的信息 -u：指定用户 123456ps -ef | grep vim #查看pidroot 3268 2884 0 16:21 pts/1 00:00:00 vim install.logroot 3370 2822 0 16:21 pts/0 00:00:00 grep vimkill 3268 #杀掉进程kill -9 3268 #强制杀掉进程 十、系统性能1、top实时动态查看系统整体运行情况top [选项] -b：以批处理模式操作 -c：显示完整的治命令 -d：屏幕刷新间隔时间 -I：忽略失效过程 -s：保密模式 -S：累积模式 -i&lt;时间&gt;：设置间隔时间 -u&lt;用户名&gt;：指定用户名 -p&lt;进程号&gt;：指定进程 -n&lt;次数&gt;：循环显示的次数 在top命令执行过程中可以使用的一些交互命令: h：显示帮助画面，给出一些简短的命令总结说明 k：终止一个进程 i：忽略闲置和僵死进程，这是一个开关式命令 q：退出程序 r：重新安排一个进程的优先级别 S：切换到累计模式 s：改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成ms。输入0值则系统将不断刷新，默认值是5s f或者F：从当前显示中添加或者删除项目 o或者O：改变显示项目的顺序 l：切换显示平均负载和启动时间信息 m：切换显示内存信息 t：切换显示进程和CPU状态信息 c：切换显示命令名称和完整命令行 M：根据驻留内存大小进行排序 P：根据CPU使用百分比大小进行排序 T：根据时间/累计时间进行排序 w：将当前设置写入~/.toprc文件中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879[root@www~]$ top# 统计信息：前五行是系统整体的统计信息top - 16:07:37 up 241 days, 20:11, 1 user, load average: 0.96, 1.13, 1.25Tasks: 231 total, 1 running, 230 sleeping, 0 stopped, 0 zombieCpu(s): 12.7%us, 8.4%sy, 0.0%ni, 77.1%id, 0.0%wa, 0.0%hi, 1.8%si, 0.0%stMem: 12196436k total, 12056552k used, 139884k free, 64564k buffersSwap: 2097144k total, 151016k used, 1946128k free, 3120236k cached# 进程信息：统计信息下方类似表格区域显示的是各个进程的详细信息，默认5秒刷新一次PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND18411 pplive 20 0 11.9g 7.8g 5372 S 220.2 67.1 16761:00 java 1875 pplive 20 0 3958m 127m 4564 S 4.6 1.1 12497:35 java 4 root 20 0 0 0 0 S 0.3 0.0 184:01.76 ksoftirqd/0 13 root 20 0 0 0 0 S 0.3 0.0 135:49.83 ksoftirqd/2 25 root 20 0 0 0 0 S 0.3 0.0 136:54.49 ksoftirqd/5 # 统计信息说明： # 第1行：Top 任务队列信息(系统运行状态及平均负载)，与uptime命令结果相同。 # 第1段：系统当前时间，例如：16:07:37 # 第2段：系统运行时间，未重启的时间，时间越长系统越稳定。 # 格式：up xx days, HH:MM # 例如：241 days, 20:11, 表示连续运行了241天20小时11分钟 # 第3段：当前登录用户数，例如：1 user，表示当前只有1个用户登录 # 第4段：系统负载，即任务队列的平均长度，3个数值分别统计最近1，5，15分钟的系统平均负载 # 系统平均负载：单核CPU情况下，0.00 表示没有任何负荷，1.00表示刚好满负荷，超过1侧表示超负荷，理想值是0.7； # 多核CPU负载：CPU核数 * 理想值0.7 = 理想负荷，例如：4核CPU负载不超过2.8何表示没有出现高负载。 # 第2行：Tasks 进程相关信息 # 第1段：进程总数，例如：Tasks: 231 total, 表示总共运行231个进程 # 第2段：正在运行的进程数，例如：1 running, # 第3段：睡眠的进程数，例如：230 sleeping, # 第4段：停止的进程数，例如：0 stopped, # 第5段：僵尸进程数，例如：0 zombie # 第3行：Cpus CPU相关信息，如果是多核CPU，按数字1可显示各核CPU信息，此时1行将转为Cpu核数行，数字1可以来回切换。 # 第1段：us 用户空间占用CPU百分比，例如：Cpu(s): 12.7%us, # 第2段：sy 内核空间占用CPU百分比，例如：8.4%sy, # 第3段：ni 用户进程空间内改变过优先级的进程占用CPU百分比，例如：0.0%ni, # 第4段：id 空闲CPU百分比，例如：77.1%id, # 第5段：wa 等待输入输出的CPU时间百分比，例如：0.0%wa, # 第6段：hi CPU服务于硬件中断所耗费的时间总额，例如：0.0%hi, # 第7段：si CPU服务软中断所耗费的时间总额，例如：1.8%si, # 第8段：st Steal time 虚拟机被hypervisor偷去的CPU时间（如果当前处于一个hypervisor下的vm，实际上hypervisor也是要消耗一部分CPU处理时间的） # 第4行：Mem 内存相关信息（Mem: 12196436k total, 12056552k used, 139884k free, 64564k buffers） # 第1段：物理内存总量，例如：Mem: 12196436k total, # 第2段：使用的物理内存总量，例如：12056552k used, # 第3段：空闲内存总量，例如：Mem: 139884k free, # 第4段：用作内核缓存的内存量，例如：64564k buffers # 第5行：Swap 交换分区相关信息（Swap: 2097144k total, 151016k used, 1946128k free, 3120236k cached） # 第1段：交换区总量，例如：Swap: 2097144k total, # 第2段：使用的交换区总量，例如：151016k used, # 第3段：空闲交换区总量，例如：1946128k free, # 第4段：缓冲的交换区总量，3120236k cached # 进程信息说明： # A: PID = (Process Id) 进程Id； # E: USER = (User Name) 进程所有者的用户名； # H: PR = (Priority) 优先级 # I: NI = (Nice value) nice值。负值表示高优先级，正值表示低优先级 # O: VIRT = (Virtual Image (kb)) 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES # Q: RES = (Resident size (kb)) 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA # T: SHR = (Shared Mem size (kb)) 共享内存大小，单位kb # W: S = (Process Status) 进程状态。D=不可中断的睡眠状态,R=运行,S=睡眠,T=跟踪/停止,Z=僵尸进程 # K: %CPU = (CPU usage) 上次更新到现在的CPU时间占用百分比 # N: %MEM = (Memory usage (RES)) 进程使用的物理内存百分比 # M: TIME+ = (CPU Time, hundredths) 进程使用的CPU时间总计，单位1/100秒 # b: PPID = (Parent Process Pid) 父进程Id # c: RUSER = (Real user name) # d: UID = (User Id) 进程所有者的用户id # f: GROUP = (Group Name) 进程所有者的组名 # g: TTY = (Controlling Tty) 启动进程的终端名。不是从终端启动的进程则显示为 ? # j: P = (Last used cpu (SMP)) 最后使用的CPU，仅在多CPU环境下有意义 # p: SWAP = (Swapped size (kb)) 进程使用的虚拟内存中，被换出的大小，单位kb # l: TIME = (CPU Time) 进程使用的CPU时间总计，单位秒 # r: CODE = (Code size (kb)) 可执行代码占用的物理内存大小，单位kb # s: DATA = (Data+Stack size (kb)) 可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb # u: nFLT = (Page Fault count) 页面错误次数 # v: nDRT = (Dirty Pages count) 最后一次写入到现在，被修改过的页面数 # y: WCHAN = (Sleeping in Function) 若该进程在睡眠，则显示睡眠中的系统函数名 # z: Flags = (Task Flags &lt;sched.h&gt;) 任务标志，参考 sched.h # X: COMMAND = (Command name/line) 命令名/命令行 2、free显示系统使用和空闲的内存情况free [选项] -b：以Byte为单位显示内存使用情况 -k：以KB为单位显示内存使用情况 -m：以MB为单位显示内存使用情况 -o：不显示缓冲区调节列 -s&lt;间隔秒数&gt;：持续观察内存使用状况 -t：显示内存总和列 -V：显示版本信息 1234567891011121314151617[root@www~]$ free -m total used free shared buffers cachedMem: 2016 1973 42 0 163 1497-/+ buffers/cache: 312 1703Swap: 4094 0 4094# 第一部分Mem行解释： # total：内存总数；total=used+free # used：已经使用的内存数； # free：空闲的内存数； # shared：当前已经废弃不用； # buffers Buffer：缓存内存数； # cached Page：缓存内存数。# 第二部分(-/+ buffers/cache)解释: # (-buffers/cache) used内存数：第一部分Mem行中的 used – buffers – cached；反映的是被程序实实在在吃掉的内存。 # (+buffers/cache) free内存数: 第一部分Mem行中的 free + buffers + cached；反映的是可以挪用的内存总数。# 第三部分Swap交换分区: 3、cat /proc/meminfo查看系统内存情况 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950[root@www~]$ cat /proc/meminfo MemTotal: 262144 kB MemFree: 237904 kB Cached: 10540 kB Active: 10220 kB Inactive: 7004 kB Active(anon): 6608 kB Inactive(anon): 76 kB Active(file): 3612 kB Inactive(file): 6928 kB Unevictable: 0 kB Mlocked: 0 kB SwapTotal: 524288 kB SwapFree: 524288 kB Dirty: 0 kB Writeback: 0 kB AnonPages: 6684 kB Shmem: 2632 kB Slab: 6972 kB SReclaimable: 4288 kB SUnreclaim: 2684 kB # 显示解释# MemTotal: 所有可用RAM大小（即物理内存减去一些预留位和内核的二进制代码大小）# MemFree: LowFree与HighFree的总和，被系统留着未使用的内存# Buffers: 用来给文件做缓冲大小# Cached: 被高速缓冲存储器（cache memory）用的内存的大小（等于 diskcache minus SwapCache ）.# SwapCached:被高速缓冲存储器（cache memory）用的交换空间的大小已经被交换出来的内存，但仍然被存放在swapfile中。用来在需要的时候很快的被替换而不需要再次打开I/O端口。# Active: 在活跃使用中的缓冲或高速缓冲存储器页面文件的大小，除非非常必要否则不会被移作他用.# Inactive: 在不经常使用中的缓冲或高速缓冲存储器页面文件的大小，可能被用于其他途径.# HighTotal:# HighFree: 该区域不是直接映射到内核空间。内核必须使用不同的手法使用该段内存。# LowTotal:# LowFree: 低位可以达到高位内存一样的作用，而且它还能够被内核用来记录一些自己的数据结构。Among many# other things, it is where everything from the Slab is allocated. Bad things happen when you’re out of lowmem.# SwapTotal: 交换空间的总大小# SwapFree: 未被使用交换空间的大小# Dirty: 等待被写回到磁盘的内存大小。# Writeback: 正在被写回到磁盘的内存大小。# AnonPages：未映射页的内存大小# Mapped: 设备和文件等映射的大小。# Slab: 内核数据结构缓存的大小，可以减少申请和释放内存带来的消耗。# SReclaimable:可收回Slab的大小# SUnreclaim：不可收回Slab的大小（SUnreclaim+SReclaimable＝Slab）# PageTables：管理内存分页页面的索引表的大小。# NFS_Unstable:不稳定页表的大小# VmallocTotal: 可以vmalloc虚拟内存大小# VmallocUsed: 已经被使用的虚拟内存大小。# VmallocChunk: largest contigious block of vmalloc area which is free 3、iostat监视磁盘操作活动iostat [选项] [时间] [次数] -C：显示CPU使用情况 -d：显示磁盘使用情况 -k：以 KB 为单位显示 -m：以 M 为单位显示 -N：显示磁盘阵列(LVM) 信息 -n：显示NFS 使用情况 -p[磁盘]：显示磁盘和分区的情况 -t：显示终端和CPU的信息 -x：显示详细信息 -V：显示版本信息 1234567891011121314151617181920212223242526272829303132333435363738394041[root@www~]# iostat#系统信息和监测时间Linux 2.6.18-128.el5 (CT1186) 2012年12月28日avg-cpu: %user %nice %system %iowait %steal %idle 8.30 0.02 5.07 0.17 0.00 86.44 Device: tps Blk_read/s Blk_wrtn/s Blk_read Blk_wrtnsda 22.73 43.70 487.42 674035705 7517941952sda1 0.00 0.00 0.00 2658 536sda2 0.11 3.74 3.51 57721595 54202216sda3 0.98 0.61 17.51 9454172 270023368sda4 0.00 0.00 0.00 6 0sda5 6.95 0.12 108.73 1924834 1677123536sda6 2.20 0.18 31.22 2837260 481488056sda7 12.48 39.04 326.45 602094508 5035104240# cpu属性值说明： # %user：CPU处在用户模式下的时间百分比。 # %nice：CPU处在带NICE值的用户模式下的时间百分比。 # %system：CPU处在系统模式下的时间百分比。 # %iowait：CPU等待输入输出完成时间的百分比。 # %steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。 # %idle：CPU空闲时间百分比。# 备注：如果%iowait的值过高，表示硬盘存在I/O瓶颈，%idle值高，表示CPU较空闲，如果%idle值高但系统响应慢时，有可能是CPU等待分配内存，此时应加大内存容量。%idle值如果持续低于10，那么系统的CPU处理能力相对较低，表明系统中最需要解决的资源是CPU。 # disk属性值说明： # rrqm/s: 每秒进行 merge 的读操作数目。即 rmerge/s # wrqm/s: 每秒进行 merge 的写操作数目。即 wmerge/s # r/s: 每秒完成的读 I/O 设备次数。即 rio/s # w/s: 每秒完成的写 I/O 设备次数。即 wio/s # rsec/s: 每秒读扇区数。即 rsect/s # wsec/s: 每秒写扇区数。即 wsect/s # rkB/s: 每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。 # wkB/s: 每秒写K字节数。是 wsect/s 的一半。 # avgrq-sz: 平均每次设备I/O操作的数据大小 (扇区)。 # avgqu-sz: 平均I/O队列长度。 # # await: 平均每次设备I/O操作的等待时间 (毫秒)。 # svctm: 平均每次设备I/O操作的服务时间 (毫秒)。 # %util: 一秒中有百分之多少的时间用于 I/O 操作，即被io消耗的cpu百分比# 备注：如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间；如果 await 远大于 svctm，说明I/O 队列太长，io响应太慢，则需要进行必要优化。如果avgqu-sz比较大，也表示有当量io在等待。 十一、软件安装1、yum软件包管理器(1)yum命令是在Fedora和RedHat以及SUSE中基于rpm的软件包管理器。yum [选项] [参数] 软件包选项： -h：显示帮助信息 -y：对所有的提问都回答“yes” -c：指定配置文件 -q：安静模式 -v：详细模式 -d：设置调试等级（0-10） -e：设置错误等级（0-10） -R：设置yum处理一个命令的最大等待时间 -C：完全从缓存中运行，而不去下载或者更新任何头文件 参数： install：安装rpm软件包 update：更新rpm软件包 check-update：检查是否有可用的更新rpm软件包 remove：删除指定的rpm软件包 list：显示软件包的信息 search：检查软件包的信息 info：显示指定的rpm软件包的描述信息和概要信息 clean：清理yum过期的缓存 shell：进入yum的shell提示符 resolvedep：显示rpm软件包的依赖关系 localinstall：安装本地的rpm软件包 localupdate：显示本地rpm软件包进行更新 deplist：显示rpm软件包的所有依赖关系 12345678910111213141516171819202122yum install #全部安装yum install package1 #安装指定的安装包package1yum groupinsall group1 #安装程序组group1yum update #全部更新yum update package1 #更新指定程序包package1yum check-update #检查可更新的程序yum upgrade package1 #升级指定程序包package1yum groupupdate group1 #升级程序组group1yum info package1 #显示安装包信息package1yum list #显示所有已经安装和可以安装的程序包yum list package1 #显示指定程序包安装情况package1yum groupinfo group1 #显示程序组group1信息yum search string 根据关键字string查找安装包yum remove &amp;#124; erase package1 #删除程序包package1yum groupremove group1 #删除程序组group1yum deplist package1 #查看程序package1依赖情况yum clean packages #清除缓存目录下的软件包yum clean headers #清除缓存目录下的 headersyum clean oldheaders #清除缓存目录下旧的 headers (2)国内yum源 1234567891011#1.首先备份/etc/yum.repos.d/CentOS-Base.repomv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup#2.下载对应版本repo文件, 放入/etc/yum.repos.d/(操作前请做好相应备份)#网易yum源：http://mirrors.163.com/.help/CentOS6-Base-163.repo#中科大yum源，安装方法查看：https://lug.ustc.edu.cn/wiki/mirrors/help/centos#sohuyum源，安装方法查看: http://mirrors.sohu.com/help/centos.html#3.运行以下命令生成缓存yum clean allyum makecache 2、apt-get软件包管理工具(1)apt-get命令是Debian Linux发行版中的APT软件包管理工具。apt-get [选项] [参数] 软件包选项： -h：本帮助文件。 -q：输出到日志 - 无进展指示 -qq：不输出信息，错误除外 -d：仅下载 - 不安装或解压归档文件 -s：不实际安装。模拟执行命令 -y：假定对所有的询问选是，不提示 -f：尝试修正系统依赖损坏处 -m：如果归档无法定位，尝试继续 -u：同时显示更新软件包的列表 -b：获取源码包后编译 -V 显示详细的版本号 -c=?：阅读此配置文件 -o=?：设置自定的配置选项，如 -o dir::cache=/tmp 参数： update：重新获取软件包列表 upgrade：进行更新 install：安装新的软件包 remove：移除软件包 autoremove：自动移除全部不使用的软件包 purge：移除软件包和配置文件 source：下载源码档案 build-dep：为源码包配置编译依赖 dist-upgrade：发行版升级 dselect-upgrade：依照 dselect 的选择更新 clean：清除下载的归档文件 autoclean：清除旧的的已下载的归档文件 check：检验是否有损坏的依赖 12345678apt-get install packagename # 安装一个新软件包apt-get remove packagename # 卸载一个已安装的软件包（保留配置文件）apt-get –purge remove packagename # 卸载一个已安装的软件包（删除配置文件）apt-get autoclean apt # 把已装或已卸的软件都备份在硬盘上,删除你已经删掉的软件apt-get clean # 把安装的软件的备份也删除apt-get upgrade # 更新所有已安装的软件包apt-get dist-upgrade # 将系统升级到新版本apt-get autoclean # 定期运行这个命令来清除那些已经卸载的软件包的.deb文件 (2)国内apt-get源 123456789101112131415161718192021222324252627#1.原文件重命名备份sudo mv /etc/apt/sources.list /etc/apt/sources.list.bak#2.编辑源列表文件sudo vim /etc/apt/sources.list#3.用下面文本做内容#deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse#deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse#deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse#deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse# ##测试版源#deb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse# #源码#deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse#deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse#deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse#deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse# ##测试版源#deb-src http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse# #Canonical 合作伙伴和附加#deb http://archive.canonical.com/ubuntu/ xenial partner#deb http://extras.ubuntu.com/ubuntu/ xenial main#4.更新sudo apt-get updatesudo apt-get upgrade 十二、网络管理1、ping测试网络状况ping [选项] 目的主机 -d：使用Socket的SO_DEBUG功能； -c&lt;完成次数&gt;：设置完成要求回应的次数 -f：极限检测 -i&lt;间隔秒数&gt;：指定收发信息的间隔时间 -I&lt;网络界面&gt;：使用指定的网络界面送出数据包 -l&lt;前置载入&gt;：设置在送出要求信息之前，先行发出的数据包 -n：只输出数值 -p&lt;范本样式&gt;：设置填满数据包的范本样式 -q：不显示指令执行过程，开头和结尾的相关信息除外 -r：忽略普通的Routing Table，直接将数据包送到远端主机上 -R：记录路由过程 -s&lt;数据包大小&gt;：设置数据包的大小 -t&lt;存活数值&gt;：设置存活数值TTL的大小 -v：详细显示指令的执行过程 1ping www.baidu.com 2、nslookup查询DNS信息nslookup [选项] 域名 -sil：不显示任何警告信息 12345678[root@www~]# nslookup www.baidu.comServer: 192.168.226.2Address: 192.168.226.2#53Non-authoritative answer:www.baidu.com canonical name = www.a.shifen.com.Name: www.a.shifen.comAddress: 115.239.211.112 3、ifconfig查看与临时配置网络ifconfig [参数] add&lt;地址&gt;：设置网络设备IPv6的ip地址； del&lt;地址&gt;：删除网络设备IPv6的IP地址； down：关闭指定的网络设备；","categories":[{"name":"linux","slug":"linux","permalink":"http://pythonfood.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://pythonfood.github.io/tags/linux/"}]},{"title":"mysql","slug":"mysql","date":"2017-12-29T01:00:00.000Z","updated":"2018-05-21T08:07:48.760Z","comments":true,"path":"2017/12/29/mysql/","link":"","permalink":"http://pythonfood.github.io/2017/12/29/mysql/","excerpt":"mysql常用命令笔记。","text":"mysql常用命令笔记。 一、mysql安装1、mysql官网下载安装：https://dev.mysql.com/downloads/mysql/2、mysql目录结构： bin目录：存储可执行文件 data目录：存储数据文件 lib目录：存储库文件 include目录：存储包含的头文件 share目录：错误消息和字符集文件 docs目录：文档 3、启动/停止mysql服务： (1)在windows服务列表里启动/停止mysql服务。(2)通过cmd命令启动/停止mysql服务： 启动mysql：net start mysql 停止mysql：net stop mysql 二、mysql操作1、查看数据库版本：mysql -V 2、登录数据库：mysql -uroot -p123456 -P3306 -h127.0.0.1 参数 描述 -D, –database=name 打开指定数据库 –delimiter = name 指定分隔符 -h, –host=name 服务器名称 -p, –password[=name] 密码 -P, –port=# 端口号 –prompt=name 设置提示符 -u, –user=name 用户名 -V, –version 输出版本信息并退出 3、退出数据库： exit; quit; \\q; 4、修改mysql提示符： 连接客户端时通过参数指定：mysql -uroot -p123456 --prompt 提示符 连接上客户端后通过命令修改：prompt 提示符 参数 描述 \\D 完整的日期 \\d 当前数据库 \\h 服务器名称 \\u 当前用户 5、显示当前服务器版本：SELECT VERSION();6、显示当前日期时间：SELECT NOW();7、显示当前用户：SELECT USER(); 三、数据库操作注意，本文的命令格式中： {}是必选项 |是选项中做选择 []是可选项 1、创建数据库：CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name [DEFAULT] CHARACTER SET [=] charset_name 12CREATE DATABASE test;CREATE DATABASE test1 IF NOT EXISTS CHARACTER SET gbk; 2、查看数据库列表：SHOW {DATABASES | SCHEMAS} [LIKE &#39;pattern&#39; | WHERE expr] 1SHOW DATABASES; 3、显示数据库创建时所使用的指令：SHOW CREATE DATABASE test 4、打开数据库：USE db_name 5、查看当前数据库：SELECT DATABASE() 6、修改数据库：ALTER {DATABASE | SCHEMA} db_name [DEFAULT] CHARACTER SET [=] charset_name 1ALTER DATABASE test1 CHARACTER SET utf8; 7、删除数据库：DROP {DATABASE | SCHEMA} [IF EXISTS] db_name 12DROP DATABASE test1;DROP DATABASE IF EXISTS test1; 8、查看警告：SHOW WARNINGS; 四、数据表操作1、数据类型: (1)数值类型 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 字节 (-128，127) (0，255) 小整数值 SMALLINT 2 字节 (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 字节 (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 字节 (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 字节 (-9 233 372 036 854 775 808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 FLOAT 4 字节 (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 单精度，浮点数值 DOUBLE 8 字节 (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度，浮点数值 DECIMAL 对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 (2)字符串类型 类型 大小 用途 CHAR 0-255字节 定长字符串 VARCHAR 0-65535 字节 变长字符串 TINYBLOB 0-255字节 不超过255个字符的二进制字符串 TINYTEXT 0-255字节 短文本字符串 BLOB 0-65 535字节 二进制形式的长文本数据 TEXT 0-65 535字节 长文本数据 MEDIUMBLOB 0-16 777 215字节 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215字节 中等长度文本数据 LONGBLOB 0-4 294 967 295字节 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295字节 极大文本数据 ENUM(‘value1’,’value2’,…) 1或2个字节，取决于枚举值的个数(最多65535个值) SET(‘value1’,’value2’,…) 1、2、3、4或8个字节，取决于set成员的数目(最多64个) (3)日期类型 类型 大小 范围 格式 用途 DATE 3 1000-01-01/9999-12-31 YYYY-MM-DD 日期值 TIME 3 ‘-838:59:59’/‘838:59:59’ HH:MM:SS 时间值或持续时间 YEAR 1 1901/2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00/9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:00/2037-12-31 23:59:59 YYYYMMDD HHMMSS 混合日期和时间值，时间戳 2、创建数据表：CREATE TABLE [IF NOT EXISTS] table_name(column_name data_type, ...) 1CREATE TABLE tb1( username VARCHAR(20),age TINYINT UNSIGNED,salary FLOAT(8,2) UNSIGNED); 3、查看数据表列表：SHOW TABLES [FROM db_name] [LINK &#39;pattern&#39; | WHERE expr] 4、查看数据表结构：SHOW COLUMNS FROM table_name 1SHOW COLUMNS FROM test; 5、约束条件：约束保证数据的完整性、唯一性。约束分为表级约束和列级约束。 主键约束：PRIMARY KEY 空与非空：NULL/NOT NULL 唯一约束：UNIQUE 默认值：DEFAULT 自动增加：AUTO_INCREMENT 外键约束：FOREIGN KEY (1)主键约束：PRIMARY KEY主键约束不允许重复，也不允许为空。每个表只允许存在一个主键。主键约束可以在列级别创建，也可以在表级别创建。 1234# 基本模式CREATE TABLE test(id SMALLINT UNSIGNED PRIMARY KEY, username VARCHAR(30) NOT NULL;# 组合模式CREATE TABLE test1(id INT, name VARCHAR(20), pwd VARCHAR(20), primary key(id, name)); (2)空与非空：NULL/NOT NULL非空约束保证当前列的值不为空值。非空约束只能列级别创建。空约束是代表字段值可以为空，一般省略不写。 1CREATE TABLE test(username VARCHAR(20) NOT NULL, age TINYINT UNSIGNED); (3)唯一约束：UNIQUE唯一约束保证记录的唯一性。唯一约束的字段可以为空。每个表可以许存在多个唯一约束。唯一约束可以在列级别创建，也可以在表级别创建。 1234# 基本模式CREATE TABLE test(id SMALLINT UNSIGNED, username VARCHAR(20) UNIQUE KEY, age TINYINT UNSIGNED);#组合模式CREATE TABLE test1(id INT NOT NULL, name VARCHAR(20), password VARCHAR(10), UNIQUE(name,password)); (4)默认值：DEFAULT插入记录时，如果没有为字段赋值，则自动赋值默认值。默认值只能列级别创建。 1CREATE TABLE test(id SMALLINT UNSIGNED, username VARCHAR(30), age TINYINT DEFAULT 0); (5)自动增加：AUTO_INCREMENT自动编号须与主键配合，只能在数值类型中使用。默认起始值为1，每次增量为1。 1CREATE TABLE test(id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY, username VARCHAR(20) NOT NULL); (6)外键约束：FOREIGN KEY外键约束保证一个或两个表之间的参照完整性。实现一对一或一对多的关系。外键约束可以在列级别创建，也可以在表级别创建。 外键约束的要求： 父表和子表必须使用相同的存储引擎，而且禁止使用临时表。 数据表的存储引擎只能为InnoDB。(MySQL配置文件 default-storage-engine=INNODB) 外键列和参照列必须具有相似的数据类型。而且数字的长度或是否有符号位必须相同；而字符的长度则可以不同。 外键列和参照列必须创建索引，如果外键列不存在索引的话MySQL将自动创建索引。 123456# 父表CREATE TABLE provinces(id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT, pname VARCHAR(20) NOT NULL);# 子表CREATE TABLE users(id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT, username VARCHAR(10) NOT NULL, pid SMALLINT UNSIGNED, FOREIGN KEY (pid) REFERENCES provinces(id));# 查看数据表索引SHOW INDEXES FROM provinces; 外键约束的参照操作： CASCADE：从父表删除或更新且自动删除或更新子表中匹配的行。 SET NULL：从父表删除或更新行，并设置子表中的外键列为NULL。如果使用该选项，必须保证子表列没有指定NOT NULL。 RESTRICT：拒绝对父表的删除或更新操作。 NO ACTION：标准SQL的关键字，在MySQL中与RESTRICT相同。 1234# 父表CREATE TABLE provinces(id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT, pname VARCHAR(20) NOT NULL);# 子表CREATE TABLE users(id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT, username VARCHAR(10) NOT NULL, pid SMALLINT UNSIGNED, FOREIGN KEY (pid) REFERENCES provinces(id) ON DELETE CASCADE); 6、修改数据表： (1)数据表更名：方法一：ALTER TABLE table_name RENAME [TO | AS] new_table_name方法二：RENAME TABLE table_name TO new_table_name [,table_name1 TO new_table_name2,...] 12ALTER TABLE test RENAME test1;RENAME TABLE test TO test1; (2)添加单列：ALTER TABLE table_name ADD [COLUMN] column_name column_definition [FIRST | AFTER column_name1] 123ALTER TABLE test ADD age TINYINT UNSIGNED NOT NULL DEFAULT 10;ALTER TABLE test ADD password VARCHAR(32) NOT NULL AFTER username;ALTER TABLE test ADD truename VARCHAR(20) NOT NULL FIRST; (3)添加多列：ALTER TABLE table_name ADD [COLUMN] (column_name column_definition,...) (4)删除列：ALTER TABLE table_name DROP [COLUMN] column_name 12ALTER TABLE test DROP truename;ALTER TABLE test DROP password, DROP age; (5)修改列名称：ALTER TABLE table_name CHANGE [COLUMN] column_name new_column_name column_definition [FIRST | AFTER column_name1] 1ALTER TABLE test CHANGE pid p_id TINYINT UNSIGNED NOT NULL; (6)修改列定义：ALTER TABLE table_name MODIFY [COLUMN] column_name column_definition [FIRST | AFTER column_name1] 1ALTER TABLE test MODIFY id SMALLINT UNSIGNED NOT NULL FIRST; (7)添加主键约束：ALTER TABLE table_name ADD [CONSTRAINT [symbol]] PRIMARY KEY [index_type] (index_column_name,...) 1ALTER TABLE test ADD CONSTRAINT PK_test_id PRIMARY KEY (id); (8)删除主键约束：ALTER TABLE table_name DROP PRIMARY KEY 1ALTER TABLE test DROP PRIMARY KEY; (9)添加唯一约束：ALTER TABLE table_name ADD [CONSTRAINT [symbol]] UNIQUE [INDEX | KEY] [index_name] [index_type] (index_column_name,...) 1ALTER TABLE test ADD UNIQUE (username); (10)删除唯一约束：ALTER TABLE table_name DROP {INDEX | KEY} index_name 1ALTER TABLE test DROP INDEX username; (11)添加默认约束：ALTER TABLE table_name ALTER [COLUMN] column_name SET DEFAULT literal 1ALTER TABLE test ALTER age SET DEFAULT 10; (12)删除默认约束：ALTER TABLE table_name ALTER [COLUMN] column_name DROP DEFAULT; 1ALTER TABLE test ALTER age DROP DEFAULT; (13)添加外键约束：ALTER TABLE table_name ADD [CONSTRAINT [symbol]] FOREIGN KEY [index_name] (index_column_name,...) reference_name 1ALTER TABLE user ADD FOREIGN KEY (pid) REFERENCES provinces (id); (14)删除外键约束：ALTER TABLE table_name DROP FOREIGN KEY fk_symbol 123#首先查看user表的外键约束的名称SHOW CREATE TABLE user;ALTER TABLE user DROP FOREIGN KEY user_ibfk_1; 五、数据操作1、插入记录:方法一：INSERT [INTO] table_name [(column_name,...)] {VALUES | VALUE} ({expr | DEFAULT},...), (...), ...方法二：INSERT [INTO] table_name SET column_name={expr | DEFAULT}, ... 说明：一次只能插入一行，此方法可以使用子查询(SubQuery) 方法三：INSERT [INTO] table_name [(column_name,...)] SELECT ... 说明：此方法可以将查询结果插入到指定数据表 1234567891011121314# 对于自动增加的主键id可以赋值NULLINSERT test VALUES(NULL,&apos;Tom&apos;,&apos;123&apos;,25,1);# 对于自动增加的主键id也可以赋值DEFAULTINSERT test VALUES(DEFAULT,&apos;Tom&apos;,&apos;123&apos;,25,1);# 字段可以插入表达式INSERT test VALUES(DEFAULT,&apos;Tom&apos;,&apos;123&apos;,3*7+4,1);# 字段有默认值的可以赋值DEAFULTINSERT test VALUES(DEFAULT,&apos;Tom&apos;,&apos;123&apos;,DEFAULT,1);# 同时插入多行记录INSERT test VALUES(DEFAULT,&apos;Tom&apos;,&apos;123&apos;,3*7+4,1),(NULL,&apos;Rose&apos;,md5(&apos;123&apos;),DEFAULT,0);# 方法二插入记录INSERT test SET username=&apos;Ben&apos;,password=&apos;456&apos;;# 方法三插入记录INSERT test(username) SELECT username FROM user WHERE age&gt;=20; 2、删除记录：DELETE FROM table_name [WHERE where_condition] 1DELETE FROM users WHERE id=6; 3、更新记录UPDATE [LOW_PRIORITY] [IGNORE] table_reference SET column_name1={expr1 | DEFAULT}, [,column_name2={expr2 | DEFAULT}], ... [WHERE where_condition] 123456# 更新所有age字段增加5UPDATE user SET age=age+5;# 同时更新多个字段UPDATE user SET age=age-id, sex=0;# 根据条件更新字段UPDATE user SET age=age+5 WHERE id%2=0; 4、查询记录：SELECT select_expr [select_expr1,...] [FROM table_references] [WHERE where_condition] [GROUP BY {column_name | position} [ASC | DESC],...] [HIVING where_condition] [ORDER BY {column_name | expr | position} [ASC | DESC],...] [LIMIT {[offset,] row_count | row_count OFFSET offset}] 12345678910111213141516171819202122# 查询所有字段SELECT * FROM test;# 查询部分字段，显示结果集的字段顺序可以和表中字段顺序不同SELECT username,id FROM user;# 查询某个表中某个字段SELECT user.id, user.username FROM USER;# 使用AS个查询字段取别名SELECT id AS uId,username AS uName FROM user;# WHERE条件SELECT id,username FROM user WHERE age&gt;10;# GROUP BY分组SELECT sex FROM user GROUP BY sex;SELECT sex FROM user GROUP BY 1;#按照位置分组# HIVING分组条件SELECT sex,age FROM user GROUP BY sex HIVING age&gt;20;#条件字段必须在查询字段列表里SELECT sex FROM user GROUP BY sex HIVING count(age)&gt;20;#聚合函数，条件字段可以不在查询字段列表里# ORDER BY排序SELECT * FROM user ORDER BY id DESC;SELECT * FROM user ORDER BY age,id DESC;#一个字段排序不能满足需求，可以再加字段排序# LIMIT显示查询数量SELECT * FROM user LIMIT 2;SELECT * FROM user LIMIT 3,2;#从第4条开始返回2条 六、子查询和连接1、子查询：子查询(SubQuery)是指出现在其他SQL语句内的SELECT子句。子查询必须在小括号()内。ps:SET NAMES gbk;#设置客户端显示格式 (1)使用比较运算符的子查询：=、&gt;、&lt;、&gt;=、&lt;=、&lt;&gt;、!&gt;、&lt;=&gt; 1SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price=(SELECT ROUND(AVG(goods_price),2) FROM tdb_goods); 使用ANY、SOME、ALL修饰比较运算符: ANY SOME ALL &gt;、&gt;= 最小值 最小值 最大值 &lt;、&lt;= 最大值 最大值 最小值 = 任意值 任意值 &lt;&gt;、!= 任意值 12SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price &gt; ALL (SELECT goods_price FROM tdb_goods WHERE goods_cate = &apos;超极本&apos;);SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price &lt; ANY (SELECT goods_price FROM tdb_goods WHERE goods_cate = &apos;超极本&apos;); (2)使用 [NOT] IN 的子查询： IN 与 ANY 等效 NOT IN 与 !=ALL、&lt;&gt;ALL等效 1SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price NOT IN (SELECT goods_price FROM tdb_goods WHERE goods_cate = &apos;超极本&apos;); (3)使用 [NOT] EXISTS 的子查询：如果子查询返回任何行，EXISTS将返回TRUE,否则将返回FALSE。 2、连接：table_reference {[INNER | CROSS] JOIN | {LEFT | RIGHT} [OUTER] JOIN} table_reference ON conditional_expr 内连接：INNER JOIN 和 CROSS JOIN 和 JOIN 是等价的。 外连接：LEFT JOIN 是左外连接; RIGHT JOIN 是右外连接。 (1)内连接 INNER JOIN：显示左表及右表符合连接条件的记录。(交集) 1SELECT goods_id,goods_name,cate_name FROM tdb_goods INNER JOIN tdb_goods_cates ON tdb_goods.cate_id = tdb_goods_cates.cate_id; (2)左外连接 LEFT JOIN:显示左表的全部记录及右表符合连接条件的记录。(右表以左表为准) 1SELECT goods_id,goods_name,cate_name FROM tdb_goods LEFT JOIN tdb_goods_cates ON tdb_goods.cate_id = tdb_goods_cates.cate_id; (3)右外连接 RIGHT JOIN:显示右表的全部记录及左表符合连接条件的记录。(左表以右表为准) 1SELECT goods_id,goods_name,cate_name FROM tdb_goods RIGHT JOIN tdb_goods_cates ON tdb_goods.cate_id = tdb_goods_cates.cate_id; 3、多表连接：连续使用INNER JOIN ... ON ...进行多表连接 123# 当不同表中字段名称相同时，需使用AS给表取别名# \\G以表格美化显示SELECT goods_id,goods_name,cate_name,brand_name,goods_price FROM tdb_goods AS g INNER JOIN tdb_goods_cates AS c ON g.cate_id = c.cate_id INNER JOIN tdb_goods_brands AS b ON g.brand_id = b.brand_id\\G; 4、自身连接：同一个数据表对其自身进行连接。 123456#无限分类的数据表设计CREATE TABLE tdb_goods_types(type_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,type_name VARCHAR(20) NOT NULL,parent_id SMALLINT UNSIGNED NOT NULL DEFAULT 0); #查找所有分类及其父类SELECT s.type_id,s.type_name,p.type_name FROM tdb_goods_types AS s LEFT JOIN tdb_goods_types AS p ON s.parent_id = p.type_id;#查找所有分类及其子类SELECT p.type_id,p.type_name,s.type_name FROM tdb_goods_types AS p LEFT JOIN tdb_goods_types AS s ON s.parent_id = p.type_id; 5、多表更新：UPDATE table_references SET column_name1={expr1 | DEFAULT} [,column_name2={expr2 | DEFAULT}],... [WHERE where_condition] 1UPDATE tdb_goods INNER JOIN tdb_goods_cates ON goods_cate = cate_name SET goods_cate = cate_id; 注意：多表更新需要一步到位：ps：创建数据表的同时将查询结果写入到数据表：CREATE TABLE [IF NOT EXISTS] table_name [(create_definition,...)] SELECT select_statement123456# 1.查询结果创建表CREATE TABLE tdb_goods_brands(brand_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,brand_name VARCHAR(40) NOT NULL) SELECT brand_name FROM tdb_goods GROUP BY brand_name;# 2.连表更新UPDATE tdb_goods AS g INNER JOIN tdb_goods_brands AS b ON g.brand_name = b.brand_name SET g.brand_name = b.brand_id;# 3.修改字段名称和字段类型ALTER TABLE tdb_goods CHANGE goods_cate cate_id SMALLINT UNSIGNED NOT NULL, CHANGE brand_name brand_id SMALLINT UNSIGNED NOT NULL; 6、多表删除：DELETE table_name[.*] [,table_name1[.*]]... FROM table_references [WHERE where_condition] 1DELETE t1 FROM tdb_goods AS t1 LEFT JOIN (SELECT goods_id,goods_name FROM tdb_goods GROUP BY goods_name HIVING COUNT(goods_name) &gt;= 2) AS t2 ON t1.goods_name = t2.goods_name WHERE t1.goods_id &gt; t2.goods_id; 七、mysql函数1、字符函数： 名称 描述 CONCAT() 字符连接 CONCAT_WS() 使用指定的分隔符进行字符连接 FORMAT() 数字格式化 LOWER() 转换成小写字母 UPPER() 转换成大写字母 LEFT() 获取左侧字符 RIGHT() 获取右侧字符 LENGTH() 获取字符串长度 RIGHT() 获取右侧字符 LTRIM() 删除前导空格 RTRIM() 删除后续空格 TRIM() 删除前导和后续 SUBSTRING() 字符串截取 [NOT]LIKE() 模式匹配 REPLACE() 字符串替换 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#CONCAT()连接用户名&apos;Tom&apos;和密码&apos;123&apos;，输出&apos;Tom123&apos;SELECT CONCAT(username,password) AS usinfo FROM user;#CONCAT_WS()指定分隔符&apos;_&apos;连接用户名&apos;Tom&apos;和密码&apos;123&apos;，输出&apos;Tom_123&apos;SELECT CONCAT_WS(&apos;_&apos;,username,password) AS usinfo FROM user;#FORMAT()格式化数字保留一位小数，输出&apos;1234.6&apos;SELECT FORMAT(1234.56,1);#LOWER()大写变小写，输出&apos;mysql&apos;SELECT LOWER(&apos;Mysql&apos;);#LEFT()取左侧2位字符，输出&apos;My&apos;SELECT LEFT(&apos;Mysql&apos;,2);#LENGTH()获取字符串长度包含空格，输出&apos;7&apos;SELECT LENGTH(&apos;Mysql &apos;);#LTRIM()删除前导空格，输出&apos;Mysql &apos;SELECT LTRIM(&apos; Mysql &apos;);#TRIM()删除前导和后续空格，输出&apos;Mysql&apos;SELECT TRIM(&apos; Mysql &apos;);#TRIM()可以使用LEADING删除前导字符，输出&apos;Mysql!!&apos;SELECT TRIM(LEADING &apos;!&apos; FROM &apos;!!Mysql!!&apos;);#TRIM()可以使用TRAILING删除后续字符，输出&apos;!!Mysql&apos;SELECT TRIM(TRAILING &apos;!&apos; FROM &apos;!!Mysql!!&apos;);#TRIM()可以使用BOTH删除前导和后续字符，输出&apos;Mysql&apos;SELECT TRIM(BOTH &apos;!&apos; FROM &apos;!!Mysql!!&apos;);#REPLACE()替换指定字符，输出&apos;Mysql&apos;SELECT REPLACE(&apos;!!My!!sql!!&apos;, &apos;!&apos;, &apos;&apos;);#SUBSTRING()截取字符串，注意索引第一位是1，不是0。输出&apos;My&apos;SELECT SUBSTRING(&apos;Mysql&apos;, 1, 2);#SUBSTRING()截取字符串可以从倒数开始，但截取长度不能为负数。输出&apos;l&apos;SELECT SUBSTRING(&apos;Mysql&apos;,-1);#LIKE匹配，%代表通配符，/代表任意一个字符。输出&apos;Tom&apos;SELECT * FROM user WHERE first_name LIKE &apos;%o%&apos;;#如果匹配的字符是%，则需要在%任意放置一个字符，用ESCAPE表述忽略字符后面的%。输出&apos;To%m&apos;SELECT * FROM user WHERE first_name LIKE &apos;%1%%&apos; ESCAPE &apos;1&apos;; 2、数值运算符与函数： 名称 描述 CEIL() 进一取整，向上取整 DIV 整数除法 FLOOR() 舍一取整，向下取整 MOD 取余数（取模） POWER() 幂运算 ROUND() 四舍五入 TRUNCATE() 数字截取 12345678SELECT CEIL(3.01); # 向上取整,输出&apos;4&apos;SELECT FLOOR(3.99); # 向下取整,输出&apos;3&apos;SELECT 3 DIV 4; # 整数除法,输出&apos;0&apos;SELECT 5 MOD 3; # 取余，输出&apos;2&apos;SELECT POWER(3,3); # 幂运算,输出&apos;27&apos;SELECT ROUND(3.652,2); # 四舍五入，输出&apos;3.65&apos;SELECT truncate(123.45,0); #数字截断，到小数点后0位，输出&apos;123&apos;SELECT truncate(123.45,-1); # 数字截取，把那一位整个去掉.输出&apos;120&apos; 3、比较运算符与函数： 名称 描述 [NOT] BETWEEN…AND.. 【不】在范围之内 [NOT] IN() 【不】在列出值范围内 IS [NOT] NULL 【不】为空 12345SELECT 15 BETWEEN 10 AND 20; # 返回1，TRUESELECT 15 NOT BETWEEN 10 AND 20; # 返回0，FALSESELECT 15 IN (10,15,20,25); # 返回1，TRUESELECT 5 IN (10,15,20,25); # 返回0，FALSESELECT * FROM user WHERE username IS NULL; # 返回用户名为空的用户 4、日期时间函数： 名称 描述 NOW() 当前日期和时间 CURDATE() 当前日期 CURTIME() 当前时间 DATE_ADD() 日期变化 DATEDIFF() 日期差值 DATE_FORMAT() 日期格式化 12345678SELECT NOW();SELECT CURDATE();SELECT CURTIME;SELECT DATE_ADD(&apos;2017-12-27&apos;, INTERVAL 365 DAY); # 日期增加365天SELECT DATE_ADD(&apos;2017-12-27&apos;, INTERVAL 1 YEAR); # 日期增加1年SELECT DATE_ADD(&apos;2017-12-27&apos;, INTERVAL -3 WEEK); # 日期减少3周SELECT DATEDIFF(&apos;2016-12-27&apos;,&apos;2017-12-27&apos;); # 查看两个日期之间相差多少天SELECT DATE_FORMAT(&apos;2017-2-3&apos;,&apos;%m/%d/%Y&apos;); # 格式化为&apos;02/03/2017&apos; 5、信息函数： 名称 描述 CONNECTION_ID() 连接ID DATABASE() 当前数据库 LAST_INSERT_ID() 最后插入记录的id号 USER() 当前用户 VERSION() 版本信息 123456SELECT CONNECTION_ID(); # 查看当前连接IDSELECT DATABASES(); # 查看当前数据库DESC test_table; # 查看数据表，看看是否有id字段SELECT LAST_INSERT_ID(); # 可以查看最后写入的id号，同时写入多条记录时只显示第一条记录的id号SELECT USER(); # 当前登录的用户SELECT VERSION(); # 当前数据库版本 6、聚合函数： 名称 描述 AVG() 平均值 COUNT() 计数 MAX() 最大值 MIN() 最小值 SUM() 求和 123SELECT AVG(age) FROM user;SELECT COUNT(id) AS counts FROM user;SELECT MAX(age) FROM user; 7、加密函数： 名称 描述 MD5() 信息摘要算法 PASSWORD() 密码算法 12SELECT MD5(&apos;admin&apos;); # 信息摘要算法，如果为web页面做准备，推荐MD5SET PASSWORD = PASSWORD(&apos;654321&apos;); # 主要用来修改用户密码 8、自定义函数：CREATE FUNCTION function_name RETURNS {STRING|INTEGER|REAL|DECIMAL} rourine_body 123456789101112131415# 不带参数的函数CREATE FUNCTION f1() RETURNS VARCHAR(30) RETURN DATE_FORMAT(NOW(),&apos;%Y年%m月%d日 %h点：%i分：%s秒&apos;);SELECT f1();# 带参数的函数CREATE FUNCTION f2(num1 SMALLINT UNSIGNED, num2 SMALLINT UNSIGNED) RETURNS FLOAT(10,2) UNSIGNED RETURN (num1 + num2)/2;SELECT f2(10,20);# 有复合结构函数体的函数DELIMITER // # 重定义结束符，所有命令都以//结束。因为函数体中有的语句末尾带有;会导致函数结束。#符合函数结构体需要使用begin...end语句。CREATE FUNCTION adduser(username VARCHAR(20)) RETURNS INT UNSIGNED BEGIN INSERT user(username) values(username); RETURN LAST_INSERT_ID(); END //#删除函数DROP function adduser; 八、存储过程mysql执行过程：SQL命令——&gt;Mysql引擎——&gt;(分析)语法正确——&gt;可识别命令——&gt;(执行)执行结果——&gt;(返回)客户端 1、存储过程：存储过程是SQL语句和控制语句的预编译集合，以一个名称存储并作为一个单元处理。存储过程是预编译的，只在第一次执行时执行mysql执行过程，后续的执行会大大提高效率。 增强SQL语句的功能和灵活性 实现较快的执行速度 减少网络流量 2、创建存储过程：CREATE [DEFINER = {user | CURRENT_USER}] PROCEDURE sp_name ([proc_parameter[,…]]) [characteristic…] routine_body (1)参数： proc_parameter: [IN| OUT |INOUT] parameter_name type IN，表示该参数的值必须在调用存储过程时指定 OUT，表示该参数的值可以被存储过程改变，并且可以返回 INOUT，表示该参数的值调用时指定，并可以被改变和返回 (2)特性： COMMENT:注释 CONTAINS SQL:包含SQL语句，但不包含读或写数据的语句 NO SQL：不包含SQL语句 READS SQL DATA：包含读数据的语句 MODIFIES SQL DATA：包含写数据的语句 SQL SECURITY{DEFINER|INVOKER}指明谁有权限来执行 (3)过程体: 由合法的SQL语句构成（记录的增删改查和多表连接，不能创建数据库或数据表） 复合结构：BEGIN…END 可包含声明，循环，控制结构 (4)调用存储过程： CALL sp_name([parameter[,…]]) CALL sp_name[()] 1234567891011121314151617181920212223242526272829303132# 创建不带参数的存储过程CREATE PROCEDURE sp1() SELECT VERSION();CALL sp1;CALL SP1();# 创建带有IN类型参数的存储过程DELIMITER // # 修改当前定界符为//CREATE PROCEDURE removeUserById(IN id INT UNSIGNED) BEGIN DELETE FROM users WHERE id = id; END //DELIMITER ; # 修改当前定界符回;CALL removeUserById(3);SELECT * FROM users; # 返回空集是因为where id = id,所以参数不能和数据表的字段相同。DROP PROCEDURE removeUserById; # 存储过程不能修改过程体，只能先删除# 重新创建一遍DELIMITER //CREATE PROCEDURE removeUserById(IN p_id INT UNSIGNED) BEGIN DELETE FROM users WHERE id = p_id; END //DELIMITER ;CALL removeUserById(22);SELECT * FROM users WHERE id=22;# 创建带有IN类型和OUT类型参数的存储过程DELIMITER //CREATE PROCEDURE removeAndReturnNums(IN p_id INT UNSIGNED, OUT countNum INT UNSIGNED) BEGIN DELETE FROM users WHERE id =p_id; SELETE COUNT(id) FROM users INTO countNum; END //DELIMITER ;CALL removeAndReturnNums(27,@nums); # @的是用户变量,用于接受返回信息，只对当前mysql客户端生效SELECT @nums;# 创建带有多个OUT类型参数的存储过程DELIMITER //CREATE PROCEDURE removeUserByAgeAndReturnInfos(IN p_age SMALLINT UNSIGNED,OUT deleteNums INT UNSIGNED, OUT userCount SMALLINT UNSIGNED) BEGIN DELETE FROM users WHERE age = p_age; SELECT ROW_COUNT() INTO deleteNums; SELECT COUNT(id) FROM users INTO userCount; END //DELIMITER ;CALL removeUserByAgeAndReturnInfos(23, @a, @b);SELECT @a,@b; 九、存储引擎1、存储引擎：Mysql可以将数据以不同的技术存储在文件（内存）中，这种技术称为存储引擎。 MyISAM： INNODB： Memory： CSV： Archive： 2、相关概念： (1)并发控制：多个连接对记录进行修改时保证数据的一致性和完整性。 (2)锁： 共享锁(读锁)：在同一时间段内，多个用户可以读取同一个资源，读取过程中数据不会发生变化。 排他锁(写锁)：在任何时候只能有一个用户写入资源，当进行写锁时会阻塞其他读锁或写锁操作。 (3)锁颗粒： 表锁，是一种开销最小的锁策略。 行锁，是一种开销最大的锁策略。 (4)事务：事务用于保证事务的完整性。 (5)外键：保证数据一致性的策略。 (6)索引：是对数据表中的一列或多列的值进行排序的一种结构 3、各种存储引擎的特点： 特点 MyISAM INNODB Memory Archive 存储限制 256TB 64TB 有 无 事务安全 - 支持 - - 支持索引 支持 支持 支持 颗粒度 表锁 行锁 表锁 行锁 数据压缩 支持 - - 支持 支持外键 - 支持 - - 4、修改存储引擎的方法：方法一：通过修改Mysql配置文件default-storage-engine = engine方法二：通过创建数据表命令CREATE TABLE table_name(... ...) ENGINE = engine_name方法三：通过修改数据表命令ALTER TABLE table_name ENGINE [=] engine_name 1234567#通过创建数据表命令修改存储引擎CREATE TABLE test(name VARCHAR(20)) ENGINE = MyISAM;SHOW CREATE TABLE test;#通过修改数据表命令修改存储引擎ALTER TABLE test ENGINE = InnoDB;SHOW CREATE TABLE test; 十、事务Mysql事务主要用于处理操作量大，复杂度高的数据。 在Mysql中只有使用了Innodb数据库引擎的数据库或表才支持事务。 事务处理可以用来维护数据库的完整性，保证成批的SQL语句要么全部执行，要么全部不执行。 事务用来管理insert,update,delete语句 1、事务是必须满足4个条件： 原子性(Atomicity，或称不可分割性)：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性(Consistency)：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 隔离性(Isolation，又称独立性)：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 持久性(Durability)：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 2、事务控制语句： BEGIN或START TRANSACTION：显式地开启一个事务。 COMMIT或COMMIT WORK：COMMIT会提交事务，并使已对数据库进行的所有修改称为永久性的。 ROLLBACK或ROLLBACK WORK：回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。 SAVEPOINT identifier：SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT。 RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常。 ROLLBACK TO identifier；把事务回滚到标记点。 SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。 3、事务处理方法：方法一：用BEGIN, ROLLBACK, COMMIT来实现 BEGIN：开始一个事务 ROLLBACK：事务回滚 COMMIT：事务确认 方法二：直接用 SET 来改变 MySQL 的自动提交模式: SET AUTOCOMMIT=0：禁止自动提交 SET AUTOCOMMIT=1：开启自动提交 1234567891011CREATE TABLE test(id INT(5)) ENGINE=innodb;BEGIN; # 开始事务INSERT INTO test VALUE(5);COMMIT; # 提交事务SELECT * FROM test;BEGIN; # 开始事务INSERT INTO test VALUE(6);ROLLBACK; # 回滚SELECT * FROM test; 十一、备份还原1、mysqldump参数 (1)参数详解 -d 结构(–no-data:不导出任何数据，只导出数据库表结构) -t 数据(–no-create-info:只导出数据，而不添加CREATE TABLE 语句) -n (–no-create-db:只导出数据，而不添加CREATE DATABASE 语句） -B (–databases:导出数据库列表，单个库时可省略） -R (–routines:导出存储过程以及自定义函数) -E (–events:导出事件) --triggers (默认导出触发器，使用–skip-triggers屏蔽导出) --tables 表列表（单个表时可省略） (2)参数组合 同时导出结构以及数据时可同时省略-d和-t 同时不导出结构和数据可使用-ntd 只导出存储过程和函数可使用-R -ntd 导出所有(结构&amp;数据&amp;存储过程&amp;函数&amp;事件&amp;触发器)使用-R -E 只导出结构&amp;函数&amp;事件&amp;触发器使用-R -E -d 2、导出数据库(备份) (1)导出一个数据库的结构：mysqldump -d dbname -uroot -p &gt; dbname.sql(2)导出多个数据库的结构：mysqldump -d -B dbname1 dbname2 -uroot -p &gt; dbname.sql(3)导出一个数据库中数据（不包含结构）：mysqldump -t dbname -uroot -p &gt; dbname.sql(4)导出多个数据库中数据（不包含结构）：mysqldump -t -B dbname1 dbname2 -uroot -p &gt; dbname.sql(5)导出一个数据库的结构以及数据：mysqldump dbname -uroot -p &gt; dbname.sql(6)导出多个数据库的结构以及数据：mysqldump -B dbname1 dbname2 -uroot -p &gt; dbname.sql(7)导出一个数据库中一个表的结构：mysqldump -d dbname1 tablename -uroot -p &gt; tablename.sql(8)导出一个数据库中多个表的结构：mysqldump -d -B dbname1 --tables tablename1 tablename2 -uroot -p &gt; tablename.sql(9)导出一个数据库中一个表的数据（不包含结构）：mysqldump -t dbname1 tablename -uroot -p &gt; tablename.sql(10)导出一个数据库中多个表的数据（不包含结构）：mysqldump -t -B dbname1 --tables tablename1 tablename2 -uroot -p &gt; tablename.sql(11)导出一个数据库中一个表的结构以及数据：mysqldump dbname1 tablename -uroot -p &gt; tablename.sql(12)导出一个数据库中多个表的结构以及数据：mysqldump -B dbname1 --tables tablename1 tablename2 -uroot -p &gt; tablename.sql 3、导出存储过程和函数操作 (1)只导出存储过程和函数(不导出结构和数据，要同时导出结构的话，需要同时使用-d)：mysqldump -R -ndt dbname -u root -p &gt; dbname.sql(2)只导出事件：mysqldump -E -ndt dbname -u root -p &gt; dbname.sql(3)不导出触发器（触发器是默认导出的–triggers，使用–skip-triggers屏蔽导出触发器）：mysqldump --skip-triggers dbname1 -u root -p &gt; dbname.sql 4、导入数据库(还原) 方法一：mysql -uroot -p123456 -h127.0.0.1 -P3306 dbname &lt; dbname.sql方法二：12345678# 1.登录数据库mysql -uroot -p -hlocalhost -P3306# 2.选择数据库use dbname;# 3.设置数据库编码(根据需要)set names utf8;# 4、导入数据（注意sql文件的路径）source /home/tester/dbname.sql; 持续更新…","categories":[{"name":"mysql","slug":"mysql","permalink":"http://pythonfood.github.io/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://pythonfood.github.io/tags/mysql/"}]},{"title":"monkey","slug":"monkey","date":"2017-12-28T07:00:00.000Z","updated":"2018-05-11T06:39:52.054Z","comments":true,"path":"2017/12/28/monkey/","link":"","permalink":"http://pythonfood.github.io/2017/12/28/monkey/","excerpt":"Monkey是Android中的一个命令行工具，可以运行在模拟器里或实际设备中。它向系统发送伪随机的用户事件流(如按键输入、触摸屏输入、手势输入等)，实现对正在开发的应用程序进行压力测试。Monkey测试是一种为了测试软件的稳定性、健壮性的快速有效的方法。","text":"Monkey是Android中的一个命令行工具，可以运行在模拟器里或实际设备中。它向系统发送伪随机的用户事件流(如按键输入、触摸屏输入、手势输入等)，实现对正在开发的应用程序进行压力测试。Monkey测试是一种为了测试软件的稳定性、健壮性的快速有效的方法。 一、常用选项 --help：打印帮助信息-v：指定打印信息的详细级别，一个-v增加一个级别，默认级别为0。 二、事件选项 -s：指定产生随机事件种子值，相同的种子值产生相同的事件序列。--throttle：每个事件结束后的间隔时间。--pct-touch：指定(触摸事件)的百分比--pct-motion：（滑动事件)--pct-trackball：(轨迹球事件)--pct-nav：（导航事件 up/down/left/right）--pct-majornav：(主要导航事件 back key 、 menu key)--pct-syskeys：(系统按键事件 Home 、Back 、startCall 、 endCall 、 volumeControl)--pct-appswitch ：（activity之间的切换）--pct-anyevent ：（任意事件） 三、约束选项 -p：指定有效的package（如不指定，则对系统中所有package有效），一个-p 对应一个有效package。-c：activity必须至少包含一个指定的category，才能被启动，否则启动不了。 四、调试选项 --dbg-no-events：初始化启动的activity，但是不产生任何事件。--hprof：指定该项后在事件序列发送前后会立即生成分析报告 —— 一般建议指定该项。--ignore-crashes：忽略崩溃--ignore-timeouts：忽略超时--ignore-security-exceptions：忽略安全异常--kill-process-after-error：发生错误后直接杀掉进程--monitor-native-crashes：跟踪本地方法的崩溃问题--wait-dbg：知道连接了调试器才执行monkey测试。 五、小示例adb shell monkey -p（指定包名） com.hiveview.cloudscreen.py --throttle（操作延时ms） 1000 -s(指定seed值) 1500859116902 -v -v（信息反馈级别） 1000（执行次数） adb shell monkey -p com.hiveview.cloudscreen.py --throttle 100 --pct-majornav 50 --pct-nav 50 -v -v 1000 &gt;d:\\monkey.txt adb shell monkey -p com.hiveview.cloudscreen.py --throttle 100 --ignore-crashes --ignore-timeouts --monitor-native-crashes --pct-majornav 50 --pct-nav 50 -v -v 1000 &gt;d:\\monkey_log.txt adb shell monkey -p com.hiveview.cloudscreen.py --throttle 100 --pct-nav 50 --pct-majornav 50 -v -v 1000 &gt;d:\\monkey_log.txt 持续更新…","categories":[{"name":"app测试","slug":"app测试","permalink":"http://pythonfood.github.io/categories/app测试/"}],"tags":[{"name":"monkey","slug":"monkey","permalink":"http://pythonfood.github.io/tags/monkey/"}]},{"title":"接口测试","slug":"接口测试","date":"2017-12-28T06:00:00.000Z","updated":"2018-05-11T06:37:41.161Z","comments":true,"path":"2017/12/28/接口测试/","link":"","permalink":"http://pythonfood.github.io/2017/12/28/接口测试/","excerpt":"接口测试是测试系统组件间接口的一种测试。接口测试主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。测试的重点是要检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等。","text":"接口测试是测试系统组件间接口的一种测试。接口测试主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。测试的重点是要检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等。 一、API种类 面向对象语言的API 库与框架的API API与协议 API与设备接口 Web API(HTTP API) 二、HTTP API GET：向特定的资源发出请求。 POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。 PUT：从客户端向服务器传送的数据取代指定的文档的内容。 DELETE：请求服务器删除Request-URI所标识的资源。 OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。 HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回，用于获取报头。 TRACE：回显服务器收到的请求，主要用于测试或诊断。 CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 三、接口测试必要性 可以发现很多在前端测试发现不了的bug。 检查系统的稳定性。 检查系统的异常处理能力。 检查系统的安全性。 前端经常变，接口测好了后端不用变。 四、接口测试流程(1)需求讨论(2)需求评审(3)场景设计(4)用例设计(5)数据准备(6)执行 五、接口文档内容 接口说明 调用url 请求方法（get/post） 请求参数、参数类型、请求参数说明 返回参数说明 ps:部分接口文档有请求头header，服务器会先接收header信息来判断该请求是否有权限请求。 六、接口用例设计先附一个很全面的接口测试用例设计的帖子 1、功能测试(1)功能是否正常(2)是否按照接口文档实现(3)正常场景(4)异常场景 2、业务测试(1)业务规则 例如，bbs的需求是这样的： 登录失败5次，就需要等待15分钟之后再登录 新注册的用户需要过了实习期才能发帖 删除帖子扣除积分 (2)业务流程(3)业务依赖 依赖第三方接口超时 3、参数测试(1)参数组合 组合可选参数 参数的顺序 (2)默认值(3)参数范围 数值大小 数值范围 字串长短 (4)必传非必传 覆盖所有必选参数 (5)参数类型 正确的参数类型 错误的参数类型 (6)非空校验 参数有 参数空 参数null (7)参数个数 多参数 少参数 (8)特殊字符 4、兼容测试(1)兼容老版本 5、异常场景(1)重复提交(2)并发测试(3)事务测试(4)分布式测试(5)环境异常(6)大数量测试 同时处理大批量数据的测试 DB数据量很大时，测试DB操作 6、安全测试(1)参数是否加密 前后端数据传输是否加密 日志信息是否加密 (2)绕过验证 例如：购买一个商品，价格100元，但是在提交订单时候，把商品的价格改成1元，后端有没有做验证？再把价格改为-1元，余额会不会反向增加？ (3)绕过身份授权 例如：修改商品信息接口，只有卖家才能修改，那么传一个普通用户，能不能修改？再传一个其他的卖家，能不能修改？ (4)密码安全规则 密码的复杂程度校验 (5)权限验证(6)header(7)cookie(8)唯一识别码(9)sql注入 7、性能测试(1)响应时间(2)吞吐量(3)并发数(4)服务器资源使用率 cpu 内存 IO network 七、做好接口测试的前提1、系统化的接口文档(1)传统的接口文档，一般采用word或wiki等系统来记录，从单次使用上似乎比较简单，因为大家会更习惯这样的操作，但这种形式存在比较大的问题： 接口文档非标准化，无法直接与接口测试工具接口使用。 接口维护困难，接口有变化时比较难标识清楚，沟通成本很高。 (2)系统化接口文档，例如rap，具备接口维护标准化、版本化管理、MOCK测试等功能；对标准化的接口内容做二次开发，可以直接导出Soapui等工具使用的格式，直接导入工具中使用，有以下好处： 接口测试时不再需要手工输入相关字段，节省时间成本。 版本化管理，能够清晰的知道哪些接口有变化。 2、标准化的接口规范(1)按接口提供方为单位进行首次划分，按接口使用方进行二次划分，再按业务模块进行细分。分类原则根据内容多少进行优化，不需要固定，如本身接口较少就没有必要分得过细，较多时就需要多划分模块。例如：系统A，提供有 1、2、3、4、5、6、7、8、9 这9个接口，接口分别给B系统、C系统使用，其中1、2为公用接口，3、4、5为B专用，6、7、8、9为C系统专用，划分如下： 项目A 公共接口 接口1 接口2 供B接口 接口3 接口4 接口5 供C接口 接口6 接口7 接口8 接口9 (2)按接口链接URL做为唯一，不同的接口参数做为接口变量，接口有参数变更时在原来接口上进行维护，而不是新增加接口。(3)为接口增加版本号，方便清楚哪些接口本次有变更，易于维护用例。 持续更新…","categories":[{"name":"接口测试","slug":"接口测试","permalink":"http://pythonfood.github.io/categories/接口测试/"}],"tags":[{"name":"接口测试","slug":"接口测试","permalink":"http://pythonfood.github.io/tags/接口测试/"}]},{"title":"web测试","slug":"web测试","date":"2017-12-28T05:00:00.000Z","updated":"2018-05-11T06:37:14.740Z","comments":true,"path":"2017/12/28/web测试/","link":"","permalink":"http://pythonfood.github.io/2017/12/28/web测试/","excerpt":"web端测试笔记。","text":"web端测试笔记。 一、好的测试用例的标准 覆盖到所有的功能需求点。 覆盖到所有的业务逻辑（包括正常逻辑和异常逻辑），即正常流和异常流。 覆盖到所有的典型用户场景。 测试目标明确，并且测试步骤能够最快的达到测试目的。 没有冗余的用例。 二．如何达到好的用例标准 了解软件的原始需求，明确测试目的。 熟悉软件的功能需求和实现原理，梳理测试点，基于需求编写测试用例。 梳理业务逻辑，基于逻辑编写测试用例。 基于用户场景编写测试用例。 三、测试用例框架 UI测试 功能测试 业务测试 场景测试 稳定性测试 容错性测试 兼容性测试 易用性测试 本地化测试 安全测试 性能测试 四、测试用例设计1、UI测试(1)静态测试 对于用户界面的布局、风格、字体、图片等与显示相关的部分测试应该采用静态测试，比如点检表测试。 (2)内容测试 用来检验Web应用系统提供信息的正确性、准确性和相关性。如文字标题是否与文字内容符合，是否存在不需要的文字，是否有相应的操作提示信息(成功、失败、不符合校验等)。 (3)图形测试 要确保图形有明确的用途，图片或动画不要胡乱地堆在一起，以免浪费传输时间。图片尺寸要尽量地小，并且要能清楚地说明某件事情。 验证所有页面字体的风格是否一致。 背景颜色应该与字体颜色和前景颜色相搭配。 图片的大小和质量也是一个很重要的因素，一般采用JPG 或GIF 压缩。 (4)整体界面测试 测试整个网站系统的页面结构设计是否符合用户需求规范。 是否凭直觉就知道要找的信息在什么地方。 整个We 应用系统的设计风格是否一致。 2、功能测试(1)基本功能 是否正确实现了功能需求定义。 (2)界面测试 新增： 新增的记录必须排在首页首行。 提交失败后必须保留用户已输入的内容，以便再次提交。 提交时或提交前需对主要标识字段进行重复值、空值（空格）判断。 需要验证字段的类型、最大长度限制验证。 可输入/选择框以正常色显示；不可输入/选择框以灰色显示。 删除： 必须有确认删除的提示信息。 删除成功后刷新不显示被删除的记录。 删除成功后返回到原记录所在页面；而当原记录所在页不存在时，则返回上一页。 当被删除的记录与其它记录存在关联时，视实际需求给予不允许删除、更明细提示等信息。 修改： 如界面存在复选按钮，勾选多条记录进行修改时，需给予只能对一条记录进行修改，默认为第一条的提示信息。 修改时加载的内容都为该记录的实际内容，而不再为默认值。 修改完成后必须回到原记录所在位置，且刷新显示修改后的值。 提交失败后必须保留用户已修改的内容，以便再次提交。 在查询条件下修改返回后如不满足查询条件则不显示。 需对主要标识字段进行重复值、空值（空格）判断。 需要验证字段的类型、最大长度限制验证 可输入/选择框以正常色显示；不可输入/选择框以灰色显示； 检查修改时的验证与新增时的验证是否一致。例如很多时候开发人员会想着在新增时做验证，但是做修改功能时容易忽略验证 查询： 每次查询后定位到首页。 每次查询后保留当前查询条件。 当查询条件较多时，请配以重置按钮一同使用。 当未查询到任何记录时，需给予未查找相关记录的提示信息。 除用户明确要求不需要外，需提供模糊查询及组合查询功能。 查看： 一般是选择列表中某一记录点击查看按钮显示记录的详细信息或是双击列表中某一项显示该记录的详细信息 注意设置查看窗口的高度和宽度的合理值。超过最佳设置值时，显示滚动条。 取消： 在数据量较多的页面中，当进行了修改后，取消请给予提示。 取消返回到原记录所在位置。 保存： 当保存所费时间较长时，需给予进度界面提示。 必须控制不可以重复保存。 保存操作是否成功应该给出结果信息，成功或是失败。 重置： 必须保证重置后与初始进入此页面时一致性。 返回： 当从一个页面点击按钮或链接进入子页面时，子页面必须提供返回按钮。 若没有特殊要求，返回应该是返回当前页面的上一页。 翻页： 带条件进行翻页时，翻页同时可执行查询功能。 如翻页后进入子页面，子页面需从首页开始显示。 如有单页复选功能，翻页后不保留选中状态。 全选： 勾选全选则选中当页所有记录。 去掉当页某个记录的勾选，则全选也去掉勾选。 翻页后，自动去掉已勾选的记录及全选的勾选。 单个勾选当前页面所有记录时，全选按钮应该是选中状态。 (3)导航测试 导航测试是导航描述了用户在一个页面内操作的方式，在不同的用户接口控制之间，例如按钮、对话框、列表和窗口等。 或在不同的连接页面之间。常采用手工对网页进行浏览、根据一般用户的浏览习惯来进行评判。导航测试的内容： 导航是否直观。 Web 系统主要部分是否可以通过主页访问。 Web系统是否需要站点地图、搜索引擎或其他的导航器帮助。 是否缺少返回上一目录的导航功能(虽然可以通过直接点击来实现，但是加入这个功能会更方便，因为大多数用户查找问题或文档时都是先查找同一个目录)。 导航条、菜单、连接的风格是否一致。 各种提示是否准确，确保用户凭直觉就知道是否还有内容，内容在什么地方。一般最好让最终用户参与导航测试，效果将更加明显。 (4)链接测试 首先，测试所有链接是否按指示的那样确实链接到了该链接的页面。 其次，测试所链接的页面是否存在。 最后，保证Web应用系统上没有孤立的页面，所谓孤立页面是指没有链接指向该页面。 (5)表单测试 当用户使用表单进行用户注册、登陆、信息提交等操作时，我们必须测试提交操作的完整性，以校验提交给服务器的信息的正确性。例如：用户填写的出生日期与职业是否恰当，填写的所属省份与所在城市是否匹配等。如果使用了默认值，还要检验默认值的正确性。如果表单只能接受指定的某些值，则也要进行测试。例如：只能接受某些字符，测试时可以跳过这些字符，看系统是否会报错。 (6)页面缓存 Cookie：Cookies是否能正常工作，Cookies是否按预定的时间进行保存，刷新对Cookies 有什么影响等，点击商务网站可添加商品信息后删除Cookie，刷新后查看购物车中的商品是否成功清除。 Session：测试过程中需关注Session的实效时间。 Cache：在web系统前端性能测试时，需关注Cache对测试结果的影响。 (7)脚本功能 为了实现一些特殊的效果或功能，系统往往会使用JavaScript、VBSScript脚本编程技术。 (8)上传下载 在测试时需要考虑文件上传格式、上传内容、上传能否正确打开、上传过程中如果出现异常是否有提示信息。对于文件下载则需要考虑的文件能否正确打开使用、下载过程能否中断，中断是否能续传，下载保存的文件是否正确等。 (9)数据库测试 数据校验：根据业务规则，需要对用户输入进行校验，则要保证这些校验功能正常工作。一般测试数据的一致性错误和输出错误。 数据一致性错误：主要是由于用户提交的表单信息不正确而造成的; 输出错误：主要是由于网络速度或程序设计问题等引起的 (10)翻页测试 对于[首页、上一页、下一页、尾页],翻页链接或按钮的测试： 有无数据时控件的显示情况。 在首页时，首页和上一页是否能点击。 在尾页时，下一页和尾页是否能点击。 在非首页和非尾页时，四个按钮功能是否正确。 翻页后，列表中的记录是否仍然按照指定的排序进行了排序。 第一页时，点跳转按钮go，页面会刷新，这样感觉不好。 对记录进行增、删、改、查时，页面始终都会跳转到第一页，这样易用性不好。 对于[总页数，当前页数]，主要要检查的测试点： 总页数是否等于总的记录数/指定每页条数。 当前页数是否正确。 对于[跳转页]，主要要检查的测试点： 是否能正常跳转到指定页数。 输入的跳转页数非法时的处理。 对于[指定每页显示条数[，主要要检查的测试点： 是否有默认的指定每页显示条数。 指定每页的条数后，列表显示的记录数，页数是否正常。 输入的每页条数非法时的处理。 (11)输入框测试 字符型输入框： 字符型输入框：英文全角、英文半角、数字、空或者空格、特殊字符“~！@#￥%……&amp;*？[]{}”特别要注意单引号和&amp;符号。禁止直接输入特殊字符时，使用“粘贴、拷贝”功能尝试输入。 长度检查：最小长度、最大长度、最小长度-1、最大长度+1、输入超工字符比如把整个文章拷贝过去。 空格检查：输入的字符间有空格、字符前有空格、字符后有空格、字符前后有空格 多行文本框输入：允许回车换行、保存后再显示能够保存输入的格式、仅输入回车换行，检查能否正确保存（若能，检查保存结果，若不能，查看是否有正常提示）、 安全性检查：输入特殊字符串（null,NULL,,javascript,,,,,）、输入脚本函数(alert(“abc”))、doucment.write(“abc”)、hello） 数值型输入框： 边界值：最大值、最小值、最大值+1、最小值-1 位数：最小位数、最大位数、最小位数-1最大位数+1、输入超长值、输入整数 异常值、特殊字符：输入空白（NULL）、空格或”~!@#$%^&amp;*()_+{}|[]\\:”&lt;&gt;?;’,./?;:’-=等可能导致系统错误的字符、禁止直接输入特殊字符时，尝试使用粘贴拷贝查看是否能正常提交、word中的特殊功能，通过剪贴板拷贝到输入框，分页符，分节符类似公式的上下标等、数值的特殊符号如∑，㏒，㏑，∏，+，-等、输入负整数、负小数、分数、输入字母或汉字、小数（小数前0点舍去的情况，多个小数点的情况）、首位为0的数字如01、02、科学计数法是否支持1.0E2、全角数字与半角数字、数字与字母混合、16进制，8进制数值、货币型输入（允许小数点后面几位）、 安全性检查：不能直接输入就copy。 日期型输入框： 合法性检查：(输入0日、1日、32日)、月输入[1、3、5、7、8、10、12]、日输入[31]、月输入[4、6、9、11]、日输入[30][31]、输入非闰年，月输入[2]，日期输入[28、29]、输入闰年，月输入[2]、日期输入[29、30]、月输入[0、1、12、13]考虑开始日期与结束日历的比较，特别是在查询的时候。 异常值、特殊字符：输入空白或NULL、输入~！@#￥%……&amp;*（）{}[]等可能导致系统错误的字符。 安全性检查：不能直接输入，就copy，是否数据检验出错？ (12)窗口测试 窗口是否基于相关的输入和菜单命令适当地打开。 窗口能否改变大小、移动和滚动。 窗口中的数据内容能否用鼠标、功能键、方向键和键盘访问。 当被覆盖并重新调用后，窗口能否正确地再生。 需要时能否使用所有窗口相关的功能。 所有窗口相关的功能是可操作的吗。 是否有相关的下拉式菜单、工具条、滚动条、对话框、按钮、图标和其他控制可为窗口使用，并适当地显示。 显示多个窗口时，窗口的名称是否被适当地表示。 活动窗口是否被适当地加亮。 如果使用多任务，是否所有的窗口被实时更新。 多次或不正确按鼠标是否会导致无法预料的副作用。 窗口的声音和颜色提示和窗口的操作顺序是否符合需求。 窗口是否正确地被关闭。 (13)搜索功能 如果支持模糊查询，搜索名称中任意一个字符是否能搜索到。 关键字：有大小写混合的情况。 关键字：含有一个或多个空格的情况，包含前空格、中空格、后空格。 关键字：是否支持通配符。 关键字：有效关键字，但是没有匹配搜索结果。 输入html标签，如：&amp;lt,html&amp;gt。 比较长的名称是否能查到。 输入系统中不存在的与之匹配的条件。 用户进行查询操作时，一般不进行查询条件清空。 不同查询条件之间来回选择，是否出现页面错误。 测试多个查询条件时，要注意查询条件的组合测试。 3、业务测试(1)业务模块 首先要保证单个模块功能的正确性 (2)业务流程 对各个业务模块间传递的数据进行测试，这往往是容易出现问题的地方，测试时一定要设计不同的数据进行测试。如某一功能模块具有最基本的增删改查功能，则需要进行以下测试： 单项功能测试（增加、修改、查询、删除）。 增加——&gt;增加——&gt;增加 （连续增加测试）。 增加——&gt;删除。 增加——&gt;删除——&gt;增加 （新增加的内容与删除内容一致）。 增加——&gt;修改——&gt;删除。 修改——&gt;修改——&gt;修改 （连续修改测试）。 修改——&gt;增加（新增加的内容与修改前内容一致）。 修改——&gt;删除。 修改——&gt;删除——&gt;增加 （新增加的内容与删除内容一致）。 删除——&gt;删除——&gt;删除 （连续删除测试）。 (3)用户权限（使用权限）： 赋予一个人员相应的权限后，在界面上看此人员是否具有此权限，并以此人员身份登陆，验证权限设置是否正确（能否超出所给予的权限）。 删除或修改已经登陆系统并正在进行操作的人员的权限，程序能否正确处理。 重新注册系统变更登陆身份后再登录，看程序是否能正确执行，具有权限是否正确。 在有工作组或角色管理的情况下，删除包含用户的工作组或角色，程序能否正确处理。 不同权限用户登录同一个系统，权限范围是否正确。 覆盖系统所有权限设定。 能否添加信息为空的用户(其中包括空用户名及空口令、空用户名非空口令、非空用户名及空口令)。 能否添加长用户名及长口令，如果允许，新用户能否正确登录。 系统是否允许删除系统管理员这一特殊用户或修改系统管理员口令，删除或修改后系统的实际情况。 登录用户能否修改自己的权限。 添加用户（有标识或编号）:标识相同，用户名不同；标识相同，用户名相同；标识不同，用户名相同；标识不同，用户名不同。 登录用户能否修改本人（或其他人）的信息，删除本人（或其他人）。 修改用户的信息（包括权限，口令，基本信息等），对其他模块的影响。 修改用户信息：修改后的用户信息和已经存在的用户信息相同；修改后的用户信息和已经存在的用户信息不同。 不给用户授权，是否允许登录。 改某些设置时，是否会影响具有上级权限及相同权限人员的设置。 系统管理员修改了某些数据，以其他人员身份登录时数据是否改变。 用户能否同时属于多个组，各个组的权限能否交叉；删除后重新添加的用户是否具有以前的权限；更改用户各项属性（包括权限）看对权限是否有影响。 4、场景测试 以真实的用户场景进行测试 5、稳定性测试 系统不间断运行（7*24），验证是否内存泄露、系统其他资源是否存在泄露。 如果很紧急上线，可以跑一晚上或者周末跑两天。一般压力很大的情况下，数据库连接数问题、内存泄露问题会曝露的比较快，但是死锁可能不能体现，所以要看系统重要性，如12306稳定性则最好7*24小时。 网络环境测试。 6、容错性测试 输入系统不允许的数据作为输入。 把某个相关模块或者子系统停掉，验证对当前系统的影响。 配置文件删除或者配置错误。 数据库注入错误数据。 7、兼容性测试(1)浏览器兼容 同一浏览器不同版本兼容。 不同浏览器兼容：IE，FireFox、Chrome、Safari、QQ浏览器、UC浏览器、360浏览器等。浏览器的差异主要体现在javaScript、ActiveX和HTML解码方法处理不同，因此需要在web系统测试时注意，尤其是通过某个控件跳转浏览器时更需要注意。 (2)操作系统兼容 同一操作系统不同版本兼容。 不同操作系统兼容：Windows，MAC，Linux等。在测试过程中需要关注被测试对象在不同操作系统上的表现、尤其是有数据交互时。 (3)分辨率兼容 常见的分辨率：1280X1024、1024X768、800X600等。不同的显示分辨率可能会导致web页面变形，严重时会导致功能无法使用，因此需要测试在不同分辨率下的系统表现。即使在某些分辨率下不能工作，也需要给出提示信息。 (4)插件兼容 在web系统应用了一些控件，如文本编辑器，文件上传下载，这些控件也需要考虑在不同的操作系统，不同的分辨率下的应用表现。 (5)移动浏览 在移动浏览器上测试您的网页，兼容性问题也可能在移动设备上。 8、体验性测试 系统界面的控件是否可以通过tab键遍历，并且顺序合理。 主要功能的入口和操作是否易于理解。 界面是否布局合理，功能是否易于查找和使用。 操作步骤。 操作习惯。 有足够的提示信息，且信息文字描述准确。 风格、样式、颜色是否协调。 界面布局是否整齐、协调（保证全部显示出来的，尽量不要使用滚动条。 界面操作、标题描述是否恰当（描述有歧义、注意是否有错别字）。 操作是否符合人们的常规习惯（有没有把相似的功能的控件放在一起，方便操作）。 提示界面是否符合规范（不应该显示英文的cancel、ok，应该显示中文的确定等）。 界面中各个控件是否对齐。 日期控件是否可编辑。 日期控件的长度是否合理，以修改时可以把时间全部显示出来为准。 查询结果列表列宽是否合理、标签描述是否合理。 查询结果列表太宽没有横向滚动提示。 对于信息比较长的文本，文本框有没有提供自动竖直滚动条。 数据录入控件是否方便。 有没有支持Tab键，键的顺序要有条理，不乱跳。 有没有提供相关的热键。 控件的提示语描述是否正确。 模块调用是否统一，相同的模块是否调用同一个界面。 用滚动条移动页面时，页面的控件是否显示正常。 日期的正确格式应该是XXXX-XX-XX或XXXX-XX-XXXX:XX:XX。 页面是否有多余按钮或标签。 窗口标题或图标是否与菜单栏的统一。 窗口的最大化、最小化是否能正确切换。 对于正常的功能，用户可以不必阅读用户手册就能使用。 执行风险操作时，有确认、删除等提示吗。 操作顺序是否合理。 正确性检查：检查页面上的form, button, table, header, footer,提示信息，还有其他文字拼写，句子的语法等是否正确。 系统应该在用户执行错误的操作之前提出警告，提示信息。 页面分辨率检查，在各种分辨率浏览系统检查系统界面友好性。 合理性检查：做delete, update, add, cancel, back等操作后，查看信息回到的页面是否合理。 背景灰度冻结。 9、本地化测试 本地化翻译 本地化显示 本地化网络 10、安全测试 通过将内部URL直接粘贴到浏览器地址栏而不进行登录测试。内部页面不应打开。 如果您使用用户名和密码登录，并浏览内部页面，请直接尝试更改URL选项。也就是说，如果您检查发布商站点ID = 123的发布商站点统计信息，请尝试直接将URL站点ID参数更改为与登录用户无关的不同站点ID。应该拒绝访问该用户查看其他统计信息。 在登录用户名，密码，输入文本框等输入字段中尝试一些无效输入。检查系统对所有无效输入的反应。 Web目录或文件不能直接访问，除非它们具有下载选项。 测试CAPTCHA以自动执行脚本登录。 测试SSL是否用于安全措施。当用户从非安全的http：//页面切换到安全的https：//页面时，如果使用正确的消息应该被显示，反之亦然。 所有事务，错误消息，安全漏洞尝试都应该在Web服务器上的某个地方登录日志文件。 11、性能测试 响应速度 负载测试 压力测试 持续更新…","categories":[{"name":"web测试","slug":"web测试","permalink":"http://pythonfood.github.io/categories/web测试/"}],"tags":[{"name":"web测试","slug":"web测试","permalink":"http://pythonfood.github.io/tags/web测试/"}]},{"title":"app测试","slug":"app测试","date":"2017-12-28T04:00:00.000Z","updated":"2018-05-11T06:36:51.109Z","comments":true,"path":"2017/12/28/app测试/","link":"","permalink":"http://pythonfood.github.io/2017/12/28/app测试/","excerpt":"app端测试笔记。","text":"app端测试笔记。 一、测试资源确认及准备 产品需求文档、产品原型图、接口说明文档以及设计说明文档等应齐全； 测试设备及工具的准备：IOS和andriod不同版本的真机，以及相关测试工具的准备。 二、测试用例设计与评审 根据产品需求文档、产品原型图等文档，设计客户端的一般功能测试用例； 测试用例评审、修改与完善，评审通过后着手进入正式测试阶段。 三、测试用例框架 功能测试 UI测试 兼容性测试 稳定性测试 可靠性测试 本地化测试 体验性测试 安全性测试 安装升级和卸载 启动运行和退出 网络环境 中断恢复 手机权限 消息推送 屏幕旋转 文件存储 系统配置 性能测试 竞品测试 探索测试 四、测试用例设计1、功能测试 功能点测试。 业务逻辑测试。 关联性测试。 与PC端交互正常。 注册： 同表单编辑页面。 用户名密码长度。 注册后的提示页面。 前台注册页面和后台的管理页面数据是否一致。 注册后，在后台管理中页面提示。 登录： 使用合法的用户登录系统。 系统是否允许多次非法的登录，是否有次数限制。 使用已经登录的账号登录系统是否正确处理。 用户名、口令（密码）错误或漏填时能否登陆。 删除或修改后的用户，原用户名登陆。 不输入用户口令和重复点“确定/取消”按钮，是否允许登录。 登陆后，页面中登录信息。 页面中有注销按钮。 登录超时的处理。 免登陆： 当应用开启时自动以上一次登录的用户身份来使用App。 考虑无网络情况时能否正常进入免登录状态。 切换用户登陆后，要校验用户登录信息以及数据内容是否相应更新，确保原用户退出。 根据Mtop的现有规则，一个账户只允许登陆一台机器。所以，需要检查一个账户登录多台手机的情况。原手机里的用户需要被退出，给出友好提示。 App切换到后台，在切换回前台的校验。 切换到后台，再切换回到前台的测试。 密码更换后，检查有数据交换时是否进行了有效身份的校验。 支持自动登录的应用在进行数据校验时，检查系统是否能自动登录成功并且数据操作无误。 检查用户主动退出登录后，下次启动App，应停留在登录界面。 离线浏览： 支持离线浏览，即在本地客户端会缓存一部分数据供用户查看。 在无线网络情况可以浏览本地数据。 退出App再开启App时能正常浏览。 切换到后台再回到前台可以正常浏览。 锁屏后再解锁回到应用前台可以正常浏览。 在对服务器段的数据有更新时回给予离线的相应提示。 输入框测试： 字符型： 字符型输入框：英文全角，英文半角、数字、空或者空格、特殊字符如~!@#$%^&amp;*()_+&lt;&gt;:”{}|`特别要注意单引号和&amp;符号。禁止直接输入特殊字符时，使用“粘贴、拷贝”功能尝试输入。 长度检查：最小长度、最大长度、最小长度-1、最大长度+1、输入超长字符比如把整个文章拷贝过去。 空格检查：输入的字符间有空格、字符前有空格、字符后有空格、字符前后有空格。 多行文本框输入：允许回车换行、保存后再显示能够保存输入的格式、仅输入回车换行，检查能否正确保存（若能，检查保存结果，若不能，查看是否有正常提示）。 安全性检查：输入特殊字符串输入特殊字符串NULL，null，JavaScript，输入脚本函数。 数字型： 边界值：最大值、最小值、最大值+1、最小值-1。 位数：最小位数、最大位数、最小位数-1、最大位数+1、输入超长值、输入整数。 异常值、特殊字符：输入空白（NULL）、空格或”~!@#$%等可能导致系统错误的字符、禁止直接输入特殊字符时，尝试使用粘贴拷贝查看是否能正常提交。输入负整数、负小数、分数、输入字母或汉字、小数、科学计数法是否支持1.0E2、全角数字与半角数字、数字与字母混合。 安全性检查：不能直接输入就复制然后粘贴。 对于必填项，先录入再删除是否可以提交成功；或者先录入错误数据再改为正确数据是否可提交成功 。 录入小数然后全选，直接录入新值，是否可正常录入；（可能出现小数全选后无法直接填写新值）。 日期型： 合法性检查：输入0月，13月，32日等，闰年2月的处理方式等，考虑开始日期与结束日期的比较，特别是在查询的时候。 异常值、特殊字符：输入空格或空、输入~！@#￥%……&amp;*（）{}[]等可能导致系统错误的字符。 安全性检查：不能直接输入，就copy，是否数据检验出错。 信息重复： 在一些需要命名,且名字应该唯一的信息输入重复的名字或ID,看系统有没有处理,会否报错,重名包括是否区分大小写,以及在输入内容的前后输入空格,系统是否作出正确处理。 2、UI测试 UI与实际设计的效果图是否一致。 用户界面(如菜单、对话框、窗口和其它可视控件)布局、风格是否满足客户要求，文字是否正确，页面是否美观，文字，图片组合是否完美，操作是否友好等 导航测试： 按钮、对话框、列表和窗口等；或在不同的连接页面之间需要导航。 是否易于导航，导航是否直观。 是否需要搜索引擎。 导航帮助是否准确直观。 导航与页面结构、菜单、连接页面的风格是否一致。 图形测试： 横向比较，各控件操作方式统一。 自适应界面设计，内容根据窗口大小自适应。 页面标签风格是否统一。 页面是否美观。 页面的图片应有其实际意义而要求整体有序美观。 内容测试： 输入框说明文字的内容与系统功能是否一致。 文字长度是否加以限制。 文字内容是否表意不明。 是否有错别字。 信息是否为中文显示。 过度渲染。 3、兼容性测试 不同机型兼容： 主流机型TOP100等。 系统版本兼容： android&gt;=2.3、ios&gt;=7。 不同分辨率兼容： 800x480、854x480、800x600、960x540、960x640、960x720、1024x576、1024x600、1024x768、1280x720、1280x768、1280x800等分辨率。 新旧版本兼容。 输入法兼容。 安全软件兼容。 通讯软件兼容。 竞品软件兼容。 4、稳定性测试 煲机测试。 暴力测试。 电池边界压力。 存储边界压力。 网速边界压力。 反复/长期操作，系统资源是否占用异常。 单点连续点击是否会响应多次请求。 多点触控，同时点击2个不同的按钮，同时响应2个操作是否会引起导致页面显示异常，或者程序崩溃。 5、可靠性测试 检验产品在出现异常时的处理机制。 同时需要检验出现这些异常场景，或者是比较极限的情况的时候会否出现crash、anr的情况。 6、本地化测试 本地化安装。 本地化升级。 本地化网络。 本地化翻译。 本地化显示： 其他语言的语言习惯（如繁体）。 英文注意复数。 多语言下，需要特别检查以图片形式展示的文案（如果功能引导，启动引导图）。 一致性。（一方面是代指的一致性，一方面如果有系列应用共用功能的文案也需要保持一致）。 检查英文语言下的切断、断行是否正确。 当文字长度不一致时，UI界面是否能正常适配。 区域性设定。 7、体验性测试 易用性： 操作顺序是否合理 操作是否符合人们的常规习惯，右上角分享菜单等。 日期控件是否可编辑。 信息比较长的文本，文本框有没有提供自动垂直滚动条。 是否支持Tab键，跳转顺序是否条理，键的顺序是否有条理，不乱跳。 友好性： 执行风险操作时，是否有确认提示，如删除、移除、注销确认提示吗 界面操作、标题描述是否恰当。例如应该是气泡提示的却显示成方框提示。 用滚动条移动页面时，页面的控件是否显示正常。 控件的提示语描述是否正确 视觉设计： 风格.样式.颜色是否协调 界面布局是否整齐、协调。例如搜索栏上面应该显示三个按钮，实际上只显示了两个或者显示折行 界面中各个控件是否对齐 页面是否有多余按钮或标签 8、安全性测试 App安全测试大概划分为以下几类： 从数据的本地存储到数据的传输、处理以及远程访问等各个环节，基于相应的安全标准/行业标准评估App的安全特性。 借鉴在Web App和网络安全测试的一些成功经验在智能终端App测试中进行裁减或适配。 检测App的用户授权级别，数据泄漏，非法授权访问等。 对App的输入有效性校验、认证、授权、敏感数据存储、数据加密等方面进行检测,以期发现潜在的安全问题。 基于各种通信协议或相应的行业安全标准检视App是否满足相应的要求。 检查包括检查权限、日志、传输通道。 扫描主要测试端口。 渗透属于专项测试领域。 apk文件在PC杀软上检测。 手机杀毒软件检测。 数据安全性： 当将密码或其它的敏感数据输入到应用程序时，其不会被存储在设备中，同时密码也不会被解码。 输入的密码将不以明文形式进行显示。 密码、信用卡明细或其他的敏感数据将不被存储在它们预输入的位置上。 不同的应用程序的个人身份证或密码长度必须至少在4-8个数字长度之间。 当应用程序处理信用卡明细或其它的敏感数据时，不以明文形式将数据写到其他单独的文件或者临时文件中。以防止应用程序异常终止而又没有删除它的临时文件，文件可能遭受入侵者的袭击，然后读取这些数据信息。 党建敏感数据输入到应用程序时，其不会被存储在设备中。 应用程序应考虑或者虚拟机器产生的用户提示信息或安全警告。 应用程序不能忽略系统或者虚拟机器产生的用户提示信息或安全警告，更不能在安全警告显示前，利用显示误导信息欺骗用户，应用程序不应该模拟进行安全警告误导用户。 在数据删除之前，应用程序应当通知用户或者应用程序提供一个“取消”命令的操作。 应用程序应当能够处理当不允许应用软件连接到个人信息管理的情况。 当进行读或写用户信息操作时，应用程序将会向用户发送一个操作错误的提示信息。 在没有用户明确许可的前提下不损坏删除个人信息管理应用程序中的任何内容。 如果数据库中重要的数据正要被重写，应及时告知用户。 能合理的处理出现的错误。 意外情况下应提示用户。 9、安装升级和卸载 安装： 在各个操作系统上（Android&gt;=2.3，ios&gt;=7.0，根据各个应用要求的最低系统）能安装成功。 分别安装在手机内存或者sd卡上都能成功。 在安装过程中，突然断网或网络不好，是否给出有好的提示，网络恢复之后是否能正常下载。 在安装过程中，突然内存不足，是否有相应的提示。 在安装过程中，是否支持取消操作。 在安装过程中，突然死机，断电，卡死，手机恢复正常后，是否能正常安装。 软件安装后是否能够正常运行，安装后的文件夹以及文件是否写到了指定的目录里。 软件安装各个选项的组合是否符合概要设计说明。 软件安装向导的UI测试 卸载： 卸载清理安装目录，保留sd卡数据。 在卸载过程中，突然死机，断电，卡死，手机恢复正常后，是否能正常卸载。 卸载完成之后，查看文件是否卸载干净。 卸载是否支持取消功能，单击取消后软件卸载的情况。 系统直接卸载UI测试，是否有卸载状态进度条提示。 卸载用户使用过程中产生的文件是否有提示。 其修改的配置信息是否复原。 卸载是否影响其他软件的功能。 更新： 是否可以隔版本升级。 是否可以覆盖安装低版本。 忽略本次版本升级，下次是否可以升级。 没有更新或者网络时提示正确。 大版本更新不升级无法使用。 是否有完整的升级策略（强制升级，灰度发布）。 下载升级包过程中是否可以取消。 升级包下载是否可以续传。 升级过程是否可以中断（取消按钮，back键）。 在线升级验证数字签名。 Android系统第一次安装非官方市场应用，需要手动取消限制，此过程是否会影响到apk包安装（正对预装应用的测试）。 收到升级提示后，下载了apk并未安装，同名替换该apk，下次再收到升级提示后，是否正常升级。 升级覆盖安装是否数据保留。 用户设置项状态是否保留。 新版上移除老版的功能是否正常。 升级后的版本各功能正常。 不同渠道包覆盖安装。 版本跨度较大的覆盖安装。 版本为非强制升级时，用户可以取消升级，老版本正常使用，用户下次启动时，仍出现更新提示（根据客户端策略是下次还是搁多长时间）。 版本为强制升级时，给出强制更新提示后用户没有更新就退出客户端,用户下次启动时，仍出现强制更新提示。 打开旧版app时，是否有更新提示，且在不同的手机版本上都能更新成功。 打开新版app时，不显示更新提示，在设置中检查更新，提示已更新到最新版本。 在不删除客户端的情况下，用户是否能更新成功，查看新版功能是否正常。 更新过程中，更新速度是否合理。 更新过程中，突然网络不好是否有提示。 更新过程中，突然死机，断电，卡死，手机恢复正常后，是否能更新成功。 10、启动运行和退出 启动的方式：首次启动，热启动，冷启动。 首次启动是否出现欢迎界面，可否进入App，停留时间是否合理。 首次启动后拉取的信息是否正确。 再次启动时间是否符合预期。 再次启动app功能是否异常。 再次启动后状态检查：如初始化信息、初始状态、启动对网络。 再次启动进程服务检查：进程名、进程数、服务名、服务数、第三方调用的SDK如GPS。 再次带登陆的应用是否再次启动的时候正常登录。 出现崩溃是否可以再次启动。 手动终止进程、服务是否可以在此启动。 其他系统软件工具停止进程、清理软件数据，是否可以启动。 启动入口：桌面正常启动，最近运行启动，所有程序列表中启动，锁屏快捷启动。 其他入口：从其他程序开启应用，从外部以文件形式打开应用（如果有）。 退回：从其他程序退回时回到被测应用，被测应用打开其他应用再从桌面图标启动。 异常启动：崩溃后启动，写文件时被强制杀进程后启动，网络请求未收到回包强制杀进程后再启动，网络超时时启动（启动需要有超时机制）。 运行速度是否流畅。 各个模块之间的切换是否正常。 11、网络环境 移动网络： 移动4G/3G/2G。 联通4G/3G/2G。 电信4G/3G/2G。 wifi热点： 移动。 联通。 电信。 切换网络： wifi/4G/3G/2G。 wifi/wifi。 飞行模式/4G/3G/2G。 飞行模式/wifi。 双卡双待切换。 断网： 页面UI呈现是否正常，数据是否完整，toast提示是否正确。 断网恢复网络。 弱网： 弱网络状态下的功能： 均在2G，3G，4G，高延时，高丢包，假热点的状态下，弱网状态的功能正常。 弱网络状态下的体验： 中间的转态状态正常。 异常反馈的文案正常，样式正确。 弱网络状态下的响应时间。 弱网恢复强网。 12、中断恢复 中断情况： 锁屏。 断电。 充电。 电话。 短信。 音乐。 闹钟。 音量。 数据线。 耳机。 蓝牙。 日历提醒。 低电量提醒。 切换其他app。 其他app通知。 强行关闭。 back。 home。 音频资源。 相机视频资源。 App切换到后台，再回到App，检查是否停留在上一次操作界面。 App切换到后台，再回到App，检查功能及应用状态是否正常。 App切换到后台，再回到前台时，注意程序是否崩溃，功能状态是否正常，尤其是对于从后台切换回前台数据有自动更新的时候。 手机锁屏解锁后进入App注意是否会崩溃，功能状态是否正常，尤其是对于从后台切换回前台数据有自动更新的时候。 当App使用过程中有电话进来中断后再切换到App，功能状态是否正常。 当杀掉App进城后，再开启App，App能否正常启动。 出现必须处理的提示框后，切换到后台，再切换回来，检查提示框是否还存在，有时候会出现应用自动跳过提示框的缺陷。 对于有数据交换的页面，每个页面都必须要进行前后台切换、锁屏的测试，这种页面最容易出现崩溃。 在所有界面执行锁屏操作，解锁后观察是否正常运行。 在所有界面执行长时间锁屏操作，解锁后观察是否正常运行。 在所有界面，和所有过程，按home键切后台，再切回时观察是否正常。 在所有的loading过程中，按back键。 在所有的loading过程中，按home键。 界面切换动画时尝试多次按back键。 正常的点击动作，尝试快速按两次。 后摄像头和前摄像头无法同时启动，后摄像头启动还包括打开闪光灯（与手电筒类应用的兼容性）。 检查键盘展开和收起的时机，与home、back、锁屏组合测试。 从第三方启动后，home键回到桌面，再从桌面打开被测应用，显示是否正确（应确定是显示第三方启动界面，还是显示程序正常启动界面，前者如微信，后者如QQ）。 断电后重启。 来电结束后，返回被测应用界面。 在某些特殊情况下，来电后，移动网络会被切断。 13、手机权限 软件权限： 扣费风险：包括短信、拨打电话、连接网络等。 隐私泄露风险：包括访问手机信息、访问联系人信息等。 对App的输入有效性校验、认证、授权、数据加密等方面进行检测。 限制/允许使用手机功能接入互联网。 限制/允许使用手机发送接收信息功能。 限制/允许使用本地连接。 限制/允许使用手机拍照或录音。 限制/允许使用手机读取用户数据。 限制/允许使用手机写入用户数据。 限制/允许应用程序来注册自动启动应用程序。 需要用户确认的权限没有授权，权限默认关闭。 当某些权限被安全软件或者系统禁止时，是否可以正常使用。 使用安全软件进行安全漏洞、病毒扫描，看被测APP是否会被提示有安全问题。 第三方安全软件弹框请求禁止权限时，选择后，是否会影响到被测应用的正常流程。 14、消息推送 检查Push消息是否按照指定的业务规则发送。 消息推送默认打开。 关闭消息推送关闭后，收不到推送消息。 打开推送开关能否正常接收消息。 app运行时消息推送不会进入消息栏。 app后台挂机时，消息栏可以接收到推送提醒，点击后从消息栏消失。 如果用户设置了免打扰的时间段，检查在免打扰时间段内，用户接收不到Push。在非免打扰时间段内，用户能正常收到Push。 当Push消息是针对登录用户的时候。 只对手机上最后一个登录用户进行消息推送。 点击消息推送跳转正确。 15、屏幕旋转 当适应横屏时，是否对横屏进行了适配。 确认哪些界面是需要允许横屏或者禁止横屏的。 将屏幕锁定为竖屏或者横屏，在几个界面跳转，界面是否正常。 横竖屏切换，页面需要重新加载，UI是否正确，重新加载的页面可能会发生内存无法释放的情况。 同一页面横屏后再竖过来是否能和之前显示一致。在横屏情况下做一系列操作看看是否正常。 16、文件存储 APP被安装在SD卡或者手机存储空间。 APP使用过程中产生的临时文件存储路径、命名方式等。 APP中涉及的下载操作产生的文件存储方式。 存储的文件被锁、占用。 磁盘空间不足。 磁盘无权限（如读、写）。 无SD卡时的存储提示是否有。 有SD卡但无存储空间时存储提示是否有。 内置SD卡，存储是否正确。 外置SD卡，存储是否正确。 SD卡被使用时移除，存储是否正确，提示是否有。 将SD卡的内容删除后操作（如，下载的内容，删除下载的文件，在下载管理对该文件操作）。 17、系统配置 语言环境。 省电管理。 后台进程驻留管理。 字体大小和类型。 是否支持横竖屏自适应。 18、性能测试 CPU。 内存。 电量。 流量。 温度。 FPS。 安装时间： 普通安装。 覆盖安装。 启动时间： 冷启动。 热启动。 跳转时间： 页面间跳转。 控件间跳转。 19、竞品测试 和竞品对各个指标进行定量对比。 20、探索测试 自由式探索。 场景式探索。 策略试探索。 反馈式探索。 持续更新…","categories":[{"name":"app测试","slug":"app测试","permalink":"http://pythonfood.github.io/categories/app测试/"}],"tags":[{"name":"app测试","slug":"app测试","permalink":"http://pythonfood.github.io/tags/app测试/"}]},{"title":"流程分析","slug":"流程分析","date":"2017-12-27T10:00:00.000Z","updated":"2018-05-11T06:35:33.467Z","comments":true,"path":"2017/12/27/流程分析/","link":"","permalink":"http://pythonfood.github.io/2017/12/27/流程分析/","excerpt":"现在的软件几乎都是用事件触发来控制流程的，事件触发时的情景便形成了场景，而同一事件不同的触发顺序和处理结果就形成事件流。这种在软件设计方面的思想也可引入到软件测试中，可以比较生动地描绘出事件触发时的情景，有利于测试设用例场景用来描述流经用例的路径。","text":"现在的软件几乎都是用事件触发来控制流程的，事件触发时的情景便形成了场景，而同一事件不同的触发顺序和处理结果就形成事件流。这种在软件设计方面的思想也可引入到软件测试中，可以比较生动地描绘出事件触发时的情景，有利于测试设用例场景用来描述流经用例的路径。 一、场景设计法三个流程 1.基本流：通过业务流程输入都为正确的，能够最后到达目标的流程2.备选流：通过实现业务流程时，因错误操作或异常输入，导致流程存在反复，但最终能够完成期望业务的流程。3.异常流：通过实现业务流程时，因错误操作或异常输入，导致业务没有正确完成。 二、流程分析应用步骤 1.理解需求，确定业务流程（基本流、备选流、异常流）。2.绘制流程图（再次明确流程路径）。3.根据业务流程图，抽取测试路径（每次路径需包含一个从未走过的路径）。4.细化路径设计测试用例。 三、流程分析法注意点 需使用等价类、边界值、正交试验、判定表、因果图等方法保证单个功能的正确性。 四、小示例1.画出流程图2.流程图类需求3.根据需求画流程图，流程覆盖写用例 持续更新…","categories":[{"name":"测试用例","slug":"测试用例","permalink":"http://pythonfood.github.io/categories/测试用例/"}],"tags":[{"name":"测试用例","slug":"测试用例","permalink":"http://pythonfood.github.io/tags/测试用例/"}]},{"title":"状态迁移","slug":"状态迁移","date":"2017-12-27T09:00:00.000Z","updated":"2018-05-11T06:35:28.157Z","comments":true,"path":"2017/12/27/状态迁移/","link":"","permalink":"http://pythonfood.github.io/2017/12/27/状态迁移/","excerpt":"状态迁移关注被测对象的状态变化，在需求规格说明书中是否有不可达到的状态和非法的状态，是否产生非法的状态迁移。","text":"状态迁移关注被测对象的状态变化，在需求规格说明书中是否有不可达到的状态和非法的状态，是否产生非法的状态迁移。 一、状态 被测对象在特定输入条件下所保持的响应形式 二、状态迁移应用步骤 1.根据需求明确状态节点。2.绘制状态迁移图。3.绘制状态迁移树。4.抽取测试用例。 三、小示例1.状态迁移类需求2.根据需求画状态迁移图案例13.根据需求画状态迁移图案例2 持续更新…","categories":[{"name":"测试用例","slug":"测试用例","permalink":"http://pythonfood.github.io/categories/测试用例/"}],"tags":[{"name":"测试用例","slug":"测试用例","permalink":"http://pythonfood.github.io/tags/测试用例/"}]},{"title":"正交试验","slug":"正交试验","date":"2017-12-27T08:00:00.000Z","updated":"2018-05-11T06:35:23.527Z","comments":true,"path":"2017/12/27/正交试验/","link":"","permalink":"http://pythonfood.github.io/2017/12/27/正交试验/","excerpt":"正交试验是研究多因素多水平的一种设计方法，它是根据正交性从全面试验中挑选出部分有代表性的点进行试验，这些有代表性的点具备了“均匀分散，齐整可比”的特点，正交试验设计是一种基于正交表的、高效率、快速、经济的试验。","text":"正交试验是研究多因素多水平的一种设计方法，它是根据正交性从全面试验中挑选出部分有代表性的点进行试验，这些有代表性的点具备了“均匀分散，齐整可比”的特点，正交试验设计是一种基于正交表的、高效率、快速、经济的试验。 一、正交试验重要概念 1.因子：所有参与试验的影响试验结果的条件成为因子。2.水平：影响试验因子的取值或输入称为水平。3.整齐可比：在同一张正交表中，每个因子每个水平出现的次数完全相同。试验中，每个因子的每个水平与其他因子的水平参与试验的机率完全相同。4.均匀分散：同一张正交表中，任意两列水平搭配是完全相同的。 二、正交试验应用步骤 1.分析需求获取因子和水平。2.根据因子和水平选择合适的正交表。3.替换因子和水平，获取试验次数。4.根据试验或其他因素补充试验次数。5.细化输出获取测试用例。 三、正交试验注意点 1.选择正交表的因子与水平恰好与正交表相同。2.根据对象因子与正交表中的因子不同，选择正交表中因子稍大于被测对象因子数，且试验次数最少的，多余的因子弃用。3.被测对象水平与正交表中的水平不同，可根据实际情况进行合并，然后拆分。4.因子水平都不相同，则可选择因子，水平稍大于被测对象的，且实验次数最少的。 四、小示例1.提取因子和水平2.设计正交试验表，补充缺少的必要用例3.替换因子水平得出用例 持续更新…","categories":[{"name":"测试用例","slug":"测试用例","permalink":"http://pythonfood.github.io/categories/测试用例/"}],"tags":[{"name":"测试用例","slug":"测试用例","permalink":"http://pythonfood.github.io/tags/测试用例/"}]},{"title":"因果图","slug":"因果图","date":"2017-12-27T07:00:00.000Z","updated":"2018-05-11T06:35:17.687Z","comments":true,"path":"2017/12/27/因果图/","link":"","permalink":"http://pythonfood.github.io/2017/12/27/因果图/","excerpt":"因果图是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，它适合于检查程序输入条件的各种组合情况。","text":"因果图是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，它适合于检查程序输入条件的各种组合情况。 一、输入与输出的关系 1.恒等：若ci是1，则ei也是1；否则ei为0。2.非：若ci是1，则ei是0；否则ei是1。3.或：若c1或c2或c3是1，则ei是1；否则ei为0。“或”可有任意个输入。4.与：若c1和c2都是1，则ei为1；否则ei为0。“与”也可有任意个输入。 二、输入与输入的关系 1.E约束（异）：a和b中至多有一个可能为1，即a和b不能同时为1。2.I约束（或）：a、b和c中至少有一个必须是1，即 a、b 和c不能同时为0。3.O约束（唯一）；a和b必须有一个，且仅有1个为1。4.R约束（要求）：a是1时，b必须是1，即不可能a是1时b是0。 三、输出与输出的关系 1.M(屏蔽)：a出现时，b必定不出现；a不出现时，b则不确定。 四、小示例1.根据关系画用例的因果图2.根据用例因果图设计判定表3.去除因果图判定表的无效项 持续更新…","categories":[{"name":"测试用例","slug":"测试用例","permalink":"http://pythonfood.github.io/categories/测试用例/"}],"tags":[{"name":"测试用例","slug":"测试用例","permalink":"http://pythonfood.github.io/tags/测试用例/"}]},{"title":"判定表","slug":"判定表","date":"2017-12-27T06:00:00.000Z","updated":"2018-05-11T06:35:10.647Z","comments":true,"path":"2017/12/27/判定表/","link":"","permalink":"http://pythonfood.github.io/2017/12/27/判定表/","excerpt":"判定表是分析和表达多逻辑条件下执行不同操作的情况的工具。（在遇到复杂业务逻辑时可以利用该表理清业务逻辑关系）","text":"判定表是分析和表达多逻辑条件下执行不同操作的情况的工具。（在遇到复杂业务逻辑时可以利用该表理清业务逻辑关系） 一、判定表重要概念 1.条件 条件桩：列出了所有条件，通常认为列出条件的次序无关紧要。条件项：列出了所有条件的取值组合，在所有可能情况下的真假值。 2.动作 动作桩：列出所有可能的操作，这些操作的排列顺序没有约束。动作项：列出在条件项的各种取值情况下应该采取的动作。 3.规则 规则：任何一个条件组合的特定取值及其他相应要执行的操作称为规则。在判定表中贯穿条件项和动作项的一列就是一条规则。 二、判定表的4个组成部分 三、判定表应用步骤 1.理解需求，列出条件桩和动作桩。2.设计及优化判定表。（2的n次方种）3.填写动作项。4.根据判定表中输出结果的表现，进行判定表的合并（非必须），简化判定表。5.抽取测试用例。 四、小示例根据判定条件编写判定表测试用例 持续更新…","categories":[{"name":"测试用例","slug":"测试用例","permalink":"http://pythonfood.github.io/categories/测试用例/"}],"tags":[{"name":"测试用例","slug":"测试用例","permalink":"http://pythonfood.github.io/tags/测试用例/"}]},{"title":"边界值","slug":"边界值","date":"2017-12-27T05:00:00.000Z","updated":"2018-05-11T06:32:37.451Z","comments":true,"path":"2017/12/27/边界值/","link":"","permalink":"http://pythonfood.github.io/2017/12/27/边界值/","excerpt":"边界值是对输入或输出的边界值进行测试的一种黑盒测试方法。通常边界值分析法是作为对等价类划分法的补充，这种情况下，其测试用例来自等价类的边界。","text":"边界值是对输入或输出的边界值进行测试的一种黑盒测试方法。通常边界值分析法是作为对等价类划分法的补充，这种情况下，其测试用例来自等价类的边界。 一、边界值三点（边值点） 1.上点：边界上的点，闭内开外（闭指域的边界是封闭的，即闭区间；开指域的边界是开放的，即开区间）。2.离点：离上点最近的点称为离点。开内闭外。（根据上点的精度确定）3.内点：边界值有效范围内的任意一点。 二、边界值如何确定离点 1.如果边界是闭区间，则离点在外。2.如果边界是开区间，则离点在内。 三、边界值应用场景 1.如果需求规定了取值范围或规定了取值个数时，可利用该范围的边界及边界附近的数据进行测试。2.如果需求规定了取值的个数，则少于个数一个，或多余个数一个的值进行测试。3.如果需求规定了一个有序集合的时候，可使用该集合的第一个和最后一个值进行测试。4.如果程序中使用一个内部数据结构的话，则应该从这个数据结构的边界值进行考虑。 四、边界值应用步骤 1.根据等价类方法划分有效等价类和无效等价类，确定上点、离点及内点，每一个点统一编号。2.设计一个新的测试用例，使其尽可能覆盖所有尚未覆盖的有效等价类，直到所有的有效等价类完全覆盖。3.设计一个新的测试用例，使其仅覆盖一个无效等价类，直到所有的无效等价类完全覆盖。 五、小示例在等价类基础上根据输入值编写边界值测试用例 持续更新…","categories":[{"name":"测试用例","slug":"测试用例","permalink":"http://pythonfood.github.io/categories/测试用例/"}],"tags":[{"name":"测试用例","slug":"测试用例","permalink":"http://pythonfood.github.io/tags/测试用例/"}]},{"title":"等价类","slug":"等价类","date":"2017-12-27T04:00:00.000Z","updated":"2018-05-11T06:32:17.201Z","comments":true,"path":"2017/12/27/等价类/","link":"","permalink":"http://pythonfood.github.io/2017/12/27/等价类/","excerpt":"等价类是把所有可能的输入数据,即程序的输入域划分成若干部分（子集）,然后从每一个子集中选取少数具有代表性的数据作为测试用例。","text":"等价类是把所有可能的输入数据,即程序的输入域划分成若干部分（子集）,然后从每一个子集中选取少数具有代表性的数据作为测试用例。 一、等价类划分规则 1.如果输入条件规定了一个取值范围，那么就应该确定一个有效等价类以及两个无效等价类。如月份取值在1~12之间，由此可确定一个有效等价类即月份在1~12之间，和两个无效等价类，即月份取值小于1及月份取值大于12.2.规定了输入条件必须如何的情况下可以确定一个有效等价类和一个无效等价类。如输入值必须大于0，则有效等价类为输入值大于0 ，无效等价类为输入值小于或者等于0.3.在输入数据是一个bool常量的情况下，可以确定一个有效等价类和一个无效等价类。4.在规定了输入数据由n个值构成的情况下，并要求定其中的每个值进行测试时，可以确定n个有效等价类和一个无效等价类。如交通工具类型为公共汽车、卡车、出租车、火车或者摩托车，那么就应该为每一个输入值确定一个有效等价类和一个无效等价类例如拖车。5.在规定了输入数据冰箱最受的规则的情况下，可以确定一个有效等价类和若干个无效等价类（从不同角度违反规则）。如输入值必须是数字类型的字符，则可确定一个有效等价类，及输入值为数字类型得字符，和多个无效等价类，即输入值为字母、为专用字符（如+、*、@等）以及为非打印字符（如回车、空格等）。6.在确知已划分的等价类中各元素在程序处理中的方式不同的情况下,则应再将该等价类进一步的划分为更小的等价类。划分等价类之后，应建立等价类表，列出与每一个输入条件对于的有效等价类和无效等价类。 二、等价类设计测试用例 1.根据需求，划分有效等价类和无效等价类，有效等价类统一编号，无效等价类统一编号。2.设计一个新的测试用例,使其尽可能多地覆盖尚未被覆盖地有效等价类,重复这一步，直到所有的有效等价类都被覆盖为止。3.设计一个新的测试用例,使其仅覆盖一个尚未被覆盖的无效等价类,重复这一步，直到所有的无效等价类都被覆盖为止。 三、等价类四则运算法 1.不考虑需求其他子项，细致分解当期测试点及详细需求，做累加。2.根据业务规则减少，排除相关不可能出现的规则，减少不可能出现的组合。3.如果有效等价类中具有互斥条件的需求时，可运用乘得到用例个数。4.排除所有具有重复特性的等价类，尽可能做到有效等价类之间交集为空。 四、小示例1.有效等价类一条用例尽量覆盖所有有效等价类2.无效等价类一条用例覆盖一个无效等价类3.根据覆盖条件编写等价类测试用例 持续更新…","categories":[{"name":"测试用例","slug":"测试用例","permalink":"http://pythonfood.github.io/categories/测试用例/"}],"tags":[{"name":"测试用例","slug":"测试用例","permalink":"http://pythonfood.github.io/tags/测试用例/"}]},{"title":"github","slug":"github","date":"2017-12-26T03:00:00.000Z","updated":"2018-07-18T10:23:49.831Z","comments":true,"path":"2017/12/26/github/","link":"","permalink":"http://pythonfood.github.io/2017/12/26/github/","excerpt":"github是一个基于git的代码托管平台，免费用户只能使用公共仓库（公开代码），付费用户可以建私人仓库。","text":"github是一个基于git的代码托管平台，免费用户只能使用公共仓库（公开代码），付费用户可以建私人仓库。 一、注册安装 注册github账号：https://github.com/ 下载安装git：https://git-scm.com/downloads 二、常用配置1、github创建仓库 (1) 登录github点击【New repository】创建仓库，仓库名字随便起。(2) 注意仓库地址后续关联本地项目用：https://github.com/yourName/yourRepo.git 2、本地创建ssh key (1) git bash输入命令：$ ssh-keygen -t rsa -C &quot;yourEmail@email.com&quot;(2) 在C:\\Users\\tester.ssh路径下会生成 id_rsa 和 id_rsa.pub 两个文件。(3) 复制 id_rsa.pub 里的内容，然后登录Github —&gt; 【用户头像】 —&gt; 【Settings】 —&gt; 【SSH and GPG KEY】 —&gt; 【New SSH key】，将复制内容粘贴到【Key】，【Title】随便起，最后点击【Add SSH key】。(4) 验证是否成功，在git bash下输入：$ ssh -T git@github.com 3、设置username和email git bash下输入命令: $ git config --global user.name &quot;yourName&quot; $ git config --global user.email &quot;yourEmail@email.com&quot; 三、本地操作进入项目路径，git bash输入命令： $ git init # 初始化仓库 $ git add index.html # 生成首页 $ git add . 或 $ git add * # 工作区添加所有文件到暂存区 $ git add &lt;filename&gt; # 工作区添加指定文件到暂存区 $ git status # 查看当前状态 $ git commit -m &quot;&lt;submission information&gt;&quot; # 暂存区提交代码到版本库 $ git remote add origin git@github.com:yourName/yourRepo.git # git仓库关联github仓库 $ git push origin master # 提交项目到远端github仓库 $ git clone /path/to/repository # 克隆本地仓库版本 $ git clone https://github.com/otherName/otherRepo.git # 克隆github仓库 四、分支合并 $ git checkout -b feature_name # 创建分支 $ git checkout master # 切回主分支 $ git branch -d feature_name # 删除分支 $ git push origin &lt;branch&gt; # 将分支推送到远端仓库分支 $ git fetch origin/master:tmp # 将远端仓库分支下载到本地分支 $ git diff tmp origin/master # 比较两个分支差异 $ git merge origin/master # 合并分支 $ git pull origin feature_name # 取回远端分支与当前分支合并，相当于fetch+merge 持续更新…","categories":[{"name":"github","slug":"github","permalink":"http://pythonfood.github.io/categories/github/"}],"tags":[{"name":"github","slug":"github","permalink":"http://pythonfood.github.io/tags/github/"}]},{"title":"markdown","slug":"markdown","date":"2017-12-26T02:00:00.000Z","updated":"2018-08-11T12:23:21.113Z","comments":true,"path":"2017/12/26/markdown/","link":"","permalink":"http://pythonfood.github.io/2017/12/26/markdown/","excerpt":"markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。markdown用于编写说明文档，并且以“README.MD”的文件名保存在软件的目录下面。","text":"markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。markdown用于编写说明文档，并且以“README.MD”的文件名保存在软件的目录下面。 一、粗体和斜体**粗体** ***加粗斜体*** *斜体* _斜体_ ~~删除线~~ 二、分级标题# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 这是一个一级标题 ================ 这是一个二级标题 ---------------- 三、列表+ 无 - 无 * 无 + 序 - 序 * 序 + 列 - 列 * 列 + 表 - 表 * 表 1.有 2.序 3.列 4.表 四、引用&gt;引用 引用一段话 五、多层引用&gt;&gt;&gt;多 &gt;&gt;层 &gt;引用 六、图片![图片Alt](图片地址 “图片Title”) 七、超链接[连接文字](连接地址 “连接Title”) 八、代码`内行代码` 两行```包夹多行代码 1个tab或4个空格缩进， 也可以写多行代码 九、代码块2个tab键或8个空格键 十、表格|学号|姓名|分数| |:---|:--:|---:| |111|我|70| |左对齐|居中|右对齐| ps:表格里写”|”,需要使用&amp;#124;代替。 十一、分隔线*** * * * ****** - - - _ _ _ _ _ _ 十二、代码高亮 ``` key 我是高亮代码``` key值代表代码类型： apache bash cpp： c++ cs： c# css django dos go html http java javascript json markdown matlab monkey nginx objectivec perl php python r ruby sql swift text/plain typescript vim xml 十三、转义字符 Markdown中，以下字符支持使用反斜线\\转义： \\ 反斜线 ` 反引号 * 星号 _ 下划线 {} 大括号 [] 中括号 () 小括号 # 井号 + 加号 - 减号（连字符） . 句点 ! 感叹号 持续更新…","categories":[{"name":"markdown","slug":"markdown","permalink":"http://pythonfood.github.io/categories/markdown/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://pythonfood.github.io/tags/markdown/"}]},{"title":"hexo","slug":"hexo","date":"2017-12-26T01:00:00.000Z","updated":"2018-05-11T06:31:23.859Z","comments":true,"path":"2017/12/26/hexo/","link":"","permalink":"http://pythonfood.github.io/2017/12/26/hexo/","excerpt":"hexo常用命令笔记。","text":"hexo常用命令笔记。 一、安装npm install hexo -g 二、升级npm update hexo -g 三、初始化hexo init 四、显示Hexo版本号hexo version 五、新建文章hexo n &quot;postName&quot; hexo new &quot;postName&quot; 六、生成静态文件hexo g hexo generate 七、启动本地服务hexo s hexo server hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP 八、部署hexo d hexo deploy 九、草稿hexo p hexo publish [layout] &lt;title&gt; 十、列出网站资料hexo list &lt;type&gt; 十一、清除db.json和publichexo clean 十二、新建页面hexo new page &quot;pageName&quot; 持续更新…","categories":[{"name":"hexo","slug":"hexo","permalink":"http://pythonfood.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://pythonfood.github.io/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-12-25T07:31:56.646Z","updated":"2017-12-25T07:31:56.646Z","comments":true,"path":"2017/12/25/hello-world/","link":"","permalink":"http://pythonfood.github.io/2017/12/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}