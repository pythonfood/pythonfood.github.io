<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PythonFood</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://pythonfood.github.io/"/>
  <updated>2018-05-11T06:59:51.195Z</updated>
  <id>http://pythonfood.github.io/</id>
  
  <author>
    <name>Python Food</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>持续集成-jenkins</title>
    <link href="http://pythonfood.github.io/2018/05/01/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90-jenkins/"/>
    <id>http://pythonfood.github.io/2018/05/01/持续集成-jenkins/</id>
    <published>2018-05-01T04:00:00.000Z</published>
    <updated>2018-05-11T06:59:51.195Z</updated>
    
    <content type="html"><![CDATA[<p>持续集成jenkins使用笔记。<br><a id="more"></a></p><h2 id="一、持续集成流程"><a href="#一、持续集成流程" class="headerlink" title="一、持续集成流程"></a>一、持续集成流程</h2><p>(1)提交代码<br>(2)拉取代码<br>(3)编译<br>(4)打包<br>(5)配置<br>(6)测试<br>(7)反馈问题<br>(8)开发处理<br>(9)回到(1)</p><h2 id="二、持续集成工具"><a href="#二、持续集成工具" class="headerlink" title="二、持续集成工具"></a>二、持续集成工具</h2><p>(1)代码管理工具：</p><blockquote><p>Git：官网下载安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a><br>GitHub：官网地址<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></p></blockquote><p>(2)集成工具：</p><blockquote><p>Jenkins：官网下载安装<a href="https://jenkins.io/download/" target="_blank" rel="noopener">https://jenkins.io/download/</a><br>1)安装后会自动启动浏览器，输入<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a><br>2)根据页面中标红路径找到管理员密码吗<br>3)输入管理员密码，点击【Continue】<br>4)安装插件，默认选项即可<br>5)安装完需要创建用户，此处点击【Continue as admin】使用默认账户即可<br>6)点击【Start using Jekins】启动<br>7)修改密码，进入【admin-设置】，向上拉找到密码处即可修改</p></blockquote><h2 id="三、Jenkins系统配置"><a href="#三、Jenkins系统配置" class="headerlink" title="三、Jenkins系统配置"></a>三、Jenkins系统配置</h2><p>(1)插件管理：</p><blockquote><p>1)进入【系统管理-管理插件-已安装】查看下面插件：</p><blockquote><ul><li>Git Plugin</li><li>GitHub Plugin</li><li>Gradle Plugin</li><li>Android Emulator Plugin</li></ul></blockquote><p>2)未安装的进入【可选插件】里安装即可</p></blockquote><p>(2)Gradle配置：</p><blockquote><p>1)进入【系统管理-全局工具配置】找到【Gradle安装】<br>2)点击【新增Gradle】<br>3)选择自动安装，名称输入和版本一致即可<br>4)再点击【Apply】-【Save】</p></blockquote><p>(3)GitHub配置：</p><blockquote><p>1)进入【系统管理-系统设置】找到【GitHub】<br>2)点击【Add GitHub Server】<br>3)在【GitHub Server】的【API URL】输入(<a href="https://api.github.com" target="_blank" rel="noopener">https://api.github.com</a>)<br>4)再点击【Credentials】右侧的问号设置权限，展开的内容里右键点击【personal access token】新窗口打开github<br>5)在github页面【Token description】输入自定义名称,勾选【repo】,点击【Generate token】<br>6)在github页面生成Personal access tokens后复制<br>7)回到jenkins页面点击【add】-【jenkins】<br>8)在弹出窗口里【Kind】类别选择【Secret text】,将刚才复制的token粘贴到【Secret】，再点击【add】就创建了身份信息<br>9)可以点击【Test connection】验证一下，验证通过后点击【保存】</p></blockquote><h2 id="四、Jenkins-JOB配置"><a href="#四、Jenkins-JOB配置" class="headerlink" title="四、Jenkins JOB配置"></a>四、Jenkins JOB配置</h2><p>创建任务：</p><blockquote><p>1)点击页面中【创建一个新任务】<br>2)输入任务名称，选择【构建一个自由风格的软件项目】，点击【确定】进入设置界面<br>3)进行自定义配置后点击【保存】</p></blockquote><h2 id="五、JOB配置小示例"><a href="#五、JOB配置小示例" class="headerlink" title="五、JOB配置小示例"></a>五、JOB配置小示例</h2><p>进入创建的任务详情界面，点击【配置】进行job配置<br>(1)拉取代码：</p><blockquote><p>1)【源码管理】选择【Git】，输入代码库的URL地址<br>2)点击【Add】-【jenkins】配置github权限<br>3)弹出界面输入github的帐户名和密码，点击【Add】添加<br>4)【Credentials】选择刚添加的github账户</p></blockquote><p>(2)编译、打包：</p><blockquote><p>1)【构建】点击【增加构建步骤】<br>2)选择【Invoke Gradle script】<br>3)【Gradle Version】选择对应版本<br>4)【Tasks】填写“build”等信息</p></blockquote><p>(3)配置：</p><blockquote><p>1)【构建】点击【增加构建步骤】<br>2)选择【Install Android package】<br>3)【APK file】填写生成的apk路径（此处可以先生构建一次4)查看路径，再复制到这里）<br>5)勾选【Uninstall existing APK first】</p></blockquote><p>(4)测试：</p><blockquote><p>1)【构建】点击【增加构建步骤】<br>2)选择【Run Android monkey tester】<br>3)【Package IDs】输入包名<br>4)【Event count】输入执行次数<br>5)【Delay between events】输入间隔时间ms<br>6)点击【Apply】,点击【保存】</p></blockquote><p>(5)立即构建：</p><blockquote><p>1)进入创建的任务详情界面<br>2)点击【立即构建】进行构建<br>3)点击构建的任务可以查看详情<br>4)【Console Output】可以查看日志信息</p></blockquote><p>(6)定时构建：</p><blockquote><p>1)进入创建的任务详情界面<br>2)点击【配置】进行job配置<br>3)【构建触发器】下选择【Build periodically】<br>4)【日程表】里输入规则，例如“H/15 <em> </em> <em> </em>”(每15分钟构建一次)<br>5)点击【日程表】右侧问号，可以查看规则描述<br>6)点击【Apply】,点击【保存】</p></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;持续集成jenkins使用笔记。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="持续集成" scheme="http://pythonfood.github.io/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    
      <category term="jenkins" scheme="http://pythonfood.github.io/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>unittest测试框架</title>
    <link href="http://pythonfood.github.io/2018/05/01/unittest%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    <id>http://pythonfood.github.io/2018/05/01/unittest测试框架/</id>
    <published>2018-05-01T01:00:00.000Z</published>
    <updated>2018-05-11T06:59:06.744Z</updated>
    
    <content type="html"><![CDATA[<p>unittest中最核心的四个概念是：test fixture, test case, test suite, test runner。<br><a id="more"></a></p><h2 id="一、unittest框架"><a href="#一、unittest框架" class="headerlink" title="一、unittest框架"></a>一、unittest框架</h2><p>(1)Test Fixture</p><ul><li>setup()</li><li>testcase()</li><li>teardown()</li></ul><p>(2)Test Case<br>(3)Test Suite<br>(4)Test Runner</p><h2 id="二、unittest小示例"><a href="#二、unittest小示例" class="headerlink" title="二、unittest小示例"></a>二、unittest小示例</h2><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import unittestdemo1</span><br><span class="line">import unittestdemo2</span><br><span class="line">import unittest</span><br><span class="line">from appium import webdriver</span><br><span class="line"></span><br><span class="line">class MyTestCase(unittest.TestCase):</span><br><span class="line">#初始化setup</span><br><span class="line">def setUp(self):</span><br><span class="line">desired_caps=&#123;&#125;</span><br><span class="line">        desired_caps[&apos;platformName&apos;]=&apos;Android&apos;</span><br><span class="line">        desired_caps[&apos;platformVersion&apos;]=&apos;5.1.1&apos;</span><br><span class="line">        desired_caps[&apos;deviceName&apos;]=&apos;61f9c06a&apos;</span><br><span class="line">        desired_caps[&apos;appPackage&apos;]=&apos;com.android.contacts&apos;</span><br><span class="line">        desired_caps[&apos;appActivity&apos;]=&apos;com.android.contacts.DialtactsContactsEntryActivity&apos;</span><br><span class="line">        desired_caps[&apos;unicodeKeyboard&apos;]=&apos;true&apos;</span><br><span class="line">        desired_caps[&apos;resetKeyboard&apos;]=&apos;true&apos;</span><br><span class="line">        self.driver = webdriver.Remote(&apos;http://127.0.0.1:4723/wd/hub&apos;, desired_caps)</span><br><span class="line"></span><br><span class="line">#测试用例1</span><br><span class="line">def test_something(self):</span><br><span class="line">self.assertEqual(False, True)</span><br><span class="line">print(&apos;test_something&apos;)</span><br><span class="line">#测试用例2</span><br><span class="line">def test_anything(self):</span><br><span class="line">self.assertEqual(True, True)</span><br><span class="line">print(&apos;test_anything&apos;)</span><br><span class="line"></span><br><span class="line">#释放资源teardown</span><br><span class="line">def tearDown(self):</span><br><span class="line">self.driver.quit()</span><br><span class="line"></span><br><span class="line">if __name__ ==&quot;__main__&quot;:</span><br><span class="line">#以类的形式添加测试用例</span><br><span class="line">cases1 = unittest.TestLoader().loadTestsFromTestCase(unittestdemo1.MyTestCase)</span><br><span class="line">cases2 = unittest.TestLoader().loadTestsFromTestCase(unittestdemo2.MyTestCase)</span><br><span class="line">#定义suite</span><br><span class="line">suite = unittest.TestSuite([cases1, cases2])</span><br><span class="line">#以单条测试用例形式装载</span><br><span class="line">    suite.addTest(MyTestCase(&apos;test_something&apos;))</span><br><span class="line">suite.addTest(MyTestCase(&apos;test_anything&apos;))</span><br><span class="line">    </span><br><span class="line">#定义runner</span><br><span class="line">    runner = unittest.TextTestRunner(verbosity=2)</span><br><span class="line">#用runner执行suite</span><br><span class="line">    runner.run(suite)</span><br></pre></td></tr></table></figure></blockquote><h2 id="三、DDT数据驱动模式"><a href="#三、DDT数据驱动模式" class="headerlink" title="三、DDT数据驱动模式"></a>三、DDT数据驱动模式</h2><p>(1)官网下载安装：<a href="https://pypi.python.org/pypi/ddt" target="_blank" rel="noopener">https://pypi.python.org/pypi/ddt</a><br>(2)使用前导入模块<code>from ddt import ddt,data,unpack</code><br>(3)首先说明测试类使用的是ddt测试框架：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@ddt</span><br><span class="line">class MyTestCase(unittest.TestCase)</span><br></pre></td></tr></table></figure></blockquote><p>(4)数据驱动主要是解决带参数的测试用例：<br>1）使用元组存放测试的数据，一个参数的情况：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@data(1,-3,2,0)</span><br><span class="line">def testcase(self, value):</span><br></pre></td></tr></table></figure></blockquote><p>2）使用元组存放测试的数据，多个参数的情况：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@data((3,2),(4,3),(5,3))</span><br><span class="line">@unpack</span><br><span class="line">def testcase(self, value1, value2):</span><br></pre></td></tr></table></figure></blockquote><h2 id="四、DDT小示例"><a href="#四、DDT小示例" class="headerlink" title="四、DDT小示例"></a>四、DDT小示例</h2><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from ddt import ddt,data,unpack</span><br><span class="line"></span><br><span class="line">@ddt</span><br><span class="line">class MyTestCase(unittest.TestCase):</span><br><span class="line"></span><br><span class="line">@data(1,2,3)</span><br><span class="line">def test_something(self, value):</span><br><span class="line">print(value)</span><br><span class="line">self.assertEqual(value, 2)</span><br><span class="line"></span><br><span class="line">@data((1,2),(2,3))</span><br><span class="line">@unpack</span><br><span class="line">def test_anything(self, value1, value2):</span><br><span class="line">print(value1,value2)</span><br><span class="line">self.assertEqual(value2, value1+1)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">unittest.main()</span><br></pre></td></tr></table></figure></blockquote><p>ps:使用ddt框架后，测试用例的名称会改变，所以装载Test Suite时不能使用单条测试用例装载了，尽量使用类的形式装载Test Suite。</p><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;unittest中最核心的四个概念是：test fixture, test case, test suite, test runner。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="测试框架" scheme="http://pythonfood.github.io/categories/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="unittest" scheme="http://pythonfood.github.io/tags/unittest/"/>
    
  </entry>
  
  <entry>
    <title>接口测试-python</title>
    <link href="http://pythonfood.github.io/2018/04/01/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95-python/"/>
    <id>http://pythonfood.github.io/2018/04/01/接口测试-python/</id>
    <published>2018-04-01T04:00:00.000Z</published>
    <updated>2018-05-11T06:58:28.813Z</updated>
    
    <content type="html"><![CDATA[<p>接口测试python实现脚本测试笔记。<br><a id="more"></a></p><h2 id="一、requests模块"><a href="#一、requests模块" class="headerlink" title="一、requests模块"></a>一、requests模块</h2><p>(1)安装<code>pip install requests</code><br>(2)使用前导入<code>import requests</code></p><h2 id="二、GET请求ddt自动化"><a href="#二、GET请求ddt自动化" class="headerlink" title="二、GET请求ddt自动化"></a>二、GET请求ddt自动化</h2><p>(1)代码结构：</p><blockquote><p>1)构造Header<br>2)构造cookies<br>3)发送Get请求<br>4)获取返回值<br>5)对结果进行校验</p></blockquote><p>(2)代码示例：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line">import unittest</span><br><span class="line">import ddt</span><br><span class="line"></span><br><span class="line">@ddt.ddt</span><br><span class="line">class ApiTestClass(unittest.TestCase):</span><br><span class="line">    </span><br><span class="line">    @ddt.data(&apos;android&apos;,&apos;&apos;,&apos;ios&apos;)</span><br><span class="line">    def test_Get(self,os_phone):</span><br><span class="line">        #header部分配置</span><br><span class="line">        headers = &#123;&apos;User-Agent&apos;:&apos;Dalvik/1.6.0 (Linux; U; Android 4.3; Coolpad 8720L Build/JSS15Q)&apos;,</span><br><span class="line">                   &apos;Host&apos;:&apos;bdsp.x.jd.com&apos;,</span><br><span class="line">                   &apos;Connection&apos;:&apos;Keep-Alive&apos;,</span><br><span class="line">                   &apos;Accept-Encoding&apos;:&apos;gzip&apos;</span><br><span class="line">                   &#125;</span><br><span class="line">        </span><br><span class="line">        #cookies部分配置</span><br><span class="line">        cookies = dict(search_test = &apos;1&apos;)</span><br><span class="line">        </span><br><span class="line">        #get请求获得返回数据</span><br><span class="line">        res = requests.get(&apos;http://bdsp.x.jd.com/app/config?os=&apos;+os_phone+&apos;&amp;key=wx3ebc9e606b4f9242&amp;sdkv=5&apos;, </span><br><span class="line">                           headers = headers,</span><br><span class="line">                           cookies = cookies)</span><br><span class="line">        </span><br><span class="line">        print(res.text)</span><br><span class="line">        print(res.status_code)</span><br><span class="line">        </span><br><span class="line">        #测试点校验</span><br><span class="line">        self.assertTrue(&apos;15*1000&apos; in res.text)</span><br><span class="line">                      </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    cases = unittest.TestLoader().loadTestsFromTestCase(ApiTestClass)</span><br><span class="line">    suite = unittest.TestSuite([cases])</span><br><span class="line">    #suite.addTest(ApiTestClass(&apos;test_Get&apos;))</span><br><span class="line">    </span><br><span class="line">    runner = unittest.TextTestRunner()</span><br><span class="line">    runner.run(suite)</span><br></pre></td></tr></table></figure></blockquote><h2 id="三、POST请求ddt自动化"><a href="#三、POST请求ddt自动化" class="headerlink" title="三、POST请求ddt自动化"></a>三、POST请求ddt自动化</h2><p>(1)代码结构：</p><blockquote><p>1)构造Keyword(即request body)<br>2)构造Header<br>3)构造cookies<br>4)发送Get请求<br>5)获取返回值<br>6)对结果进行校验</p></blockquote><p>(2)代码示例：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import unittest</span><br><span class="line">import ddt</span><br><span class="line"></span><br><span class="line">@ddt.ddt</span><br><span class="line">class ApiTestClass(unittest.TestCase):</span><br><span class="line">    </span><br><span class="line">    @ddt.data((&apos;60.206.137.140&apos;,&apos;hjfwp9VflXZU3FsuM3cu6PBV&apos;),</span><br><span class="line">              (&apos;&apos;,&apos;&apos;)</span><br><span class="line">              )</span><br><span class="line">    @ddt.unpack</span><br><span class="line">    def test_Post(self,m_host,m_accessToken):</span><br><span class="line">        #header部分配置</span><br><span class="line">        headers = &#123;&apos;Content-Type&apos;:&apos;application/x-www-form-urlencoded&apos;,</span><br><span class="line">                   &apos;Content-Length&apos;:&apos;36&apos;,</span><br><span class="line">                   &apos;Host&apos;:m_host,</span><br><span class="line">                   &apos;Connection&apos;:&apos;Keep-Alive&apos;,</span><br><span class="line">                   &apos;Accept-Encoding&apos;:&apos;gzip&apos;,</span><br><span class="line">                   &apos;User-Agent&apos;:&apos;okhttp/3.8.1&apos;</span><br><span class="line">                   &#125;</span><br><span class="line">        </span><br><span class="line">        #cookies部分配置</span><br><span class="line">        cookies = dict(search_test = &apos;1&apos;)</span><br><span class="line">        </span><br><span class="line">        #data部分配置</span><br><span class="line">        keyword = &#123;&apos;accessToken&apos;:m_accessToken&#125;</span><br><span class="line">        </span><br><span class="line">        #post请求获得返回数据</span><br><span class="line">        res = requests.post(&apos;http://60.206.137.140/iot_api/family/queryFamilyList.json&apos;, </span><br><span class="line">                           headers = headers,</span><br><span class="line">                           cookies = cookies,</span><br><span class="line">                           data = keyword</span><br><span class="line">                           )</span><br><span class="line">        </span><br><span class="line">        print(res.text)</span><br><span class="line">        print(res.status_code)</span><br><span class="line">        </span><br><span class="line">        #测试点校验</span><br><span class="line">        self.assertTrue(&apos;北京市北京市&apos; in res.text)</span><br><span class="line">                      </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    cases = unittest.TestLoader().loadTestsFromTestCase(ApiTestClass)</span><br><span class="line">    suite = unittest.TestSuite([cases])</span><br><span class="line">    #suite.addTest(ApiTestClass(&apos;test_Post&apos;))</span><br><span class="line">    </span><br><span class="line">    runner = unittest.TextTestRunner()</span><br><span class="line">    runner.run(suite)</span><br></pre></td></tr></table></figure></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接口测试python实现脚本测试笔记。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="接口测试" scheme="http://pythonfood.github.io/categories/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="python" scheme="http://pythonfood.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>接口测试-jmeter</title>
    <link href="http://pythonfood.github.io/2018/04/01/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95-jmeter/"/>
    <id>http://pythonfood.github.io/2018/04/01/接口测试-jmeter/</id>
    <published>2018-04-01T03:00:00.000Z</published>
    <updated>2018-05-11T06:58:28.803Z</updated>
    
    <content type="html"><![CDATA[<p>接口测试jmeter工具使用笔记。<br><a id="more"></a></p><h2 id="一、jmeter安装"><a href="#一、jmeter安装" class="headerlink" title="一、jmeter安装"></a>一、jmeter安装</h2><p>1、<a href="https://pythonfood.github.io/2018/02/01/appium安装-windows/#1-安装jdk">安装java</a></p><p>2、安装jmeter</p><blockquote><p>(1)官网下载最新版zip包：<a href="http://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">http://jmeter.apache.org/download_jmeter.cgi</a><br>(2)解压下载的zip包到自定义路径即可，例如：<code>D:\Program Files\jmeter</code></p></blockquote><p>3、运行jmeter</p><blockquote><p>(1)进入jmeter解压路径的\bin路径下，例如：<code>D:\Program Files\jmeter\apache-jmeter-4.0\bin</code><br>(2)双击<code>jmeter.bat</code>即可运行jmeter。</p></blockquote><p>4、安装插件</p><blockquote><p>(1)下载 <code>plugins-manager.jar</code>：<a href="http://www.jmeter-plugins.org/get/" target="_blank" rel="noopener">http://www.jmeter-plugins.org/get/</a><br>(2)将下载的jar包放到jmeter路径的\lib\ext路径下，例如：<code>D:\Program Files\jmeter\apache-jmeter-4.0\lib\ext</code><br>(3)启动jmeter，菜单栏【选项】会多出一个【Plugins Manager】的选项。<br>(4)点击 【Plugins Manager】选项打开jmeter插件管理。</p><blockquote><ul><li>Installed Plugins：显示已安装的插件。</li><li>Available Plugins：显示可安装的插件。</li><li>Upgrades：显示可以升级的插件。</li></ul></blockquote><p>(5)通过”勾选/取消勾选”插件，并点击右下角【Apply Changes and Restart JMeter】按钮来卸载、安装、升级插件。</p></blockquote><h2 id="二、jmeter基础原件"><a href="#二、jmeter基础原件" class="headerlink" title="二、jmeter基础原件"></a>二、jmeter基础原件</h2><p><a href="http://jmeter.apache.org/usermanual/component_reference.html#introduction" target="_blank" rel="noopener">官方文档介绍</a></p><h3 id="1、测试计划"><a href="#1、测试计划" class="headerlink" title="1、测试计划"></a>1、测试计划</h3><p>Test Plan 是其它JMeter测试元件的容器，jmeter创建测试的所有内容是于基于一个计划的。<br><img src="/2018/04/01/接口测试-jmeter/测试计划.png" alt="测试计划"></p><p>除了测试计划下的元件还有两种控制器。<br><img src="/2018/04/01/接口测试-jmeter/控制器.png" alt="控制器"></p><h3 id="2、线程用户"><a href="#2、线程用户" class="headerlink" title="2、线程用户"></a>2、线程用户</h3><p>Threads （Users）是一个虚拟用户组，线程组内线程数量在运行过程中不会发生改变。<br><img src="/2018/04/01/接口测试-jmeter/线程用户.png" alt="线程用户"></p><p>(1)thread group(线程组)</p><blockquote><p>1) 名称：可以给线程组设置一个命名。<br>2) 注释：可以对线程组添加备注以标记。<br>3) 在取样器错误后要执行的动作：</p><blockquote><ul><li>继续执行后续的。</li><li>启动下一线程组循环。</li><li>停止线程。</li><li>停止测试。</li><li>立刻停止测试。</li></ul></blockquote><p>4) 线程数：即用户数，一个虚拟用户占用一个进程或线程，需要多少用户并发，设置多少虚拟用户数在这里也就是设置多少个线程数。<br>5) Ramp-Up Period(in seconds)准备时长：设置的虚拟用户数需要多长时间全部启动。如果线程数为100，准备时长为10，那么需要10秒钟启动100个线程，也就是每秒钟启动10个线程。<br>6) 循环次数：每个线程发送请求的次数。</p><blockquote><ul><li>如果线程数为20，循环次数为100，那么每个线程发送100次请求。总请求数为20*100=2000 。</li><li>如果勾选了“永远”，那么所有线程会一直发送请求，一到选择停止运行脚本。</li></ul></blockquote><p>7) Delay Thread creation until needed：直到需要时延迟线程的创建。<br>8) 调度器：可以设置线程组启动的开始时间和结束时间。实践结论是配置调度器时，需要设置循环次数为永远，防止因循环次数不够而终止压测。             </p><blockquote><ul><li>启动时间:测试计划什么时候启动，启动延迟会覆盖它。当启动时间已过，手动运行脚本时也当前时间也会覆盖它(但启动时间页面显示不会变)。</li><li>结束时间：测试计划什么时候结束，持续时间会覆盖它。</li><li>持续时间（秒）：测试计划持续多长时间，会覆盖结束时间。</li><li>启动延迟（秒）：测试计划延迟多长时间启动，会覆盖启动时间。</li></ul></blockquote></blockquote><h3 id="3、配置元件"><a href="#3、配置元件" class="headerlink" title="3、配置元件"></a>3、配置元件</h3><p>Config Element 用于提供对静态数据配置的支持。<br><img src="/2018/04/01/接口测试-jmeter/配置元件.png" alt="配置元件"></p><p>(1)CSV Data Set Config(csv数据文件设置)</p><blockquote><p>1) 名称：可以给元件一个命名。<br>2) 注释：可以对元件添加备注以标记。<br>3) Filename：所需数据文件的路径。如和脚本同一路径，可直接填写文件名<br>4) File encoding：编码和文件保持一致即可，默认为ANSI。如有中文，建议为UTF-8<br>5) Variable Names：引用变量时的变量名，对应数据文件中的每一列，以逗号分隔。如不填写，文件的第一行数据将被读取为变量名<br>6) Delimiter：在.txt、.dat文件中，可以用逗号（,）或者Tab键（\t）来区分列与列<br>7) Allow quoted data：True时，可以使用双引号来识别逗号或双引号（如数据文件中为 1,2,”3,”4”,5” ，则识别出的为A_1=1，B_1=2，C_1=3,”4”,5）<br>8) Recycle on EOF：到数据文件结尾时是否循环读取。设置为True时，线程数过多，数据文件读取到最后一行时，会再次从第一行开始读取。设置为False，到达文件结尾时如继续读取，则值会默认为<eof>，可通过设置jmeter属性csvdataset.eofstring来改变该值。<br>9) Stop thread on EOF：Recycle on EOF设置为False，Stop thread on EOF设置为True，则读取数据文件最后一行后，停止测试，不管还有多少线程组未执行。<br>10) Sharing mode：共享模式。默认在所有线程组中使用，可选择每个线程组单独打开</eof></p><blockquote><ul><li>All threads:文件在所有线程间共享</li><li>Current thread group: 每个文件会针对每个线程组打开一次</li><li>Current thread: 每个文件会针对每个线程单独打开</li><li>Identifier:所有线程共享相同的标识，共享相同的文件。如有４个线程组，测试人员可以使用一个通用ＩＤ，以便在两个或多个线程组之间共享文件。</li></ul></blockquote></blockquote><h3 id="4、监听器"><a href="#4、监听器" class="headerlink" title="4、监听器"></a>4、监听器</h3><p>Listener 是用来对测试结果数据进行处理和可视化展示的一系列元件。<br><img src="/2018/04/01/接口测试-jmeter/监听器.png" alt="监听器"></p><p>(1)View Results in Table(察看结果树)</p><blockquote><p>1) 名称：可以给元件一个命名。<br>2) 注释：可以对元件添加备注以标记。<br>3) 所有数据写入一个文件：提供结果保存功能。保存信息可勾选配置。<br>4) Text下拉列表：用来显示不同的取样器请求，默认Text方式显示。<br>5) 取样器结果：显示取样器运行结果。<br>6) 请求：显示请求表单内容，不同取样器会有不同显示格式。<br>7) 响应数据：显示服务器响应数据，同时还提供查询功能。</p></blockquote><p>(2)Aggregate Report(聚合报告)</p><blockquote><p>1) 名称：可以给元件一个命名。<br>2) 注释：可以对元件添加备注以标记。<br>3) 所有数据写入一个文件：提供结果保存功能。保存信息可勾选配置。<br>4) Label： 请求的名称，就是我们在进行测试的httprequest sampler的名称<br>5) Samples： 总共发给服务器的请求数量<br>6) Average： 单个请求的平均响应时间，单位是毫秒<br>7) Median： 50%的请求的响应时间<br>8) 90%Line： 90%的请求的响应时间<br>9) 95%Line： 95%的请求的响应时间<br>10) 99%Line： 99%的请求的响应时间<br>11) Min： 最小的响应时间<br>12) Max： 最大的响应时间<br>13) Error%： 错误率=错误的请求的数量/请求的总数<br>14) Throughput： 吞吐量即表示每秒完成的请求数<br>15) Received KB/sec： 每秒从服务器端接收到的数据量<br>16) Sent KB/Sec： 每秒从发送到服务器端的数据量</p></blockquote><h3 id="5、定时器"><a href="#5、定时器" class="headerlink" title="5、定时器"></a>5、定时器</h3><p>Timer 用于操作之间设置等待时间，等待时间是性能测试中常用的控制客户端QPS的手段。<br><img src="/2018/04/01/接口测试-jmeter/定时器.png" alt="定时器"></p><p>(1)Constant Timer(固定定时器)</p><blockquote><p>1) 名称：可以给元件一个命名。<br>2) 注释：可以对元件添加备注以标记。<br>3) 线程延迟（毫秒）：让每个线程在请求之前按相同的指定时间停顿。需要注意的是，固定定时器的延时不会计入单个sampler的响应时间，但会计入事务控制器的时间。</p></blockquote><h3 id="6、前置处理器"><a href="#6、前置处理器" class="headerlink" title="6、前置处理器"></a>6、前置处理器</h3><p>Pre Processors 用于在实际的请求发出之前对即将发出的请求进行特殊处理。<br><img src="/2018/04/01/接口测试-jmeter/前置处理器.png" alt="前置处理器"></p><p>(1)User Parameters(用户参数)</p><blockquote><p>1) 名称：可以给元件一个命名。<br>2) 注释：可以对元件添加备注以标记。<br>3) 每次迭代更新一次：如果选中该选项，则参数的值在每个迭代中保持不变，在新的迭代开始时取下一个值。如果取消该选项，则参数值在每个在其作用域内的sampler发出请求时取下一个可用值。<br>4) 添加变量<br>5) 添加用户<br>6) 删除变量<br>7) 删除用户<br>8) UP：向上移动<br>9) down: 向下移动</p></blockquote><h3 id="7、后置处理器"><a href="#7、后置处理器" class="headerlink" title="7、后置处理器"></a>7、后置处理器</h3><p>Post Processors 用于对Sampler发出请求后得到的服务器响应进行处理。一般用来提取响应中的特定数据。<br><img src="/2018/04/01/接口测试-jmeter/后置处理器.png" alt="后置处理器"></p><p>(1)JSON Extractor(json提取器)</p><blockquote><p>1) 名称：可以给元件一个命名。<br>2) 注释：可以对元件添加备注以标记。<br>3) Apply to：Sampler可能会产生子Sampler，这里需要选择从哪个Sampler中进行提取。</p><blockquote><ul><li>Main sample and sub-samples:作用于父节点的取样器及对应子节点的取样器</li><li>Main sample only：仅作用于父节点的取样器</li><li>Sub-samples only:仅作用于子节点的取样器</li><li>JMeter Variable:作用于jmeter变量(输入框内可输入jmeter的变量名称)</li></ul></blockquote><p>4) Variable Names：变量名。例如:status<br>5) JSON Path Expressions： Json提取表达式。例如:$.status<br>6) Match No. (0 for Random)：当提取有多个结果值时，选择需要的值保存到变量中，默认值为0</p><blockquote><ul><li>0：随机一个</li><li>-1：全部值，使用_N 方式保存（N从1开始），比如status_1,status_2…</li><li>X: 自然数，比如1，返回第X个值（如果X大于返回值的数量，结果会不能获取，最终返回设置的默认值）</li></ul></blockquote><p>7) Compute concatenation var：如果有匹配到多个值，选择此项，会将全部值保存到_ALL，并使用逗号分割每个值。Match No. (0 for Random)需要为-1才有效，不然只能匹配到一个值了。<br>8) Default Value： 缺省值</p></blockquote><h3 id="8、断言"><a href="#8、断言" class="headerlink" title="8、断言"></a>8、断言</h3><p>Assertions 断言用于检查测试中得到的相应数据等是否符合预期，断言一般用来设置检查点。<br><img src="/2018/04/01/接口测试-jmeter/断言.png" alt="断言"></p><p>(1)Response Assertion(响应断言)</p><blockquote><p>1) 名称：可以给元件一个命名。<br>2) 注释：可以对元件添加备注以标记。<br>3) Apply to：Sampler可能会产生子Sampler，这里需要选择从哪个Sampler中进行提取。</p><blockquote><ul><li>Main sample and sub-samples:作用于父节点的取样器及对应子节点的取样器</li><li>Main sample only：仅作用于父节点的取样器</li><li>Sub-samples only:仅作用于子节点的取样器</li><li>JMeter Variable:作用于jmeter变量(输入框内可输入jmeter的变量名称)</li></ul></blockquote><p>4)要测试的响应字段：要检查的项。</p><blockquote><ul><li>响应报文</li><li>Documeng(text)：测试文件</li><li>URL样本</li><li>响应代码</li><li>响应信息</li><li>Response Headers:响应头部</li><li>Ignore status：忽略返回的响应报文状态码</li></ul></blockquote><p>5) 模式匹配规则：</p><blockquote><ul><li>包括：返回结果包括你指定的内容</li><li>匹配：（好像跟Equals查不多，弄不明白有什么区别）   </li><li>Equals：返回结果与你指定结果一致</li><li>Substring：返回结果是指定结果的字串</li><li>否：不进行匹配</li></ul></blockquote><p>6) 要测试的模式:即填写你指定的结果（可填写多个）,按钮【添加】、【删除】是进行指定内容的管理</p></blockquote><h3 id="9、测试片段"><a href="#9、测试片段" class="headerlink" title="9、测试片段"></a>9、测试片段</h3><p>Test Fragment 是控制器上的一个种特殊的线程组，它在测试树上与线程组处于一个层级。它与线程组有所不同，因为它不被执行，除非它是一个模块控制器或者是被控制器所引用时才会被执行。<br><img src="/2018/04/01/接口测试-jmeter/测试片段.png" alt="测试片段"></p><p>(1)Test Fragment(测试片段)</p><blockquote><p>1) 名称：可以给元件一个命名。<br>2) 注释：可以对元件添加备注以标记。</p></blockquote><h3 id="10、非测试元件"><a href="#10、非测试元件" class="headerlink" title="10、非测试元件"></a>10、非测试元件</h3><p>Non-Test Elements 提供http镜像服务、http代理服务、属性显示等功能。<br><img src="/2018/04/01/接口测试-jmeter/非测试元件.png" alt="非测试元件"></p><p>1)Property Display(属性显示)</p><blockquote><p>1) 名称：可以给元件一个命名。<br>2) 注释：可以对元件添加备注以标记。<br>3) System：系统变量。<br>4) Jmeter Properties：jmeter变量。</p></blockquote><h3 id="11、取样器"><a href="#11、取样器" class="headerlink" title="11、取样器"></a>11、取样器</h3><p>Sampler 是测试中向服务器发送请求，记录响应信息，记录响应时间的最小单元。<br><img src="/2018/04/01/接口测试-jmeter/取样器.png" alt="取样器"></p><p>(1)HTTP Sampler(HTTP取样器)</p><blockquote><p>1) 名称：可以给元件一个命名。<br>2) 注释：可以对元件添加备注以标记。<br>3) 协议：向目标服务器发送http请求时的协议，http/https，大小写不敏感，默认http.<br>4) 服务器名称或IP：http请求发送的目标服务器名称或者IP地址。<br>5) 端口号：目标服务器的端口号，默认值为80，可不填<br>6) 方法：发送http请求的方法</p><blockquote><ul><li>GET：向特定的资源发出请求。</li><li>POST：向指定资源提交数据进行处理请求。</li><li>HEAD：获得报文首部</li><li>PUT：向指定资源位置上传其最新内容。</li><li>OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。</li><li>TRACE：追踪路径，回显服务器收到的请求，主要用于测试或诊断。</li><li>DELETE：请求服务器删除Request-URI所标识的资源。</li><li>PATCH：实体中包含一个表，表中说明与该URI所表示的原内容的区别。 </li></ul></blockquote><p>7) 路径：目标的URL路径（不包括服务器地址和端口）<br>8) Content encoding：内容的编码方式（Content-Type=application/json;charset=utf-8）<br>9) 自动重定向：发出的http请求得到响应是301/302，jmeter会重定向到新的界面<br>10) 跟随重定向：响应Code是3XX时，自动跳转至目标地址。JMeter会记录重定向过程中的所有请求响应。<br>11) Use keep Alive：jmeter 和目标服务器之间使用 Keep-Alive方式进行HTTP通信（默认选中）。<br>12) Use multipart/from-data for HTTP POST ：当发送HTTP POST 请求时使用。<br>13) browser-compatible headers：浏览器兼容请求头。<br>14) Parameters：xx=xx&amp;xxx=xx格式的参数为GET或者POST请求中，url中带的参数值。</p><blockquote><ul><li>Encode?：参数有“=”、“&amp;”、“？”等特殊符号时选择。</li><li>Include Equals：自动添加参数名和值之间的等号。</li></ul></blockquote><p>15) Body Data：json格式的是POST请求中的参数<br>16) Files Upload：发出HTTP请求并获得响应的HTML文件内容后还对该HTML进行Parse，并获取HTML中包含的所有资源（图片、flash等）：（默认不选中）<br>17) Implementation:执行</p><blockquote><ul><li>Java：使用的http是使用的JAVA JVM提供的方法，有相关的限制。</li><li>HttpClient4：使用Apache HttpClient 4.1部件</li><li>空白：使用HTTP默认请求中的配置或jmeter.properties中jmeter.httpsample中的配置</li></ul></blockquote><p>18) Timeouts：超时</p><blockquote><ul><li>Connect：连接</li><li>Response：响应</li></ul></blockquote><p>19) Embedded Resources from HTML Files：解析HTML文件并发送所有资源请求(包括图片，java小程序，JS，CSS等)</p><blockquote><ul><li>从HTML文件获取所有内含的资源</li><li>Parallel downloads.Number：并行下载.数量</li><li>URLs must match：URL需匹配</li></ul></blockquote><p>20) Source address：IP欺骗，指定请求要用到的本地地址（参数化）。<br>21) Proxy Server：代理相关设置</p><blockquote><ul><li>服务器名称或IP</li><li>端口号</li><li>用户名</li><li>密码</li></ul></blockquote><p>22)Save response as MD5 hash?：在执行时仅记录服务端响应数据的MD5值，而不记录完整的响应数据。在需要进行数据量非常大的测试时，建议选中该项以减少取样器记录响应数据的开销。</p></blockquote><h3 id="12、逻辑控制器"><a href="#12、逻辑控制器" class="headerlink" title="12、逻辑控制器"></a>12、逻辑控制器</h3><p>Logic Controller 用来控制采样器的执行顺序。分为两类：一种是控制采样器的逻辑执行顺序，如Loop Controller、If Controller等；一种是对采样器进行分组，方便控制的，如Throughput Controller、Transaction Controller等。<br><img src="/2018/04/01/接口测试-jmeter/逻辑控制器.png" alt="逻辑控制器"></p><p>(1)Loop Controller(循环控制器)</p><blockquote><p>1) 名称：可以给元件一个命名。<br>2) 注释：可以对元件添加备注以标记。<br>3) Loop Count：循环次数<br>4) Forever：永远循环</p></blockquote><p>(2)ForEach Controller(遍历循环控制器)</p><blockquote><p>1) 名称：可以给元件一个命名。<br>2) 注释：可以对元件添加备注以标记。<br>3) 输入变量前缀：在其中输入需要遍历的用户参数（User Parameter）<br>4) Start index for loop(exclusive）：循环指数开始（唯一）→ 遍历查询的变量范围，开始的值（这里如果不填写，默认从1开始，如果没有1开始的变量，执行时会报错）<br>5) End index for loop(inclusive）：循环指数结束（包含）→ 遍历查询的变量范围，结束的值<br>6) 输出变量名称：将遍历查询到的符合条件的用户参数赋值给输入变量（Vname），然后就可以在控制器下的取样器使用，格式为${输出变量名}<br>7) Add”<em>”before number：输入变量名称中是否使用“</em>”进行间隔</p></blockquote><p>(3)Switch Controller(转换控制器)</p><blockquote><p>1) 名称：可以给元件一个命名。<br>2) 注释：可以对元件添加备注以标记。<br>3) Switch value：控制器具体赋值的value值字段。当Value为空时，默认执行第1个子节点元素。</p><blockquote><ul><li>第一种：是数值，Switch控制器下的子节点从0开始计数，通过指定子节点所在的数值来确定执行哪个元素。</li><li>第二种：是直接指定子元素的名称，比如采样器的Name来进行匹配。当指定的名称不存在时，不执行任何元素。</li></ul></blockquote></blockquote><p>(4)While Controller(while条件控制器)</p><blockquote><p>1) 名称：可以给元件一个命名。<br>2) 注释：可以对元件添加备注以标记。<br>3) Condition(function or variable):条件（函数或变量）。需要注意的是：条件是评估两次,一次取样前,一次随机取样。里面可填入判断依据的条件，可能的条件值有：</p><blockquote><ul><li>空白：最后一个示例循环失败时退出循环。</li><li>最后一个值：最后一个示例循环失败时退出循环。 如果之前的最后一个示例只是循环失败,不进入循环。</li><li>否则：退出时(或不输入)循环条件等于字符串“ 假 ”</li></ul></blockquote></blockquote><p>(5)If Controller(IF控制器)</p><blockquote><p>1) 名称：可以给元件一个命名。<br>2) 注释：可以对元件添加备注以标记。<br>3) Condition(default javascript)（条件（默认JavaScript））:使用JavaScript的函数或变量进行评估判断条件为真或假<br>4) interpret condition as variable expression（条件解释为变量表达式）:如果勾选该项，那么变量表达式会进行求值，并与“ture”或“false”进行比较，而无需使用JavaScript<br>5) evaluate for all children（对所有子条件执行）:如果勾选该项，则该controller在没一个子节点执行时执行一次；</p></blockquote><p>(6)Module Controller(模块控制器)</p><blockquote><p>1) 名称：可以给元件一个命名。<br>2) 注释：可以对元件添加备注以标记。<br>3) Find target element(寻找目标元素)：寻找测试计划中需要特定测试的元素，模块；也可理解为该控制器可以控制已经封装好的模块元素。</p></blockquote><p>(7)Simple Controller(简单控制器)</p><blockquote><p>1) 名称：可以给元件一个命名。<br>2) 注释：可以对元件添加备注以标记。</p></blockquote><h2 id="三、原件作用域和顺序"><a href="#三、原件作用域和顺序" class="headerlink" title="三、原件作用域和顺序"></a>三、原件作用域和顺序</h2><h3 id="1、元件的作用域"><a href="#1、元件的作用域" class="headerlink" title="1、元件的作用域"></a>1、元件的作用域</h3><p>jmeter中共有8类可被执行的元件（test plan和thread group不属于元件）。<br>其中：sampler（取样器）是不与其他元件发生交互的作用的元件，Logic Controller（逻辑控制器）只对其子节点的sampler有效，而其他元件需要与sampler等元件交互。</p><blockquote><p>1）Config Elements（配置元件）：影响其范围内的所有元件<br>2）Pre-porcessors（前置处理器）：在其作用范围内的每一个sampler元件之前执行<br>3）Timer（定时器）：对其作用范围内的每一个sampler有效<br>4）Post-porcessors（后置处理器）：在其作用范围内的每一个sampler元件之后执行<br>5）Assirtions（断言）：对其作用范围内的每一个sampler元件执行后的结果执行校验<br>6）Listener（监听器）：收集其作用范围内的每一个sampler元件的信息并且呈现出来</p></blockquote><p>在jmeter中，元件的作用域是靠test plan的树形结构中元件的父子关系来确定的，其原则如下：</p><blockquote><p>1） sampler（取样器）不与其他元件相互作用，因此不存在作用域问题<br>2） Logic Controller（逻辑控制器）只对其子节点中的sampler和Logic Controller作用<br>3） 除sampler和Logic Controller外的其他元件，如果是某个sampler的子节点，则该元件仅对其父节点作用<br>4） 除sampler和Logic Controller外的其他元件，如果其父节点不是sampler，则其作用域是该元件父节点下的其他所有后带节点（包括子节点，子节点的子节点等）</p></blockquote><h3 id="2、元件的执行顺序"><a href="#2、元件的执行顺序" class="headerlink" title="2、元件的执行顺序"></a>2、元件的执行顺序</h3><p>在同一作用域范围内，test plan中的元件按照以下顺序执行：</p><blockquote><p>1） Config Elements（配置元件）<br>2） Pre-porcessors（前置处理器）<br>3） Timer（定时器）<br>4） Sampler（取样器）<br>5） Post-porcessors（后置处理器）（除非Sampler得到的返回结果为空）<br>6） Assirtions（断言）（除非Sampler得到的返回结果为空）<br>7） Listener（监听器）（除非Sampler得到的返回结果为空）</p></blockquote><p>PS:Pre-porcessors、Post-porcessors和Assirtions等元件仅对Sampler作用，如在它们作用域内没有任何Sampler，则不会被执行；如果在同一作用域范围内有多个同一类型的元件，则这些元件按照它们在test plan中的上下顺序依次执行。</p><h2 id="四、jmeter运行模式"><a href="#四、jmeter运行模式" class="headerlink" title="四、jmeter运行模式"></a>四、jmeter运行模式</h2><p>1、GUI模式<br>GUI打开已有的jmx文件，点击启动按钮运行 。</p><p>2、命令行模式<br>(1)依赖：<br>配置jmeter环境变量（windows下为将${jmeterhome}/bin加入Path变量）。<br>如果未加入环境变量，在执行的时候可以直接给出全路径或在${jmeterhome}/bin下执行。</p><p>(2)命令：<br><code>jmeter -n -t &lt;testplan filename&gt; -l &lt;listener filename&gt;</code></p><ul><li>-h 帮助 -&gt; 打印出有用的信息并退出 </li><li>-n 非 GUI 模式 -&gt; 在非 GUI 模式下运行 JMeter </li><li>-t 测试文件 -&gt; 要运行的 JMeter 测试脚本文件 </li><li>-l jtl文件 -&gt; 记录结果的文件 </li><li>-r 远程执行 -&gt; 启动远程服务 </li><li>-H 代理主机 -&gt; 设置 JMeter 使用的代理主机 </li><li>-P 代理端口 -&gt; 设置 JMeter 使用的代理主机的端口号 </li><li>-j 日志文件-&gt;设置JMeter日志文件的名称 </li></ul><p>(3)实例：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JMeter -n -t my_test.jmx -l log.jtl -H my.proxy.server -P 8000</span><br></pre></td></tr></table></figure></blockquote><p>(4)执行步骤：<br>jmeter默认去当前目录寻找脚本文件，并把日志记录在当前目录。比如你在 C:\tools\apache-jmeter-4.0\bin 目录下执行以上命令，jmeter会去该目录下寻找test.jmx脚本并把执行结果放在该目录。<br>如果你的脚本在其他目录，而且想要把执行结果放在另外文件夹，可以使用绝对路径告诉jmeter。</p><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接口测试jmeter工具使用笔记。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="接口测试" scheme="http://pythonfood.github.io/categories/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="jmeter" scheme="http://pythonfood.github.io/tags/jmeter/"/>
    
  </entry>
  
  <entry>
    <title>接口测试-postman</title>
    <link href="http://pythonfood.github.io/2018/04/01/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95-postman/"/>
    <id>http://pythonfood.github.io/2018/04/01/接口测试-postman/</id>
    <published>2018-04-01T02:00:00.000Z</published>
    <updated>2018-05-11T06:58:28.803Z</updated>
    
    <content type="html"><![CDATA[<p>接口测试postman工具使用笔记。<br><a id="more"></a></p><h2 id="一、适用范围"><a href="#一、适用范围" class="headerlink" title="一、适用范围"></a>一、适用范围</h2><ul><li>PC</li><li>WAP</li><li>APP</li></ul><h2 id="二、环境准备"><a href="#二、环境准备" class="headerlink" title="二、环境准备"></a>二、环境准备</h2><p>(1)下载安装:<a href="https://www.getpostman.com/apps" target="_blank" rel="noopener">https://www.getpostman.com/apps</a><br>(2)注册账户</p><h2 id="三、发送一条http-Get请求"><a href="#三、发送一条http-Get请求" class="headerlink" title="三、发送一条http Get请求"></a>三、发送一条http Get请求</h2><p>(1)GET请求输入URL(可以从fiddler复制)<br>(2)GET请求输入Headers(可以从fiddler复制)<br>(3)点击【Send】可以查看返回信息<br>(4)可以对返回值内容增加校验，GET请求的Tests里设置校验方法和校验字段<br>(5)点击【Send】可以查看返回信息和测试结果<br>(6)可以将以上测试步骤，点击【Save】保存到一个集合<br>(7)可以修改请求的测试参数，点击【Save as】保存到同一个集合<br>(8)以此类推形成一个自动化测试的集合<br>(9)点击该集合的【Run】弹出集合运行界面<br>(10)可以修改循环次数【iterations】、延迟【Delay】等参数<br>(11)点击【Run …】运行脚本，查看测试结果</p><h2 id="四、发送一条http-Post请求"><a href="#四、发送一条http-Post请求" class="headerlink" title="四、发送一条http Post请求"></a>四、发送一条http Post请求</h2><p>(1)POST请求输入URL(可以从fiddler复制)<br>(2)POST请求输入Headers(可以从fiddler复制)<br>(3)POST请求输入Body(可以从fiddler的WebForms里一项一项复制)<br>(4)点击【Send】可以查看返回信息<br>(5)可以对返回值内容增加校验，POST请求的Tests里设置校验方法和校验字段<br>(6)点击【Send】可以查看返回信息和测试结果<br>(7)可以将以上测试步骤，点击【Save】保存到一个集合<br>(8)可以修改请求的测试参数，点击【Save as】保存到同一个集合<br>(9)以此类推形成一个自动化测试的集合<br>(10)点击该集合的【Run】弹出集合运行界面<br>(11)可以修改循环次数【iterations】、延迟【Delay】等参数<br>(12)点击【Run …】运行脚本，查看测试结果</p><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接口测试postman工具使用笔记。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="接口测试" scheme="http://pythonfood.github.io/categories/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="postman" scheme="http://pythonfood.github.io/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>接口测试-fiddler</title>
    <link href="http://pythonfood.github.io/2018/04/01/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95-fiddler/"/>
    <id>http://pythonfood.github.io/2018/04/01/接口测试-fiddler/</id>
    <published>2018-04-01T01:00:00.000Z</published>
    <updated>2018-05-11T06:58:28.803Z</updated>
    
    <content type="html"><![CDATA[<p>接口测试fiddler工具使用笔记。<br><a id="more"></a></p><h2 id="一、Fiddler-环境准备"><a href="#一、Fiddler-环境准备" class="headerlink" title="一、Fiddler 环境准备"></a>一、Fiddler 环境准备</h2><p>(1)官网下载安装:<a href="https://www.telerik.com/download/fiddler" target="_blank" rel="noopener">https://www.telerik.com/download/fiddler</a><br>(2)相关设置:【Tools-options-HTTPS-Connections】,设置好之后退出再启动一次。</p><p><img src="/2018/04/01/接口测试-fiddler/HTTPS设置.png" alt="HTTPS设置"><br><img src="/2018/04/01/接口测试-fiddler/Connections设置.png" alt="Connections设置"></p><h2 id="二、Fiddler-工作原理"><a href="#二、Fiddler-工作原理" class="headerlink" title="二、Fiddler 工作原理"></a>二、Fiddler 工作原理</h2><p><img src="/2018/04/01/接口测试-fiddler/fiddler工作原理.png" alt="fiddler工作原理"></p><h2 id="三、Fiddler-基本界面"><a href="#三、Fiddler-基本界面" class="headerlink" title="三、Fiddler 基本界面"></a>三、Fiddler 基本界面</h2><p>(1)Session部分:</p><blockquote><ul><li>#:id</li><li>Result:服务器返回的状态码</li><li>Protocol:协议</li><li>Host:发送给服务器的host值</li><li>URL:</li></ul></blockquote><p>(2)Inspectors:<br>1)Request部分:</p><blockquote><ul><li>Headers:头部信息<blockquote><ul><li>User-Agent:用户的身份</li><li>Referer:请求的上一个请求来源</li><li>Host:当前的host</li></ul></blockquote></li><li>TextView:</li><li>WebForms:请求的参数值</li><li>HexView:16进制的view</li><li>Cookies:</li><li>Raw:最原始的所有的数据</li><li>JSON:json形式的请求</li><li>XML:xml形式的请求</li></ul></blockquote><p>2)Response部分:</p><blockquote><ul><li>TextView:可以看到整个返回的内容</li><li>Raw:返回所有的相关的内容</li><li>JSON:返回json形式的数据</li><li>XML:返回xml形式的数据</li><li>WebView:返回的html页面</li><li>ImageView:返回的图片内容</li></ul></blockquote><p>(3)Statistics:静态统计</p><p>(4)Composer:构造各种各样的请求发送给服务器</p><p>(5)AutoResponder:配置假数据模拟后端服务器返回的数据</p><h2 id="四、Fiddler-设置断点修改Request"><a href="#四、Fiddler-设置断点修改Request" class="headerlink" title="四、Fiddler 设置断点修改Request"></a>四、Fiddler 设置断点修改Request</h2><p>(1)通过工具栏设置断点(缺点是会拦截所有的请求)</p><blockquote><p>1)设置断点【Rules-Automatic Breakpoints-Before Request F11】<br>2)清除请求区域<br>3)浏览器进行百度搜索“fiddler”<br>4)fiddler对应的请求，点击【Response部分-Run to Completion】<br>5)fiddler新弹出的请求应该就是需要改参数的请求<br>6)fiddler需要修改参数的请求，点击【Request部分-WebForms】<br>7)修改对应的参数<br>8)点击【Repose部分-Run to Completion】<br>9)回到浏览器查看请求是否修改成功</p></blockquote><p>(2)通过命令设置断点(可以拦截指定站点)</p><blockquote><p>1)session部分底部输入命令<code>bpu www.baidu.com</code>，其他操作同上。<br>2)清除拦截，输入命令<code>bpu</code></p></blockquote><h2 id="五、Fiddler-设置断点修改Response"><a href="#五、Fiddler-设置断点修改Response" class="headerlink" title="五、Fiddler 设置断点修改Response"></a>五、Fiddler 设置断点修改Response</h2><p>(1)通过工具栏设置断点(缺点是会拦截所有的请求)</p><blockquote><p>1)点击设置【Rules-Automatic Breakpoints-After Response Alt+F11】<br>2)清除请求区域<br>3)浏览器进行百度搜索“哈哈”<br>4)fiddler修改Response部分的参数<br>5)点击【Response部分-Run to Completion】<br>6)回到浏览器查看请求是否修改成功</p></blockquote><p>(2)通过命令设置断点(可以拦截指定站点)</p><blockquote><p>1)session部分底部输入命令<code>bpafter www.baidu.com</code>，其他操作同上。<br>2)清除拦截，输入命令<code>bpafter</code></p></blockquote><p>(3)AutoResponder设置</p><blockquote><p>1)浏览器进行百度搜索“哈哈”<br>2)fiddler对应的请求,点击【AutoResponder-Add Rule】<br>3)勾选【Enable reles】【Unmatched requests passthrough】【Enable Latency】<br>4)下边规则改为模糊匹配，例如改为：<code>regex:(?inx)^https://www.baidu.com/s?.+</code><br>5)下边下拉框返回状态码任意可选，例如选择:404_Plain.dat<br>6)点击【Save】按钮<br>7)回到浏览器重新百度搜索任意字符，看是否返回404<br>ps:可以通过下拉列表的“find a file”自定义规则，文件内容自定义。</p></blockquote><h2 id="六、Fiddler-小工具"><a href="#六、Fiddler-小工具" class="headerlink" title="六、Fiddler 小工具"></a>六、Fiddler 小工具</h2><p>(1)会话的过滤</p><blockquote><p>1)点击【Filters-Use Filters】<br>2)【No Host Filter】下拉框选择【Show only the following Hosts】<br>3)输入要过滤的站点，例如:www.baidu.com<br>4)点击【Actions-Run Filterset now】<br>5)此时session对话框只显示过滤站点请求</p></blockquote><p>(2)会话的比较<br>下载windiff:<a href="https://www.grigsoft.com/download-windiff.htm" target="_blank" rel="noopener">https://www.grigsoft.com/download-windiff.htm</a><br>解压后复制到fiddler安装路径即可</p><blockquote><p>1)选中两个要对比的请求<br>2)右键点击【Compare】<br>3)调起windiff工具进行对比</p></blockquote><p>(3)编码小工具</p><blockquote><p>1)点击【Tools-TextWizard】<br>2)上部分输入原始内容，下部分显示编解码内容<br>3)例如：上面输入(<a href="https://www.grigsoft.com/download-windiff.htm" target="_blank" rel="noopener">https://www.grigsoft.com/download-windiff.htm</a>) ，下面选择URLEecode,即可看到结果。</p></blockquote><h2 id="七、Fiddler-Host设置"><a href="#七、Fiddler-Host设置" class="headerlink" title="七、Fiddler Host设置"></a>七、Fiddler Host设置</h2><blockquote><p>1)点击【Tools-HOSTS…】<br>2)勾选对话框顶部【Enable Remapping of requests for one host to a differenthost or IP,overing DNS】<br>3)点击会话框底部【Import Windows Hosts File】，导入系统host<br>4)任意修改host,点击【Save】host即生效<br>5)不使用修改的host,只需要取消勾选对话框顶部【Enable Remapping of requests for one host to a differenthost or IP,overing DNS】</p></blockquote><h2 id="八、Fiddler-构造HTTP请求"><a href="#八、Fiddler-构造HTTP请求" class="headerlink" title="八、Fiddler 构造HTTP请求"></a>八、Fiddler 构造HTTP请求</h2><p>(1)构造Get请求</p><blockquote><p>1)选择一条Get请求，点击【Inspectors-Headers】<br>2)复制Headers的头部信息，粘贴到【Composer-Parsed】的对话框<br>3)首先删除掉复制信息的“Get”类型<br>4)再剪切复制信息的URL，粘贴到上方的输入框，去掉URL尾部的“HTTP/1.1”协议<br>5)点击【Execute】发送请求<br>6)查看session界面请求是否发送<br>ps:可以任意修改URL进行接口测试</p></blockquote><p>(2)构造Post请求</p><blockquote><p>1)选择一条Post请求，点击【Inspectors-Raw】<br>2)复制所有信息，粘贴到【Composer-Parsed】的对话框，请求方式选择【POST】<br>3)首先删除掉复制信息的“Post”类型<br>4)再剪切复制信息的URL，粘贴到上方的输入框，去掉URL尾部的“HTTP/1.1”协议<br>5)剪切空行以下的request body信息，粘贴到下面的输入框<br>6)点击【Execute】发送请求<br>7)查看session界面请求是否发送<br>ps:可以任意修改URL和request body信息进行接口测试</p></blockquote><h2 id="九、Fiddler-抓取手机包"><a href="#九、Fiddler-抓取手机包" class="headerlink" title="九、Fiddler 抓取手机包"></a>九、Fiddler 抓取手机包</h2><p>(1)配置Fiddler允许监听https<br>(2)配置Fiddler允许远程连接<br>(3)手机端设置代理服务</p><blockquote><p>1)设置【Tools-Options-HTTPS】<br>2)设置【Tools-Options-Connections】<br>3)手机当前连接wifi里设置代理:主机名填写电脑的ip地址，端口填写8888<br>4)手机操作应用，请求就会发送到fiddler,其他操作同PC端操作</p></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接口测试fiddler工具使用笔记。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="接口测试" scheme="http://pythonfood.github.io/categories/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="fiddler" scheme="http://pythonfood.github.io/tags/fiddler/"/>
    
  </entry>
  
  <entry>
    <title>selenium常用API</title>
    <link href="http://pythonfood.github.io/2018/03/01/selenium%E5%B8%B8%E7%94%A8API/"/>
    <id>http://pythonfood.github.io/2018/03/01/selenium常用API/</id>
    <published>2018-03-01T02:00:00.000Z</published>
    <updated>2018-05-11T06:55:16.658Z</updated>
    
    <content type="html"><![CDATA[<p>selenium常用API笔记。<br><a id="more"></a></p><h2 id="一、浏览器操作"><a href="#一、浏览器操作" class="headerlink" title="一、浏览器操作"></a>一、浏览器操作</h2><p>(1)浏览器最大化</p><blockquote><p><code>driver.maximize_window()</code> #浏览器最大化</p></blockquote><p>(2)设置浏览器宽、高</p><blockquote><p><code>driver.set_window_size(480, 800)</code> #设置浏览器宽、高</p></blockquote><p>(3)浏览器后退</p><blockquote><p><code>driver.back()</code> #浏览器后退</p></blockquote><p>(4)浏览器前进</p><blockquote><p><code>driver.forward()</code> #浏览器前进</p></blockquote><p>(5)刷新当前页面</p><blockquote><p><code>driver.refresh()</code> #刷新当前页面</p></blockquote><p>(6)退出浏览器</p><blockquote><p><code>driver.quit()</code> #退出浏览器</p></blockquote><p>(7)关闭单个窗口</p><blockquote><p><code>driver.close()</code> #关闭单个窗口</p></blockquote><h2 id="二、元素定位"><a href="#二、元素定位" class="headerlink" title="二、元素定位"></a>二、元素定位</h2><p>(1)id定位 </p><blockquote><p><code>find_element_by_id(&quot;kw&quot;)</code> #一般唯一</p></blockquote><p>(2)name定位 </p><blockquote><p><code>find_element_by_name(&quot;wd&quot;)</code> #一般唯一</p></blockquote><p>(3)class_name定位 </p><blockquote><p><code>find_element_by_class_name(&quot;bg s_btn&quot;)</code> #不唯一</p></blockquote><p>(4)tag_name定位</p><blockquote><p><code>find_element_by_tag_name(&quot;input&quot;)</code> #不唯一</p></blockquote><p>(5)link_text定位</p><blockquote><p><code>find_element_by_link_text(u&quot;这是一条新闻&quot;)</code> #定位文本链接</p></blockquote><p>(6)partial_link_text定位</p><blockquote><p><code>find_element_by_partial_link_text(&quot;这是一条新&quot;)</code> #定位可以唯一标识这个文本链接的一部分</p></blockquote><p>(7)xpath定位</p><blockquote><p>1)绝对路径定位</p><blockquote><p><code>find_element_by_xpath(&quot;/html/body/div[2]/form/span/input&quot;)</code> #从根节点开始绝对路径</p></blockquote><p>2)相对路径定位</p><blockquote><p><code>find_element_by_xpath(&quot;//input[@id=’input’]&quot;)</code> #通过自身的id 属性定位<br><code>find_element_by_xpath(&quot;//span[@id=’input-container’]/input&quot;)</code> #通过上一级目录的id 属性定位<br><code>find_element_by_xpath(&quot;//div[@name=’q’]/form/span[2]/input&quot;)</code> #通过上三级目录的name 属性定位<br><code>find_element_by_xpath(&quot;//div[@id=’hd’ or @name=’q’]/form/span/input&quot;)</code> #通过布尔逻辑运算 属性定位</p></blockquote></blockquote><p>(8)css_selector定位</p><blockquote><p><code>find_element_by_css_selector(&quot;#su&quot;)</code> #通过id属性定位<br><code>find_element_by_css_selector(&quot;.s_ipt&quot;)</code> #通过class属性定位<br><code>find_element_by_css_selector(&quot;input&quot;)</code> #通过标签名定位<br><code>find_element_by_css_selector(&quot;span&gt;input&quot;)</code> #通过父子关系定位<br><code>find_element_by_css_selector(&quot;input[maxlength=&#39;100&#39;]&quot;)</code> #通过属性定位<br><code>find_element_by_css_selector(&quot;span.bgs_ipt_wr&gt;input.s_ipt&quot;)</code> #组合定位</p><blockquote><p><img src="/2018/03/01/selenium常用API/css_selector定位.png" alt="css_selector定位"></p></blockquote></blockquote><p>(9)用By定位<br>需要使用定位方法时，By可以设置定位策略。使用前导入By模块<code>from selenium.webdriver.common.by import By</code>。</p><blockquote><p><code>find_element(By.ID,&quot;kw&quot;)</code><br><code>find_element(By.NAME,&quot;wd&quot;)</code><br><code>find_element(By.CLASS_NAME,&quot;s_ipt&quot;)</code><br><code>find_element(By.TAG_NAME,&quot;input&quot;)</code><br><code>find_element(By.LINK_TEXT,u&quot;新闻&quot;)</code><br><code>find_element(By.PARTIAL_LINK_TEXT,u&quot;新&quot;)</code><br><code>find_element(By.XPATH,&quot;//*[@class=&#39;bgs_btn&#39;]&quot;)</code><br><code>find_element(By.CSS_SELECTOR,&quot;span.bgs_btn_wr&gt;input#su&quot;)</code></p></blockquote><h2 id="三、元素操作"><a href="#三、元素操作" class="headerlink" title="三、元素操作"></a>三、元素操作</h2><p>(1)clear()  #清除输入框内容</p><blockquote><p><code>driver.find_element_by_id(&quot;user_name&quot;).clear()</code></p></blockquote><p>(2)send_keys(“xx”) #输入框里输入xx内容</p><blockquote><p><code>driver.find_element_by_id(&quot;user_name&quot;).send_keys(&quot;username&quot;)</code></p></blockquote><p>(3)click() #单击一个按钮、连接等</p><blockquote><p><code>driver.find_element_by_id(&quot;dl_an_submit&quot;).click()</code></p></blockquote><p>(4)submit() #提交表单</p><blockquote><p><code>driver.find_element_by_id(&quot;dl_an_submit&quot;).submit()</code></p></blockquote><p>(5)size #返回元素的尺寸</p><blockquote><p><code>size=driver.find_element_by_id(&quot;kw&quot;).size</code> #返回百度输入框的宽高</p></blockquote><p>(6)text #获取元素的文本</p><blockquote><p><code>text=driver.find_element_by_id(&quot;cp&quot;).text</code> #返回百度页面底部备案信息</p></blockquote><p>(7)get_attribute(name) #获得属性值</p><blockquote><p><code>attribute=driver.find_element_by_id(&quot;kw&quot;).get_attribute(&#39;type&#39;)</code> #返回元素的属性值，可以是id、name、type 或元素拥有的其它任意属性</p></blockquote><p>(8)is_displayed() #检查该元素是否用户可见    </p><blockquote><p><code>result=driver.find_element_by_id(&quot;kw&quot;).is_displayed()</code> #返回元素的结果是否可见，返回结果为True 或False</p></blockquote><h2 id="四、鼠标事件"><a href="#四、鼠标事件" class="headerlink" title="四、鼠标事件"></a>四、鼠标事件</h2><p>ActionChains用于生成用户的行为，所有的行为都存储在actionchains对象中。通过perform()执行存储的行为。<br>使用前导入ActionChains模块<code>from selenium.webdriver.common.action_chains import ActionChains</code>。</p><p>(1)perform() #顺序执行所有ActionChains中存储的行为</p><blockquote><p><code>ActionChains(driver).context_click(操作对象).perform()</code> #ActionChains方法的书写格式</p></blockquote><p>(2)context_click() #右击 </p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">right =driver.find_element_by_xpath(&quot;xx&quot;) #定位到要右击的元素</span><br><span class="line">ActionChains(driver).context_click(right).perform() #对定位到的元素执行鼠标右键操作</span><br></pre></td></tr></table></figure></blockquote><p>(3)double_click() #双击</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double =driver.find_element_by_xpath(&quot;xxx&quot;) #定位到要双击的元素</span><br><span class="line">ActionChains(driver).double_click(double).perform() #对定位到的元素执行鼠标双击操作</span><br></pre></td></tr></table></figure></blockquote><p>(4)drag_and_drop() #鼠标拖放</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element = driver.find_element_by_name(&quot;xxx&quot;) #定位元素的原位置</span><br><span class="line">target = driver.find_element_by_name(&quot;xxx&quot;) #定位元素要移动到的目标位置</span><br><span class="line">ActionChains(driver).drag_and_drop(element, target).perform() #执行元素的移动操作</span><br></pre></td></tr></table></figure></blockquote><p>(5)move_to_element() #鼠标悬停</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">above = driver.find_element_by_xpath(&quot;xxx&quot;) #定位到鼠标移动到上面的元素</span><br><span class="line">ActionChains(driver).move_to_element(above).perform() #对定位到的元素执行鼠标移动到上面的操作</span><br></pre></td></tr></table></figure></blockquote><p>(6)click_and_hold() #按下鼠标左键    </p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">left=driver.find_element_by_xpath(&quot;xxx&quot;) #定位到鼠标按下左键的元素</span><br><span class="line">ActionChains(driver).click_and_hold(left).perform() #对定位到的元素执行鼠标左键按下的操作</span><br></pre></td></tr></table></figure></blockquote><h2 id="五、键盘事件"><a href="#五、键盘事件" class="headerlink" title="五、键盘事件"></a>五、键盘事件</h2><p>使用前导入keys模块<code>from selenium.webdriver.common.keys import Keys</code>。</p><p>(1)send_keys(Keys.BACK_SPACE) #删除键（BackSpace）</p><p>(2)send_keys(Keys.SPACE) #空格键(Space)</p><p>(3)send_keys(Keys.TAB) #制表键(Tab)</p><p>(4)send_keys(Keys.ESCAPE) #回退键（Esc）</p><p>(5)send_keys(Keys.ENTER) #回车键（Enter）</p><p>(6)send_keys(Keys.F5) #刷新建（F5）</p><p>(7)send_keys(Keys.CONTROL,’a’) #全选（Ctrl+A）</p><p>(8)send_keys(Keys.CONTROL,’c’) #复制（Ctrl+C）</p><p>(9)send_keys(Keys.CONTROL,’x’) #剪切（Ctrl+X）</p><p>(10)send_keys(Keys.CONTROL,’v’) #粘贴（Ctrl+V）</p><h2 id="六、获取验证信息"><a href="#六、获取验证信息" class="headerlink" title="六、获取验证信息"></a>六、获取验证信息</h2><p>(1)获得当前页面title，判断页面跳转是否符合预期</p><blockquote><p><code>title = driver.title</code></p></blockquote><p>(2)获得当前URL，一般用来测试重定向</p><blockquote><p><code>url = driver.current_url</code></p></blockquote><h2 id="七、设置等待时间"><a href="#七、设置等待时间" class="headerlink" title="七、设置等待时间"></a>七、设置等待时间</h2><p>(1)sleep() #休眠等待<br>sleep()方法以秒为单位，假如休眠时间小于 1 秒，可以用小数表示。<br>使用前导入sleep模块<code>from time import sleep</code>。</p><blockquote><p><code>sleep(0.5)</code></p></blockquote><p>(2)implicitly_wait() #隐式等待<br>隐式等待是通过一定的时长等待页面所元素加载完成。<br>如果超出了设置的时长元素还没有被加载测抛NoSuchElementException异常。<br>implicitly_wait()默认参数的单位为秒。</p><blockquote><p><code>driver.implicitly_wait(10)</code> #设置智能等待10秒</p></blockquote><p>(3)WebDriverWait() #显式等待<br>显式等待是等待某个条件成立时继续执行，否则在达到最大时长则抛TimeoutException异常。</p><p>WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None)，参数解释如下：</p><ul><li>driver - WebDriver 的驱动程序(Ie, Firefox, Chrome 或远程)</li><li>timeout - 最长超时时间，默认以秒为单位</li><li>poll_frequency - 休眠时间的间隔（步长）时间，默认为 0.5 秒</li><li>ignored_exceptions - 超时后的异常信息，默认情况下抛 NoSuchElementException 异常。</li></ul><p>使用前导入WebDriverWait模块<code>from selenium.webdriver.support.ui import WebDriverWait</code>。</p><p>WebDriverWai()一般由 unit()或 until_not()方法配合使用，下面是 unit()和 until_not()方法的说明：<br>1)until(method, message=’’)调用该方法提供的驱动程序作为一个参数，直到返回值不为False。</p><blockquote><p><code>element = WebDriverWait(driver, 10).until(lambda x: x.find_element_by_id(“someId”))</code></p></blockquote><p>2)until_not(method, message=’’)调用该方法提供的驱动程序作为一个参数，直到返回值为 False。</p><blockquote><p><code>is_disappeared = WebDriverWait(driver, 30, 1, (ElementNotVisibleException)).until_not(lambda x: x.find_element_by_id(“someId”).is_displayed())</code>    </p></blockquote><h2 id="八、定位一组对象"><a href="#八、定位一组对象" class="headerlink" title="八、定位一组对象"></a>八、定位一组对象</h2><p>(1)find_elements 用于获取一组元素:</p><blockquote><p><code>find_elements_by_id(‘xx’)</code><br><code>find_elements_by_name(‘xx’)</code><br><code>find_elements_by_class_name(‘xx’)</code><br><code>find_elements_by_tag_name(‘xx’)</code><br><code>find_elements_by_link_text(‘xx’)</code><br><code>find_elements_by_partial_link_text(‘xx’)</code><br><code>find_elements_by_xpath(‘xx’)</code><br><code>find_elements_by_css_selector(‘xx’)</code></p></blockquote><p>(2)可以使用for… in …对这一组元素进行遍历:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for checkbox in checkboxes:</span><br><span class="line">checkbox.click()</span><br></pre></td></tr></table></figure></blockquote><p>(3)也可以使用pop（）方法获得这一组元素中的第几个，然后再对该元素进行操作：</p><blockquote><p><code>find_elements_by_id(‘xx’).pop().click()</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pop（）或pop（-1）#默认获取一组元素中的最后一个</span><br><span class="line">pop(0)   #默认获取一组元素的第一个元素</span><br><span class="line">pop(1)   #默认获取一组元素的第二个元素</span><br><span class="line">...... #以此类推</span><br></pre></td></tr></table></figure></blockquote></blockquote><h2 id="九、层级定位"><a href="#九、层级定位" class="headerlink" title="九、层级定位"></a>九、层级定位</h2><p>经常会有这样的需求：页面上有很多个属性基本相同的元素 ，现在需要具体定位到其中的一个。由于属性基本相当，所以在定位的时候会有些麻烦，这时候就需要用到层级定位。先定位父元素，然后再通过父元素定位子孙元素：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#点击 Link1 链接（弹出下拉列表）</span><br><span class="line">driver.find_element_by_link_text(&apos;Link1&apos;).click() </span><br><span class="line">#在父亲元件下找到 link 为 Action 的子元素</span><br><span class="line">menu=driver.find_element_by_id(&apos;dropdown1&apos;).find_element_by_link_text(&apos;Another action&apos;)</span><br></pre></td></tr></table></figure></blockquote><h2 id="十、表单切换"><a href="#十、表单切换" class="headerlink" title="十、表单切换"></a>十、表单切换</h2><p>在web应用中经常会出现frame/iframe 表单内嵌套的应用，WebDriver只能在一个页面上进行元素识别定位，对于frame/iframe表单内嵌页面上的元素无法直接定位。这时需要通过switch_to.frame()方法将当前定位的主体切换为frame/iframe表单的内嵌页面中。</p><p>(1)switch_to_frame()默认可以直接取表单的id或name属性进行切换：</p><blockquote><p><code>driver.switch_to_frame(&quot;if&quot;)</code> #id = “if”<br><code>driver.switch_to_frame(&quot;nf&quot;)</code> #name = “nf” </p></blockquote><p>(2)如果 iframe 没有可用的 id 和 name 可以通过下面的方式进行定位：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#先通过xpth定位到iframe </span><br><span class="line">xf = driver.find_element_by_xpath(&apos;//*[@class=&quot;if&quot;]&apos;)</span><br><span class="line">#再将定位对象传给switch_to_frame()方法 </span><br><span class="line">driver.switch_to_frame(xf)</span><br></pre></td></tr></table></figure></blockquote><p>(3)如果完成了在当前表单上的操作，跳出当前表单：</p><blockquote><p><code>driver.switch_to.parent_content()</code> #返回到父级表单<br><code>driver.switch_to.default_conent()</code> #返回到主文档页面</p></blockquote><h2 id="十一、多窗口切换"><a href="#十一、多窗口切换" class="headerlink" title="十一、多窗口切换"></a>十一、多窗口切换</h2><ul><li><code>current_window_handle</code> #获得当前窗口句柄。</li><li><code>window_handles</code> #返回所有窗口的句柄到当前对话。</li><li><code>switch_to.window</code>(窗口句柄) #切换到对应的窗口。</li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nowhandle=driver.current_window_handle #获得当前窗口句柄。</span><br><span class="line">driver.find_element_by_link_text(u&quot;发表话题&quot;).click()</span><br><span class="line">time.sleep(3)</span><br><span class="line">allhandles=driver.window_handles #返回所有窗口的句柄到当前对话。</span><br><span class="line">for handle in allhandles:</span><br><span class="line">if(handle!=nowhandle):</span><br><span class="line">driver.switch_to.window(handle) #切换到对应的窗口。</span><br></pre></td></tr></table></figure></blockquote><h2 id="十二、警告框处理"><a href="#十二、警告框处理" class="headerlink" title="十二、警告框处理"></a>十二、警告框处理</h2><p>处理javascript所生成的alert、confirm、prompt，可以使用switch_to_alert()方法定位到alert/confirm/prompt，然后使用text/accept/dismiss/send_keys等方法进行操作：</p><ul><li><code>text</code> #返回 alert/confirm/prompt 中的文字信息。</li><li><code>accept</code> #点击确认按钮。</li><li><code>dismiss</code> #点击取消按钮，如果有的话。</li><li><code>send_keys</code> #输入值，这个 alert\confirm 没有对话框就不能用了，不然会报错。</li></ul><blockquote><p><code>driver.switch_to_alert().accept()</code></p></blockquote><h2 id="十三、上传文件"><a href="#十三、上传文件" class="headerlink" title="十三、上传文件"></a>十三、上传文件</h2><p>(1)查找到input标签，通过send_keys)传入本地文件路径从而模拟上传功能:</p><blockquote><p><code>driver.find_element_by_name(&quot;file&quot;).send_keys(&#39;D:\\upload_file.txt&#39;)</code> #查找到input标签，然后send进去</p></blockquote><p>(2)使用AutoIt识别flash控件和windows控件实现自动上传文件</p><blockquote><p>1)下载安装，官方网站：<a href="https://www.autoitscript.com/site/" target="_blank" rel="noopener">https://www.autoitscript.com/site/</a><br>2)配置编辑AutoIt。<br>3)<code>os.system(&quot;D:\\upfile.exe&quot;)</code> #通过系统调用upfile.exe上传程序 </p></blockquote><h2 id="十四、下载文件"><a href="#十四、下载文件" class="headerlink" title="十四、下载文件"></a>十四、下载文件</h2><p>(1)以FireFox为例，为了让FireFox浏览器能实现文件的载，我们需要通过FirefoxProfile()对其参数做一个设置:</p><ul><li><code>browser.download.folderList</code> #设置成0代表下载到浏览器默认下载路径；设置成2则可以保存到指定目录。</li><li><code>browser.download.manager.showWhenStarting</code> #是否显示开始，Ture为显示，Flase为不显示。</li><li><code>browser.download.dir</code> #用于指定你所下载文件的目录。os.getcwd()该函数不需要传递参数，用于返回当前的目录。</li><li><code>browser.helperApps.neverAsk.saveToDisk</code> #指定要下载页面的Content-type值，“application/octet-stream”为文件的类型。HTTP Content-type常用对照表：<a href="http://tool.oschina.net/commons" target="_blank" rel="noopener">http://tool.oschina.net/commons</a></li></ul><p>(2)这些参数的设置可以通过在Firefox浏览器地址栏输入：about:config 进行设置，如图： </p><p><img src="/2018/03/01/selenium常用API/firefox参数设置.png" alt="firefox参数设置"></p><p>(3)浏览器设置代码示例：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8 </span><br><span class="line">from selenium import webdriver </span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">fp = webdriver.FirefoxProfile()</span><br><span class="line">fp.set_preference(&quot;browser.download.folderList&quot;,2) </span><br><span class="line">fp.set_preference(&quot;browser.download.manager.showWhenStarting&quot;,False) </span><br><span class="line">fp.set_preference(&quot;browser.download.dir&quot;, os.getcwd()) </span><br><span class="line">fp.set_preference(&quot;browser.helperApps.neverAsk.saveToDisk&quot;, &quot;application/octet-stream&quot;)</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox(firefox_profile=fp) </span><br><span class="line">driver.get(&quot;http://pypi.Python.org/pypi/selenium&quot;) </span><br><span class="line">driver.find_element_by_partial_link_text(&quot;selenium-2&quot;).click()</span><br></pre></td></tr></table></figure></blockquote><h2 id="十五、操作Cookie"><a href="#十五、操作Cookie" class="headerlink" title="十五、操作Cookie"></a>十五、操作Cookie</h2><p>webdriver操作cookie的方法有：</p><ul><li><code>get_cookies()</code> #获得所有cookie信息  </li><li><code>get_cookie(name)</code> #返回有特定name值有cookie信息  </li><li><code>add_cookie(cookie_dict)</code> #添加cookie，必须有name和value值  </li><li><code>delete_cookie(name)</code> #删除特定(部分)的cookie信息  </li><li><code>delete_all_cookies()</code> #删除所有cookie信息</li></ul><p>(1)先通过get_cookies()来获取当前浏览器的cookie信息。<br>通过打印结果可以看出，cookie 是以字典的形式进行存放的，知道了cookie的存放形式，那么我们就可以按照这种形式向浏览器中写入cookie信息。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver.get(&quot;http://www.youdao.com&quot;)</span><br><span class="line">cookie= driver.get_cookies() # 获得cookie信息 </span><br><span class="line">print cookie #将获得cookie的信息打印</span><br></pre></td></tr></table></figure><blockquote><p><img src="/2018/03/01/selenium常用API/cookie打印信息.png" alt="cookie打印信息"></p></blockquote></blockquote><p>(2)再进行cookie的添加、删除等操作。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver.get(&quot;http://www.youdao.com&quot;)</span><br><span class="line">driver.add_cookie(&#123;&apos;name&apos;:&apos;key-aaaaaaa&apos;, &apos;value&apos;:&apos;value-bbbbbb&apos;&#125;) #向cookie的name 和value添加会话信息。</span><br></pre></td></tr></table></figure></blockquote><h2 id="十六、调用javascript"><a href="#十六、调用javascript" class="headerlink" title="十六、调用javascript"></a>十六、调用javascript</h2><p>当webdriver遇到没法完成的操作时，可以考虑调用JavaScript来完成。<br>webdriver提供<code>execute_script()</code>方法用来调用js代码：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#修改元素的属性</span><br><span class="line">js = &apos;document.querySelectorAll(&quot;select&quot;)[0].style.display=&quot;block&quot;;&apos;</span><br><span class="line">driver.execute_script(js)</span><br></pre></td></tr></table></figure></blockquote><h2 id="十七、控制浏览器滚动条"><a href="#十七、控制浏览器滚动条" class="headerlink" title="十七、控制浏览器滚动条"></a>十七、控制浏览器滚动条</h2><p>(1)上下滚动：<br><code>document.body.scrollTop</code> #网页被卷去的高。置顶设置：scrollTop为0；置底设置：scrollTop大于窗口的高度像素。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#将页面滚动条拖到底部</span><br><span class="line">js=&quot;var q=document.documentElement.scrollTop=10000&quot;</span><br><span class="line">driver.execute_script(js)</span><br><span class="line">time.sleep(3)</span><br><span class="line">#将滚动条移动到页面的顶部</span><br><span class="line">js1=&quot;var q=document.documentElement.scrollTop=0&quot;</span><br><span class="line">driver.execute_script(js1)</span><br><span class="line">time.sleep(3)</span><br></pre></td></tr></table></figure></blockquote><p>(2)左右滚动：<br><code>window.scrollTo(左边距,上边距)</code> #指定左右滚动的坐标即可</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">js=&quot; window.scrollTo(200,1000);&quot; </span><br><span class="line">driver.execute_script(js)</span><br></pre></td></tr></table></figure></blockquote><h2 id="十八、窗口截图"><a href="#十八、窗口截图" class="headerlink" title="十八、窗口截图"></a>十八、窗口截图</h2><p>Webdriver提供了截图函数<code>get_screenshot_as_file()</code>来截取当前窗口:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">driver.find_element_by_id(&apos;kw_error&apos;).send_key(&apos;selenium&apos;) </span><br><span class="line">driver.find_element_by_id(&apos;su&apos;).click() </span><br><span class="line">except: </span><br><span class="line">driver.get_screenshot_as_file(&quot;D:\\baidu_error.jpg&quot;) #截图，保存到指定路径</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure></blockquote><h2 id="十九、获取对象的属性值"><a href="#十九、获取对象的属性值" class="headerlink" title="十九、获取对象的属性值"></a>十九、获取对象的属性值</h2><p>有时候我们定位页面上的元素发现常用的id、name等属性是相同的。这个时候我们只能通过常规的定位方法定位出一组元素，然后观察通过元素的属性可以定位出单个元素。<br>可使用.get_attribute()方法:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 选择页面上所有的tag name为input的元素</span><br><span class="line">inputs = driver.find_elements_by_tag_name(&apos;input&apos;)</span><br><span class="line">#然后循环遍历出属性data-node值为594434493的元素，单击勾选</span><br><span class="line">for input in inputs:</span><br><span class="line">if input.get_attribute(&apos;data-node&apos;) == &apos;594434493&apos;:</span><br><span class="line">input.click()</span><br></pre></td></tr></table></figure></blockquote><h2 id="二十、验证码处理"><a href="#二十、验证码处理" class="headerlink" title="二十、验证码处理"></a>二十、验证码处理</h2><p>(1)去掉验证码。<br>(2)设置万能码。<br>(3)验证码识别技术<br>例如可以通过Python-tesseract来识别图片验证码,能够读取任何常规的图片文件(JPG,GIF,PNG,TIFF 等)。不过，目前市面上的验证码识别技术识别率都不是100% 。<br>(4)记录cookie<br>通过向浏览器中添加cookie可以绕过登录的验证码,这种方式最大的问题是如何从浏览器的Cookie中找到用户名和密码对应的key值，并传传输入对应的登录信息。如果网站登录时根本不将用户名和密码写Cookie，这会存在一定的安全风险。那么这种方式就不起作用了。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#访问xx网站 </span><br><span class="line">driver.get(&quot;http://www.xx.cn&quot;)</span><br><span class="line">#将用户名密码写入浏览器cookie </span><br><span class="line">driver.add_cookie(&#123;&apos;name&apos;:&apos;Login_UserNumber&apos;, &apos;value&apos;:&apos;username&apos;&#125;) </span><br><span class="line">driver.add_cookie(&#123;&apos;name&apos;:&apos;Login_Passwd&apos;, &apos;value&apos;:&apos;password&apos;&#125;)</span><br><span class="line">#再次访问xx网站，将会自动登录 </span><br><span class="line">driver.get(&quot;http://www.xx.cn/&quot;) </span><br><span class="line">time.sleep(3)</span><br></pre></td></tr></table></figure></blockquote><p>(5)内部提供一个接口获得验证码，然后通过js代码把获取的验证码填写进去：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#自动获取验证码并填写</span><br><span class="line">js=&quot;$.getJSON(&apos;http://xxx.xxx.com/util/getCode.jsonp?callback=?&apos;,function(data)&#123;$(&apos;.imgcode&apos;).val(data.code);&#125;)&quot;</span><br><span class="line">driver.execute_script(js)</span><br></pre></td></tr></table></figure></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;selenium常用API笔记。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web测试" scheme="http://pythonfood.github.io/categories/web%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="selenium" scheme="http://pythonfood.github.io/tags/selenium/"/>
    
  </entry>
  
  <entry>
    <title>selenium安装-windows</title>
    <link href="http://pythonfood.github.io/2018/03/01/selenium%E5%AE%89%E8%A3%85-windows/"/>
    <id>http://pythonfood.github.io/2018/03/01/selenium安装-windows/</id>
    <published>2018-03-01T01:00:00.000Z</published>
    <updated>2018-05-11T06:55:16.648Z</updated>
    
    <content type="html"><![CDATA[<p>selenium环境搭建的简单步骤：安装Python——安装pip——安装selenium——安装浏览器驱动。<br><a id="more"></a></p><h2 id="一、安装Python"><a href="#一、安装Python" class="headerlink" title="一、安装Python"></a>一、<a href="https://pythonfood.github.io/2017/12/28/python安装-windows/#more">安装Python</a></h2><h2 id="二、安装pip"><a href="#二、安装pip" class="headerlink" title="二、安装pip"></a>二、安装pip</h2><blockquote><p>方法1：自动安装</p><blockquote><p>在第1步安装python时，已经安装了pip。</p></blockquote><p>方法2：手动安装</p><blockquote><p>(1)下载pip压缩包：<a href="https://pypi.python.org/pypi/pip#downloads" target="_blank" rel="noopener">https://pypi.python.org/pypi/pip#downloads</a><br>(2)解压后cmd进入解压目录，执行<code>python setup.py install</code>进行安装。</p></blockquote></blockquote><h2 id="三、安装selenium"><a href="#三、安装selenium" class="headerlink" title="三、安装selenium"></a>三、安装selenium</h2><blockquote><p>方法1：命令行安装</p><blockquote><p>进入cmd输入命令’pip install selenium’。</p></blockquote><p>方法2：下载whl包安装</p><blockquote><p>(1)下载selenium安装包：<a href="https://pypi.python.org/pypi/selenium" target="_blank" rel="noopener">https://pypi.python.org/pypi/selenium</a> 或 <a href="https://www.seleniumhq.org/download/" target="_blank" rel="noopener">https://www.seleniumhq.org/download/</a><br>(2)下载完成后，进入cmd输入命令<code>pip install</code>，再直接将文件拖入cmd窗口，回车即可安装。</p></blockquote></blockquote><h2 id="四、安装浏览器驱动"><a href="#四、安装浏览器驱动" class="headerlink" title="四、安装浏览器驱动"></a>四、安装浏览器驱动</h2><blockquote><p>(1)下载浏览器驱动</p><blockquote><p>不同浏览器需下载不同驱动，不同版本浏览器对应不同版本驱动。这里只给出chrome和firefox的驱动下载地址：<br>1)chrome：<a href="http://npm.taobao.org/mirrors/chromedriver" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver</a> 或 <a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/index.html</a><br>2)firefox：<a href="https://github.com/mozilla/geckodriver/releases" target="_blank" rel="noopener">https://github.com/mozilla/geckodriver/releases</a></p></blockquote><p>(2)安装浏览器驱动</p><blockquote><p>下载完驱动后解压，将驱动放置在可执行路径下。这里给出三种路径：<br>1)将浏览器驱动放到python的Path路径下。<br>2)将浏览器驱动放到浏览器的Path路径下。<br>3)自定义路径，新建driver文件夹，将驱动放在driver文件下，最后将该路径添加到环境变量中。</p></blockquote></blockquote><h2 id="五、验证环境（小示例）"><a href="#五、验证环境（小示例）" class="headerlink" title="五、验证环境（小示例）"></a>五、验证环境（小示例）</h2><blockquote><p>(1)创建python文件selenium_python.py，内容如下：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(&apos;http://www.baidu.com/&apos;)</span><br></pre></td></tr></table></figure></blockquote><p>(2)cmd执行命令<code>python selenium_python.py</code>。<br>(3)脚本自动执行，结果如下：</p><blockquote><p><img src="/2018/03/01/selenium安装-windows/脚本执行结果.png" alt="脚本执行结果"></p></blockquote></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;selenium环境搭建的简单步骤：安装Python——安装pip——安装selenium——安装浏览器驱动。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web测试" scheme="http://pythonfood.github.io/categories/web%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="selenium" scheme="http://pythonfood.github.io/tags/selenium/"/>
    
  </entry>
  
  <entry>
    <title>appium键值表</title>
    <link href="http://pythonfood.github.io/2018/02/01/appium%E9%94%AE%E5%80%BC%E8%A1%A8/"/>
    <id>http://pythonfood.github.io/2018/02/01/appium键值表/</id>
    <published>2018-02-01T04:00:00.000Z</published>
    <updated>2018-05-11T06:54:00.686Z</updated>
    
    <content type="html"><![CDATA[<p>appium键值表查询。<br><a id="more"></a></p><h2 id="一、电话键"><a href="#一、电话键" class="headerlink" title="一、电话键"></a>一、电话键</h2><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th><th style="text-align:left">键值</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_CALL</td><td style="text-align:left">拨号键</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left">KEYCODE_ENDCALL</td><td style="text-align:left">挂机键</td><td style="text-align:left">6</td></tr><tr><td style="text-align:left">KEYCODE_HOME</td><td style="text-align:left">按键Home</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">KEYCODE_MENU</td><td style="text-align:left">菜单键</td><td style="text-align:left">82</td></tr><tr><td style="text-align:left">KEYCODE_BACK</td><td style="text-align:left">返回键</td><td style="text-align:left">4</td></tr><tr><td style="text-align:left">KEYCODE_SEARCH</td><td style="text-align:left">搜索键</td><td style="text-align:left">84</td></tr><tr><td style="text-align:left">KEYCODE_CAMERA</td><td style="text-align:left">拍照键</td><td style="text-align:left">27</td></tr><tr><td style="text-align:left">KEYCODE_FOCUS</td><td style="text-align:left">拍照对焦键</td><td style="text-align:left">80</td></tr><tr><td style="text-align:left">KEYCODE_POWER</td><td style="text-align:left">电源键</td><td style="text-align:left">26</td></tr><tr><td style="text-align:left">KEYCODE_NOTIFICATION</td><td style="text-align:left">通知键</td><td style="text-align:left">83</td></tr><tr><td style="text-align:left">KEYCODE_MUTE</td><td style="text-align:left">话筒静音键</td><td style="text-align:left">91</td></tr><tr><td style="text-align:left">KEYCODE_VOLUME_MUTE</td><td style="text-align:left">扬声器静音键</td><td style="text-align:left">164</td></tr><tr><td style="text-align:left">KEYCODE_VOLUME_UP</td><td style="text-align:left">音量增加键</td><td style="text-align:left">24</td></tr><tr><td style="text-align:left">KEYCODE_VOLUME_DOWN</td><td style="text-align:left">音量减小键</td><td style="text-align:left">25</td></tr></tbody></table><h2 id="二、控制键"><a href="#二、控制键" class="headerlink" title="二、控制键"></a>二、控制键</h2><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th><th style="text-align:left">键值</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_ENTER</td><td style="text-align:left">回车键</td><td style="text-align:left">66</td></tr><tr><td style="text-align:left">KEYCODE_ESCAPE</td><td style="text-align:left">ESC键</td><td style="text-align:left">111</td></tr><tr><td style="text-align:left">KEYCODE_DPAD_CENTER</td><td style="text-align:left">导航键 确定键</td><td style="text-align:left">23</td></tr><tr><td style="text-align:left">KEYCODE_DPAD_UP</td><td style="text-align:left">导航键 向上</td><td style="text-align:left">19</td></tr><tr><td style="text-align:left">KEYCODE_DPAD_DOWN</td><td style="text-align:left">导航键 向下</td><td style="text-align:left">20</td></tr><tr><td style="text-align:left">KEYCODE_DPAD_LEFT</td><td style="text-align:left">导航键 向左</td><td style="text-align:left">21</td></tr><tr><td style="text-align:left">KEYCODE_DPAD_RIGHT</td><td style="text-align:left">导航键 向右</td><td style="text-align:left">22</td></tr><tr><td style="text-align:left">KEYCODE_MOVE_HOME</td><td style="text-align:left">光标移动到开始键</td><td style="text-align:left">122</td></tr><tr><td style="text-align:left">KEYCODE_MOVE_END</td><td style="text-align:left">光标移动到末尾键</td><td style="text-align:left">123</td></tr><tr><td style="text-align:left">KEYCODE_PAGE_UP</td><td style="text-align:left">向上翻页键</td><td style="text-align:left">92</td></tr><tr><td style="text-align:left">KEYCODE_PAGE_DOWN</td><td style="text-align:left">向下翻页键</td><td style="text-align:left">93</td></tr><tr><td style="text-align:left">KEYCODE_DEL</td><td style="text-align:left">退格键</td><td style="text-align:left">67</td></tr><tr><td style="text-align:left">KEYCODE_FORWARD_DEL</td><td style="text-align:left">删除键</td><td style="text-align:left">112</td></tr><tr><td style="text-align:left">KEYCODE_INSERT</td><td style="text-align:left">插入键</td><td style="text-align:left">124</td></tr><tr><td style="text-align:left">KEYCODE_TAB</td><td style="text-align:left">Tab键</td><td style="text-align:left">61</td></tr><tr><td style="text-align:left">KEYCODE_NUM_LOCK</td><td style="text-align:left">小键盘锁</td><td style="text-align:left">143</td></tr><tr><td style="text-align:left">KEYCODE_CAPS_LOCK</td><td style="text-align:left">大写锁定键</td><td style="text-align:left">115</td></tr><tr><td style="text-align:left">KEYCODE_BREAK</td><td style="text-align:left">Break/Pause键</td><td style="text-align:left">121</td></tr><tr><td style="text-align:left">KEYCODE_SCROLL_LOCK</td><td style="text-align:left">滚动锁定键</td><td style="text-align:left">116</td></tr><tr><td style="text-align:left">KEYCODE_ZOOM_IN</td><td style="text-align:left">放大键</td><td style="text-align:left">168</td></tr><tr><td style="text-align:left">KEYCODE_ZOOM_OUT</td><td style="text-align:left">缩小键</td><td style="text-align:left">169</td></tr></tbody></table><h2 id="三、组合键"><a href="#三、组合键" class="headerlink" title="三、组合键"></a>三、组合键</h2><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_ALT_LEFT</td><td style="text-align:left">Alt+Left</td></tr><tr><td style="text-align:left">KEYCODE_ALT_RIGHT</td><td style="text-align:left">Alt+Right</td></tr><tr><td style="text-align:left">KEYCODE_CTRL_LEFT</td><td style="text-align:left">Control+Left</td></tr><tr><td style="text-align:left">KEYCODE_CTRL_RIGHT</td><td style="text-align:left">Control+Right</td></tr><tr><td style="text-align:left">KEYCODE_SHIFT_LEFT</td><td style="text-align:left">Shift+Left</td></tr><tr><td style="text-align:left">KEYCODE_SHIFT_RIGHT</td><td style="text-align:left">Shift+Right</td></tr></tbody></table><h2 id="四、基本键"><a href="#四、基本键" class="headerlink" title="四、基本键"></a>四、基本键</h2><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th><th style="text-align:left">键值</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_0</td><td style="text-align:left">按键’0’</td><td style="text-align:left">7</td></tr><tr><td style="text-align:left">KEYCODE_1</td><td style="text-align:left">按键’1’</td><td style="text-align:left">8</td></tr><tr><td style="text-align:left">KEYCODE_2</td><td style="text-align:left">按键’2’</td><td style="text-align:left">9</td></tr><tr><td style="text-align:left">KEYCODE_3</td><td style="text-align:left">按键’3’</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">KEYCODE_4</td><td style="text-align:left">按键’4’</td><td style="text-align:left">11</td></tr><tr><td style="text-align:left">KEYCODE_5</td><td style="text-align:left">按键’5’</td><td style="text-align:left">12</td></tr><tr><td style="text-align:left">KEYCODE_6</td><td style="text-align:left">按键’6’</td><td style="text-align:left">13</td></tr><tr><td style="text-align:left">KEYCODE_7</td><td style="text-align:left">按键’7’</td><td style="text-align:left">14</td></tr><tr><td style="text-align:left">KEYCODE_8</td><td style="text-align:left">按键’8’</td><td style="text-align:left">15</td></tr><tr><td style="text-align:left">KEYCODE_9</td><td style="text-align:left">按键’9’</td><td style="text-align:left">16</td></tr><tr><td style="text-align:left">KEYCODE_A</td><td style="text-align:left">按键’A’</td><td style="text-align:left">29</td></tr><tr><td style="text-align:left">KEYCODE_B</td><td style="text-align:left">按键’B’</td><td style="text-align:left">30</td></tr><tr><td style="text-align:left">KEYCODE_C</td><td style="text-align:left">按键’C’</td><td style="text-align:left">31</td></tr><tr><td style="text-align:left">KEYCODE_D</td><td style="text-align:left">按键’D’</td><td style="text-align:left">32</td></tr><tr><td style="text-align:left">KEYCODE_E</td><td style="text-align:left">按键’E’</td><td style="text-align:left">33</td></tr><tr><td style="text-align:left">KEYCODE_F</td><td style="text-align:left">按键’F’</td><td style="text-align:left">34</td></tr><tr><td style="text-align:left">KEYCODE_G</td><td style="text-align:left">按键’G’</td><td style="text-align:left">35</td></tr><tr><td style="text-align:left">KEYCODE_H</td><td style="text-align:left">按键’H’</td><td style="text-align:left">36</td></tr><tr><td style="text-align:left">KEYCODE_I</td><td style="text-align:left">按键’I’</td><td style="text-align:left">37</td></tr><tr><td style="text-align:left">KEYCODE_J</td><td style="text-align:left">按键’J’</td><td style="text-align:left">38</td></tr><tr><td style="text-align:left">KEYCODE_K</td><td style="text-align:left">按键’K’</td><td style="text-align:left">39</td></tr><tr><td style="text-align:left">KEYCODE_L</td><td style="text-align:left">按键’L’</td><td style="text-align:left">40</td></tr><tr><td style="text-align:left">KEYCODE_M</td><td style="text-align:left">按键’M’</td><td style="text-align:left">41</td></tr><tr><td style="text-align:left">KEYCODE_N</td><td style="text-align:left">按键’N’</td><td style="text-align:left">42</td></tr><tr><td style="text-align:left">KEYCODE_O</td><td style="text-align:left">按键’O’</td><td style="text-align:left">43</td></tr><tr><td style="text-align:left">KEYCODE_P</td><td style="text-align:left">按键’P’</td><td style="text-align:left">44</td></tr><tr><td style="text-align:left">KEYCODE_Q</td><td style="text-align:left">按键’Q’</td><td style="text-align:left">45</td></tr><tr><td style="text-align:left">KEYCODE_R</td><td style="text-align:left">按键’R’</td><td style="text-align:left">46</td></tr><tr><td style="text-align:left">KEYCODE_S</td><td style="text-align:left">按键’S’</td><td style="text-align:left">47</td></tr><tr><td style="text-align:left">KEYCODE_T</td><td style="text-align:left">按键’T’</td><td style="text-align:left">48</td></tr><tr><td style="text-align:left">KEYCODE_U</td><td style="text-align:left">按键’U’</td><td style="text-align:left">49</td></tr><tr><td style="text-align:left">KEYCODE_V</td><td style="text-align:left">按键’V’</td><td style="text-align:left">50</td></tr><tr><td style="text-align:left">KEYCODE_W</td><td style="text-align:left">按键’W’</td><td style="text-align:left">51</td></tr><tr><td style="text-align:left">KEYCODE_X</td><td style="text-align:left">按键’X’</td><td style="text-align:left">52</td></tr><tr><td style="text-align:left">KEYCODE_Y</td><td style="text-align:left">按键’Y’</td><td style="text-align:left">53</td></tr><tr><td style="text-align:left">KEYCODE_Z</td><td style="text-align:left">按键’Z’</td><td style="text-align:left">54</td></tr></tbody></table><h2 id="五、符号键"><a href="#五、符号键" class="headerlink" title="五、符号键"></a>五、符号键</h2><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_PLUS</td><td style="text-align:left">按键’+’</td></tr><tr><td style="text-align:left">KEYCODE_MINUS</td><td style="text-align:left">按键’-‘</td></tr><tr><td style="text-align:left">KEYCODE_STAR</td><td style="text-align:left">按键’*’</td></tr><tr><td style="text-align:left">KEYCODE_SLASH</td><td style="text-align:left">按键’/‘</td></tr><tr><td style="text-align:left">KEYCODE_EQUALS</td><td style="text-align:left">按键’=’</td></tr><tr><td style="text-align:left">KEYCODE_AT</td><td style="text-align:left">按键’@’</td></tr><tr><td style="text-align:left">KEYCODE_POUND</td><td style="text-align:left">按键’#’</td></tr><tr><td style="text-align:left">KEYCODE_APOSTROPHE</td><td style="text-align:left">按键’’’ (单引号)</td></tr><tr><td style="text-align:left">KEYCODE_BACKSLASH</td><td style="text-align:left">按键’\’</td></tr><tr><td style="text-align:left">KEYCODE_COMMA</td><td style="text-align:left">按键’,’</td></tr><tr><td style="text-align:left">KEYCODE_PERIOD</td><td style="text-align:left">按键’.’</td></tr><tr><td style="text-align:left">KEYCODE_LEFT_BRACKET</td><td style="text-align:left">按键’[‘</td></tr><tr><td style="text-align:left">KEYCODE_RIGHT_BRACKET</td><td style="text-align:left">按键’]’</td></tr><tr><td style="text-align:left">KEYCODE_SEMICOLON</td><td style="text-align:left">按键’;’</td></tr><tr><td style="text-align:left">KEYCODE_GRAVE</td><td style="text-align:left">按键’`’</td></tr><tr><td style="text-align:left">KEYCODE_SPACE</td><td style="text-align:left">空格键</td></tr></tbody></table><h2 id="六、小键盘"><a href="#六、小键盘" class="headerlink" title="六、小键盘"></a>六、小键盘</h2><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_NUMPAD_0</td><td style="text-align:left">小键盘按键’0’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_1</td><td style="text-align:left">小键盘按键’1’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_2</td><td style="text-align:left">小键盘按键’2’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_3</td><td style="text-align:left">小键盘按键’3’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_4</td><td style="text-align:left">小键盘按键’4’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_5</td><td style="text-align:left">小键盘按键’5’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_6</td><td style="text-align:left">小键盘按键’6’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_7</td><td style="text-align:left">小键盘按键’7’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_8</td><td style="text-align:left">小键盘按键’8’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_9</td><td style="text-align:left">小键盘按键’9’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_ADD</td><td style="text-align:left">小键盘按键’+’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_SUBTRACT</td><td style="text-align:left">小键盘按键’-‘</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_MULTIPLY</td><td style="text-align:left">小键盘按键’*’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_DIVIDE</td><td style="text-align:left">小键盘按键’/‘</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_EQUALS</td><td style="text-align:left">小键盘按键’=’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_COMMA</td><td style="text-align:left">小键盘按键’,’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_DOT</td><td style="text-align:left">小键盘按键’.’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_LEFT_PAREN</td><td style="text-align:left">小键盘按键’(‘</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_RIGHT_PAREN</td><td style="text-align:left">小键盘按键’)’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_ENTER</td><td style="text-align:left">小键盘按键回车</td></tr></tbody></table><h2 id="七、功能键"><a href="#七、功能键" class="headerlink" title="七、功能键"></a>七、功能键</h2><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_F1</td><td style="text-align:left">按键F1</td></tr><tr><td style="text-align:left">KEYCODE_F2</td><td style="text-align:left">按键F2</td></tr><tr><td style="text-align:left">KEYCODE_F3</td><td style="text-align:left">按键F3</td></tr><tr><td style="text-align:left">KEYCODE_F4</td><td style="text-align:left">按键F4</td></tr><tr><td style="text-align:left">KEYCODE_F5</td><td style="text-align:left">按键F5</td></tr><tr><td style="text-align:left">KEYCODE_F6</td><td style="text-align:left">按键F6</td></tr><tr><td style="text-align:left">KEYCODE_F7</td><td style="text-align:left">按键F7</td></tr><tr><td style="text-align:left">KEYCODE_F8</td><td style="text-align:left">按键F8</td></tr><tr><td style="text-align:left">KEYCODE_F9</td><td style="text-align:left">按键F9</td></tr><tr><td style="text-align:left">KEYCODE_F10</td><td style="text-align:left">按键F10</td></tr><tr><td style="text-align:left">KEYCODE_F11</td><td style="text-align:left">按键F11</td></tr><tr><td style="text-align:left">KEYCODE_F12</td><td style="text-align:left">按键F12</td></tr></tbody></table><h2 id="八、多媒体键"><a href="#八、多媒体键" class="headerlink" title="八、多媒体键"></a>八、多媒体键</h2><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_MEDIA_PLAY</td><td style="text-align:left">播放</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_STOP</td><td style="text-align:left">停止</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_PAUSE</td><td style="text-align:left">暂停</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_PLAY_PAUSE</td><td style="text-align:left">播放/暂停</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_FAST_FORWARD</td><td style="text-align:left">快进</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_REWIND</td><td style="text-align:left">快退</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_NEXT</td><td style="text-align:left">下一首</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_PREVIOUS</td><td style="text-align:left">上一首</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_CLOSE</td><td style="text-align:left">关闭</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_EJECT</td><td style="text-align:left">弹出</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_RECORD</td><td style="text-align:left">录音</td></tr></tbody></table><h2 id="九、手柄按键"><a href="#九、手柄按键" class="headerlink" title="九、手柄按键"></a>九、手柄按键</h2><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_BUTTON_1</td><td style="text-align:left">通用游戏手柄按钮 #1</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_2</td><td style="text-align:left">通用游戏手柄按钮 #2</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_3</td><td style="text-align:left">通用游戏手柄按钮 #3</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_4</td><td style="text-align:left">通用游戏手柄按钮 #4</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_5</td><td style="text-align:left">通用游戏手柄按钮 #5</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_6</td><td style="text-align:left">通用游戏手柄按钮 #6</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_7</td><td style="text-align:left">通用游戏手柄按钮 #7</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_8</td><td style="text-align:left">通用游戏手柄按钮 #8</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_9</td><td style="text-align:left">通用游戏手柄按钮 #9</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_10</td><td style="text-align:left">通用游戏手柄按钮 #10</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_11</td><td style="text-align:left">通用游戏手柄按钮 #11</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_12</td><td style="text-align:left">通用游戏手柄按钮 #12</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_13</td><td style="text-align:left">通用游戏手柄按钮 #13</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_14</td><td style="text-align:left">通用游戏手柄按钮 #14</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_15</td><td style="text-align:left">通用游戏手柄按钮 #15</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_16</td><td style="text-align:left">通用游戏手柄按钮 #16</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_A</td><td style="text-align:left">游戏手柄按钮 A</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_B</td><td style="text-align:left">游戏手柄按钮 B</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_C</td><td style="text-align:left">游戏手柄按钮 C</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_X</td><td style="text-align:left">游戏手柄按钮 X</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_Y</td><td style="text-align:left">游戏手柄按钮 Y</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_Z</td><td style="text-align:left">游戏手柄按钮 Z</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_L1</td><td style="text-align:left">游戏手柄按钮 L1</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_L2</td><td style="text-align:left">游戏手柄按钮 L2</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_R1</td><td style="text-align:left">游戏手柄按钮 R1</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_R2</td><td style="text-align:left">游戏手柄按钮 R2</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_MODE</td><td style="text-align:left">游戏手柄按钮 Mode</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_SELECT</td><td style="text-align:left">游戏手柄按钮 Select</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_START</td><td style="text-align:left">游戏手柄按钮 Start</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_THUMBL</td><td style="text-align:left">Left Thumb Button</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_THUMBR</td><td style="text-align:left">Right Thumb Button</td></tr></tbody></table><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;appium键值表查询。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="app测试" scheme="http://pythonfood.github.io/categories/app%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="appium" scheme="http://pythonfood.github.io/tags/appium/"/>
    
  </entry>
  
  <entry>
    <title>appium常用API</title>
    <link href="http://pythonfood.github.io/2018/02/01/appium%E5%B8%B8%E7%94%A8API/"/>
    <id>http://pythonfood.github.io/2018/02/01/appium常用API/</id>
    <published>2018-02-01T03:00:00.000Z</published>
    <updated>2018-05-11T06:54:01.436Z</updated>
    
    <content type="html"><![CDATA[<p>appium常用API笔记。<br><a id="more"></a></p><h2 id="一、元素定位"><a href="#一、元素定位" class="headerlink" title="一、元素定位"></a>一、元素定位</h2><p>(1)id定位<br>find_element_by_id(“resrouce-id”)</p><blockquote><p><code>driver.find_element_by_id(&#39;com.android.calculator2:id/digit8&#39;)</code></p></blockquote><p>(2)name定位<br>find_element_by_name(“text”)</p><blockquote><p><code>driver.find_element_by_name(&quot;昵称&quot;)</code></p></blockquote><p>(3)class_name定位<br>find_element_by_class_name(“class”)</p><blockquote><p><code>driver.find_element_by_class_name(&quot;android.widget.Button&quot;)</code></p></blockquote><p>(4)accessibility_id定位<br>find_element_by_accessibility_id(“content-desc”)</p><blockquote><p><code>driver.find_element_by_accessibility_id(&quot;delete&quot;)</code></p></blockquote><p>(5)xpath定位<br>find_element_by_xpath(“xpath”)</p><blockquote><p><code>driver.find_element_by_xpath(&quot;//android.widget.Button[@text=&#39;8&#39;]&quot;)</code></p></blockquote><p>(6)uiautomator定位<br>find_element_by_android_uiautomator(uia_string)<br>uiautomator可以针对resourceid、Text、description、class、package、index、instance等进行定位。</p><blockquote><p>1)resourceId方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().resourceId(&quot;%s&quot;)&#39;)</code></p></blockquote><p>2)text方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().text(&quot;%s&quot;)&#39;)</code></p></blockquote><p>3)description方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().description(&quot;%s&quot;)&#39;)</code></p></blockquote><p>4)className方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().className(&quot;%s&quot;)&#39;)</code></p></blockquote><p>5)packageName方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().packageName(&quot;%s&quot;)&#39;)</code></p></blockquote><p>6)index方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().index(&quot;%s&quot;)&#39;)</code></p></blockquote><p>7)instance方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().instance(&quot;%s&quot;)&#39;)</code></p></blockquote><p>8)className+index方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().className(&quot;%s&quot;).childSelector(new UiSelector().index(&quot;%d&quot;))&#39;)</code></p></blockquote><p>9)伪xpath方法定位</p><blockquote><p>a.通过同级元素定位同级元素</p><blockquote><p><code>driver.find_element_by_android_uiautomator(‘new UiSelector().text(&quot;Custom View&quot;).fromParent(new UiSelector().text(&quot;Accessibility Service&quot;))‘).click()</code>            </p></blockquote><p>b.通过父级元素定位子集元素</p><blockquote><p><code>driver.find_element_by_android_uiautomator(‘new UiSelector().className(&quot;android.widget.ListView&quot;).childSelector(new UiSelector().text(&quot;Custom View&quot;))‘).click()</code>  </p></blockquote></blockquote></blockquote><p>(7)用By定位</p><ul><li>By.ID   #相当于by_id</li><li>By.NAME   #相当于by_name</li><li>By.CLASS_NAME  #相当于by_class_name</li><li>By.ACCESSIBILITY_ID  #相当于by_accessibility_id</li><li>By.XPATH   #相当于by_xpath</li></ul><blockquote><p><code>find_element(By.ID,&quot;com.android.calculator2:id/digit8&quot;)</code></p></blockquote><h2 id="二、应用操作"><a href="#二、应用操作" class="headerlink" title="二、应用操作"></a>二、应用操作</h2><p>(1)安装应用<br><code>install_app()</code> #安装应用到设备中去。需要apk包的路径。</p><blockquote><p><code>driver.install_app(&quot;path/to/my.apk&quot;)</code><br><code>driver.install_app(&quot;D:\\android\\apk\\ContactManager.apk&quot;)</code></p></blockquote><p>(2)卸载应用<br><code>remove_app()</code> #从设备中删除一个应用。</p><blockquote><p><code>driver.remove_app(&quot;com.example.android.apis&quot;)</code></p></blockquote><p>(3)关闭应用<br><code>close_app()</code> #关闭打开的应用，默认关闭当前打开的应用，所以不需要入参。相当于按home键将应用置于后台，可以通过launch_app()再次启动。</p><blockquote><p><code>driver.close_app()</code></p></blockquote><p>(4)启动应用<br><code>launch_app()</code> #该方法需要配合close_app()使用的。</p><blockquote><p><code>driver.launch_app()</code></p></blockquote><p>(5)检查应用是否安装<br><code>is_app_installed()</code> #检查应用是否已经安装。需要传参应用包的名字。返回结果为Ture或False。</p><blockquote><p><code>driver.is_app_installed(&#39;com.example.android.apis&#39;)</code></p></blockquote><p>(6)将应用置于后台<br><code>background_app()</code> #将当前活跃的应用程序发送到后台。这个方法需要入参，需要指定应用置于后台的时长。</p><blockquote><p><code>driver.background_app(2)</code></p></blockquote><p>(7)应用重置<br><code>reset_app()</code> #重置当前被测程序到出始化状态。该方法不需要入参。</p><blockquote><p><code>driver.reset_app()</code></p></blockquote><p>(8)启动activity<br><code>start_activity()</code> #启动一个app或者在当前app中打开一个新的activity，仅适用于android。</p><blockquote><p><code>driver.start_activity(&#39;com.example.android.apis&#39;, &#39;.Foo&#39;)</code></p></blockquote><h2 id="三、键盘操作"><a href="#三、键盘操作" class="headerlink" title="三、键盘操作"></a>三、键盘操作</h2><p>ps：<a href="https://pythonfood.github.io/2018/02/01/appium键值表/#more">appium键值表</a><br>(1)send_keys()方法</p><blockquote><p><code>driver.find_element_by_name(“Name”).send_keys(&quot;jack&quot;)</code></p></blockquote><p>(2)keyevent()方法</p><blockquote><p><code>`driver.keyevent(4)</code> #点击Android的返回键`</p></blockquote><p>(3)press_keycode()方法</p><blockquote><p><code>driver.press_keycode(3)</code> #点击Android的HOME键</p></blockquote><p>(4)long_press_keycode()方法</p><blockquote><p><code>driver.long_press_keycode(4)</code> #长按Android的返回键</p></blockquote><p>(5)隐藏键盘</p><blockquote><p><code>driver.hide_keyboard()</code> #android不需要参数，ios需要传参key_name</p></blockquote><h2 id="四、TouchAction操作"><a href="#四、TouchAction操作" class="headerlink" title="四、TouchAction操作"></a>四、TouchAction操作</h2><p>使用前导入TouchAction模块<code>from appium.webdriver.common.touch_action import TouchAction</code><br>(1)点击<br><code>tap(self,el=None,x=None,y=None,count=1)</code><br>(2)短按<br><code>press(self, el=None, x=None, y=None)</code><br>(3)长按<br><code>long_press(self, el=None, x=None, y=None, duration=1000(ms))</code><br>(4)释放<br><code>release(self)</code><br>(5)移动到<br><code>move_to(self,el=None,x=None,y=None)</code><br>(6)等待<br><code>wait(self,ms=0)</code><br>(7)执行<br><code>perform(self)</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#关于perform官网给的伪代码中讲</span><br><span class="line">TouchAction().tap(el).perform()</span><br><span class="line">#与</span><br><span class="line">driver.perform(TouchAction().tap(el))</span><br><span class="line">#效果一致</span><br></pre></td></tr></table></figure></blockquote><p>(8)多点触控<br><code>MultiTouch()</code> #多点触控,它只提供了两个方法:一个<code>add()</code>、一个执行<code>perform()</code>。<br>使用前导入MultiAction模块<code>from appium.webdriver.common.multi_action import MultiAction</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from appium.webdriver.common.touch_action import TouchAction</span><br><span class="line">from appium.webdriver.common.multi_action import MultiAction</span><br><span class="line"></span><br><span class="line">action0 = TouchAction().tap(el1)</span><br><span class="line">action1 = TouchAction().tap(el2)</span><br><span class="line">MultiTouch().add(action0).add(action1).perform()</span><br></pre></td></tr></table></figure></blockquote><h2 id="五、上下文操作"><a href="#五、上下文操作" class="headerlink" title="五、上下文操作"></a>五、上下文操作</h2><p>(1)当前会话中的所有上下文，使用后可以识别H5页面的控件<br><code>driver.contexts</code></p><blockquote><p>获取的是一个list列表：</p><blockquote><ul><li>NATIVE_APP:这个就是native，也就是原生的</li><li>WEBVIEW_com.xxxx :这个就是webview</li></ul></blockquote></blockquote><p>(2)当前会话的当前上下文<br><code>driver.current_context</code><br>(3)切换上下文<br><code>driver.switch_to.context(&quot;content_str&quot;)</code></p><blockquote><p>1)切换到webview</p><blockquote><p>方法一：<code>driver.switch_to.context(&#39;webview的context&#39;)</code><br>方法二：<code>driver.switch_to.context(contexts[1])</code> #从contexts列表里取第二个参数</p></blockquote><p>2)切回native</p><blockquote><p>方法一：<code>driver.switch_to.context(&quot;NATIVE_APP&quot;)</code> #这个NATIVE_APP是固定的参数<br>方法二：<code>driver.switch_to.context(contexts[0])</code> #从contexts列表里取第一个参数</p></blockquote></blockquote><p>(4)应用的字符串<br><code>driver.app_strings</code></p><h2 id="六、屏幕操作"><a href="#六、屏幕操作" class="headerlink" title="六、屏幕操作"></a>六、屏幕操作</h2><p>(1)点击<br>1)<code>click()</code></p><blockquote><p><code>driver.find_element_by_id(&quot;com.wuba.zhuanzhuan:id/ae8&quot;).click()</code></p></blockquote><p>2)<code>driver.tap()</code></p><blockquote><p><code>driver.tap([(216,1776)],200)</code></p></blockquote><p>(2)滑动<br><code>driver.swipe(x1, y1, x2, y2,duration)</code> #从坐标(x1,x2)滑动到坐标(x2,y2)，duration非必填项，滑动时间</p><blockquote><p>一个向上下左右滑动的方法封装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#获得屏幕大小宽和高</span><br><span class="line">def getSize(driver):</span><br><span class="line">    x = driver.get_window_size()[&apos;width&apos;]</span><br><span class="line">    y = driver.get_window_size()[&apos;height&apos;]</span><br><span class="line">    return (x, y)</span><br><span class="line"></span><br><span class="line">#屏幕向上滑动</span><br><span class="line">def swipeUp(driver,t=1000):</span><br><span class="line">    l = getSize(driver)</span><br><span class="line">    x1 = int(l[0] * 0.5)    #x坐标</span><br><span class="line">    y1 = int(l[1] * 0.75)   #起始y坐标</span><br><span class="line">    y2 = int(l[1] * 0.25)   #终点y坐标</span><br><span class="line">    driver.swipe(x1, y1, x1, y2,t)</span><br><span class="line"></span><br><span class="line">#屏幕向下滑动</span><br><span class="line">def swipeDown(driver,t=1000):</span><br><span class="line">    l = getSize(driver)</span><br><span class="line">    x1 = int(l[0] * 0.5)  #x坐标</span><br><span class="line">    y1 = int(l[1] * 0.25)   #起始y坐标</span><br><span class="line">    y2 = int(l[1] * 0.75)   #终点y坐标</span><br><span class="line">    driver.swipe(x1, y1, x1, y2,t)</span><br><span class="line">#屏幕向左滑动</span><br><span class="line">def swipLeft(driver,t):</span><br><span class="line">    l=getSize(driver)</span><br><span class="line">    x1=int(l[0]*0.75)</span><br><span class="line">    y1=int(l[1]*0.5)</span><br><span class="line">    x2=int(l[0]*0.05)</span><br><span class="line">    driver.swipe(x1,y1,x2,y1,t)</span><br><span class="line">#屏幕向右滑动</span><br><span class="line">def swipRight(driver,t=1000):</span><br><span class="line">    l=getSize(driver)</span><br><span class="line">    x1=int(l[0]*0.05)</span><br><span class="line">    y1=int(l[1]*0.5)</span><br><span class="line">    x2=int(l[0]*0.75)</span><br><span class="line">    driver.swipe(x1,y1,x2,y1,t)</span><br><span class="line"> </span><br><span class="line">#调用向下滑动的方法</span><br><span class="line">swipeDown(driver)</span><br></pre></td></tr></table></figure></p></blockquote><p>(3)滚动<br><code>driver.scroll(origin_el,destination_el)</code></p><p>(4)拖动<br><code>driver.drag_and_drop(el1,el2)</code></p><p>(5)快速滑动<br><code>driver.flick(start_x, start_y, end_x, end_y)</code></p><p>(6)缩小<br><code>driver.pinch(element)</code></p><p>(7)放大<br><code>driver.zoom(element)</code></p><p>(8)锁屏<br><code>driver.lock()</code> #android不需要传参，ios可以传参锁屏多少秒</p><p>(9)截屏<br><code>get_screenshot_as_file()</code></p><blockquote><p><code>driver.get_screenshot_as_file(&#39;../screenshot/foo.png&#39;)</code>#保存的图片路径和名称</p></blockquote><p>(10)屏幕旋转<br><code>rotate(ScreenOrientation orientation)</code></p><ul><li>landscape：限制界面为横屏，旋转屏幕也不会改变当前状态。</li><li>portrait：限制界面为竖屏，旋转屏幕也不会改变当前状态。</li><li>sensor:根据传感器定位方向，旋转手机90度，180,270,360，界面都会发生变化。</li><li>sensorLandscape：（横屏的旋转，不会出现竖屏的现象）根据传感器定位方向，旋转手机180度界面旋转。一般横屏游戏会是这个属性。</li><li>sensorPortrait：（竖屏的旋转，不会出现横屏的现象）根据传感器定位方向，旋转手机180度界面会旋转。</li><li>unspecified：由系统选择显示方向，不同的设备可能会有所不同。（旋转手机，界面会跟着旋转）</li><li>user: 用户当前的首选方向。</li><li>nosensor：不由传感器确定方向。旋转设备的时候，界面不会跟着旋转。初始界面方向由系统提供。</li></ul><p>(11)获取当前屏幕的方向<br><code>get_orientation()</code></p><h2 id="七、网络设置"><a href="#七、网络设置" class="headerlink" title="七、网络设置"></a>七、网络设置</h2><p>(1)返回网络类型数值<br><code>driver.network_connection</code></p><p>(2)网络设置<br><code>driver.setNetworkConnection(bitmask掩码)</code><br>使用前导入ConnectionType模块<code>from appium.webdriver.connectiontype import ConnectionType</code></p><blockquote><p><code>driver.set_network_connection(2)</code><br><code>driver.set_network_connection(ConnectionType.WIFI_ONLY)</code></p></blockquote><p>网络的bitmask掩码如下：</p><table><thead><tr><th style="text-align:left">值 (别名)</th><th style="text-align:left">数据连接</th><th style="text-align:left">Wifi连接</th><th style="text-align:left">飞行模式</th></tr></thead><tbody><tr><td style="text-align:left">0 (NO_CONNECTION)</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">1 (AIRPLANE_MODE)</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">2 (WIFI_ONLY)</td><td style="text-align:left">0</td><td style="text-align:left">1</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">4 (DATA_ONLY)</td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">6 (ALL_NETWORK_ON)</td><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">0</td></tr></tbody></table><h2 id="八、位置设置"><a href="#八、位置设置" class="headerlink" title="八、位置设置"></a>八、位置设置</h2><p>(1)打开定位设置<br><code>driver.toggle_location_services()</code> </p><p>(2)设置设备的经纬度<br><code>driver.set_location(latitude纬度，longitude经度，altitude海拔高度)</code></p><h2 id="九、文件操作"><a href="#九、文件操作" class="headerlink" title="九、文件操作"></a>九、文件操作</h2><p>(1)把本地文件push到设备上。<br><code>push_file()</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = &quot;some data for the file&quot;</span><br><span class="line">path = &quot;/data/local/tmp/file.txt&quot;</span><br><span class="line">driver.push_file(path, data.encode(&apos;base64&apos;))</span><br></pre></td></tr></table></figure></blockquote><p>(2)将设备上的文件pull到本地硬盘上<br><code>pull_file()</code></p><blockquote><p><code>driver.pull_file(&#39;Library/AddressBook/AddressBook.sqlitedb&#39;)</code></p></blockquote><p>(3)将设备上的文件夹pull到本地硬盘上，一般远程文件为/data/local/tmp下的文件。<br><code>pull_folder()</code></p><h2 id="十、activity操作"><a href="#十、activity操作" class="headerlink" title="十、activity操作"></a>十、activity操作</h2><p>(1)启动activity<br><code>driver.start_activity()</code></p><p>(2)获取当前activity<br><code>driver.current_activity</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">activity = self.driver.current_activity </span><br><span class="line">print(u&quot;当前的activity是:&quot;, activity)</span><br></pre></td></tr></table></figure></blockquote><p>(3)等待activity启动直到x秒超时，每隔y秒扫描一次<br><code>driver.wait_activity(activity, x, y)</code></p><p>(4)检查是否存在某个activity(未找到则返回异常）<br><code>driver.find_element_by_id(activity)</code></p><p>ps:查看包名和activity的方法：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 1)启动应用，输入命令，查看</span><br><span class="line">adb shell dumpsys window | findstr mCurrentFocus </span><br><span class="line"># 2)启动应用，输入命令，查看</span><br><span class="line">adb shell dumpsys activity activities</span><br><span class="line"># 3)有安装包，cmd输入命令，查看</span><br><span class="line">aapt dump badging &lt;file_path.apk&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="十一、其他操作"><a href="#十一、其他操作" class="headerlink" title="十一、其他操作"></a>十一、其他操作</h2><p>(1)打开通知栏<br><code>driver.open_notifications()</code></p><p>(2)摇一摇手机<br><code>driver.shake()</code></p><p>(3)获取控件各种属性<br><code>get_attribute()</code><br>可获取的字符串类型：</p><ul><li>name(返回content-desc或text)</li><li>text(返回text)</li><li>className(返回class，只有API=&gt;18才能支持)</li><li>resourceId(返回resource-id，只有API=&gt;18才能支持)</li><li>…uiautomator获得的属性</li></ul><blockquote><p><code>driver.find_element_by_id().get_attribute(name)</code></p></blockquote><p>(4)返回元素是否选择<br><code>element.is_slected()</code></p><p>(5)返回元素是否可用<br><code>element.is_enabled()</code></p><p>(6)返回元素的文本值<br><code>element.text()</code></p><p>(7)清除输入的内容<br><code>element.clear()</code></p><p>(8)获取元素的大小<br><code>driver.element.size</code></p><ul><li>new_size[“height”] = size[“height”]</li><li>new_size[“width”] = size[“width”]</li></ul><p>(9)获取元素左上角的坐标<br><code>driver.element.location</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#返回element的x坐标, int类型</span><br><span class="line">driver.element.location.get(&apos;x&apos;)</span><br><span class="line">#返回element的y坐标, int类型</span><br><span class="line">driver.element.location.get(&apos;y&apos;)</span><br></pre></td></tr></table></figure></blockquote><h2 id="十二、unittest断言"><a href="#十二、unittest断言" class="headerlink" title="十二、unittest断言"></a>十二、unittest断言</h2><p>在unittest单元测试框架中，TestCase类提供了一些方法来检查并报告故障：<br>(1)<code>assertEqual(first, second, msg=None)</code>#判断first和second的值是否相等，如果不相等则测试失败，msg用于定义失败后所抛出的异常信息。<br>(2)<code>assertNotEqual(first, second, msg=None)</code>#测试first和second不相等，如果相等，则测试失败。<br>(3)<code>assertTure(expr,msg=None)</code><br>(4)<code>assertFalse(expr,msg=None)</code>#测试expr为Ture（或为False）<br>(5)<code>assertIs(first, second, msg=None)</code><br>(6)<code>assertIsNot(first, second, msg=None)</code>#测试的first和second是（或不是）相同的对象。<br>(7)<code>assertIsNone(expr, msg=None)</code><br>(8)<code>assertIsNotNone(expr, msg=None)</code>#测试expr是（或不是）为None<br>(9)<code>assertIn(first, second, msg=None)</code><br>(10)<code>assertNotIn(first, second, msg=None)</code>#测试first是（或不是）在second中。second包含是否包含first。</p><h2 id="十三、脚本设计原则"><a href="#十三、脚本设计原则" class="headerlink" title="十三、脚本设计原则"></a>十三、脚本设计原则</h2><p>(1)LOVE原则(NativeApp)：</p><blockquote><p>1)Locate定位元素<br>2)Operate操作元素<br>3)Verify验证结果<br>4)Exception异常处理</p></blockquote><p>(2)S-LOVE原则(HybridApp)：</p><blockquote><p>1)Switch切换上下文<br>2)Locate定位元素<br>3)Operate操作元素<br>4)Verify验证结果<br>5)Exception异常处理</p></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;appium常用API笔记。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="app测试" scheme="http://pythonfood.github.io/categories/app%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="appium" scheme="http://pythonfood.github.io/tags/appium/"/>
    
  </entry>
  
  <entry>
    <title>appium DesiredCapabilities</title>
    <link href="http://pythonfood.github.io/2018/02/01/appium-DesiredCapabilities/"/>
    <id>http://pythonfood.github.io/2018/02/01/appium-DesiredCapabilities/</id>
    <published>2018-02-01T02:00:00.000Z</published>
    <updated>2018-05-11T06:54:01.436Z</updated>
    
    <content type="html"><![CDATA[<p>Appium Desired Capabilities 详解。<br><a id="more"></a></p><h2 id="一、基本参数"><a href="#一、基本参数" class="headerlink" title="一、基本参数"></a>一、基本参数</h2><table><thead><tr><th style="text-align:left">关键字</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">automationName</td><td style="text-align:left">自动化测试引擎</td><td style="text-align:left">Appium或 Selendroid</td></tr><tr><td style="text-align:left">platformName</td><td style="text-align:left">手机操作系统</td><td style="text-align:left">iOS, Android, 或 FirefoxOS</td></tr><tr><td style="text-align:left">platformVersion</td><td style="text-align:left">手机操作系统版本</td><td style="text-align:left">如： 7.1, 4.4；ios的 9.0</td></tr><tr><td style="text-align:left">deviceName</td><td style="text-align:left">手机或模拟器设备名称</td><td style="text-align:left">android的忽略，ios如iPhone Simulator</td></tr><tr><td style="text-align:left">app</td><td style="text-align:left">.ipa .apk文件路径</td><td style="text-align:left">比如/abs/path/to/my.apk或<a href="http://myapp.com/app.ipa" target="_blank" rel="noopener">http://myapp.com/app.ipa</a></td></tr><tr><td style="text-align:left">browserName</td><td style="text-align:left">启动手机浏览器</td><td style="text-align:left">iOS如:Safari，Android如:Chrome,Chromium,Browser</td></tr><tr><td style="text-align:left">newCommandTimeout</td><td style="text-align:left">设置命令超时时间，单位：秒。</td><td style="text-align:left">比如 60</td></tr><tr><td style="text-align:left">autoLaunch</td><td style="text-align:left">Appium是否需要自动安装和启动应用。默认值true</td><td style="text-align:left">true, false</td></tr><tr><td style="text-align:left">language</td><td style="text-align:left">(Sim/Emu-only) 设定模拟器 ( simulator / emulator ) 的语言。</td><td style="text-align:left">如： fr</td></tr><tr><td style="text-align:left">locale</td><td style="text-align:left">(Sim/Emu-only) 设定模拟器 ( simulator / emulator ) 的区域设置。</td><td style="text-align:left">如： fr_CA</td></tr><tr><td style="text-align:left">udid</td><td style="text-align:left">ios真机的唯一设备标识</td><td style="text-align:left">如： 1ae203187fc012g</td></tr><tr><td style="text-align:left">orientation</td><td style="text-align:left">设置横屏或竖屏</td><td style="text-align:left">LANDSCAPE (横向) 或 PORTRAIT (纵向)</td></tr><tr><td style="text-align:left">autoWebview</td><td style="text-align:left">直接转换到 WebView 上下文。 默认值 false、</td><td style="text-align:left">true, false</td></tr><tr><td style="text-align:left">noReset</td><td style="text-align:left">不要在会话前重置应用状态。默认值false。</td><td style="text-align:left">true, false</td></tr><tr><td style="text-align:left">fullReset</td><td style="text-align:left">(iOS) 删除整个模拟器目录。(Android)通过卸载默认值 false</td><td style="text-align:left">true, false</td></tr></tbody></table><h2 id="二、android特有"><a href="#二、android特有" class="headerlink" title="二、android特有"></a>二、android特有</h2><table><thead><tr><th style="text-align:left">关键字</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">appActivity</td><td style="text-align:left">启动app包,一般点开头</td><td style="text-align:left">如：.MainActivity, .Settings</td></tr><tr><td style="text-align:left">appPackage</td><td style="text-align:left">Android应用的包名</td><td style="text-align:left">比如com.example.android.myApp</td></tr><tr><td style="text-align:left">appWaitActivity</td><td style="text-align:left">等待启动的Activity名称</td><td style="text-align:left">SplashActivity</td></tr><tr><td style="text-align:left">deviceReadyTimeout</td><td style="text-align:left">设置超时时间</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left">androidCoverage</td><td style="text-align:left">用于执行测试的 instrumentation类</td><td style="text-align:left">com.my.Pkg/com.my.Pkg.instrumentation.MyInstrumentation</td></tr><tr><td style="text-align:left">enablePerformanceLogging</td><td style="text-align:left">(仅适用于 Chrome 和 webview) 开启 Chromedriver 的性能日志。(默认 false)</td><td style="text-align:left">true, false</td></tr><tr><td style="text-align:left">androidDeviceReadyTimeout</td><td style="text-align:left">等待设备在启动应用后超时时间，单位秒</td><td style="text-align:left">如 30</td></tr><tr><td style="text-align:left">androidDeviceSocket</td><td style="text-align:left">开发工具的 socket 名称。Chromedriver 把它作为开发者工具来进行连接。</td><td style="text-align:left">如 chrome_devtools_remote</td></tr><tr><td style="text-align:left">avd</td><td style="text-align:left">需要启动的 AVD (安卓模拟器设备) 名称。</td><td style="text-align:left">如 api19</td></tr><tr><td style="text-align:left">avdLaunchTimeout</td><td style="text-align:left">以毫秒为单位，等待 AVD 启动并连接到 ADB的超时时间。(默认值 120000)</td><td style="text-align:left">300000</td></tr><tr><td style="text-align:left">avdReadyTimeout</td><td style="text-align:left">以毫秒为单位，等待 AVD 完成启动动画的超时时间。(默认值 120000)</td><td style="text-align:left">300000</td></tr><tr><td style="text-align:left">avdArgs</td><td style="text-align:left">启动 AVD 时需要加入的额外的参数。</td><td style="text-align:left">如 -netfast</td></tr><tr><td style="text-align:left">useKeystore</td><td style="text-align:left">使用一个自定义的 keystore 来对 apk 进行重签名。默认值 false</td><td style="text-align:left">true or false</td></tr><tr><td style="text-align:left">keystorePath</td><td style="text-align:left">自定义keystore路径。默认~/.android/debug.keystore</td><td style="text-align:left">如 /path/to.keystore</td></tr><tr><td style="text-align:left">keystorePassword</td><td style="text-align:left">自定义 keystore 的密码。</td><td style="text-align:left">如 foo</td></tr><tr><td style="text-align:left">keyAlias</td><td style="text-align:left">key 的别名</td><td style="text-align:left">如 androiddebugkey</td></tr><tr><td style="text-align:left">keyPassword</td><td style="text-align:left">key 的密码</td><td style="text-align:left">如 foo</td></tr><tr><td style="text-align:left">chromedriverExecutable</td><td style="text-align:left">webdriver可执行文件的绝对路径 应该用它代替Appium 自带的 webdriver)</td><td style="text-align:left">/abs/path/to/webdriver</td></tr><tr><td style="text-align:left">autoWebviewTimeout</td><td style="text-align:left">毫秒为单位，Webview上下文激活的时间。默认2000</td><td style="text-align:left">如 4</td></tr><tr><td style="text-align:left">intentAction</td><td style="text-align:left">用于启动activity的intent action。(默认值 android.intent.action.MAIN)</td><td style="text-align:left">如 android.intent.action.MAIN, android.intent.action.VIEW</td></tr><tr><td style="text-align:left">intentCategory</td><td style="text-align:left">用于启动 activity 的 intent category。 (默认值 android.intent.category.LAUNCHER)</td><td style="text-align:left">如 android.intent.category.LAUNCHER, android.intent.category.APP_CONTACTS</td></tr><tr><td style="text-align:left">intentFlags</td><td style="text-align:left">用于启动activity的标识(flags) (默认值 0x10200000)</td><td style="text-align:left">如 0x10200000</td></tr><tr><td style="text-align:left">optionalIntentArguments</td><td style="text-align:left">用于启动 activity 的额外 intent 参数。请查看 Intent 参数</td><td style="text-align:left">如 –esn <extra_key>, –ez <extra_key> <extra_boolean_value></extra_boolean_value></extra_key></extra_key></td></tr><tr><td style="text-align:left">dontStopAppOnReset</td><td style="text-align:left">在使用 adb 启动应用时不要停止被测应用的进程。默认值： false</td><td style="text-align:left">true 或 false</td></tr><tr><td style="text-align:left">unicodeKeyboard</td><td style="text-align:left">使用 Unicode 输入法。默认值 false</td><td style="text-align:left">true 或 false</td></tr><tr><td style="text-align:left">resetKeyboard</td><td style="text-align:left">重置输入法到原有状态，默认值 false</td><td style="text-align:left">true 或 false</td></tr><tr><td style="text-align:left">noSign</td><td style="text-align:left">跳过检查和对应用进行 debug 签名的步骤。默认值 false</td><td style="text-align:left">true 或 false</td></tr><tr><td style="text-align:left">ignoreUnimportantViews</td><td style="text-align:left">调用 uiautomator 的函数这个关键字能加快测试执行的速度。默认值 false</td><td style="text-align:left">true 或 false</td></tr><tr><td style="text-align:left">disableAndroidWatchers</td><td style="text-align:left">关闭 android 监测应用无响ANR和崩溃crash的监视器默认值： false。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">chromeOptions</td><td style="text-align:left">允许传入 chrome driver 使用的 chromeOptions 参数。</td><td style="text-align:left">chromeOptions: {args: [‘–disable-popup-blocking‘]}</td></tr></tbody></table><h2 id="三、ios特有"><a href="#三、ios特有" class="headerlink" title="三、ios特有"></a>三、ios特有</h2><table><thead><tr><th style="text-align:left">关键字</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">calendarFormat</td><td style="text-align:left">(Sim-only) 为iOS的模拟器设置日历格式</td><td style="text-align:left">如 gregorian (公历)</td></tr><tr><td style="text-align:left">bundleId</td><td style="text-align:left">被测应用的bundle ID，真机上执行测试时，你可以不提供 app 关键字，但你必须提供udid</td><td style="text-align:left">如 io.appium.TestApp</td></tr><tr><td style="text-align:left">udid</td><td style="text-align:left">连接真机的唯一设备编号 ( Unique device identifier )</td><td style="text-align:left">如 1ae203187fc012g</td></tr><tr><td style="text-align:left">launchTimeout</td><td style="text-align:left">以毫秒为单位，在Appium运行失败之前设置一个等待 instruments的时间</td><td style="text-align:left">比如： 20000</td></tr><tr><td style="text-align:left">locationServicesEnabled</td><td style="text-align:left">(Sim-only) 强制打开或关闭定位服务。默认值是保持当前模拟器的设定</td><td style="text-align:left">true 或 false</td></tr><tr><td style="text-align:left">locationServicesAuthorized</td><td style="text-align:left">使用这个关键字时，你同时需要使用 bundleId 关键字来发送你的应用的 bundle ID。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">autoAcceptAlerts</td><td style="text-align:left">当 iOS 的个人信息访问警告 (如 位置、联系人、图片) 出现时，自动选择接受( Accept )。默认值 false。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">autoDismissAlerts</td><td style="text-align:left">当 iOS 的个人信息访问警告 (如 位置、联系人、图片) 出现时，自动选择不接受( Dismiss )。默认值 false。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">nativeInstrumentsLib</td><td style="text-align:left">使用原生 intruments 库 (即关闭 instruments-without-delay )</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">nativeWebTap</td><td style="text-align:left">(Sim-only) 在Safari中允许”真实的”，默认值： false。注意：取决于 viewport 大小/比例， 点击操作不一定能精确地点中对应的元素。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">safariInitialUrl</td><td style="text-align:left">(Sim-only) (&gt;= 8.1) Safari 的初始地址。默认值是一个本地的欢迎页面</td><td style="text-align:left">例如： <a href="https://www.github.com" target="_blank" rel="noopener">https://www.github.com</a></td></tr><tr><td style="text-align:left">safariAllowPopups</td><td style="text-align:left">(Sim-only) 允许 javascript 在 Safari 中创建新窗口。默认保持模拟器当前设置。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">safariIgnoreFraudWarning</td><td style="text-align:left">(Sim-only) 阻止 Safari 显示此网站可能存在风险的警告。默认保持浏览器当前设置。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">safariOpenLinksInBackground</td><td style="text-align:left">(Sim-only) Safari 是否允许链接在新窗口打开。默认保持浏览器当前设置。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">keepKeyChains</td><td style="text-align:left">(Sim-only) 当 Appium 会话开始/结束时是否保留存放密码存放记录 (keychains) (库(Library)/钥匙串(Keychains))</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">localizableStringsDir</td><td style="text-align:left">从哪里查找本地化字符串。默认值 en.lproj</td><td style="text-align:left">en.lproj</td></tr><tr><td style="text-align:left">processArguments</td><td style="text-align:left">通过 instruments 传递到 AUT 的参数</td><td style="text-align:left">如 -myflag</td></tr><tr><td style="text-align:left">interKeyDelay</td><td style="text-align:left">以毫秒为单位，按下每一个按键之间的延迟时间。</td><td style="text-align:left">如 100</td></tr><tr><td style="text-align:left">showIOSLog</td><td style="text-align:left">是否在 Appium 的日志中显示设备的日志。默认值 false</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">sendKeyStrategy</td><td style="text-align:left">输入文字到文字框的策略。模拟器默认值：oneByOne (一个接着一个) 。真实设备默认值：grouped (分组输入)</td><td style="text-align:left">oneByOne, grouped 或 setValue</td></tr><tr><td style="text-align:left">screenshotWaitTimeout</td><td style="text-align:left">以秒为单位，生成屏幕截图的最长等待时间。默认值： 10。</td><td style="text-align:left">如 5</td></tr><tr><td style="text-align:left">waitForAppScript</td><td style="text-align:left">用于判断 “应用是否被启动” 的 iOS 自动化脚本代码。默认情况下系统等待直到页面内容非空。结果必须是布尔类型。</td><td style="text-align:left">例如 true;, target.elements().length &gt; 0;, $.delay(5000); true;</td></tr></tbody></table><h2 id="四、小示例"><a href="#四、小示例" class="headerlink" title="四、小示例"></a>四、小示例</h2><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from appium import webdriver</span><br><span class="line"></span><br><span class="line">desired_caps=&#123;&#125;</span><br><span class="line">desired_caps[&apos;platformName&apos;]=&apos;Android&apos;</span><br><span class="line">desired_caps[&apos;platformVersion&apos;]=&apos;5.1.1&apos;</span><br><span class="line">desired_caps[&apos;deviceName&apos;]=&apos;172.16.10.26:5555&apos;</span><br><span class="line">desired_caps[&apos;appPackage&apos;]=&apos;com.peng.cloudp.tv&apos;</span><br><span class="line">desired_caps[&apos;appActivity&apos;]=&apos;..activity.StartPageActivity&apos;</span><br><span class="line">desired_caps[&apos;unicodeKeyboard&apos;]=&apos;true&apos;</span><br><span class="line">desired_caps[&apos;resetKeyboard&apos;]=&apos;true&apos;</span><br><span class="line">driver = webdriver.Remote(&apos;http://127.0.0.1:4723/wd/hub&apos;, desired_caps)</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Appium Desired Capabilities 详解。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="app测试" scheme="http://pythonfood.github.io/categories/app%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="appium" scheme="http://pythonfood.github.io/tags/appium/"/>
    
  </entry>
  
  <entry>
    <title>appium安装-windows</title>
    <link href="http://pythonfood.github.io/2018/02/01/appium%E5%AE%89%E8%A3%85-windows/"/>
    <id>http://pythonfood.github.io/2018/02/01/appium安装-windows/</id>
    <published>2018-02-01T01:00:00.000Z</published>
    <updated>2018-05-11T06:54:01.426Z</updated>
    
    <content type="html"><![CDATA[<p>appium环境搭建的简单步骤：安装jdk——安装android sdk——安装python——安装node.js——安装appium server——安装appium python客户端。<br><a id="more"></a></p><h2 id="一、安装jdk"><a href="#一、安装jdk" class="headerlink" title="一、安装jdk"></a>一、安装jdk</h2><blockquote><p>(1)下载jdk</p><blockquote><p>官网地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p></blockquote><p>(2)安装jdk</p><blockquote><p>根据提示安装，安装路径自定义：D:\Program Files\Java\jdk1.7.0_80</p></blockquote><p>(3)配置java环境变量</p><blockquote><p>1)系统变量→新建JAVA_HOME变量→变量值：D:\Program Files\Java\jdk1.7.0_80<br>2)系统变量→新建CLASSPATH变量→变量值：<code>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar</code><br>3)系统变量→编辑Path变量→增加：<code>;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</code>   </p></blockquote><p>(4)验证环境</p><blockquote><p>cmd输入<code>java -version</code>命令查看java版本。</p></blockquote></blockquote><h2 id="二、安装android-sdk"><a href="#二、安装android-sdk" class="headerlink" title="二、安装android sdk"></a>二、安装android sdk</h2><blockquote><p>(1)下载android sdk</p><blockquote><p>可以直接下载adt：<a href="http://tools.android-studio.org/index.php/adt-bundle-plugin" target="_blank" rel="noopener">http://tools.android-studio.org/index.php/adt-bundle-plugin</a></p></blockquote><p>(2)安装android sdk</p><blockquote><p>将adt压缩包解压到自定义路径：D:\Program Files\adt-bundle-windows-x86-20130917  </p></blockquote><p>(3)配置android环境变量</p><blockquote><p>1)系统变量→新建ANDROID_HOME变量→变量值：D:\Program Files\adt-bundle-windows-x86-20130917\sdk<br>2)系统变量→编辑Path变量→增加：<code>;%ANDROID_HOME%\tools;%ANDROID_HOME%\platform-tools;</code></p></blockquote><p>(4)验证环境</p><blockquote><p>cmd输入<code>adb</code>命令查看adb版本。</p></blockquote></blockquote><h2 id="三、安装Python"><a href="#三、安装Python" class="headerlink" title="三、安装Python"></a>三、<a href="https://pythonfood.github.io/2017/12/28/python安装-windows/#more">安装Python</a></h2><h2 id="四、安装node-js"><a href="#四、安装node-js" class="headerlink" title="四、安装node.js"></a>四、安装node.js</h2><blockquote><p>(1)下载node.js</p><blockquote><p>官网地址：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></p></blockquote><p>(2)安装node.js</p><blockquote><p>根据提示安装，安装路径自定义，自动添加PATH环境变量。</p></blockquote><p>(3)验证环境</p><blockquote><p>cmd输入<code>node -v</code>命令查看node版本。</p></blockquote></blockquote><h2 id="五、安装appium-server"><a href="#五、安装appium-server" class="headerlink" title="五、安装appium server"></a>五、安装appium server</h2><blockquote><p>方法1：npm安装</p><blockquote><p>(1)cmd输入<code>npm install -g appium</code>命令等待安装完成。（可能会被墙）<br>(2)cmd输入<code>npm install -g appium-doctor</code>命令安装Appium-doctor。<br>(3)cmd输入<code>appium-doctor</code>命令看到’All Checks were successful’则环境搭建成功。</p></blockquote><p>方法2：下载安装</p><blockquote><p>(1)下载地址：<a href="http://appium.io/" target="_blank" rel="noopener">http://appium.io/</a> 或 <a href="https://bitbucket.org/appium/appium.app/downloads/" target="_blank" rel="noopener">https://bitbucket.org/appium/appium.app/downloads/</a><br>(2)根据提示安装，安装路径自定义，自动添加PATH环境变量：<code>;D:\Program Files\Appium\node_modules\.bin;</code><br>(3)打开Appium图标验证安装成功。</p></blockquote><p>ps：appiun的server已经很久没有更新了，目前appium-desktop来继续他的使命。</p></blockquote><h2 id="六、安装appium-python客户端"><a href="#六、安装appium-python客户端" class="headerlink" title="六、安装appium python客户端"></a>六、安装appium python客户端</h2><blockquote><p>方法1：pip安装</p><blockquote><p>cmd输入<code>pip install Appium-Python-Client</code>命令等待安装完成。</p></blockquote><p>方法2：下载源码安装 </p><blockquote><p>(1)下载地址：<a href="https://pypi.python.org/pypi/Appium-Python-Client" target="_blank" rel="noopener">https://pypi.python.org/pypi/Appium-Python-Client</a><br>(2)解压后，cmd输入<code>cd Appium-Python-Client-X.X</code>命令进入目录。<br>(3)cmd输入<code>python setup.py install</code>命令进行安装。</p></blockquote></blockquote><h2 id="七、验证环境-小示例"><a href="#七、验证环境-小示例" class="headerlink" title="七、验证环境(小示例)"></a>七、验证环境(小示例)</h2><blockquote><p>(1)启动服务</p><blockquote><p>1)连接手机。<br>2)cmd输入<code>appium</code>命令启动服务。<br>3)打印日志如下图，则服务启动成功：</p><blockquote><p><img src="/2018/02/01/appium安装-windows/启动appium服务.png" alt="启动appium服务"></p></blockquote></blockquote><p>(2)代码示例</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from appium import webdriver</span><br><span class="line">from time import sleep</span><br><span class="line">import unittest</span><br><span class="line"></span><br><span class="line">class CalTest(unittest.TestCase):</span><br><span class="line">def setUp(self):</span><br><span class="line">desired_caps=&#123;&#125;</span><br><span class="line">desired_caps[&apos;platformName&apos;]=&apos;Android&apos;</span><br><span class="line">desired_caps[&apos;platformVersion&apos;]=&apos;5.0.2&apos;</span><br><span class="line">desired_caps[&apos;deviceName&apos;]=&apos;1ae7be68&apos;</span><br><span class="line">desired_caps[&apos;appPackage&apos;]=&apos;com.android.calculator2&apos;</span><br><span class="line">desired_caps[&apos;appActivity&apos;]=&apos;.Calculator&apos;</span><br><span class="line">self.driver=webdriver.Remote(&apos;http://localhost:4723/wd/hub&apos;,desired_caps)</span><br><span class="line"></span><br><span class="line">def tearDown(self):</span><br><span class="line">self.driver.quit()</span><br><span class="line"></span><br><span class="line">def test_add(self):</span><br><span class="line">driver.find_element_by_name(&quot;8&quot;).click()</span><br><span class="line">driver.find_element_by_id(&apos;digit7&apos;).click()</span><br><span class="line">driver.find_element_by_id(&apos;plus&apos;).click()</span><br><span class="line">driver.find_element_by_id(&apos;digit3&apos;).click()</span><br><span class="line">driver.find_element_by_id(&apos;equal&apos;).click()</span><br><span class="line">sleep(3)</span><br><span class="line">driver.find_element_by_id(&apos;clear&apos;).click()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">       suite = unittest.TestLoader().loadTestsFromTestCase(CalTest)</span><br><span class="line">       unittest.TextTestRunner(verbosity=2).run(suite)</span><br></pre></td></tr></table></figure></blockquote><p>(3)执行脚本    </p></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;appium环境搭建的简单步骤：安装jdk——安装android sdk——安装python——安装node.js——安装appium server——安装appium python客户端。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="app测试" scheme="http://pythonfood.github.io/categories/app%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="appium" scheme="http://pythonfood.github.io/tags/appium/"/>
    
  </entry>
  
  <entry>
    <title>安卓专项测试-流量</title>
    <link href="http://pythonfood.github.io/2018/01/01/%E5%AE%89%E5%8D%93%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95-%E6%B5%81%E9%87%8F/"/>
    <id>http://pythonfood.github.io/2018/01/01/安卓专项测试-流量/</id>
    <published>2018-01-01T06:00:00.000Z</published>
    <updated>2018-05-11T06:51:29.842Z</updated>
    
    <content type="html"><![CDATA[<p>python脚本实现安卓app的流量消耗测试。<br><a id="more"></a></p><h2 id="一、用到的adb命令"><a href="#一、用到的adb命令" class="headerlink" title="一、用到的adb命令"></a>一、用到的adb命令</h2><p>(1)获取进程ID指令：<br><code>adb shell &quot;ps | grep packagename&quot;</code><br>(2)获取进程ID流量：<br><code>adb shell cat /proc/pid/net/dev</code></p><h2 id="二、脚本实现策略"><a href="#二、脚本实现策略" class="headerlink" title="二、脚本实现策略"></a>二、脚本实现策略</h2><p>(1)设定一个场景，测试一段时间(此处最好再写一个自动化测试的脚本)。<br>(2)记录网卡eth0和eth1的Recevice和Transmit值，取本次流量值和上次流量值之差为所消耗的流量。</p><h2 id="三、测试数据分析"><a href="#三、测试数据分析" class="headerlink" title="三、测试数据分析"></a>三、测试数据分析</h2><p>(1)不同版本之间对比<br>(2)竞品之间对比</p><h2 id="四、代码实现示例"><a href="#四、代码实现示例" class="headerlink" title="四、代码实现示例"></a>四、代码实现示例</h2><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">import time</span><br><span class="line">import csv</span><br><span class="line"></span><br><span class="line">#控制类</span><br><span class="line">class Controller(object):</span><br><span class="line">    def __init__(self,count):</span><br><span class="line">        self.counter = count</span><br><span class="line">        self.allData = [(&apos;timestamp&apos;,&apos;traffic&apos;)]</span><br><span class="line">    </span><br><span class="line">    #单次获取流量值    </span><br><span class="line">    def traffic(self):</span><br><span class="line">        cmd = &apos;adb shell &quot;ps | grep com.android.browser&quot;&apos;</span><br><span class="line">        #截取进程id</span><br><span class="line">        pid = os.popen(cmd).readlines()[0].split(&apos; &apos;)[5]</span><br><span class="line">        #获取进程id所使用的流量</span><br><span class="line">        traffic = os.popen(&apos;adb shell cat /proc/&apos;+pid+&apos;/net/dev&apos;)</span><br><span class="line">        </span><br><span class="line">        for line in traffic:</span><br><span class="line">            if &apos;eth0&apos; in line:</span><br><span class="line">                #将所有空行换成&apos;#&apos;</span><br><span class="line">                line = &apos;#&apos;.join(line.split())</span><br><span class="line">                recevice0 = line.split(&apos;#&apos;)[1]</span><br><span class="line">                transmit0 = line.split(&apos;#&apos;)[9]</span><br><span class="line">            elif &apos;eth1&apos; in line:</span><br><span class="line">                #将所有空行换成&apos;#&apos;</span><br><span class="line">                line = &apos;#&apos;.join(line.split())</span><br><span class="line">                recevice1 = line.split(&apos;#&apos;)[1]</span><br><span class="line">                transmit1 = line.split(&apos;#&apos;)[9]</span><br><span class="line">        #计算流量总和        </span><br><span class="line">        alltraffic = int(recevice0)+int(transmit0)+int(recevice1)+int(transmit1)</span><br><span class="line">        #流量总和按KB计算</span><br><span class="line">        alltraffic = alltraffic/1024</span><br><span class="line">        </span><br><span class="line">        currenttime = self.getCurrentTime()</span><br><span class="line">        self.allData.append((currenttime,alltraffic))</span><br><span class="line">    </span><br><span class="line">    #多次获取流量值    </span><br><span class="line">    def run(self):</span><br><span class="line">        while self.counter&gt;0:</span><br><span class="line">            self.traffic()</span><br><span class="line">            self.counter = self.counter-1</span><br><span class="line">            time.sleep(5)</span><br><span class="line">    </span><br><span class="line">    #获取当前时间戳       </span><br><span class="line">    def getCurrentTime(self):</span><br><span class="line">        currentTime = time.strftime(&apos;%Y-%m-%d_%H:%M:%S&apos;, time.localtime())</span><br><span class="line">        return currentTime</span><br><span class="line">    </span><br><span class="line">    #数据存储</span><br><span class="line">    def SavaDataToCsv(self):</span><br><span class="line">        with open(&apos;traffic.csv&apos;, &apos;w&apos;, newline=&apos;&apos;) as csvfile:</span><br><span class="line">            writer = csv.writer(csvfile)</span><br><span class="line">            writer.writerows(self.allData)</span><br><span class="line">    </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    controller = Controller(5)</span><br><span class="line">    controller.run()</span><br><span class="line">    controller.SavaDataToCsv()</span><br></pre></td></tr></table></figure></blockquote><h2 id="五、测试结果示例"><a href="#五、测试结果示例" class="headerlink" title="五、测试结果示例"></a>五、测试结果示例</h2><p><img src="/2018/01/01/安卓专项测试-流量/流量消耗.png" alt="流量消耗"></p><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python脚本实现安卓app的流量消耗测试。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="app测试" scheme="http://pythonfood.github.io/categories/app%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="安卓性能" scheme="http://pythonfood.github.io/tags/%E5%AE%89%E5%8D%93%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>安卓专项测试-电量</title>
    <link href="http://pythonfood.github.io/2018/01/01/%E5%AE%89%E5%8D%93%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95-%E7%94%B5%E9%87%8F/"/>
    <id>http://pythonfood.github.io/2018/01/01/安卓专项测试-电量/</id>
    <published>2018-01-01T05:00:00.000Z</published>
    <updated>2018-05-11T06:52:03.073Z</updated>
    
    <content type="html"><![CDATA[<p>python脚本实现安卓app的电量消耗测试。<br><a id="more"></a></p><h2 id="一、用到的adb命令"><a href="#一、用到的adb命令" class="headerlink" title="一、用到的adb命令"></a>一、用到的adb命令</h2><p>(1)获取电量信息：<br><code>adb shell dumpsys battery</code><br>(2)切换非充电状态：<br><code>adb shell dumpsys battery set status 1</code></p><h2 id="二、脚本实现策略"><a href="#二、脚本实现策略" class="headerlink" title="二、脚本实现策略"></a>二、脚本实现策略</h2><p>(1)设定一个场景，测试一段时间(此处最好再写一个自动化测试的脚本)。<br>(2)记录电量level值，取最后一次和第一次电量差值，获取消耗的电量值。</p><h2 id="三、测试数据分析"><a href="#三、测试数据分析" class="headerlink" title="三、测试数据分析"></a>三、测试数据分析</h2><p>(1)不同版本之间对比<br>(2)竞品之间对比</p><h2 id="四、代码实现示例"><a href="#四、代码实现示例" class="headerlink" title="四、代码实现示例"></a>四、代码实现示例</h2><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">import time</span><br><span class="line">import csv</span><br><span class="line"></span><br><span class="line">#控制类</span><br><span class="line">class Controller(object):</span><br><span class="line">    def __init__(self,count):</span><br><span class="line">        self.counter = count</span><br><span class="line">        self.allData = [(&apos;timestamp&apos;,&apos;power&apos;)]</span><br><span class="line">    </span><br><span class="line">    #单次获取电量值    </span><br><span class="line">    def power(self):</span><br><span class="line">        #获取电量状态</span><br><span class="line">        powerStatus = os.popen(&apos;adb shell dumpsys battery&apos;)</span><br><span class="line">        </span><br><span class="line">        for line in powerStatus:</span><br><span class="line">            if &apos;level&apos; in line:</span><br><span class="line">                power = line.split(&apos;:&apos;)[1].strip(&apos;\n&apos;)</span><br><span class="line">        </span><br><span class="line">        currenttime = self.getCurrentTime()</span><br><span class="line">        self.allData.append((currenttime,power))</span><br><span class="line">    </span><br><span class="line">    #多次获取电量值    </span><br><span class="line">    def run(self):</span><br><span class="line">        os.popen(&apos;adb shell dumpsys battery set status 1&apos;)</span><br><span class="line">        while self.counter&gt;0:</span><br><span class="line">            self.power()</span><br><span class="line">            self.counter = self.counter-1</span><br><span class="line">            time.sleep(5)</span><br><span class="line">    </span><br><span class="line">    #获取当前时间 戳       </span><br><span class="line">    def getCurrentTime(self):</span><br><span class="line">        currentTime = time.strftime(&apos;%Y-%m-%d_%H:%M:%S&apos;, time.localtime())</span><br><span class="line">        return currentTime</span><br><span class="line">    </span><br><span class="line">    #数据存储</span><br><span class="line">    def SavaDataToCsv(self):</span><br><span class="line">        with open(&apos;power.csv&apos;, &apos;w&apos;, newline=&apos;&apos;) as csvfile:</span><br><span class="line">            writer = csv.writer(csvfile)</span><br><span class="line">            writer.writerows(self.allData)</span><br><span class="line">    </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    controller = Controller(5)</span><br><span class="line">    controller.run()</span><br><span class="line">    controller.SavaDataToCsv()</span><br></pre></td></tr></table></figure></blockquote><h2 id="五、测试结果示例"><a href="#五、测试结果示例" class="headerlink" title="五、测试结果示例"></a>五、测试结果示例</h2><p><img src="/2018/01/01/安卓专项测试-电量/电量消耗.png" alt="电量消耗"></p><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python脚本实现安卓app的电量消耗测试。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="app测试" scheme="http://pythonfood.github.io/categories/app%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="安卓性能" scheme="http://pythonfood.github.io/tags/%E5%AE%89%E5%8D%93%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>安卓专项测试-内存</title>
    <link href="http://pythonfood.github.io/2018/01/01/%E5%AE%89%E5%8D%93%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95-%E5%86%85%E5%AD%98/"/>
    <id>http://pythonfood.github.io/2018/01/01/安卓专项测试-内存/</id>
    <published>2018-01-01T04:00:00.000Z</published>
    <updated>2018-05-11T06:52:03.073Z</updated>
    
    <content type="html"><![CDATA[<p>python脚本实现安卓app的内存状态测试。<br><a id="more"></a></p><h2 id="一、用到的adb命令"><a href="#一、用到的adb命令" class="headerlink" title="一、用到的adb命令"></a>一、用到的adb命令</h2><p>(1)<code>adb shell top -d 刷新时间 &gt; meminfo</code></p><ul><li>VSS - 虚拟耗用内存</li><li>RSS - 实际使用物理内存</li></ul><p>(2)<code>cat meminfo | grep com.android.browser</code></p><h2 id="二、脚本实现策略"><a href="#二、脚本实现策略" class="headerlink" title="二、脚本实现策略"></a>二、脚本实现策略</h2><p>(1)打开app进行测试(此处最好再写一个自动化测试的脚本)。<br>(2)执行<code>adb shell top -d 1 &gt; D:\adt-workspace\appMemInfo\memInfo</code>，打印内存信息。<br>(3)执行脚本读取内存信息，保存到csv文件。</p><h2 id="三、测试数据分析"><a href="#三、测试数据分析" class="headerlink" title="三、测试数据分析"></a>三、测试数据分析</h2><p>曲线图分析：查看内存是否是一味上涨的趋势，不会回收或者部分回收。</p><h2 id="四、代码实现示例"><a href="#四、代码实现示例" class="headerlink" title="四、代码实现示例"></a>四、代码实现示例</h2><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line">import csv</span><br><span class="line"></span><br><span class="line">#控制类</span><br><span class="line">class Controller(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.allData = [(&apos;id&apos;, &apos;VSS&apos;, &apos;RSS&apos;)]</span><br><span class="line">    </span><br><span class="line">    #读取数据文件    </span><br><span class="line">    def readFile(self):</span><br><span class="line">        with open(&apos;meminfo&apos;, &apos;r&apos;, ) as memfile:</span><br><span class="line">            meminfo = memfile.readlines()</span><br><span class="line">            print(meminfo)</span><br><span class="line">        return meminfo</span><br><span class="line">    </span><br><span class="line">    #分析数据    </span><br><span class="line">    def analyzeData(self):</span><br><span class="line">        meminfo = self.readFile()</span><br><span class="line">        i=0 </span><br><span class="line">        for line in meminfo:</span><br><span class="line">            if &apos;com.android.browser&apos; in line:</span><br><span class="line">                line = &apos;#&apos;.join(line.split())</span><br><span class="line">                print(line)</span><br><span class="line">                vss = line.split(&apos;#&apos;)[5].strip(&apos;K&apos;)</span><br><span class="line">                rss = line.split(&apos;#&apos;)[6].strip(&apos;K&apos;)</span><br><span class="line">                self.allData.append((i, vss, rss))</span><br><span class="line">                i=i+1</span><br><span class="line">    #存取数据    </span><br><span class="line">    def saveDataToCsv(self):</span><br><span class="line">        with open(&apos;meminfo.csv&apos;, &apos;w&apos;, newline=&apos;&apos;) as csvfile:</span><br><span class="line">            writer = csv.writer(csvfile)</span><br><span class="line">            writer.writerows(self.allData)</span><br><span class="line">        </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    controller = Controller()</span><br><span class="line">    controller.analyzeData()</span><br><span class="line">    controller.saveDataToCsv()</span><br></pre></td></tr></table></figure></blockquote><h2 id="五、测试结果示例"><a href="#五、测试结果示例" class="headerlink" title="五、测试结果示例"></a>五、测试结果示例</h2><p><img src="/2018/01/01/安卓专项测试-内存/内存信息.png" alt="内存信息"></p><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python脚本实现安卓app的内存状态测试。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="app测试" scheme="http://pythonfood.github.io/categories/app%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="安卓性能" scheme="http://pythonfood.github.io/tags/%E5%AE%89%E5%8D%93%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>安卓专项测试-cpu</title>
    <link href="http://pythonfood.github.io/2018/01/01/%E5%AE%89%E5%8D%93%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95-cpu/"/>
    <id>http://pythonfood.github.io/2018/01/01/安卓专项测试-cpu/</id>
    <published>2018-01-01T03:00:00.000Z</published>
    <updated>2018-05-11T06:52:03.063Z</updated>
    
    <content type="html"><![CDATA[<p>python脚本实现安卓app的cpu使用率测试。<br><a id="more"></a></p><h2 id="一、用到的adb命令"><a href="#一、用到的adb命令" class="headerlink" title="一、用到的adb命令"></a>一、用到的adb命令</h2><p><code>adb shell &quot;dumpsys cpuinfo | grep packagename&quot;</code></p><h2 id="二、脚本实现策略"><a href="#二、脚本实现策略" class="headerlink" title="二、脚本实现策略"></a>二、脚本实现策略</h2><p>(1)打开app进行测试(此处最好再写一个自动化测试的脚本)。<br>(2)执行脚本定时获取CPU使用状态。</p><h2 id="三、测试数据分析"><a href="#三、测试数据分析" class="headerlink" title="三、测试数据分析"></a>三、测试数据分析</h2><p>曲线图分析：cpu使用率如果保持恒定并合理则正常；如果随着使用cpu使用率持续上升，接近100%可能存在问题。</p><h2 id="四、代码实现示例"><a href="#四、代码实现示例" class="headerlink" title="四、代码实现示例"></a>四、代码实现示例</h2><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">import time</span><br><span class="line">import csv    </span><br><span class="line"></span><br><span class="line">#控制类</span><br><span class="line">class Controller(object):</span><br><span class="line">    def __init__(self,count):</span><br><span class="line">        self.counter = count</span><br><span class="line">        self.allData = [(&apos;timestamp&apos;,&apos;cpustatus&apos;)]</span><br><span class="line">    </span><br><span class="line">    #单次查看CPU状态״̬</span><br><span class="line">    def CpuStatus(self):</span><br><span class="line">        cmd = &apos;adb shell &quot;dumpsys cpuinfo | grep com.android.calculator2&quot;&apos;</span><br><span class="line">        cpustatus = os.popen(cmd).readlines()</span><br><span class="line">        for line in cpustatus:</span><br><span class="line">            cpuvalue = line.split(&apos;%&apos;)[0].strip()  </span><br><span class="line">            break  </span><br><span class="line">            </span><br><span class="line">        currenttime = self.GetCurrentTime()</span><br><span class="line">        self.allData.append((currenttime, cpuvalue))</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    #多次查看CPU状态    </span><br><span class="line">    def run(self):</span><br><span class="line">        while self.counter&gt;0:</span><br><span class="line">            self.CpuStatus()</span><br><span class="line">            self.counter = self.counter-1</span><br><span class="line">            time.sleep(3)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    #获取当前时间戳         </span><br><span class="line">    def GetCurrentTime(self):</span><br><span class="line">        #时间格式如果写成%Y-%m-%d %H:%M:%S，写入csv时会被自定义格式隐藏秒</span><br><span class="line">        currentTime = time.strftime(&apos;%Y-%m-%d_%H:%M:%S&apos;, time.localtime()) </span><br><span class="line">        return currentTime</span><br><span class="line">    </span><br><span class="line">    #数据存储</span><br><span class="line">    def SaveDataToCSV(self):</span><br><span class="line">        with open(&apos;cpuStatus.csv&apos;, &apos;w&apos;, newline=&apos;&apos;) as csvfile:</span><br><span class="line">            writer = csv.writer(csvfile)</span><br><span class="line">            writer.writerows(self.allData)</span><br><span class="line">        </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    controller = Controller(10)</span><br><span class="line">    controller.run()</span><br><span class="line">    controller.SaveDataToCSV()</span><br></pre></td></tr></table></figure></blockquote><h2 id="五、测试结果示例"><a href="#五、测试结果示例" class="headerlink" title="五、测试结果示例"></a>五、测试结果示例</h2><p><img src="/2018/01/01/安卓专项测试-cpu/cpu使用率.png" alt="cpu使用率"></p><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python脚本实现安卓app的cpu使用率测试。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="app测试" scheme="http://pythonfood.github.io/categories/app%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="安卓性能" scheme="http://pythonfood.github.io/tags/%E5%AE%89%E5%8D%93%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>安卓专项测试-启动时间</title>
    <link href="http://pythonfood.github.io/2018/01/01/%E5%AE%89%E5%8D%93%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95-%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4/"/>
    <id>http://pythonfood.github.io/2018/01/01/安卓专项测试-启动时间/</id>
    <published>2018-01-01T02:00:00.000Z</published>
    <updated>2018-05-11T06:52:03.063Z</updated>
    
    <content type="html"><![CDATA[<p>python脚本实现安卓app的启动时间测试。<br><a id="more"></a></p><h2 id="一、用到的adb命令"><a href="#一、用到的adb命令" class="headerlink" title="一、用到的adb命令"></a>一、用到的adb命令</h2><p>(1)查看activity：</p><blockquote><p><code>adb shell dumpsys window | findstr mCurrentFocus</code><br><code>adb shell dumpsys activity activities</code></p></blockquote><p>(2)启动app：</p><blockquote><p><code>adb shell am start -W -n package/activity</code></p></blockquote><p>(3)停止app：</p><blockquote><p><code>adb shell am force-stop package</code></p></blockquote><p>(4)home退出app：</p><blockquote><p><code>adb shell input keyevent 3</code></p></blockquote><h2 id="二、脚本实现策略"><a href="#二、脚本实现策略" class="headerlink" title="二、脚本实现策略"></a>二、脚本实现策略</h2><p>策略一：获取命令执行时间，作为启动时间参考值，比较好实现。<br>策略二：在命令前后加上时间戳，以差值作为参考值，比较准确。</p><h2 id="三、测试数据分析"><a href="#三、测试数据分析" class="headerlink" title="三、测试数据分析"></a>三、测试数据分析</h2><p>一般剔除第一次数据，取剩余次数数据进行分析，因为第一次往往不准确。<br>(1)均值。<br>(2)曲线的波动范围。<br>(3)不同版本对比。<br>(4)和竞品对比。</p><h2 id="四、代码实现示例"><a href="#四、代码实现示例" class="headerlink" title="四、代码实现示例"></a>四、代码实现示例</h2><p>(1)冷启动</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">import time</span><br><span class="line">import csv</span><br><span class="line"></span><br><span class="line">#app类</span><br><span class="line">class App(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.content = &apos;&apos;</span><br><span class="line">        self.startTime = 0</span><br><span class="line">        </span><br><span class="line">    #启动app        </span><br><span class="line">    def LaunchApp(self):</span><br><span class="line">        cmd = &apos;adb shell am start -W -n com.android.calculator2/com.android.calculator2.Calculator&apos;</span><br><span class="line">        self.content = os.popen(cmd)</span><br><span class="line">   </span><br><span class="line">    #停止app</span><br><span class="line">    def StopApp(self):</span><br><span class="line">        #冷启动时强制退出</span><br><span class="line">        cmd = &apos;adb shell am force-stop com.android.calculator2&apos;</span><br><span class="line">        os.popen(cmd)</span><br><span class="line">    </span><br><span class="line">    #获取启动时间    </span><br><span class="line">    def GetLaunchedTime(self):</span><br><span class="line">        for line in self.content.readlines():</span><br><span class="line">            if &apos;ThisTime&apos; in line:</span><br><span class="line">                #split(&apos;:&apos;)[1]截取启动时间；strip(&apos;\n&apos;)去掉换行符</span><br><span class="line">                self.startTime = line.split(&apos;:&apos;)[1].strip(&apos;\n&apos;)</span><br><span class="line">                break</span><br><span class="line">        return self.startTime</span><br><span class="line"></span><br><span class="line">#控制类</span><br><span class="line">class Controller(object):</span><br><span class="line">    def __init__(self,count):</span><br><span class="line">        self.app = App()</span><br><span class="line">        self.counter = count</span><br><span class="line">        self.allData = [(&apos;timestamp&apos;,&apos;elapsedtime&apos;)]</span><br><span class="line">    </span><br><span class="line">    #单次启动和停止</span><br><span class="line">    def LaunchAndStop(self):</span><br><span class="line">        self.app.LaunchApp()</span><br><span class="line">        elapsedtime = self.app.GetLaunchedTime()</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        self.app.StopApp()</span><br><span class="line">        currenttime = self.GetCurrentTime()</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        self.allData.append((currenttime,elapsedtime))</span><br><span class="line">        </span><br><span class="line">    #多次执行启动和停止    </span><br><span class="line">    def run(self):</span><br><span class="line">        while self.counter&gt;0:</span><br><span class="line">            self.LaunchAndStop()</span><br><span class="line">            self.counter = self.counter-1</span><br><span class="line">    </span><br><span class="line">    #获取当前时间戳        </span><br><span class="line">    def GetCurrentTime(self):</span><br><span class="line">        #时间格式如果写成%Y-%m-%d %H:%M:%S，写入csv时会被自定义格式隐藏秒</span><br><span class="line">        currentTime = time.strftime(&apos;%Y-%m-%d_%H:%M:%S&apos;, time.localtime()) </span><br><span class="line">        return currentTime</span><br><span class="line">    </span><br><span class="line">    #数据存储</span><br><span class="line">    def SaveDataToCSV(self):</span><br><span class="line">        csvfile=open(&apos;coldStartTime.csv&apos;, &apos;w&apos;, newline=&apos;&apos;)    </span><br><span class="line">        writer = csv.writer(csvfile)</span><br><span class="line">        writer.writerows(self.allData)</span><br><span class="line">        csvfile.close()   </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    controller = Controller(10)</span><br><span class="line">    controller.run()</span><br><span class="line">    controller.SaveDataToCSV()</span><br></pre></td></tr></table></figure></blockquote><p>(2)热启动</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">import time</span><br><span class="line">import csv</span><br><span class="line"></span><br><span class="line">#app类</span><br><span class="line">class App(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.content = &apos;&apos;</span><br><span class="line">        self.startTime = 0</span><br><span class="line">        </span><br><span class="line">    #启动app        </span><br><span class="line">    def LaunchApp(self):</span><br><span class="line">        cmd = &apos;adb shell am start -W -n com.android.calculator2/com.android.calculator2.Calculator&apos;</span><br><span class="line">        self.content = os.popen(cmd)</span><br><span class="line">   </span><br><span class="line">    #停止app</span><br><span class="line">    def StopApp(self):</span><br><span class="line">        #热启动时home键退出</span><br><span class="line">        cmd = &apos;adb shell input keyevent 3&apos;</span><br><span class="line">        os.popen(cmd)</span><br><span class="line">    </span><br><span class="line">    #获取启动时间    </span><br><span class="line">    def GetLaunchedTime(self):</span><br><span class="line">        for line in self.content.readlines():</span><br><span class="line">            if &apos;ThisTime&apos; in line:</span><br><span class="line">                #split(&apos;:&apos;)[1]截取启动时间；strip(&apos;\n&apos;)去掉换行符</span><br><span class="line">                self.startTime = line.split(&apos;:&apos;)[1].strip(&apos;\n&apos;)</span><br><span class="line">                break</span><br><span class="line">        return self.startTime</span><br><span class="line"></span><br><span class="line">#控制类</span><br><span class="line">class Controller(object):</span><br><span class="line">    def __init__(self,count):</span><br><span class="line">        self.app = App()</span><br><span class="line">        self.counter = count</span><br><span class="line">        self.allData = [(&apos;timestamp&apos;,&apos;elapsedtime&apos;)]</span><br><span class="line">    </span><br><span class="line">    #单次启动和停止</span><br><span class="line">    def LaunchAndStop(self):</span><br><span class="line">        self.app.LaunchApp()</span><br><span class="line">        elapsedtime = self.app.GetLaunchedTime()</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        self.app.StopApp()</span><br><span class="line">        currenttime = self.GetCurrentTime()</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        self.allData.append((currenttime,elapsedtime))</span><br><span class="line">        </span><br><span class="line">    #多次执行启动和停止    </span><br><span class="line">    def run(self):</span><br><span class="line">        while self.counter&gt;0:</span><br><span class="line">            self.LaunchAndStop()</span><br><span class="line">            self.counter = self.counter-1</span><br><span class="line">    </span><br><span class="line">    #获取当前时间戳        </span><br><span class="line">    def GetCurrentTime(self):</span><br><span class="line">        #时间格式如果写成%Y-%m-%d %H:%M:%S，写入csv时会被自定义格式隐藏秒</span><br><span class="line">        currentTime = time.strftime(&apos;%Y-%m-%d_%H:%M:%S&apos;, time.localtime()) </span><br><span class="line">        return currentTime</span><br><span class="line">    </span><br><span class="line">    #数据存储</span><br><span class="line">    def SaveDataToCSV(self):</span><br><span class="line">        with open(&apos;hotStartTime.csv&apos;, &apos;w&apos;, newline=&apos;&apos;) as csvfile:</span><br><span class="line">            writer = csv.writer(csvfile)</span><br><span class="line">            writer.writerows(self.allData)</span><br><span class="line">    </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    controller = Controller(10)</span><br><span class="line">    controller.run()</span><br><span class="line">    controller.SaveDataToCSV()</span><br></pre></td></tr></table></figure></blockquote><h2 id="五、测试结果示例"><a href="#五、测试结果示例" class="headerlink" title="五、测试结果示例"></a>五、测试结果示例</h2><p>(1)冷启动</p><p><img src="/2018/01/01/安卓专项测试-启动时间/冷启动时间.png" alt="冷启动时间"></p><p>(2)热启动</p><p><img src="/2018/01/01/安卓专项测试-启动时间/热启动时间.png" alt="热启动时间"></p><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python脚本实现安卓app的启动时间测试。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="app测试" scheme="http://pythonfood.github.io/categories/app%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="安卓性能" scheme="http://pythonfood.github.io/tags/%E5%AE%89%E5%8D%93%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>安卓专项测试</title>
    <link href="http://pythonfood.github.io/2018/01/01/%E5%AE%89%E5%8D%93%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95/"/>
    <id>http://pythonfood.github.io/2018/01/01/安卓专项测试/</id>
    <published>2018-01-01T01:00:00.000Z</published>
    <updated>2018-05-11T06:52:03.053Z</updated>
    
    <content type="html"><![CDATA[<p>安卓专项测试主要包括：响应时间、cpu、内存、电量、流量、FPS、过度渲染。<br><a id="more"></a></p><h2 id="一、响应时间"><a href="#一、响应时间" class="headerlink" title="一、响应时间"></a>一、响应时间</h2><blockquote><p>1.安装：普通安装、覆盖安装<br>2.启动：冷启动、热启动</p><blockquote><p>(1)adb命令：adb logcat、adb shell am start、adb shell screenrecord等。</p><blockquote><p>小示例：<br>1)adb shell screenrecord /sdcard/demo.mp4<br>2)adb pull /sdcard/demo.mp4 d:\record<br>3)用按帧播放的视频软件播放分析，比如KMplayer。</p></blockquote><p>(2)代码里打点（埋点）。<br>(3)高速相机。<br>(4)秒表。<br>(5)第三方工具或云测平台。</p></blockquote><p>3.跳转：页面之间、控件之间</p></blockquote><h2 id="二、cpu"><a href="#二、cpu" class="headerlink" title="二、cpu"></a>二、cpu</h2><blockquote><p>1.活动状态<br>2.静默状态</p><blockquote><p>(1)第三方工具：腾讯GT、网易Emmagee、阿里易测等。（小白首选）。<br>(2)dumpsys命令：adb shell dumpsys cpuinfo | grep {PackageName}。<br>(3)top命令：adb shell top | grep {PackageName}。</p><blockquote><p>小示例：<br>1)adb shell<br>2)top | grep com.peng.cloudp.tv</p><blockquote><p>第一列PID:进度ID<br>第二列PR:优先级<br>第三列CPU:瞬时CPU占用率<br>第四列进程状态:R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程<br>第五列THR:当前应用所用的线程数<br>第六列VSS:虚拟消耗内存<br>第七列RSS:实际使用物理内存<br>第八列UID:进程所有者的用户ID<br>第九列PR:进程名称</p></blockquote></blockquote></blockquote></blockquote><h2 id="三、内存"><a href="#三、内存" class="headerlink" title="三、内存"></a>三、内存</h2><blockquote><p>1.命令查看内存数据</p><blockquote><p>(1)adb shell dumpsys meminfo {PackageName}查看内存是否是一味上涨的趋势，不会回收或者部分回收。<br>(2)/system/build.prop 查看每个应用分配的最高内存值。<br>adb shell procrank (没有可以从网上下载procrank文件)。</p><blockquote><p>PID:进程ID<br>VSS:虚拟消耗内存<br>RSS:实际使用物理内存，是共享内存+私有内存。<br>PSS:占用私有内存加上平均分配的的共享内存。<br>USS:私有内存，如果应用终止了，这部分内存会释放。如果这个值超过应用被分配的最大值，就会闪退。</p></blockquote></blockquote><p>2.Memory Monitor查看内存风险<br>3.MAT分析内存泄漏<br>4.Zombie辅助检查内存占用</p></blockquote><h2 id="四、电量"><a href="#四、电量" class="headerlink" title="四、电量"></a>四、电量</h2><blockquote><p>1.待机：无网络待机、wifi待机、3G待机等。<br>2.活动状态：不断地进行某些场景操作、看视频、灭屏下载、唤醒等。<br>3.静默状态：打开app后不操作，后台运行。</p><blockquote><p>(1)通过硬件测试：耗电量测试仪、腾讯的电量宝等<br>(2)通过adb shell dumpsys batterystats命令。（android5.0以上使用）<br>(3)第三方工具或云测平台。<br>(4)android自带的电量统计。</p></blockquote></blockquote><h2 id="五、流量"><a href="#五、流量" class="headerlink" title="五、流量"></a>五、流量</h2><blockquote><p>1.活动状态<br>2.静默状态</p><blockquote><p>(1)通过Tcpdump抓包，然后用Wireshark分析。如果想更自动化，可以用FildderCore二次开发。<br>(2)查看Linux流量统计文件。</p><blockquote><p>小示例：<br>1)ps | grep com.peng.cloudp.tv （获取的pid为9696）<br>2)cat /proc/9696/status （通过pid值获取uid为10035）<br>3)cat /proc/uid_stat/10035/tcp_snd （通过uid获取发送的流量byte,为15584）<br>4)cat /proc/uid_stat/10035/tcp_rcv （通过uid获取接收的流量byte,为16778）</p></blockquote><p>(3)利用类似DDMS的工具查看流量。（小白首选）<br>(4)通过Android API 的 TrafficStats类来统计。<br>(5)第三方工具或云测平台。</p></blockquote></blockquote><h2 id="六、FPS"><a href="#六、FPS" class="headerlink" title="六、FPS"></a>六、FPS</h2><blockquote><p>1.adb shell dumpsys gfxinfo</p><blockquote><p>小示例：<br>1)adb shell dumpsys gfxinfo com.peng.cloudp.tv &gt; com.peng.cloudp.tv.txt<br>2)抓取数据后用表格进行分析</p></blockquote><p>2.monitor.bat进行测试</p><p>3.打开【设置-开发者选项-GPU呈现模式分析-在屏幕上显示为条形图】，开启后点击应用，可以看到条形图。</p><blockquote><p>测试应用流畅度：<br>(1)条形图高于绿线，说明出现卡顿<br>(2)条形图低于绿线，说明比较流畅</p></blockquote></blockquote><h2 id="七、过度渲染"><a href="#七、过度渲染" class="headerlink" title="七、过度渲染"></a>七、过度渲染</h2><blockquote><p>1.打开【设置-开发者选项-调试GPU过度绘制-显示过度绘制区域】，开启后点击应用，可以看到各种颜色的区域。</p><blockquote><p>颜色的标识：<br>(1)蓝色1x过度绘制<br>(2)绿色2x过度绘制<br>(3)淡红色3x过度绘制<br>(4)红色超过4x过度绘制</p></blockquote><p>2.颜色越浅越好:蓝-绿-淡红-红。最理想的是一个像素只绘制一次，合格的页面是白色、蓝色为主，绿色以上区域不能超过整个的三分之一。</p><blockquote><p>验收标准：<br>(1)控制过度绘制为2x<br>(2)不允许存在4x过度绘制<br>(3)不允许存在面积超过屏幕1/4区域的3x过度绘制（淡红色区域）</p></blockquote></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安卓专项测试主要包括：响应时间、cpu、内存、电量、流量、FPS、过度渲染。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="app测试" scheme="http://pythonfood.github.io/categories/app%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="安卓性能" scheme="http://pythonfood.github.io/tags/%E5%AE%89%E5%8D%93%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>python内置函数</title>
    <link href="http://pythonfood.github.io/2017/12/30/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"/>
    <id>http://pythonfood.github.io/2017/12/30/python内置函数/</id>
    <published>2017-12-30T10:00:00.000Z</published>
    <updated>2018-05-11T06:46:37.065Z</updated>
    
    <content type="html"><![CDATA[<p>人生苦短，我用python。<br><a id="more"></a></p><h2 id="python内置函数"><a href="#python内置函数" class="headerlink" title="python内置函数"></a><a href="https://docs.python.org/3/library/functions.html#next" target="_blank" rel="noopener">python内置函数</a></h2><table><thead><tr><th style="text-align:left"></th><th style="text-align:left"></th><th style="text-align:left">Built-in Functions</th><th style="text-align:left"></th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">abs()</td><td style="text-align:left">dict()</td><td style="text-align:left">help()</td><td style="text-align:left">min()</td><td style="text-align:left">setattr()</td></tr><tr><td style="text-align:left">all()</td><td style="text-align:left">dir()</td><td style="text-align:left">hex()</td><td style="text-align:left">next()</td><td style="text-align:left">slice()</td></tr><tr><td style="text-align:left">any()</td><td style="text-align:left">divmod()</td><td style="text-align:left">id()</td><td style="text-align:left">object()</td><td style="text-align:left">sorted()</td></tr><tr><td style="text-align:left">ascii()</td><td style="text-align:left">enumerate()</td><td style="text-align:left">input()</td><td style="text-align:left">oct()</td><td style="text-align:left">staticmethod()</td></tr><tr><td style="text-align:left">bin()</td><td style="text-align:left">eval()</td><td style="text-align:left">int()</td><td style="text-align:left">open()</td><td style="text-align:left">str()</td></tr><tr><td style="text-align:left">bool()</td><td style="text-align:left">exec()</td><td style="text-align:left">isinstance()</td><td style="text-align:left">ord()</td><td style="text-align:left">sum()</td></tr><tr><td style="text-align:left">bytearray()</td><td style="text-align:left">filter()</td><td style="text-align:left">issubclass()</td><td style="text-align:left">pow()</td><td style="text-align:left">super()</td></tr><tr><td style="text-align:left">bytes()</td><td style="text-align:left">float()</td><td style="text-align:left">iter()</td><td style="text-align:left">print()</td><td style="text-align:left">tuple()</td></tr><tr><td style="text-align:left">callable()</td><td style="text-align:left">format()</td><td style="text-align:left">len()</td><td style="text-align:left">property()</td><td style="text-align:left">type()</td></tr><tr><td style="text-align:left">chr()</td><td style="text-align:left">frozenset()</td><td style="text-align:left">list()</td><td style="text-align:left">range()</td><td style="text-align:left">vars()</td></tr><tr><td style="text-align:left">classmethod()</td><td style="text-align:left">getattr()</td><td style="text-align:left">locals()</td><td style="text-align:left">repr()</td><td style="text-align:left">zip()</td></tr><tr><td style="text-align:left">compile()</td><td style="text-align:left">globals()</td><td style="text-align:left">map()</td><td style="text-align:left">reversed()</td><td style="text-align:left">__import__()</td></tr><tr><td style="text-align:left">complex()</td><td style="text-align:left">hasattr()</td><td style="text-align:left">max()</td><td style="text-align:left">round()</td></tr><tr><td style="text-align:left">delattr()</td><td style="text-align:left">hash()</td><td style="text-align:left">memoryview()</td><td style="text-align:left">set()</td></tr></tbody></table><ol><li><p><code>abs()</code>获取绝对值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; abs(-10)</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; abs(10)</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; abs(0)</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; a = -10</span><br><span class="line">&gt;&gt;&gt; a.__abs__()</span><br><span class="line">10</span><br></pre></td></tr></table></figure></li><li><p><code>all()</code>接受一个迭代器，如果迭代器的所有元素都为真，那么返回True，否则返回False</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tmp_1 = [&apos;python&apos;,123]</span><br><span class="line">&gt;&gt;&gt; all(tmp_1)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; tmp_2 = []</span><br><span class="line">&gt;&gt;&gt; all(tmp_2)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; tmp_3 = [0]</span><br><span class="line">&gt;&gt;&gt; all(tmp_3)</span><br><span class="line">False</span><br></pre></td></tr></table></figure></li><li><p><code>any()</code>接受一个迭代器，如果迭代器里有一个元素为真，那么返回True,否则返回False</p></li><li><p><code>ascii()</code>调用对象的__repr__()方法，获得该方法的返回值</p></li><li><p><code>bin()</code>接收一个十进制，转换成二进制</p></li><li><p><code>oct()</code>接收一个十进制，转换成八进制</p></li><li><p><code>hex()</code>接收一个十进制，转换成十六进制</p></li><li><p><code>bool()</code>测试一个对象是True还是False</p></li><li><p><code>bytes()</code>将一个字符串转换成字节类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = &apos;python&apos;</span><br><span class="line">&gt;&gt;&gt; x = bytes(s, encoding=&apos;utf-8&apos;)</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">b&apos;python&apos;</span><br><span class="line">&gt;&gt;&gt; a = &apos;王&apos;</span><br><span class="line">&gt;&gt;&gt; s = bytes(a, encoding=&apos;utf-8&apos;)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">b&apos;\xe7\x8e\x8b&apos;</span><br></pre></td></tr></table></figure></li><li><p><code>str()</code>将字符类型/数值类型等转换为字符串类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; str(b&apos;\xe7\x8e\x8b&apos;, encoding=&apos;utf-8&apos;)  # 字节转换为字符串</span><br><span class="line">&apos;王&apos;</span><br><span class="line">&gt;&gt;&gt; str(1)   # 整数转换为字符串</span><br><span class="line">&apos;1&apos;</span><br></pre></td></tr></table></figure></li><li><p><code>challable()</code>判断对象是否可以被调用，能被调用的对象就是一个callables对象，比如函数和带有__call__()的实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; callable(max)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; callable([1, 2, 3])</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; callable(None)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; callable(&apos;str&apos;)</span><br><span class="line">False</span><br></pre></td></tr></table></figure></li><li><p><code>char()</code>数字转字母，查看十进制数对应的ASCII字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; chr(-1)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#26&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    chr(-1)</span><br><span class="line">ValueError: chr() arg not in range(0x110000)</span><br><span class="line">&gt;&gt;&gt; chr(0)</span><br><span class="line">&apos;\x00&apos;</span><br></pre></td></tr></table></figure></li><li><p><code>ord()</code>字母转数字，查看某个ASCII对应的十进制数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ord(&apos;\x00&apos;)</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; ord(&apos;7&apos;)</span><br><span class="line">55</span><br></pre></td></tr></table></figure></li><li><p><code>classmethod()</code>用来指定一个方法为类的方法，由类直接调用执行，只有一个cls参数,执行雷的方法时，自动将调用该方法的类赋值给cls.没有此参数指定的类的方法为实例方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Province:</span><br><span class="line">    country = &quot;中国&quot;</span><br><span class="line">      </span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line">      </span><br><span class="line">    @classmethod</span><br><span class="line">    def show(cls):  # 类方法，由类调用，最少要有一个参数cls，调用的时候这个参数不用传值，自动将类名赋值给cls</span><br><span class="line">        print(cls)</span><br><span class="line">      </span><br><span class="line"># 调用方法</span><br><span class="line">Province.show()</span><br></pre></td></tr></table></figure></li><li><p><code>complie()</code>将字符串编译成python能识别或可以执行的代码，也可以将文字读成字符串再编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1)</span><br><span class="line">将source编译为代码或者AST对象。代码对象能过通过exec语句来执行或者eval()进行求值。</span><br><span class="line">参数source：字符串或者AST（abstract syntax trees）对象。</span><br><span class="line">参数filename：代码文件名称，如果不是从文件读取代码则传递一些可辨认的值。</span><br><span class="line">参数model：指定编译代码的种类。可以指定&apos;exec&apos;, &apos;eval&apos;, &apos;single&apos;。</span><br><span class="line">参数flag和dont_inherit：这两个参数为可选参数。</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; s  = &quot;print(&apos;helloworld&apos;)&quot;</span><br><span class="line">&gt;&gt;&gt; r = compile(s, &quot;&lt;string&gt;&quot;, &quot;exec&quot;)</span><br><span class="line">&gt;&gt;&gt; r</span><br><span class="line">&lt;code object &lt;module&gt; at 0x000001C648038390, file &quot;&lt;string&gt;&quot;, line 1&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>complex()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建一个值为real + imag * j的复数或者转化一个字符串或数为复数。如果第一个参数是字符串，则不需要指定第二个参数</span><br><span class="line">参数real：int，long，float或字符串。</span><br><span class="line">参数imag：int，long，float。</span><br></pre></td></tr></table></figure></li><li><p><code>delattr()</code>删除对象的属性</p></li><li><p><code>dict()</code>创建数据字典</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = dict()  空字典</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#123;&#125;</span><br><span class="line">&gt;&gt;&gt; b = dict(one = 1, two =2)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">&#123;&apos;one&apos;: 1, &apos;two&apos;: 2&#125;</span><br><span class="line">&gt;&gt;&gt; c = dict(&#123;&apos;one&apos;:1 ,&apos;two&apos;:2&#125;)</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">&#123;&apos;one&apos;: 1, &apos;two&apos;: 2&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>dir()</code>不带参数时返回当前范围内的变量，方法和定义的类型列表，带参数时返回参数的属性，方法列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dir()</span><br><span class="line">[&apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos;, &apos;li&apos;, &apos;li1&apos;, &apos;li2&apos;, &apos;li_1&apos;]</span><br><span class="line">&gt;&gt;&gt; dir(list)</span><br><span class="line">[&apos;__add__&apos;, &apos;__class__&apos;, &apos;__contains__&apos;, &apos;__delattr__&apos;, &apos;__delitem__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__getitem__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__iadd__&apos;, &apos;__imul__&apos;, &apos;__init__&apos;, &apos;__iter__&apos;, &apos;__le__&apos;, &apos;__len__&apos;, &apos;__lt__&apos;, &apos;__mul__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__reversed__&apos;, &apos;__rmul__&apos;, &apos;__setattr__&apos;, &apos;__setitem__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;append&apos;, &apos;clear&apos;, &apos;copy&apos;, &apos;count&apos;, &apos;extend&apos;, &apos;index&apos;, &apos;insert&apos;, &apos;pop&apos;, &apos;remove&apos;, &apos;reverse&apos;, &apos;sort&apos;]</span><br></pre></td></tr></table></figure></li><li><p><code>divmod()</code>分别取商和余数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; divmod(20,6)</span><br><span class="line">(3, 2)</span><br></pre></td></tr></table></figure></li><li><p><code>enumerate()</code>返回一个可以枚举的对象，该对象的next()方法将返回一个元组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; test = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line">&gt;&gt;&gt; for k,v in enumerate(test):</span><br><span class="line">    print(k,v)</span><br><span class="line"> </span><br><span class="line"># 输出结果： </span><br><span class="line">0 a</span><br><span class="line">1 b</span><br><span class="line">2 c</span><br></pre></td></tr></table></figure></li><li><p><code>eval()</code>将字符串str当成有效的表达式来求值并返回计算结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = &quot;1+2*3&quot;</span><br><span class="line">&gt;&gt;&gt; type(s)</span><br><span class="line">&lt;class &apos;str&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; eval(s)</span><br><span class="line">7</span><br></pre></td></tr></table></figure></li><li><p><code>exec()</code>执行字符串或complie方法编译过的字符串，没有返回值</p></li><li><p><code>filter()</code>过滤器，构造一个序列，等价于[ item for item in iterables if function(item)]，在函数中设定过滤条件，逐一循环迭代器中的元素，将返回值为True时的元素留下，形成一个filter类型数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filter(function, iterable)</span><br><span class="line">参数function：返回值为True或False的函数，可以为None。</span><br><span class="line">参数iterable：序列或可迭代对象。</span><br><span class="line">&gt;&gt;&gt; def bigerthan5(x):</span><br><span class="line">...     return x &gt; 5</span><br><span class="line">&gt;&gt;&gt; filter(bigerthan5, [3, 4, 5, 6, 7, 8])</span><br><span class="line">[6, 7, 8]</span><br></pre></td></tr></table></figure></li><li><p><code>float()</code>讲一个字符串或整数转换为浮点数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; float()</span><br><span class="line">0.0</span><br><span class="line">&gt;&gt;&gt; float(&apos;123&apos;)</span><br><span class="line">123.0</span><br><span class="line">&gt;&gt;&gt; float(1)</span><br><span class="line">1.0</span><br><span class="line">&gt;&gt;&gt; float(&apos;a&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#45&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    float(&apos;a&apos;)</span><br><span class="line">ValueError: could not convert string to float: &apos;a&apos;</span><br></pre></td></tr></table></figure></li><li><p><code>format()</code>格式化输出字符串，format(value, format_spec)实质上是调用了value的__format__(format_spec)方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;I am &#123;0&#125;, I like &#123;1&#125;!&quot;.format(&quot;wang&quot;, &quot;moon&quot;)     </span><br><span class="line">&apos;I am wang, I like moon!&apos;</span><br></pre></td></tr></table></figure></li><li><p><code>frozenset()</code>创建一个不可修改的集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">frozenset([iterable])</span><br><span class="line">set和frozenset最本质的区别是前者是可变的，后者是不可变的。当集合对象会被改变时（例如删除，添加元素），只能使用set，</span><br><span class="line">一般来说使用fronzet的地方都可以使用set。</span><br><span class="line">参数iterable：可迭代对象。</span><br></pre></td></tr></table></figure></li><li><p><code>getattr()</code>获取对象的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">getattr(object, name [, defalut])</span><br><span class="line">获取对象object名为name的特性，如果object不包含名为name的特性，将会抛出AttributeError异常；如果不包含名为name的特性</span><br><span class="line">且提供default参数，将返回default。</span><br><span class="line">参数object：对象</span><br><span class="line">参数name：对象的特性名</span><br><span class="line">参数default：缺省返回值</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; append = getattr(list, &apos;append&apos;)</span><br><span class="line">&gt;&gt;&gt; append</span><br><span class="line">&lt;method &apos;append&apos; of &apos;list&apos; objects&gt;</span><br><span class="line">&gt;&gt;&gt; mylist = [3, 4, 5]</span><br><span class="line">&gt;&gt;&gt; append(mylist, 6)</span><br><span class="line">&gt;&gt;&gt; mylist</span><br><span class="line">[3, 4, 5, 6]</span><br><span class="line">&gt;&gt;&gt; method = getattr(list, &apos;add&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: type object &apos;list&apos; has no attribute &apos;add&apos;</span><br><span class="line">&gt;&gt;&gt; method = getattr(list, &apos;add&apos;, &apos;NoMethod&apos;)</span><br><span class="line">&gt;&gt;&gt; method</span><br><span class="line">&apos;NoMethod&apos;</span><br></pre></td></tr></table></figure></li><li><p><code>globals()</code>返回一个描述当前全局变量的字典</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = 1</span><br><span class="line">&gt;&gt;&gt; globals()</span><br><span class="line">&#123;&apos;__loader__&apos;: &lt;class &apos;_frozen_importlib.BuiltinImporter&apos;&gt;, &apos;a&apos;: 1, &apos;__builtins__&apos;: &lt;module &apos;builtins&apos; (built-in)&gt;, &apos;__doc__&apos;: None, &apos;__name__&apos;: &apos;__main__&apos;, &apos;__package__&apos;: None, &apos;__spec__&apos;: None&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>hasattr()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hasattr(object，name)</span><br><span class="line">判断对象object是否包含名为name的特性（hasattr是通过调用getattr(object，name)）是否抛出异常来实现的。</span><br><span class="line">参数object：对象</span><br><span class="line">参数name：特性名称</span><br><span class="line">&gt;&gt;&gt; hasattr(list, &apos;append&apos;)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; hasattr(list, &apos;add&apos;)</span><br><span class="line">False</span><br></pre></td></tr></table></figure></li><li><p><code>hash()</code>哈希值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hash(object)</span><br><span class="line">如果对象object为哈希表类型，返回对象object的哈希值。哈希值为整数，在字典查找中，哈希值用于快递比价字典的键。</span><br><span class="line">两个数值如果相等，则哈希值也相等。</span><br></pre></td></tr></table></figure></li><li><p><code>help()</code>返回对象的帮助文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用内建的帮助系统，如果不包含参数，交互式帮助系统将在控制台启动。如果参数为字串，则可以是模块，类，方法等名称，并且帮助页面将会在控制台打印。参数也可以为任意对象</span><br></pre></td></tr></table></figure></li><li><p><code>id()</code>返回对象的内存地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = 1</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">1588522800</span><br></pre></td></tr></table></figure></li><li><p><code>input()</code>获取用户输入内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = input(&quot;请输入一个数字：&quot;)</span><br><span class="line"># 用户输入3</span><br><span class="line">print(num)</span><br><span class="line"># 输出结果</span><br><span class="line">3</span><br></pre></td></tr></table></figure></li><li><p><code>int()</code>将一个字符串或数值转换为一个普通整数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int([x[,radix]])</span><br><span class="line">如果参数是字符串，那么它可能包含符号和小数点。参数radix表示转换的基数（默认是10进制）。</span><br><span class="line">它可以是[2,36]范围内的值，或者0。如果是0，系统将根据字符串内容来解析。</span><br><span class="line">如果提供了参数radix，但参数x并不是一个字符串，将抛出TypeError异常；</span><br><span class="line">否则，参数x必须是数值（普通整数，长整数，浮点数）。通过舍去小数点来转换浮点数。</span><br><span class="line">如果超出了普通整数的表示范围，一个长整数被返回。</span><br><span class="line">如果没有提供参数，函数返回0。</span><br></pre></td></tr></table></figure></li><li><p><code>isinstance()</code>检查对象是否是类的对象，返回True或False</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">isinstance(obj, cls)</span><br><span class="line">检查obj是否是类cls的对象, 返回True 或 False</span><br><span class="line">class Foo(object):</span><br><span class="line">    pass</span><br><span class="line">obj = Foo()</span><br><span class="line">isinstance(obj, Foo)</span><br></pre></td></tr></table></figure></li><li><p><code>issubclass()</code>检查一个类是否是另一个类的子类。返回True或False</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">issubclass(sub, super)</span><br><span class="line">检查sub类是否是super类的派生类（子类）。返回True 或 False</span><br><span class="line"> </span><br><span class="line">class Foo(object):</span><br><span class="line">    pass</span><br><span class="line">   </span><br><span class="line">class Bar(Foo):</span><br><span class="line">    pass</span><br><span class="line">   </span><br><span class="line">issubclass(Bar, Foo)</span><br></pre></td></tr></table></figure></li><li><p><code>iter()</code>　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iter(o[, sentinel])</span><br><span class="line">返回一个iterator对象。该函数对于第一个参数的解析依赖于第二个参数。</span><br><span class="line">如果没有提供第二个参数，参数o必须是一个集合对象，支持遍历功能（__iter__()方法）或支持序列功能（__getitem__()方法），</span><br><span class="line">参数为整数，从零开始。如果不支持这两种功能，将处罚TypeError异常。</span><br><span class="line">如果提供了第二个参数，参数o必须是一个可调用对象。在这种情况下创建一个iterator对象，每次调用iterator的next()方法来无</span><br><span class="line">参数的调用o，如果返回值等于参数sentinel，触发StopIteration异常，否则将返回该值。</span><br></pre></td></tr></table></figure></li><li><p><code>len()</code>返回对象长度，参数可以是序列类型（字符串，元组或列表）或映射类型（如字典）</p></li><li><p><code>list()</code>列表构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list([iterable])</span><br><span class="line">list的构造函数。参数iterable是可选的，它可以是序列，支持编译的容器对象，或iterator对象。</span><br><span class="line">该函数创建一个元素值，顺序与参数iterable一致的列表。如果参数iterable是一个列表，将创建</span><br><span class="line">列表的一个拷贝并返回，就像语句iterables[:]。</span><br></pre></td></tr></table></figure></li><li><p><code>locals()</code>打印当前可用的局部变量的字典</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不要修改locals()返回的字典中的内容；改变可能不会影响解析器对局部变量的使用。</span><br><span class="line">在函数体内调用locals()，返回的是自由变量。修改自由变量不会影响解析器对变量的使用。</span><br><span class="line">不能在类区域内返回自由变量。</span><br></pre></td></tr></table></figure></li><li><p><code>map()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">map(function, iterable,...)</span><br><span class="line">对于参数iterable中的每个元素都应用fuction函数，并将结果作为列表返回。</span><br><span class="line">如果有多个iterable参数，那么fuction函数必须接收多个参数，这些iterable中相同索引处的元素将并行的作为function函数的参数。</span><br><span class="line">如果一个iterable中元素的个数比其他少，那么将用None来扩展改iterable使元素个数一致。</span><br><span class="line">如果有多个iterable且function为None，map()将返回由元组组成的列表，每个元组包含所有iterable中对应索引处值。</span><br><span class="line">参数iterable必须是一个序列或任何可遍历对象，函数返回的往往是一个列表(list)。</span><br><span class="line"> </span><br><span class="line">li = [1,2,3]</span><br><span class="line">data = map(lambda x :x*100,li)</span><br><span class="line">print(type(data))</span><br><span class="line">data = list(data)</span><br><span class="line">print(data)</span><br><span class="line"> </span><br><span class="line">运行结果：</span><br><span class="line"> </span><br><span class="line">&lt;class &apos;map&apos;&gt;</span><br><span class="line">[100, 200, 300]</span><br></pre></td></tr></table></figure></li><li><p><code>max()</code>返回给定元素里最大值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">max(iterable [,args...][, key])</span><br><span class="line">如果只提供iterable参数，函数返回可遍历对象（如：字符串，元组或列表）中最大的非空元素。</span><br><span class="line">如果提供多个参数，那么返回值最大的那个参数。</span><br><span class="line">可选参数key是单参数的排序函数。</span><br><span class="line">如果提供key参数，必须是以命名的形式，如：max(a, b, c, key = fun)</span><br></pre></td></tr></table></figure></li><li><p><code>meoryview()</code>查看内存地址</p></li><li><p><code>min()</code>返回给定元素里最小值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">min(iterable [,args...][, key])</span><br><span class="line">如果只提供iterable参数，函数返回可遍历对象（如：字符串，元组或列表）中最小的非空元素。</span><br><span class="line">如果提供多个参数，那么返回值最小的那个参数。</span><br><span class="line">可选参数key是单参数的排序函数。</span><br><span class="line">如果提供key参数，必须是以命名的形式，如：max(a, b, c, key = fun)</span><br></pre></td></tr></table></figure></li><li><p><code>next()</code>返回一个可迭代数据结构（如列表）中的下一项</p></li><li><p><code>object()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取一个新的，无特性(geatureless)对象。Object是所有类的基类。它提供的方法将在所有的类型实例中共享。</span><br><span class="line">该函数时2.2.版本新增，2.3版本之后，该函数不接受任何参数。</span><br></pre></td></tr></table></figure></li><li><p><code>open()</code>打开文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">open(filename [, mode [, bufsize]])</span><br><span class="line">打开一个文件，返回一个file对象。 如果文件无法打开，将处罚IOError异常。</span><br><span class="line">应该使用open()来代替直接使用file类型的构造函数打开文件。</span><br><span class="line">参数filename表示将要被打开的文件的路径字符串；</span><br><span class="line">参数mode表示打开的模式，最常用的模式有：&apos;r&apos;表示读文本，&apos;w&apos;表示写文本文件，&apos;a&apos;表示在文件中追加。</span><br><span class="line">Mode的默认值是&apos;r&apos;。</span><br><span class="line">当操作的是二进制文件时，只要在模式值上添加&apos;b&apos;。这样提高了程序的可移植性。</span><br><span class="line">可选参数bufsize定义了文件缓冲区的大小。0表示不缓冲；1表示行缓冲；任何其他正数表示使用该大小的缓冲区；</span><br><span class="line">负数表示使用系统默认缓冲区大小，对于tty设备它往往是行缓冲，而对于其他文件往往完全缓冲。如果参数值被省却。</span><br><span class="line">使用系统默认值。</span><br></pre></td></tr></table></figure></li><li><p><code>pow()</code>幂函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r = pow(2, 10)  # 2的10次方</span><br><span class="line">print(r)</span><br><span class="line">              </span><br><span class="line"># 输出</span><br><span class="line">1024</span><br></pre></td></tr></table></figure></li><li><p><code>print()</code>输出函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python2中的print语句被python3中的print()函数取代。</span><br><span class="line">如何限制print的默认换行： </span><br><span class="line">1. python2版本下，在print输出的最后加一个逗号&apos;,&apos;</span><br><span class="line">2. python3.4以后，print(value, ...,sep=&apos;&apos;,end=&apos;\n&apos;,file=sys.stdout,flush=False),将end设为空即可。</span><br></pre></td></tr></table></figure></li><li><p><code>property()</code>获取对象的所有属性</p></li><li><p><code>range()</code>根据需要生成一个指定范围的数字，可以提供你需要的控制来迭代指定的次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">用于创建包含连续算术值的列表(list)。常用于for循环。参数必须是普通整数。</span><br><span class="line">参数step默认值为1，参数start的默认值为0。</span><br><span class="line">全参数调用该函数将返回一个普通整数列表。</span><br><span class="line">step 可以是正整数或者负整数。不可以为0，否则将处罚ValueError异常。</span><br><span class="line">range(3)代表0,1,2.等价于range(0,3)</span><br><span class="line">&gt;&gt;&gt; range(0,10,2)  #第一个参数是起始数，第二个是终止数(不包含这个)，第三个数步数</span><br><span class="line">&gt;&gt;&gt;[0,2,4,6,8]</span><br></pre></td></tr></table></figure></li><li><p><code>repr()</code>将任意值转换为字符串，供计时器读取的形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">repr(object)</span><br><span class="line">返回一个对象的字符串表示。有时可以使用这个函数来访问操作。</span><br><span class="line">对于许多类型来说，repr()尝试返回一个字符串，eval()方法可以使用该字符串产生对象；</span><br><span class="line">否则用尖括号括起来的，包含类名称和其他二外信息的字符串被返回。</span><br></pre></td></tr></table></figure></li><li><p><code>reversed()</code>反转，逆序对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reversed(seq)</span><br><span class="line">返回一个逆序的iterator对象。参数seq必须是一个包含__reversed__()方法的对象或支持序列操作(__len__()和__getitem__())</span><br><span class="line">该函数是2.4中新增的</span><br></pre></td></tr></table></figure></li><li><p><code>round()</code>四舍五入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">round(x [, n])</span><br><span class="line">对参数x的第n+1位小数进行四舍五入，返回一个小数位数为n的浮点数。</span><br><span class="line">参数n的默认值是0。结果是一个浮点数。如round(0.5)结果为1.0</span><br><span class="line">&gt;&gt;&gt; round(4,6)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; round(5,6)</span><br><span class="line">5</span><br></pre></td></tr></table></figure></li><li><p><code>set()</code>class set([iterable])  返回一个新的set对象，可以选择从iterable取得的元素，set是一个内置的类</p></li><li><p><code>setattr()</code>与getattr()相对应，setattr(object,name,value) 参数是一个对象，一个字符串和一个任意值。字符串可以命名现有属性或新属性。如果对象允许，该函数将赋值给该属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setattr(x, &apos;foobar&apos;, 123) 相当于x.foobar = 123</span><br></pre></td></tr></table></figure></li><li><p><code>slice()</code>切片功能,  slice(start, stop[, step])</p></li><li><p><code>sorted()</code>排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([36,6,-12,9,-22])  列表排序</span><br><span class="line">[-22, -12, 6, 9, 36]</span><br><span class="line">&gt;&gt;&gt; sorted([36,6,-12,9,-22],key=abs) 高阶函数，以绝对值大小排序</span><br><span class="line">[6, 9, -12, -22, 36]</span><br><span class="line">&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;])  字符串排序，按照ASCII的大小排序</span><br><span class="line">[&apos;Credit&apos;, &apos;Zoo&apos;, &apos;about&apos;, &apos;bob&apos;]</span><br><span class="line">如果需要排序的是一个元组，则需要使用参数key，也就是关键字。</span><br><span class="line">&gt;&gt;&gt; a = [(&apos;b&apos;,2), (&apos;a&apos;,1), (&apos;c&apos;,0)]</span><br><span class="line">&gt;&gt;&gt; list(sorted(a,key=lambda x:x[1]))   按照元组第二个元素排序</span><br><span class="line">[(&apos;c&apos;, 0), (&apos;a&apos;, 1), (&apos;b&apos;, 2)]</span><br><span class="line">&gt;&gt;&gt; list(sorted(a,key=lambda x:x[0]))   按照元组第一个元素排序</span><br><span class="line">[(&apos;a&apos;, 1), (&apos;b&apos;, 2), (&apos;c&apos;, 0)]</span><br><span class="line">&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;],key=str.lower) 忽略大小写排序</span><br><span class="line">[&apos;about&apos;, &apos;bob&apos;, &apos;Credit&apos;, &apos;Zoo&apos;]  </span><br><span class="line">&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;],key=str.lower,reverse=True) 反向排序</span><br><span class="line">[&apos;Zoo&apos;, &apos;Credit&apos;, &apos;bob&apos;, &apos;about&apos;]</span><br></pre></td></tr></table></figure></li><li><p><code>staticmethod()</code>在类中定义一个静态方法的函数，通常@staticmethod 下面接一个函数，如此使用</p></li><li><p><code>str()</code>字符串构造函数</p></li><li><p><code>sum()</code>求和</p></li><li><p><code>super()</code>调用父类的方法</p></li><li><p><code>tuple()</code>元组构造函数</p></li><li><p><code>type()</code>显示对象所属的类型</p></li><li><p><code>vars()</code>vars([object])  使用__dict__属性返回模块，类，实例或任何其他对象的__dict__属性</p></li><li><p><code>zip()</code>将对象逐一配对，相当于制作一个迭代器，用于聚合每个迭代的元素。zip(*iterables)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st_1 = [1,2,3]</span><br><span class="line">list_2 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br><span class="line">s = zip(list_1,list_2)</span><br><span class="line">print(list(s))</span><br><span class="line"> </span><br><span class="line">运行结果：</span><br><span class="line"> </span><br><span class="line">[(1, &apos;a&apos;), (2, &apos;b&apos;), (3, &apos;c&apos;)]</span><br></pre></td></tr></table></figure></li><li><p><code>__import__()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该函数由import 语句调用，它可以被替换（导入builtins模块和分配给builtins.__import__）来改变import语句的语义，但是并不建议如此使用。</span><br></pre></td></tr></table></figure></li></ol><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a>持续更新…</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生苦短，我用python。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://pythonfood.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://pythonfood.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>pythonXML解析</title>
    <link href="http://pythonfood.github.io/2017/12/30/pythonXML%E8%A7%A3%E6%9E%90/"/>
    <id>http://pythonfood.github.io/2017/12/30/pythonXML解析/</id>
    <published>2017-12-30T09:30:00.000Z</published>
    <updated>2018-05-11T06:46:21.314Z</updated>
    
    <content type="html"><![CDATA[<p>人生苦短，我用python。<br><a id="more"></a></p><h2 id="一、XML"><a href="#一、XML" class="headerlink" title="一、XML"></a>一、XML</h2><p>XML 指可扩展标记语言（eXtensible Markup Language），标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言。</p><p>常见的XML编程接口有DOM和SAX，这两种接口处理XML文件的方式不同，使用场合也不同。</p><p>python有三种方法解析XML：SAX(simple API for XML )，DOM(Document Object Model)，ElementTree。</p><p>后面用到的XML实例文件movies.xml内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;collection shelf=&quot;New Arrivals&quot;&gt;</span><br><span class="line">&lt;movie title=&quot;Enemy Behind&quot;&gt;</span><br><span class="line">   &lt;type&gt;War, Thriller&lt;/type&gt;</span><br><span class="line">   &lt;format&gt;DVD&lt;/format&gt;</span><br><span class="line">   &lt;year&gt;2003&lt;/year&gt;</span><br><span class="line">   &lt;rating&gt;PG&lt;/rating&gt;</span><br><span class="line">   &lt;stars&gt;10&lt;/stars&gt;</span><br><span class="line">   &lt;description&gt;Talk about a US-Japan war&lt;/description&gt;</span><br><span class="line">&lt;/movie&gt;</span><br><span class="line">&lt;movie title=&quot;Transformers&quot;&gt;</span><br><span class="line">   &lt;type&gt;Anime, Science Fiction&lt;/type&gt;</span><br><span class="line">   &lt;format&gt;DVD&lt;/format&gt;</span><br><span class="line">   &lt;year&gt;1989&lt;/year&gt;</span><br><span class="line">   &lt;rating&gt;R&lt;/rating&gt;</span><br><span class="line">   &lt;stars&gt;8&lt;/stars&gt;</span><br><span class="line">   &lt;description&gt;A schientific fiction&lt;/description&gt;</span><br><span class="line">&lt;/movie&gt;</span><br><span class="line">   &lt;movie title=&quot;Trigun&quot;&gt;</span><br><span class="line">   &lt;type&gt;Anime, Action&lt;/type&gt;</span><br><span class="line">   &lt;format&gt;DVD&lt;/format&gt;</span><br><span class="line">   &lt;episodes&gt;4&lt;/episodes&gt;</span><br><span class="line">   &lt;rating&gt;PG&lt;/rating&gt;</span><br><span class="line">   &lt;stars&gt;10&lt;/stars&gt;</span><br><span class="line">   &lt;description&gt;Vash the Stampede!&lt;/description&gt;</span><br><span class="line">&lt;/movie&gt;</span><br><span class="line">&lt;movie title=&quot;Ishtar&quot;&gt;</span><br><span class="line">   &lt;type&gt;Comedy&lt;/type&gt;</span><br><span class="line">   &lt;format&gt;VHS&lt;/format&gt;</span><br><span class="line">   &lt;rating&gt;PG&lt;/rating&gt;</span><br><span class="line">   &lt;stars&gt;2&lt;/stars&gt;</span><br><span class="line">   &lt;description&gt;Viewable boredom&lt;/description&gt;</span><br><span class="line">&lt;/movie&gt;</span><br><span class="line">&lt;/collection&gt;</span><br></pre></td></tr></table></figure></p><h3 id="1、SAX"><a href="#1、SAX" class="headerlink" title="1、SAX"></a>1、SAX</h3><p>SAX是流模式，边读边解析，占用内存小，解析快，缺点是我们需要自己处理事件。</p><p>SAX解析XML文档牵涉到两个部分:解析器和事件处理器。</p><ul><li>解析器：负责读取XML文档,并向事件处理器发送事件,如元素开始跟元素结束事件;</li><li>事件处理器：则负责对事件作出相应,对传递的XML数据进行处理。 </li></ul><p>(1)ContentHandler类方法介绍<br>1)<code>characters(content)</code>方法调用时机：</p><ul><li>从行开始，遇到标签之前，存在字符，content的值为这些字符串。</li><li>从一个标签，遇到下一个标签之前， 存在字符，content的值为这些字符串。</li><li>从一个标签，遇到行结束符之前，存在字符，content的值为这些字符串。</li></ul><p>2)<code>startDocument()</code>方法文档启动的时候调用。</p><p>3)<code>endDocument()</code>方法解析器到达文档结尾时调用。</p><p>4)<code>startElement(name, attrs)</code>方法遇到XML开始标签时调用，name是标签的名字，attrs是标签的属性值字典。</p><p>5)endElement(name)方法遇到XML结束标签时调用。 </p><p>(2)make_parser方法创建一个新的解析器对象并返回。<br><code>xml.sax.make_parser( [parser_list] )</code></p><ul><li>parser_list : 可选参数，解析器列表</li></ul><p>(3)parser方法创建一个SAX解析器并解析xml文档：<br><code>xml.sax.parse( xmlfile, contenthandler[, errorhandler])</code></p><ul><li>xmlfile : xml文件名</li><li>contenthandler : 必须是一个ContentHandler的对象</li><li>errorhandler : 如果指定该参数，errorhandler必须是一个SAX ErrorHandler对象</li></ul><p>(4)parseString方法创建一个XML解析器并解析xml字符串：<br><code>xml.sax.parseString(xmlstring, contenthandler[, errorhandler])</code></p><ul><li>xmlstring  : xml字符串</li><li>contenthandler : 必须是一个ContentHandler的对象</li><li>errorhandler : 如果指定该参数，errorhandler必须是一个SAX ErrorHandler对象</li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">import xml.sax</span><br><span class="line"></span><br><span class="line">class MovieHandler( xml.sax.ContentHandler ):</span><br><span class="line">   def __init__(self):</span><br><span class="line">      self.CurrentData = &quot;&quot;</span><br><span class="line">      self.type = &quot;&quot;</span><br><span class="line">      self.format = &quot;&quot;</span><br><span class="line">      self.year = &quot;&quot;</span><br><span class="line">      self.rating = &quot;&quot;</span><br><span class="line">      self.stars = &quot;&quot;</span><br><span class="line">      self.description = &quot;&quot;</span><br><span class="line"></span><br><span class="line">   # 元素开始调用</span><br><span class="line">   def startElement(self, tag, attributes):</span><br><span class="line">      self.CurrentData = tag</span><br><span class="line">      if tag == &quot;movie&quot;:</span><br><span class="line">         print (&quot;*****Movie*****&quot;)</span><br><span class="line">         title = attributes[&quot;title&quot;]</span><br><span class="line">         print (&quot;Title:&quot;, title)</span><br><span class="line"></span><br><span class="line">   # 元素结束调用</span><br><span class="line">   def endElement(self, tag):</span><br><span class="line">      if self.CurrentData == &quot;type&quot;:</span><br><span class="line">         print (&quot;Type:&quot;, self.type)</span><br><span class="line">      elif self.CurrentData == &quot;format&quot;:</span><br><span class="line">         print (&quot;Format:&quot;, self.format)</span><br><span class="line">      elif self.CurrentData == &quot;year&quot;:</span><br><span class="line">         print (&quot;Year:&quot;, self.year)</span><br><span class="line">      elif self.CurrentData == &quot;rating&quot;:</span><br><span class="line">         print (&quot;Rating:&quot;, self.rating)</span><br><span class="line">      elif self.CurrentData == &quot;stars&quot;:</span><br><span class="line">         print (&quot;Stars:&quot;, self.stars)</span><br><span class="line">      elif self.CurrentData == &quot;description&quot;:</span><br><span class="line">         print (&quot;Description:&quot;, self.description)</span><br><span class="line">      self.CurrentData = &quot;&quot;</span><br><span class="line"></span><br><span class="line">   # 读取字符时调用</span><br><span class="line">   def characters(self, content):</span><br><span class="line">      if self.CurrentData == &quot;type&quot;:</span><br><span class="line">         self.type = content</span><br><span class="line">      elif self.CurrentData == &quot;format&quot;:</span><br><span class="line">         self.format = content</span><br><span class="line">      elif self.CurrentData == &quot;year&quot;:</span><br><span class="line">         self.year = content</span><br><span class="line">      elif self.CurrentData == &quot;rating&quot;:</span><br><span class="line">         self.rating = content</span><br><span class="line">      elif self.CurrentData == &quot;stars&quot;:</span><br><span class="line">         self.stars = content</span><br><span class="line">      elif self.CurrentData == &quot;description&quot;:</span><br><span class="line">         self.description = content</span><br><span class="line">  </span><br><span class="line">if ( __name__ == &quot;__main__&quot;):</span><br><span class="line">   </span><br><span class="line">   # 创建一个 XMLReader</span><br><span class="line">   parser = xml.sax.make_parser()</span><br><span class="line">   # turn off namepsaces</span><br><span class="line">   parser.setFeature(xml.sax.handler.feature_namespaces, 0)</span><br><span class="line"></span><br><span class="line">   # 重写 ContextHandler</span><br><span class="line">   Handler = MovieHandler()</span><br><span class="line">   parser.setContentHandler( Handler )</span><br><span class="line">   </span><br><span class="line">   parser.parse(&quot;movies.xml&quot;)</span><br></pre></td></tr></table></figure></blockquote><h3 id="2、DOM"><a href="#2、DOM" class="headerlink" title="2、DOM"></a>2、DOM</h3><p>DOM会把整个XML读入内存，解析为树，因此占用内存大，解析慢，优点是可以任意遍历树的节点。</p><p>一个 DOM 的解析器在解析一个 XML 文档时，一次性读取整个文档，把文档中所有元素保存在内存中的一个树结构里，之后你可以利用DOM 提供的不同的函数来读取或修改文档的内容和结构，也可以把修改过的内容写入xml文件。 </p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from xml.dom.minidom import parse</span><br><span class="line">import xml.dom.minidom</span><br><span class="line"></span><br><span class="line"># 使用minidom解析器打开 XML 文档</span><br><span class="line">DOMTree = xml.dom.minidom.parse(&quot;movies.xml&quot;)</span><br><span class="line">collection = DOMTree.documentElement</span><br><span class="line">if collection.hasAttribute(&quot;shelf&quot;):</span><br><span class="line">   print (&quot;Root element : %s&quot; % collection.getAttribute(&quot;shelf&quot;))</span><br><span class="line"></span><br><span class="line"># 在集合中获取所有电影</span><br><span class="line">movies = collection.getElementsByTagName(&quot;movie&quot;)</span><br><span class="line"></span><br><span class="line"># 打印每部电影的详细信息</span><br><span class="line">for movie in movies:</span><br><span class="line">   print (&quot;*****Movie*****&quot;)</span><br><span class="line">   if movie.hasAttribute(&quot;title&quot;):</span><br><span class="line">      print (&quot;Title: %s&quot; % movie.getAttribute(&quot;title&quot;))</span><br><span class="line"></span><br><span class="line">   type = movie.getElementsByTagName(&apos;type&apos;)[0]</span><br><span class="line">   print (&quot;Type: %s&quot; % type.childNodes[0].data)</span><br><span class="line">   format = movie.getElementsByTagName(&apos;format&apos;)[0]</span><br><span class="line">   print (&quot;Format: %s&quot; % format.childNodes[0].data)</span><br><span class="line">   rating = movie.getElementsByTagName(&apos;rating&apos;)[0]</span><br><span class="line">   print (&quot;Rating: %s&quot; % rating.childNodes[0].data)</span><br><span class="line">   description = movie.getElementsByTagName(&apos;description&apos;)[0]</span><br><span class="line">   print (&quot;Description: %s&quot; % description.childNodes[0].data)</span><br></pre></td></tr></table></figure></blockquote><h3 id="3、ElementTree"><a href="#3、ElementTree" class="headerlink" title="3、ElementTree"></a>3、ElementTree</h3><p>与DOM相比，ET的速度更快，API使用更直接、方便。与SAX相比，ET.iterparse函数同样提供了按需解析的功能，不会一次性在内存中读入整个文档。ET的性能与SAX模块大致相仿，但是它的API更加高层次，用户使用起来更加便捷。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">from xml.etree.ElementTree import parse</span><br><span class="line"></span><br><span class="line">f = open(r&quot;C:\PlatformConfigure\Configure\VideoStreamingServerConfigure.xml&quot;)</span><br><span class="line">et = parse(f)</span><br><span class="line">root = et.getroot()     # 获取根节点</span><br><span class="line">print(root)</span><br><span class="line"># 第一种遍历根节点的子元素（该方法要取消了，不推荐使用）</span><br><span class="line">childs = root.getchildren()</span><br><span class="line">for child in childs:</span><br><span class="line">    print(child.tag)</span><br><span class="line"></span><br><span class="line"># 第二种遍历根节点的子元素</span><br><span class="line">for child in root:</span><br><span class="line">    print(child.tag)</span><br><span class="line"></span><br><span class="line"># 查找当前节点的子元素</span><br><span class="line">print(root.find(&apos;LocalIP&apos;))  # 查找到第一个‘LocalIP’的元素</span><br><span class="line">print(root.findall(&apos;LocalIP&apos;))  # 查找到所有标签是‘LocalIP’的元素，得到的是一个列表</span><br><span class="line">print(root.iterfind(&apos;LocalIP&apos;))  # 查找到所有标签是‘LocalIP’的元素，得到的是迭代对象</span><br><span class="line">for e in root.iterfind(&apos;LocalIP&apos;):</span><br><span class="line">    print(e.tag)</span><br><span class="line"></span><br><span class="line"># 列出所有节点元素</span><br><span class="line">for e in root.iter():</span><br><span class="line">    print(e.tag)</span><br><span class="line"></span><br><span class="line"># 查找指定标签的元素节点</span><br><span class="line">print(root.iter(&apos;LocalIP&apos;))</span><br><span class="line"></span><br><span class="line"># 查找孙子节点</span><br><span class="line">print(root.findall(&apos;connstr/*&apos;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(root.findall(&apos;.//host&apos;))     # 查找任意层次下的指定节点元素</span><br><span class="line">print(root.findall(&apos;.//host/..&apos;))  # 查找任意层次下的指定节点元素的父元素</span><br><span class="line"></span><br><span class="line">print(root.findall(&apos;LocalIP[@age]&apos;))   # 查找包含age属性的LocalIP节点元素</span><br><span class="line">print(root.findall(&apos;LocalIP[@age=&quot;18&quot;]&apos;))   # 查找包含age属性值=18的LocalIP节点元素</span><br><span class="line">print(root.findall(&apos;connstr[host]&apos;))      # 查找包含host节点的connstr节点元素</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for host in root.findall(&apos;.//host&apos;):       # 输出节点的值</span><br><span class="line">    print(host.text)</span><br></pre></td></tr></table></figure></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a>持续更新…</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生苦短，我用python。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://pythonfood.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://pythonfood.github.io/tags/python/"/>
    
  </entry>
  
</feed>
