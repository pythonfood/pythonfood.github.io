<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PythonFood</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://pythonfood.github.io/"/>
  <updated>2018-03-09T07:39:28.930Z</updated>
  <id>http://pythonfood.github.io/</id>
  
  <author>
    <name>Python Food</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>持续集成-jenkins</title>
    <link href="http://pythonfood.github.io/2018/03/05/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90-jenkins/"/>
    <id>http://pythonfood.github.io/2018/03/05/持续集成-jenkins/</id>
    <published>2018-03-05T01:00:00.000Z</published>
    <updated>2018-03-09T07:39:28.930Z</updated>
    
    <content type="html"><![CDATA[<p>持续集成jenkins使用笔记。<br><a id="more"></a></p><h3 id="1-持续集成流程"><a href="#1-持续集成流程" class="headerlink" title="1.持续集成流程"></a>1.持续集成流程</h3><p>(1)提交代码<br>(2)拉取代码<br>(3)编译<br>(4)打包<br>(5)配置<br>(6)测试<br>(7)反馈问题<br>(8)开发处理<br>(9)回到(1)</p><h3 id="2-持续集成工具"><a href="#2-持续集成工具" class="headerlink" title="2.持续集成工具"></a>2.持续集成工具</h3><p>(1)代码管理工具：</p><blockquote><p>Git：官网下载安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a><br>GitHub：官网地址<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></p></blockquote><p>(2)集成工具：</p><blockquote><p>Jenkins：官网下载安装<a href="https://jenkins.io/download/" target="_blank" rel="noopener">https://jenkins.io/download/</a><br>1)安装后会自动启动浏览器，输入<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a><br>2)根据页面中标红路径找到管理员密码吗<br>3)输入管理员密码，点击【Continue】<br>4)安装插件，默认选项即可<br>5)安装完需要创建用户，此处点击【Continue as admin】使用默认账户即可<br>6)点击【Start using Jekins】启动<br>7)修改密码，进入【admin-设置】，向上拉找到密码处即可修改</p></blockquote><h3 id="3-Jenkins系统配置"><a href="#3-Jenkins系统配置" class="headerlink" title="3.Jenkins系统配置"></a>3.Jenkins系统配置</h3><p>(1)插件管理：</p><blockquote><p>1)进入【系统管理-管理插件-已安装】查看下面插件：</p><blockquote><ul><li>Git Plugin</li><li>GitHub Plugin</li><li>Gradle Plugin</li><li>Android Emulator Plugin</li></ul></blockquote><p>2)未安装的进入【可选插件】里安装即可</p></blockquote><p>(2)Gradle配置：</p><blockquote><p>1)进入【系统管理-全局工具配置】找到【Gradle安装】<br>2)点击【新增Gradle】<br>3)选择自动安装，名称输入和版本一致即可<br>4)再点击【Apply】-【Save】</p></blockquote><p>(3)GitHub配置：</p><blockquote><p>1)进入【系统管理-系统设置】找到【GitHub】<br>2)点击【Add GitHub Server】<br>3)在【GitHub Server】的【API URL】输入(<a href="https://api.github.com" target="_blank" rel="noopener">https://api.github.com</a>)<br>4)再点击【Credentials】右侧的问号设置权限，展开的内容里右键点击【personal access token】新窗口打开github<br>5)在github页面【Token description】输入自定义名称,勾选【repo】,点击【Generate token】<br>6)在github页面生成Personal access tokens后复制<br>7)回到jenkins页面点击【add】-【jenkins】<br>8)在弹出窗口里【Kind】类别选择【Secret text】,将刚才复制的token粘贴到【Secret】，再点击【add】就创建了身份信息<br>9)可以点击【Test connection】验证一下，验证通过后点击【保存】</p></blockquote><h3 id="4-Jenkins-JOB配置"><a href="#4-Jenkins-JOB配置" class="headerlink" title="4.Jenkins JOB配置"></a>4.Jenkins JOB配置</h3><p>创建任务：</p><blockquote><p>1)点击页面中【创建一个新任务】<br>2)输入任务名称，选择【构建一个自由风格的软件项目】，点击【确定】进入设置界面<br>3)进行自定义配置后点击【保存】</p></blockquote><h3 id="5-JOB配置小示例"><a href="#5-JOB配置小示例" class="headerlink" title="5.JOB配置小示例"></a>5.JOB配置小示例</h3><p>进入创建的任务详情界面，点击【配置】进行job配置<br>(1)拉取代码：</p><blockquote><p>1)【源码管理】选择【Git】，输入代码库的URL地址<br>2)点击【Add】-【jenkins】配置github权限<br>3)弹出界面输入github的帐户名和密码，点击【Add】添加<br>4)【Credentials】选择刚添加的github账户</p></blockquote><p>(2)编译、打包：</p><blockquote><p>1)【构建】点击【增加构建步骤】<br>2)选择【Invoke Gradle script】<br>3)【Gradle Version】选择对应版本<br>4)【Tasks】填写“build”等信息</p></blockquote><p>(3)配置：</p><blockquote><p>1)【构建】点击【增加构建步骤】<br>2)选择【Install Android package】<br>3)【APK file】填写生成的apk路径（此处可以先生构建一次4)查看路径，再复制到这里）<br>5)勾选【Uninstall existing APK first】</p></blockquote><p>(4)测试：</p><blockquote><p>1)【构建】点击【增加构建步骤】<br>2)选择【Run Android monkey tester】<br>3)【Package IDs】输入包名<br>4)【Event count】输入执行次数<br>5)【Delay between events】输入间隔时间ms<br>6)点击【Apply】,点击【保存】</p></blockquote><p>(5)立即构建：</p><blockquote><p>1)进入创建的任务详情界面<br>2)点击【立即构建】进行构建<br>3)点击构建的任务可以查看详情<br>4)【Console Output】可以查看日志信息</p></blockquote><p>(6)定时构建：</p><blockquote><p>1)进入创建的任务详情界面<br>2)点击【配置】进行job配置<br>3)【构建触发器】下选择【Build periodically】<br>4)【日程表】里输入规则，例如“H/15 <em> </em> <em> </em>”(每15分钟构建一次)<br>5)点击【日程表】右侧问号，可以查看规则描述<br>6)点击【Apply】,点击【保存】</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;持续集成jenkins使用笔记。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="持续集成" scheme="http://pythonfood.github.io/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    
      <category term="持续集成" scheme="http://pythonfood.github.io/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>接口测试-python</title>
    <link href="http://pythonfood.github.io/2018/03/03/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95-python/"/>
    <id>http://pythonfood.github.io/2018/03/03/接口测试-python/</id>
    <published>2018-03-03T04:00:00.000Z</published>
    <updated>2018-03-08T09:18:59.419Z</updated>
    
    <content type="html"><![CDATA[<p>接口测试python实现脚本测试笔记。<br><a id="more"></a></p><h3 id="1-requests模块"><a href="#1-requests模块" class="headerlink" title="1.requests模块"></a>1.requests模块</h3><p>(1)安装<code>pip install requests</code><br>(2)使用前导入<code>import requests</code></p><h3 id="2-GET请求ddt自动化"><a href="#2-GET请求ddt自动化" class="headerlink" title="2.GET请求ddt自动化"></a>2.GET请求ddt自动化</h3><p>(1)代码结构：</p><blockquote><p>1)构造Header<br>2)构造cookies<br>3)发送Get请求<br>4)获取返回值<br>5)对结果进行校验</p></blockquote><p>(2)代码示例：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line">import unittest</span><br><span class="line">import ddt</span><br><span class="line"></span><br><span class="line">@ddt.ddt</span><br><span class="line">class ApiTestClass(unittest.TestCase):</span><br><span class="line">    </span><br><span class="line">    @ddt.data(&apos;android&apos;,&apos;&apos;,&apos;ios&apos;)</span><br><span class="line">    def test_Get(self,os_phone):</span><br><span class="line">        #header部分配置</span><br><span class="line">        headers = &#123;&apos;User-Agent&apos;:&apos;Dalvik/1.6.0 (Linux; U; Android 4.3; Coolpad 8720L Build/JSS15Q)&apos;,</span><br><span class="line">                   &apos;Host&apos;:&apos;bdsp.x.jd.com&apos;,</span><br><span class="line">                   &apos;Connection&apos;:&apos;Keep-Alive&apos;,</span><br><span class="line">                   &apos;Accept-Encoding&apos;:&apos;gzip&apos;</span><br><span class="line">                   &#125;</span><br><span class="line">        </span><br><span class="line">        #cookies部分配置</span><br><span class="line">        cookies = dict(search_test = &apos;1&apos;)</span><br><span class="line">        </span><br><span class="line">        #get请求获得返回数据</span><br><span class="line">        res = requests.get(&apos;http://bdsp.x.jd.com/app/config?os=&apos;+os_phone+&apos;&amp;key=wx3ebc9e606b4f9242&amp;sdkv=5&apos;, </span><br><span class="line">                           headers = headers,</span><br><span class="line">                           cookies = cookies)</span><br><span class="line">        </span><br><span class="line">        print(res.text)</span><br><span class="line">        print(res.status_code)</span><br><span class="line">        </span><br><span class="line">        #测试点校验</span><br><span class="line">        self.assertTrue(&apos;15*1000&apos; in res.text)</span><br><span class="line">                      </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    cases = unittest.TestLoader().loadTestsFromTestCase(ApiTestClass)</span><br><span class="line">    suite = unittest.TestSuite([cases])</span><br><span class="line">    #suite.addTest(ApiTestClass(&apos;test_Get&apos;))</span><br><span class="line">    </span><br><span class="line">    runner = unittest.TextTestRunner()</span><br><span class="line">    runner.run(suite)</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-POST请求ddt自动化"><a href="#3-POST请求ddt自动化" class="headerlink" title="3.POST请求ddt自动化"></a>3.POST请求ddt自动化</h3><p>(1)代码结构：</p><blockquote><p>1)构造Keyword(即request body)<br>2)构造Header<br>3)构造cookies<br>4)发送Get请求<br>5)获取返回值<br>6)对结果进行校验</p></blockquote><p>(2)代码示例：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import unittest</span><br><span class="line">import ddt</span><br><span class="line"></span><br><span class="line">@ddt.ddt</span><br><span class="line">class ApiTestClass(unittest.TestCase):</span><br><span class="line">    </span><br><span class="line">    @ddt.data((&apos;60.206.137.140&apos;,&apos;hjfwp9VflXZU3FsuM3cu6PBV&apos;),</span><br><span class="line">              (&apos;&apos;,&apos;&apos;)</span><br><span class="line">              )</span><br><span class="line">    @ddt.unpack</span><br><span class="line">    def test_Post(self,m_host,m_accessToken):</span><br><span class="line">        #header部分配置</span><br><span class="line">        headers = &#123;&apos;Content-Type&apos;:&apos;application/x-www-form-urlencoded&apos;,</span><br><span class="line">                   &apos;Content-Length&apos;:&apos;36&apos;,</span><br><span class="line">                   &apos;Host&apos;:m_host,</span><br><span class="line">                   &apos;Connection&apos;:&apos;Keep-Alive&apos;,</span><br><span class="line">                   &apos;Accept-Encoding&apos;:&apos;gzip&apos;,</span><br><span class="line">                   &apos;User-Agent&apos;:&apos;okhttp/3.8.1&apos;</span><br><span class="line">                   &#125;</span><br><span class="line">        </span><br><span class="line">        #cookies部分配置</span><br><span class="line">        cookies = dict(search_test = &apos;1&apos;)</span><br><span class="line">        </span><br><span class="line">        #data部分配置</span><br><span class="line">        keyword = &#123;&apos;accessToken&apos;:m_accessToken&#125;</span><br><span class="line">        </span><br><span class="line">        #post请求获得返回数据</span><br><span class="line">        res = requests.post(&apos;http://60.206.137.140/iot_api/family/queryFamilyList.json&apos;, </span><br><span class="line">                           headers = headers,</span><br><span class="line">                           cookies = cookies,</span><br><span class="line">                           data = keyword</span><br><span class="line">                           )</span><br><span class="line">        </span><br><span class="line">        print(res.text)</span><br><span class="line">        print(res.status_code)</span><br><span class="line">        </span><br><span class="line">        #测试点校验</span><br><span class="line">        self.assertTrue(&apos;北京市北京市&apos; in res.text)</span><br><span class="line">                      </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    cases = unittest.TestLoader().loadTestsFromTestCase(ApiTestClass)</span><br><span class="line">    suite = unittest.TestSuite([cases])</span><br><span class="line">    #suite.addTest(ApiTestClass(&apos;test_Post&apos;))</span><br><span class="line">    </span><br><span class="line">    runner = unittest.TextTestRunner()</span><br><span class="line">    runner.run(suite)</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接口测试python实现脚本测试笔记。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="接口测试" scheme="http://pythonfood.github.io/categories/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="接口测试" scheme="http://pythonfood.github.io/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>接口测试-postman</title>
    <link href="http://pythonfood.github.io/2018/03/03/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95-postman/"/>
    <id>http://pythonfood.github.io/2018/03/03/接口测试-postman/</id>
    <published>2018-03-03T03:00:00.000Z</published>
    <updated>2018-03-08T09:09:33.173Z</updated>
    
    <content type="html"><![CDATA[<p>接口测试postman工具使用笔记。<br><a id="more"></a></p><h3 id="1-适用范围"><a href="#1-适用范围" class="headerlink" title="1.适用范围"></a>1.适用范围</h3><ul><li>PC</li><li>WAP</li><li>APP</li></ul><h3 id="2-环境准备"><a href="#2-环境准备" class="headerlink" title="2.环境准备"></a>2.环境准备</h3><p>(1)下载安装:<a href="https://www.getpostman.com/apps" target="_blank" rel="noopener">https://www.getpostman.com/apps</a><br>(2)注册账户</p><h3 id="3-发送一条http-Get请求"><a href="#3-发送一条http-Get请求" class="headerlink" title="3.发送一条http Get请求"></a>3.发送一条http Get请求</h3><p>(1)GET请求输入URL(可以从fiddler复制)<br>(2)GET请求输入Headers(可以从fiddler复制)<br>(3)点击【Send】可以查看返回信息<br>(4)可以对返回值内容增加校验，GET请求的Tests里设置校验方法和校验字段<br>(5)点击【Send】可以查看返回信息和测试结果<br>(6)可以将以上测试步骤，点击【Save】保存到一个集合<br>(7)可以修改请求的测试参数，点击【Save as】保存到同一个集合<br>(8)以此类推形成一个自动化测试的集合<br>(9)点击该集合的【Run】弹出集合运行界面<br>(10)可以修改循环次数【iterations】、延迟【Delay】等参数<br>(11)点击【Run …】运行脚本，查看测试结果</p><h3 id="4-发送一条http-Post请求"><a href="#4-发送一条http-Post请求" class="headerlink" title="4.发送一条http Post请求"></a>4.发送一条http Post请求</h3><p>(1)POST请求输入URL(可以从fiddler复制)<br>(2)POST请求输入Headers(可以从fiddler复制)<br>(3)POST请求输入Body(可以从fiddler的WebForms里一项一项复制)<br>(4)点击【Send】可以查看返回信息<br>(5)可以对返回值内容增加校验，POST请求的Tests里设置校验方法和校验字段<br>(6)点击【Send】可以查看返回信息和测试结果<br>(7)可以将以上测试步骤，点击【Save】保存到一个集合<br>(8)可以修改请求的测试参数，点击【Save as】保存到同一个集合<br>(9)以此类推形成一个自动化测试的集合<br>(10)点击该集合的【Run】弹出集合运行界面<br>(11)可以修改循环次数【iterations】、延迟【Delay】等参数<br>(12)点击【Run …】运行脚本，查看测试结果</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接口测试postman工具使用笔记。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="接口测试" scheme="http://pythonfood.github.io/categories/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="接口测试" scheme="http://pythonfood.github.io/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>接口测试-fiddler</title>
    <link href="http://pythonfood.github.io/2018/03/03/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95-fiddler/"/>
    <id>http://pythonfood.github.io/2018/03/03/接口测试-fiddler/</id>
    <published>2018-03-03T02:00:00.000Z</published>
    <updated>2018-03-08T09:07:58.801Z</updated>
    
    <content type="html"><![CDATA[<p>接口测试fiddler工具使用笔记。<br><a id="more"></a></p><h3 id="1-Fiddler-环境准备"><a href="#1-Fiddler-环境准备" class="headerlink" title="1.Fiddler 环境准备"></a>1.Fiddler 环境准备</h3><p>(1)官网下载安装:<a href="https://www.telerik.com/download/fiddler" target="_blank" rel="noopener">https://www.telerik.com/download/fiddler</a><br>(2)相关设置:【Tools-options-HTTPS-Connections】,设置好之后退出再启动一次。</p><p><img src="/2018/03/03/接口测试-fiddler/HTTPS设置.png" alt="HTTPS设置"><br><img src="/2018/03/03/接口测试-fiddler/Connections设置.png" alt="Connections设置"></p><h3 id="2-Fiddler-工作原理"><a href="#2-Fiddler-工作原理" class="headerlink" title="2.Fiddler 工作原理"></a>2.Fiddler 工作原理</h3><p><img src="/2018/03/03/接口测试-fiddler/fiddler工作原理.png" alt="fiddler工作原理"></p><h3 id="3-Fiddler-基本界面"><a href="#3-Fiddler-基本界面" class="headerlink" title="3.Fiddler 基本界面"></a>3.Fiddler 基本界面</h3><p>(1)Session部分:</p><blockquote><ul><li>#:id</li><li>Result:服务器返回的状态码</li><li>Protocol:协议</li><li>Host:发送给服务器的host值</li><li>URL:</li></ul></blockquote><p>(2)Inspectors:<br>1)Request部分:</p><blockquote><ul><li>Headers:头部信息<blockquote><ul><li>User-Agent:用户的身份</li><li>Referer:请求的上一个请求来源</li><li>Host:当前的host</li></ul></blockquote></li><li>TextView:</li><li>WebForms:请求的参数值</li><li>HexView:16进制的view</li><li>Cookies:</li><li>Raw:最原始的所有的数据</li><li>JSON:json形式的请求</li><li>XML:xml形式的请求</li></ul></blockquote><p>2)Response部分:</p><blockquote><ul><li>TextView:可以看到整个返回的内容</li><li>Raw:返回所有的相关的内容</li><li>JSON:返回json形式的数据</li><li>XML:返回xml形式的数据</li><li>WebView:返回的html页面</li><li>ImageView:返回的图片内容</li></ul></blockquote><p>(3)Statistics:静态统计</p><p>(4)Composer:构造各种各样的请求发送给服务器</p><p>(5)AutoResponder:配置假数据模拟后端服务器返回的数据</p><h3 id="4-Fiddler-设置断点修改Request"><a href="#4-Fiddler-设置断点修改Request" class="headerlink" title="4.Fiddler 设置断点修改Request"></a>4.Fiddler 设置断点修改Request</h3><p>(1)通过工具栏设置断点(缺点是会拦截所有的请求)</p><blockquote><p>1)设置断点【Rules-Automatic Breakpoints-Before Request F11】<br>2)清除请求区域<br>3)浏览器进行百度搜索“fiddler”<br>4)fiddler对应的请求，点击【Response部分-Run to Completion】<br>5)fiddler新弹出的请求应该就是需要改参数的请求<br>6)fiddler需要修改参数的请求，点击【Request部分-WebForms】<br>7)修改对应的参数<br>8)点击【Repose部分-Run to Completion】<br>9)回到浏览器查看请求是否修改成功</p></blockquote><p>2)通过命令设置断点(可以拦截指定站点)</p><blockquote><p>1)session部分底部输入命令<code>bpu www.baidu.com</code>，其他操作同上。<br>2)清除拦截，输入命令<code>bpu</code></p></blockquote><h3 id="5-Fiddler-设置断点修改Response"><a href="#5-Fiddler-设置断点修改Response" class="headerlink" title="5.Fiddler 设置断点修改Response"></a>5.Fiddler 设置断点修改Response</h3><p>(1)通过工具栏设置断点(缺点是会拦截所有的请求)</p><blockquote><p>1)点击设置【Rules-Automatic Breakpoints-After Response Alt+F11】<br>2)清除请求区域<br>3)浏览器进行百度搜索“哈哈”<br>4)fiddler修改Response部分的参数<br>5)点击【Response部分-Run to Completion】<br>6)回到浏览器查看请求是否修改成功</p></blockquote><p>(2)通过命令设置断点(可以拦截指定站点)</p><blockquote><p>1)session部分底部输入命令<code>bpafter www.baidu.com</code>，其他操作同上。<br>2)清除拦截，输入命令<code>bpafter</code></p></blockquote><p>(3)AutoResponder设置</p><blockquote><p>1)浏览器进行百度搜索“哈哈”<br>2)fiddler对应的请求,点击【AutoResponder-Add Rule】<br>3)勾选【Enable reles】【Unmatched requests passthrough】【Enable Latency】<br>4)下边规则改为模糊匹配，例如改为：<code>regex:(?inx)^https://www.baidu.com/s?.+</code><br>5)下边下拉框返回状态码任意可选，例如选择:404_Plain.dat<br>6)点击【Save】按钮<br>7)回到浏览器重新百度搜索任意字符，看是否返回404<br>ps:可以通过下拉列表的“find a file”自定义规则，文件内容自定义。</p></blockquote><h3 id="6-Fiddler-小工具"><a href="#6-Fiddler-小工具" class="headerlink" title="6.Fiddler 小工具"></a>6.Fiddler 小工具</h3><p>(1)会话的过滤</p><blockquote><p>1)点击【Filters-Use Filters】<br>2)【No Host Filter】下拉框选择【Show only the following Hosts】<br>3)输入要过滤的站点，例如:www.baidu.com<br>4)点击【Actions-Run Filterset now】<br>5)此时session对话框只显示过滤站点请求</p></blockquote><p>(2)会话的比较<br>下载windiff:<a href="https://www.grigsoft.com/download-windiff.htm" target="_blank" rel="noopener">https://www.grigsoft.com/download-windiff.htm</a><br>解压后复制到fiddler安装路径即可</p><blockquote><p>1)选中两个要对比的请求<br>2)右键点击【Compare】<br>3)调起windiff工具进行对比</p></blockquote><p>(3)编码小工具</p><blockquote><p>1)点击【Tools-TextWizard】<br>2)上部分输入原始内容，下部分显示编解码内容<br>3)例如：上面输入(<a href="https://www.grigsoft.com/download-windiff.htm" target="_blank" rel="noopener">https://www.grigsoft.com/download-windiff.htm</a>) ，下面选择URLEecode,即可看到结果。</p></blockquote><h3 id="7-Fiddler-Host设置"><a href="#7-Fiddler-Host设置" class="headerlink" title="7.Fiddler Host设置"></a>7.Fiddler Host设置</h3><blockquote><p>1)点击【Tools-HOSTS…】<br>2)勾选对话框顶部【Enable Remapping of requests for one host to a differenthost or IP,overing DNS】<br>3)点击会话框底部【Import Windows Hosts File】，导入系统host<br>4)任意修改host,点击【Save】host即生效<br>5)不使用修改的host,只需要取消勾选对话框顶部【Enable Remapping of requests for one host to a differenthost or IP,overing DNS】</p></blockquote><h3 id="8-Fiddler-构造HTTP请求"><a href="#8-Fiddler-构造HTTP请求" class="headerlink" title="8.Fiddler 构造HTTP请求"></a>8.Fiddler 构造HTTP请求</h3><p>(1)构造Get请求</p><blockquote><p>1)选择一条Get请求，点击【Inspectors-Headers】<br>2)复制Headers的头部信息，粘贴到【Composer-Parsed】的对话框<br>3)首先删除掉复制信息的“Get”类型<br>4)再剪切复制信息的URL，粘贴到上方的输入框，去掉URL尾部的“HTTP/1.1”协议<br>5)点击【Execute】发送请求<br>6)查看session界面请求是否发送<br>ps:可以任意修改URL进行接口测试</p></blockquote><p>(2)构造Post请求</p><blockquote><p>1)选择一条Post请求，点击【Inspectors-Raw】<br>2)复制所有信息，粘贴到【Composer-Parsed】的对话框，请求方式选择【POST】<br>3)首先删除掉复制信息的“Post”类型<br>4)再剪切复制信息的URL，粘贴到上方的输入框，去掉URL尾部的“HTTP/1.1”协议<br>5)剪切空行以下的request body信息，粘贴到下面的输入框<br>6)点击【Execute】发送请求<br>7)查看session界面请求是否发送<br>ps:可以任意修改URL和request body信息进行接口测试</p></blockquote><h3 id="9-Fiddler-抓取手机包"><a href="#9-Fiddler-抓取手机包" class="headerlink" title="9.Fiddler 抓取手机包"></a>9.Fiddler 抓取手机包</h3><p>(1)配置Fiddler允许监听https<br>(2)配置Fiddler允许远程连接<br>(3)手机端设置代理服务</p><blockquote><p>1)设置【Tools-Options-HTTPS】<br>2)设置【Tools-Options-Connections】<br>3)手机当前连接wifi里设置代理:主机名填写电脑的ip地址，端口填写8888<br>4)手机操作应用，请求就会发送到fiddler,其他操作同PC端操作</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接口测试fiddler工具使用笔记。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="接口测试" scheme="http://pythonfood.github.io/categories/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="接口测试" scheme="http://pythonfood.github.io/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>接口测试</title>
    <link href="http://pythonfood.github.io/2018/03/03/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    <id>http://pythonfood.github.io/2018/03/03/接口测试/</id>
    <published>2018-03-03T01:00:00.000Z</published>
    <updated>2018-03-08T08:38:25.018Z</updated>
    
    <content type="html"><![CDATA[<p>接口测试是测试系统组件间接口的一种测试。接口测试主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。测试的重点是要检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等。<br><a id="more"></a></p><h3 id="1-API种类"><a href="#1-API种类" class="headerlink" title="1.API种类"></a>1.API种类</h3><ul><li>面向对象语言的API</li><li>库与框架的API</li><li>API与协议</li><li>API与设备接口</li><li>Web API(HTTP API)</li></ul><h3 id="2-HTTP-API"><a href="#2-HTTP-API" class="headerlink" title="2.HTTP API"></a>2.HTTP API</h3><ul><li>GET</li><li>POST</li><li>PUT</li><li>DELETE</li><li>OPTIONS</li><li>HEAD</li><li>TRACE</li><li>CONNECT</li></ul><h3 id="3-接口测试流程"><a href="#3-接口测试流程" class="headerlink" title="3.接口测试流程"></a>3.接口测试流程</h3><p>(1)需求讨论<br>(2)需求评审<br>(3)场景设计<br>(4)用例设计<br>(5)数据准备<br>(6)执行</p><h3 id="4-接口用例设计"><a href="#4-接口用例设计" class="headerlink" title="4.接口用例设计"></a>4.接口用例设计</h3><p>(1)功能</p><blockquote><p>1)功能是否正常<br>2)功能是否按照接口文档实现</p></blockquote><p>(2)逻辑业务</p><blockquote><p>1)是否依赖业务</p></blockquote><p>(3)异常</p><blockquote><p>1)参数异常</p><ul><li>关键字参数</li><li>参数为空</li><li>多、少参数</li><li>错误参数</li></ul><p>2)数据异常</p><ul><li>关键字数据</li><li>数据为空</li><li>长度不一致</li><li>错误数据</li></ul></blockquote><p>(4)安全</p><blockquote><p>1)cookie<br>2)header<br>3)唯一识别码</p></blockquote><h3 id="5-接口测试三剑客"><a href="#5-接口测试三剑客" class="headerlink" title="5.接口测试三剑客"></a>5.接口测试三剑客</h3><p>(1)fiddler<br>(2)postman<br>(3)python</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接口测试是测试系统组件间接口的一种测试。接口测试主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。测试的重点是要检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="接口测试" scheme="http://pythonfood.github.io/categories/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="接口测试" scheme="http://pythonfood.github.io/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>unittest测试框架</title>
    <link href="http://pythonfood.github.io/2018/03/01/unittest%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    <id>http://pythonfood.github.io/2018/03/01/unittest测试框架/</id>
    <published>2018-03-01T01:00:00.000Z</published>
    <updated>2018-03-06T08:09:01.697Z</updated>
    
    <content type="html"><![CDATA[<p>unittest中最核心的四个概念是：test fixture, test case, test suite, test runner。<br><a id="more"></a></p><h3 id="1-unittest框架"><a href="#1-unittest框架" class="headerlink" title="1.unittest框架"></a>1.unittest框架</h3><p>(1)Test Fixture</p><ul><li>setup()</li><li>testcase()</li><li>teardown()</li></ul><p>(2)Test Case<br>(3)Test Suite<br>(4)Test Runner</p><h3 id="2-unittest小示例"><a href="#2-unittest小示例" class="headerlink" title="2.unittest小示例"></a>2.unittest小示例</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import unittestdemo1</span><br><span class="line">import unittestdemo2</span><br><span class="line">import unittest</span><br><span class="line">from appium import webdriver</span><br><span class="line"></span><br><span class="line">class MyTestCase(unittest.TestCase):</span><br><span class="line">#初始化setup</span><br><span class="line">def setUp(self):</span><br><span class="line">desired_caps=&#123;&#125;</span><br><span class="line">        desired_caps[&apos;platformName&apos;]=&apos;Android&apos;</span><br><span class="line">        desired_caps[&apos;platformVersion&apos;]=&apos;5.1.1&apos;</span><br><span class="line">        desired_caps[&apos;deviceName&apos;]=&apos;61f9c06a&apos;</span><br><span class="line">        desired_caps[&apos;appPackage&apos;]=&apos;com.android.contacts&apos;</span><br><span class="line">        desired_caps[&apos;appActivity&apos;]=&apos;com.android.contacts.DialtactsContactsEntryActivity&apos;</span><br><span class="line">        desired_caps[&apos;unicodeKeyboard&apos;]=&apos;true&apos;</span><br><span class="line">        desired_caps[&apos;resetKeyboard&apos;]=&apos;true&apos;</span><br><span class="line">        self.driver = webdriver.Remote(&apos;http://127.0.0.1:4723/wd/hub&apos;, desired_caps)</span><br><span class="line"></span><br><span class="line">#测试用例1</span><br><span class="line">def test_something(self):</span><br><span class="line">self.assertEqual(False, True)</span><br><span class="line">print(&apos;test_something&apos;)</span><br><span class="line">#测试用例2</span><br><span class="line">def test_anything(self):</span><br><span class="line">self.assertEqual(True, True)</span><br><span class="line">print(&apos;test_anything&apos;)</span><br><span class="line"></span><br><span class="line">#释放资源teardown</span><br><span class="line">def tearDown(self):</span><br><span class="line">self.driver.quit()</span><br><span class="line"></span><br><span class="line">if __name__ ==&quot;__main__&quot;:</span><br><span class="line">#以类的形式添加测试用例</span><br><span class="line">cases1 = unittest.TestLoader().loadTestsFromTestCase(unittestdemo1.MyTestCase)</span><br><span class="line">cases2 = unittest.TestLoader().loadTestsFromTestCase(unittestdemo2.MyTestCase)</span><br><span class="line">#定义suite</span><br><span class="line">suite = unittest.TestSuite([cases1, cases2])</span><br><span class="line">#以单条测试用例形式装载</span><br><span class="line">    suite.addTest(MyTestCase(&apos;test_something&apos;))</span><br><span class="line">suite.addTest(MyTestCase(&apos;test_anything&apos;))</span><br><span class="line">    </span><br><span class="line">#定义runner</span><br><span class="line">    runner = unittest.TextTestRunner(verbosity=2)</span><br><span class="line">#用runner执行suite</span><br><span class="line">    runner.run(suite)</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-DDT数据驱动模式"><a href="#3-DDT数据驱动模式" class="headerlink" title="3.DDT数据驱动模式"></a>3.DDT数据驱动模式</h3><p>(1)官网下载安装：<a href="https://pypi.python.org/pypi/ddt" target="_blank" rel="noopener">https://pypi.python.org/pypi/ddt</a><br>(2)使用前导入模块<code>from ddt import ddt,data,unpack</code><br>(3)首先说明测试类使用的是ddt测试框架：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@ddt</span><br><span class="line">class MyTestCase(unittest.TestCase)</span><br></pre></td></tr></table></figure></blockquote><p>(4)数据驱动主要是解决带参数的测试用例：<br>1）使用元组存放测试的数据，一个参数的情况：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@data(1,-3,2,0)</span><br><span class="line">def testcase(self, value):</span><br></pre></td></tr></table></figure></blockquote><p>2）使用元组存放测试的数据，多个参数的情况：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@data((3,2),(4,3),(5,3))</span><br><span class="line">@unpack</span><br><span class="line">def testcase(self, value1, value2):</span><br></pre></td></tr></table></figure></blockquote><h3 id="4-DDT小示例"><a href="#4-DDT小示例" class="headerlink" title="4.DDT小示例"></a>4.DDT小示例</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from ddt import ddt,data,unpack</span><br><span class="line"></span><br><span class="line">@ddt</span><br><span class="line">class MyTestCase(unittest.TestCase):</span><br><span class="line"></span><br><span class="line">@data(1,2,3)</span><br><span class="line">def test_something(self, value):</span><br><span class="line">print(value)</span><br><span class="line">self.assertEqual(value, 2)</span><br><span class="line"></span><br><span class="line">@data((1,2),(2,3))</span><br><span class="line">@unpack</span><br><span class="line">def test_anything(self, value1, value2):</span><br><span class="line">print(value1,value2)</span><br><span class="line">self.assertEqual(value2, value1+1)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">unittest.main()</span><br></pre></td></tr></table></figure></blockquote><p>ps:使用ddt框架后，测试用例的名称会改变，所以装载Test Suite时不能使用单条测试用例装载了，尽量使用类的形式装载Test Suite。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;unittest中最核心的四个概念是：test fixture, test case, test suite, test runner。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="测试框架" scheme="http://pythonfood.github.io/categories/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="测试框架" scheme="http://pythonfood.github.io/tags/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>appium键值表</title>
    <link href="http://pythonfood.github.io/2018/02/01/appium%E9%94%AE%E5%80%BC%E8%A1%A8/"/>
    <id>http://pythonfood.github.io/2018/02/01/appium键值表/</id>
    <published>2018-02-01T04:00:00.000Z</published>
    <updated>2018-02-28T07:10:54.877Z</updated>
    
    <content type="html"><![CDATA[<p>appium键值表查询。<br><a id="more"></a></p><h3 id="1-电话键"><a href="#1-电话键" class="headerlink" title="1.电话键"></a>1.电话键</h3><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th><th style="text-align:left">键值</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_CALL</td><td style="text-align:left">拨号键</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left">KEYCODE_ENDCALL</td><td style="text-align:left">挂机键</td><td style="text-align:left">6</td></tr><tr><td style="text-align:left">KEYCODE_HOME</td><td style="text-align:left">按键Home</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">KEYCODE_MENU</td><td style="text-align:left">菜单键</td><td style="text-align:left">82</td></tr><tr><td style="text-align:left">KEYCODE_BACK</td><td style="text-align:left">返回键</td><td style="text-align:left">4</td></tr><tr><td style="text-align:left">KEYCODE_SEARCH</td><td style="text-align:left">搜索键</td><td style="text-align:left">84</td></tr><tr><td style="text-align:left">KEYCODE_CAMERA</td><td style="text-align:left">拍照键</td><td style="text-align:left">27</td></tr><tr><td style="text-align:left">KEYCODE_FOCUS</td><td style="text-align:left">拍照对焦键</td><td style="text-align:left">80</td></tr><tr><td style="text-align:left">KEYCODE_POWER</td><td style="text-align:left">电源键</td><td style="text-align:left">26</td></tr><tr><td style="text-align:left">KEYCODE_NOTIFICATION</td><td style="text-align:left">通知键</td><td style="text-align:left">83</td></tr><tr><td style="text-align:left">KEYCODE_MUTE</td><td style="text-align:left">话筒静音键</td><td style="text-align:left">91</td></tr><tr><td style="text-align:left">KEYCODE_VOLUME_MUTE</td><td style="text-align:left">扬声器静音键</td><td style="text-align:left">164</td></tr><tr><td style="text-align:left">KEYCODE_VOLUME_UP</td><td style="text-align:left">音量增加键</td><td style="text-align:left">24</td></tr><tr><td style="text-align:left">KEYCODE_VOLUME_DOWN</td><td style="text-align:left">音量减小键</td><td style="text-align:left">25</td></tr></tbody></table><h3 id="2-控制键"><a href="#2-控制键" class="headerlink" title="2.控制键"></a>2.控制键</h3><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th><th style="text-align:left">键值</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_ENTER</td><td style="text-align:left">回车键</td><td style="text-align:left">66</td></tr><tr><td style="text-align:left">KEYCODE_ESCAPE</td><td style="text-align:left">ESC键</td><td style="text-align:left">111</td></tr><tr><td style="text-align:left">KEYCODE_DPAD_CENTER</td><td style="text-align:left">导航键 确定键</td><td style="text-align:left">23</td></tr><tr><td style="text-align:left">KEYCODE_DPAD_UP</td><td style="text-align:left">导航键 向上</td><td style="text-align:left">19</td></tr><tr><td style="text-align:left">KEYCODE_DPAD_DOWN</td><td style="text-align:left">导航键 向下</td><td style="text-align:left">20</td></tr><tr><td style="text-align:left">KEYCODE_DPAD_LEFT</td><td style="text-align:left">导航键 向左</td><td style="text-align:left">21</td></tr><tr><td style="text-align:left">KEYCODE_DPAD_RIGHT</td><td style="text-align:left">导航键 向右</td><td style="text-align:left">22</td></tr><tr><td style="text-align:left">KEYCODE_MOVE_HOME</td><td style="text-align:left">光标移动到开始键</td><td style="text-align:left">122</td></tr><tr><td style="text-align:left">KEYCODE_MOVE_END</td><td style="text-align:left">光标移动到末尾键</td><td style="text-align:left">123</td></tr><tr><td style="text-align:left">KEYCODE_PAGE_UP</td><td style="text-align:left">向上翻页键</td><td style="text-align:left">92</td></tr><tr><td style="text-align:left">KEYCODE_PAGE_DOWN</td><td style="text-align:left">向下翻页键</td><td style="text-align:left">93</td></tr><tr><td style="text-align:left">KEYCODE_DEL</td><td style="text-align:left">退格键</td><td style="text-align:left">67</td></tr><tr><td style="text-align:left">KEYCODE_FORWARD_DEL</td><td style="text-align:left">删除键</td><td style="text-align:left">112</td></tr><tr><td style="text-align:left">KEYCODE_INSERT</td><td style="text-align:left">插入键</td><td style="text-align:left">124</td></tr><tr><td style="text-align:left">KEYCODE_TAB</td><td style="text-align:left">Tab键</td><td style="text-align:left">61</td></tr><tr><td style="text-align:left">KEYCODE_NUM_LOCK</td><td style="text-align:left">小键盘锁</td><td style="text-align:left">143</td></tr><tr><td style="text-align:left">KEYCODE_CAPS_LOCK</td><td style="text-align:left">大写锁定键</td><td style="text-align:left">115</td></tr><tr><td style="text-align:left">KEYCODE_BREAK</td><td style="text-align:left">Break/Pause键</td><td style="text-align:left">121</td></tr><tr><td style="text-align:left">KEYCODE_SCROLL_LOCK</td><td style="text-align:left">滚动锁定键</td><td style="text-align:left">116</td></tr><tr><td style="text-align:left">KEYCODE_ZOOM_IN</td><td style="text-align:left">放大键</td><td style="text-align:left">168</td></tr><tr><td style="text-align:left">KEYCODE_ZOOM_OUT</td><td style="text-align:left">缩小键</td><td style="text-align:left">169</td></tr></tbody></table><h3 id="3-组合键"><a href="#3-组合键" class="headerlink" title="3.组合键"></a>3.组合键</h3><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_ALT_LEFT</td><td style="text-align:left">Alt+Left</td></tr><tr><td style="text-align:left">KEYCODE_ALT_RIGHT</td><td style="text-align:left">Alt+Right</td></tr><tr><td style="text-align:left">KEYCODE_CTRL_LEFT</td><td style="text-align:left">Control+Left</td></tr><tr><td style="text-align:left">KEYCODE_CTRL_RIGHT</td><td style="text-align:left">Control+Right</td></tr><tr><td style="text-align:left">KEYCODE_SHIFT_LEFT</td><td style="text-align:left">Shift+Left</td></tr><tr><td style="text-align:left">KEYCODE_SHIFT_RIGHT</td><td style="text-align:left">Shift+Right</td></tr></tbody></table><h3 id="4-基本键"><a href="#4-基本键" class="headerlink" title="4.基本键"></a>4.基本键</h3><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th><th style="text-align:left">键值</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_0</td><td style="text-align:left">按键’0’</td><td style="text-align:left">7</td></tr><tr><td style="text-align:left">KEYCODE_1</td><td style="text-align:left">按键’1’</td><td style="text-align:left">8</td></tr><tr><td style="text-align:left">KEYCODE_2</td><td style="text-align:left">按键’2’</td><td style="text-align:left">9</td></tr><tr><td style="text-align:left">KEYCODE_3</td><td style="text-align:left">按键’3’</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">KEYCODE_4</td><td style="text-align:left">按键’4’</td><td style="text-align:left">11</td></tr><tr><td style="text-align:left">KEYCODE_5</td><td style="text-align:left">按键’5’</td><td style="text-align:left">12</td></tr><tr><td style="text-align:left">KEYCODE_6</td><td style="text-align:left">按键’6’</td><td style="text-align:left">13</td></tr><tr><td style="text-align:left">KEYCODE_7</td><td style="text-align:left">按键’7’</td><td style="text-align:left">14</td></tr><tr><td style="text-align:left">KEYCODE_8</td><td style="text-align:left">按键’8’</td><td style="text-align:left">15</td></tr><tr><td style="text-align:left">KEYCODE_9</td><td style="text-align:left">按键’9’</td><td style="text-align:left">16</td></tr><tr><td style="text-align:left">KEYCODE_A</td><td style="text-align:left">按键’A’</td><td style="text-align:left">29</td></tr><tr><td style="text-align:left">KEYCODE_B</td><td style="text-align:left">按键’B’</td><td style="text-align:left">30</td></tr><tr><td style="text-align:left">KEYCODE_C</td><td style="text-align:left">按键’C’</td><td style="text-align:left">31</td></tr><tr><td style="text-align:left">KEYCODE_D</td><td style="text-align:left">按键’D’</td><td style="text-align:left">32</td></tr><tr><td style="text-align:left">KEYCODE_E</td><td style="text-align:left">按键’E’</td><td style="text-align:left">33</td></tr><tr><td style="text-align:left">KEYCODE_F</td><td style="text-align:left">按键’F’</td><td style="text-align:left">34</td></tr><tr><td style="text-align:left">KEYCODE_G</td><td style="text-align:left">按键’G’</td><td style="text-align:left">35</td></tr><tr><td style="text-align:left">KEYCODE_H</td><td style="text-align:left">按键’H’</td><td style="text-align:left">36</td></tr><tr><td style="text-align:left">KEYCODE_I</td><td style="text-align:left">按键’I’</td><td style="text-align:left">37</td></tr><tr><td style="text-align:left">KEYCODE_J</td><td style="text-align:left">按键’J’</td><td style="text-align:left">38</td></tr><tr><td style="text-align:left">KEYCODE_K</td><td style="text-align:left">按键’K’</td><td style="text-align:left">39</td></tr><tr><td style="text-align:left">KEYCODE_L</td><td style="text-align:left">按键’L’</td><td style="text-align:left">40</td></tr><tr><td style="text-align:left">KEYCODE_M</td><td style="text-align:left">按键’M’</td><td style="text-align:left">41</td></tr><tr><td style="text-align:left">KEYCODE_N</td><td style="text-align:left">按键’N’</td><td style="text-align:left">42</td></tr><tr><td style="text-align:left">KEYCODE_O</td><td style="text-align:left">按键’O’</td><td style="text-align:left">43</td></tr><tr><td style="text-align:left">KEYCODE_P</td><td style="text-align:left">按键’P’</td><td style="text-align:left">44</td></tr><tr><td style="text-align:left">KEYCODE_Q</td><td style="text-align:left">按键’Q’</td><td style="text-align:left">45</td></tr><tr><td style="text-align:left">KEYCODE_R</td><td style="text-align:left">按键’R’</td><td style="text-align:left">46</td></tr><tr><td style="text-align:left">KEYCODE_S</td><td style="text-align:left">按键’S’</td><td style="text-align:left">47</td></tr><tr><td style="text-align:left">KEYCODE_T</td><td style="text-align:left">按键’T’</td><td style="text-align:left">48</td></tr><tr><td style="text-align:left">KEYCODE_U</td><td style="text-align:left">按键’U’</td><td style="text-align:left">49</td></tr><tr><td style="text-align:left">KEYCODE_V</td><td style="text-align:left">按键’V’</td><td style="text-align:left">50</td></tr><tr><td style="text-align:left">KEYCODE_W</td><td style="text-align:left">按键’W’</td><td style="text-align:left">51</td></tr><tr><td style="text-align:left">KEYCODE_X</td><td style="text-align:left">按键’X’</td><td style="text-align:left">52</td></tr><tr><td style="text-align:left">KEYCODE_Y</td><td style="text-align:left">按键’Y’</td><td style="text-align:left">53</td></tr><tr><td style="text-align:left">KEYCODE_Z</td><td style="text-align:left">按键’Z’</td><td style="text-align:left">54</td></tr></tbody></table><h3 id="5-符号键"><a href="#5-符号键" class="headerlink" title="5.符号键"></a>5.符号键</h3><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_PLUS</td><td style="text-align:left">按键’+’</td></tr><tr><td style="text-align:left">KEYCODE_MINUS</td><td style="text-align:left">按键’-‘</td></tr><tr><td style="text-align:left">KEYCODE_STAR</td><td style="text-align:left">按键’*’</td></tr><tr><td style="text-align:left">KEYCODE_SLASH</td><td style="text-align:left">按键’/‘</td></tr><tr><td style="text-align:left">KEYCODE_EQUALS</td><td style="text-align:left">按键’=’</td></tr><tr><td style="text-align:left">KEYCODE_AT</td><td style="text-align:left">按键’@’</td></tr><tr><td style="text-align:left">KEYCODE_POUND</td><td style="text-align:left">按键’#’</td></tr><tr><td style="text-align:left">KEYCODE_APOSTROPHE</td><td style="text-align:left">按键’’’ (单引号)</td></tr><tr><td style="text-align:left">KEYCODE_BACKSLASH</td><td style="text-align:left">按键’\’</td></tr><tr><td style="text-align:left">KEYCODE_COMMA</td><td style="text-align:left">按键’,’</td></tr><tr><td style="text-align:left">KEYCODE_PERIOD</td><td style="text-align:left">按键’.’</td></tr><tr><td style="text-align:left">KEYCODE_LEFT_BRACKET</td><td style="text-align:left">按键’[‘</td></tr><tr><td style="text-align:left">KEYCODE_RIGHT_BRACKET</td><td style="text-align:left">按键’]’</td></tr><tr><td style="text-align:left">KEYCODE_SEMICOLON</td><td style="text-align:left">按键’;’</td></tr><tr><td style="text-align:left">KEYCODE_GRAVE</td><td style="text-align:left">按键’`’</td></tr><tr><td style="text-align:left">KEYCODE_SPACE</td><td style="text-align:left">空格键</td></tr></tbody></table><h3 id="6-小键盘"><a href="#6-小键盘" class="headerlink" title="6.小键盘"></a>6.小键盘</h3><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_NUMPAD_0</td><td style="text-align:left">小键盘按键’0’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_1</td><td style="text-align:left">小键盘按键’1’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_2</td><td style="text-align:left">小键盘按键’2’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_3</td><td style="text-align:left">小键盘按键’3’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_4</td><td style="text-align:left">小键盘按键’4’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_5</td><td style="text-align:left">小键盘按键’5’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_6</td><td style="text-align:left">小键盘按键’6’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_7</td><td style="text-align:left">小键盘按键’7’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_8</td><td style="text-align:left">小键盘按键’8’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_9</td><td style="text-align:left">小键盘按键’9’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_ADD</td><td style="text-align:left">小键盘按键’+’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_SUBTRACT</td><td style="text-align:left">小键盘按键’-‘</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_MULTIPLY</td><td style="text-align:left">小键盘按键’*’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_DIVIDE</td><td style="text-align:left">小键盘按键’/‘</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_EQUALS</td><td style="text-align:left">小键盘按键’=’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_COMMA</td><td style="text-align:left">小键盘按键’,’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_DOT</td><td style="text-align:left">小键盘按键’.’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_LEFT_PAREN</td><td style="text-align:left">小键盘按键’(‘</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_RIGHT_PAREN</td><td style="text-align:left">小键盘按键’)’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_ENTER</td><td style="text-align:left">小键盘按键回车</td></tr></tbody></table><h3 id="7-功能键"><a href="#7-功能键" class="headerlink" title="7.功能键"></a>7.功能键</h3><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_F1</td><td style="text-align:left">按键F1</td></tr><tr><td style="text-align:left">KEYCODE_F2</td><td style="text-align:left">按键F2</td></tr><tr><td style="text-align:left">KEYCODE_F3</td><td style="text-align:left">按键F3</td></tr><tr><td style="text-align:left">KEYCODE_F4</td><td style="text-align:left">按键F4</td></tr><tr><td style="text-align:left">KEYCODE_F5</td><td style="text-align:left">按键F5</td></tr><tr><td style="text-align:left">KEYCODE_F6</td><td style="text-align:left">按键F6</td></tr><tr><td style="text-align:left">KEYCODE_F7</td><td style="text-align:left">按键F7</td></tr><tr><td style="text-align:left">KEYCODE_F8</td><td style="text-align:left">按键F8</td></tr><tr><td style="text-align:left">KEYCODE_F9</td><td style="text-align:left">按键F9</td></tr><tr><td style="text-align:left">KEYCODE_F10</td><td style="text-align:left">按键F10</td></tr><tr><td style="text-align:left">KEYCODE_F11</td><td style="text-align:left">按键F11</td></tr><tr><td style="text-align:left">KEYCODE_F12</td><td style="text-align:left">按键F12</td></tr></tbody></table><h3 id="8-多媒体键"><a href="#8-多媒体键" class="headerlink" title="8.多媒体键"></a>8.多媒体键</h3><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_MEDIA_PLAY</td><td style="text-align:left">播放</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_STOP</td><td style="text-align:left">停止</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_PAUSE</td><td style="text-align:left">暂停</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_PLAY_PAUSE</td><td style="text-align:left">播放/暂停</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_FAST_FORWARD</td><td style="text-align:left">快进</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_REWIND</td><td style="text-align:left">快退</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_NEXT</td><td style="text-align:left">下一首</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_PREVIOUS</td><td style="text-align:left">上一首</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_CLOSE</td><td style="text-align:left">关闭</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_EJECT</td><td style="text-align:left">弹出</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_RECORD</td><td style="text-align:left">录音</td></tr></tbody></table><h3 id="9-手柄按键"><a href="#9-手柄按键" class="headerlink" title="9.手柄按键"></a>9.手柄按键</h3><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_BUTTON_1</td><td style="text-align:left">通用游戏手柄按钮 #1</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_2</td><td style="text-align:left">通用游戏手柄按钮 #2</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_3</td><td style="text-align:left">通用游戏手柄按钮 #3</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_4</td><td style="text-align:left">通用游戏手柄按钮 #4</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_5</td><td style="text-align:left">通用游戏手柄按钮 #5</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_6</td><td style="text-align:left">通用游戏手柄按钮 #6</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_7</td><td style="text-align:left">通用游戏手柄按钮 #7</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_8</td><td style="text-align:left">通用游戏手柄按钮 #8</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_9</td><td style="text-align:left">通用游戏手柄按钮 #9</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_10</td><td style="text-align:left">通用游戏手柄按钮 #10</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_11</td><td style="text-align:left">通用游戏手柄按钮 #11</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_12</td><td style="text-align:left">通用游戏手柄按钮 #12</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_13</td><td style="text-align:left">通用游戏手柄按钮 #13</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_14</td><td style="text-align:left">通用游戏手柄按钮 #14</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_15</td><td style="text-align:left">通用游戏手柄按钮 #15</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_16</td><td style="text-align:left">通用游戏手柄按钮 #16</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_A</td><td style="text-align:left">游戏手柄按钮 A</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_B</td><td style="text-align:left">游戏手柄按钮 B</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_C</td><td style="text-align:left">游戏手柄按钮 C</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_X</td><td style="text-align:left">游戏手柄按钮 X</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_Y</td><td style="text-align:left">游戏手柄按钮 Y</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_Z</td><td style="text-align:left">游戏手柄按钮 Z</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_L1</td><td style="text-align:left">游戏手柄按钮 L1</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_L2</td><td style="text-align:left">游戏手柄按钮 L2</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_R1</td><td style="text-align:left">游戏手柄按钮 R1</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_R2</td><td style="text-align:left">游戏手柄按钮 R2</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_MODE</td><td style="text-align:left">游戏手柄按钮 Mode</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_SELECT</td><td style="text-align:left">游戏手柄按钮 Select</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_START</td><td style="text-align:left">游戏手柄按钮 Start</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_THUMBL</td><td style="text-align:left">Left Thumb Button</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_THUMBR</td><td style="text-align:left">Right Thumb Button</td></tr></tbody></table><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;appium键值表查询。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="appium" scheme="http://pythonfood.github.io/categories/appium/"/>
    
    
      <category term="appium" scheme="http://pythonfood.github.io/tags/appium/"/>
    
  </entry>
  
  <entry>
    <title>appium常用API</title>
    <link href="http://pythonfood.github.io/2018/02/01/appium%E5%B8%B8%E7%94%A8API/"/>
    <id>http://pythonfood.github.io/2018/02/01/appium常用API/</id>
    <published>2018-02-01T03:00:00.000Z</published>
    <updated>2018-03-06T10:08:56.403Z</updated>
    
    <content type="html"><![CDATA[<p>appium常用API笔记。<br><a id="more"></a></p><h3 id="1-元素定位"><a href="#1-元素定位" class="headerlink" title="1.元素定位"></a>1.元素定位</h3><p>(1)id定位<br>find_element_by_id(“resrouce-id”)</p><blockquote><p><code>driver.find_element_by_id(&#39;com.android.calculator2:id/digit8&#39;)</code></p></blockquote><p>(2)name定位<br>find_element_by_name(“text”)</p><blockquote><p><code>driver.find_element_by_name(&quot;昵称&quot;)</code></p></blockquote><p>(3)class_name定位<br>find_element_by_class_name(“class”)</p><blockquote><p><code>driver.find_element_by_class_name(&quot;android.widget.Button&quot;)</code></p></blockquote><p>(4)accessibility_id定位<br>find_element_by_accessibility_id(“content-desc”)</p><blockquote><p><code>driver.find_element_by_accessibility_id(&quot;delete&quot;)</code></p></blockquote><p>(5)xpath定位<br>find_element_by_xpath(“xpath”)</p><blockquote><p><code>driver.find_element_by_xpath(&quot;//android.widget.Button[@text=&#39;8&#39;]&quot;)</code></p></blockquote><p>(6)uiautomator定位<br>find_element_by_android_uiautomator(uia_string)<br>uiautomator可以针对resourceid、Text、description、class、package、index、instance等进行定位。</p><blockquote><p>1)resourceId方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().resourceId(&quot;%s&quot;)&#39;)</code></p></blockquote><p>2)text方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().text(&quot;%s&quot;)&#39;)</code></p></blockquote><p>3)description方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().description(&quot;%s&quot;)&#39;)</code></p></blockquote><p>4)className方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().className(&quot;%s&quot;)&#39;)</code></p></blockquote><p>5)packageName方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().packageName(&quot;%s&quot;)&#39;)</code></p></blockquote><p>6)index方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().index(&quot;%s&quot;)&#39;)</code></p></blockquote><p>7)instance方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().instance(&quot;%s&quot;)&#39;)</code></p></blockquote><p>8)className+index方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().className(&quot;%s&quot;).childSelector(new UiSelector().index(&quot;%d&quot;))&#39;)</code></p></blockquote><p>9)伪xpath方法定位</p><blockquote><p>a.通过同级元素定位同级元素</p><blockquote><p><code>driver.find_element_by_android_uiautomator(‘new UiSelector().text(&quot;Custom View&quot;).fromParent(new UiSelector().text(&quot;Accessibility Service&quot;))‘).click()</code>            </p></blockquote><p>b.通过父级元素定位子集元素</p><blockquote><p><code>driver.find_element_by_android_uiautomator(‘new UiSelector().className(&quot;android.widget.ListView&quot;).childSelector(new UiSelector().text(&quot;Custom View&quot;))‘).click()</code>  </p></blockquote></blockquote></blockquote><p>(7)用By定位</p><ul><li>By.ID   #相当于by_id</li><li>By.NAME   #相当于by_name</li><li>By.CLASS_NAME  #相当于by_class_name</li><li>By.ACCESSIBILITY_ID  #相当于by_accessibility_id</li><li>By.XPATH   #相当于by_xpath</li></ul><blockquote><p><code>find_element(By.ID,&quot;com.android.calculator2:id/digit8&quot;)</code></p></blockquote><h3 id="2-应用操作"><a href="#2-应用操作" class="headerlink" title="2.应用操作"></a>2.应用操作</h3><p>(1)安装应用<br><code>install_app()</code> #安装应用到设备中去。需要apk包的路径。</p><blockquote><p><code>driver.install_app(&quot;path/to/my.apk&quot;)</code><br><code>driver.install_app(&quot;D:\\android\\apk\\ContactManager.apk&quot;)</code></p></blockquote><p>(2)卸载应用<br><code>remove_app()</code> #从设备中删除一个应用。</p><blockquote><p><code>driver.remove_app(&quot;com.example.android.apis&quot;)</code></p></blockquote><p>(3)关闭应用<br><code>close_app()</code> #关闭打开的应用，默认关闭当前打开的应用，所以不需要入参。相当于按home键将应用置于后台，可以通过launch_app()再次启动。</p><blockquote><p><code>driver.close_app()</code></p></blockquote><p>(4)启动应用<br><code>launch_app()</code> #该方法需要配合close_app()使用的。</p><blockquote><p><code>driver.launch_app()</code></p></blockquote><p>(5)检查应用是否安装<br><code>is_app_installed()</code> #检查应用是否已经安装。需要传参应用包的名字。返回结果为Ture或False。</p><blockquote><p><code>driver.is_app_installed(&#39;com.example.android.apis&#39;)</code></p></blockquote><p>(6)将应用置于后台<br><code>background_app()</code> #将当前活跃的应用程序发送到后台。这个方法需要入参，需要指定应用置于后台的时长。</p><blockquote><p><code>driver.background_app(2)</code></p></blockquote><p>(7)应用重置<br><code>reset_app()</code> #重置当前被测程序到出始化状态。该方法不需要入参。</p><blockquote><p><code>driver.reset_app()</code></p></blockquote><p>(8)启动activity<br><code>start_activity()</code> #启动一个app或者在当前app中打开一个新的activity，仅适用于android。</p><blockquote><p><code>driver.start_activity(&#39;com.example.android.apis&#39;, &#39;.Foo&#39;)</code></p></blockquote><h3 id="3-键盘操作"><a href="#3-键盘操作" class="headerlink" title="3.键盘操作"></a>3.键盘操作</h3><p>ps：<a href="https://pythonfood.github.io/2018/02/01/appium键值表/#more">appium键值表</a><br>(1)send_keys()方法</p><blockquote><p><code>driver.find_element_by_name(“Name”).send_keys(&quot;jack&quot;)</code></p></blockquote><p>(2)keyevent()方法</p><blockquote><p><code>`driver.keyevent(4)</code> #点击Android的返回键`</p></blockquote><p>(3)press_keycode()方法</p><blockquote><p><code>driver.press_keycode(3)</code> #点击Android的HOME键</p></blockquote><p>(4)long_press_keycode()方法</p><blockquote><p><code>driver.long_press_keycode(4)</code> #长按Android的返回键</p></blockquote><p>(5)隐藏键盘</p><blockquote><p><code>driver.hide_keyboard()</code> #android不需要参数，ios需要传参key_name</p></blockquote><h3 id="4-TouchAction操作"><a href="#4-TouchAction操作" class="headerlink" title="4.TouchAction操作"></a>4.TouchAction操作</h3><p>使用前导入TouchAction模块<code>from appium.webdriver.common.touch_action import TouchAction</code><br>(1)点击<br><code>tap(self,el=None,x=None,y=None,count=1)</code><br>(2)短按<br><code>press(self, el=None, x=None, y=None)</code><br>(3)长按<br><code>long_press(self, el=None, x=None, y=None, duration=1000(ms))</code><br>(4)释放<br><code>release(self)</code><br>(5)移动到<br><code>move_to(self,el=None,x=None,y=None)</code><br>(6)等待<br><code>wait(self,ms=0)</code><br>(7)执行<br><code>perform(self)</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#关于perform官网给的伪代码中讲</span><br><span class="line">TouchAction().tap(el).perform()</span><br><span class="line">#与</span><br><span class="line">driver.perform(TouchAction().tap(el))</span><br><span class="line">#效果一致</span><br></pre></td></tr></table></figure></blockquote><p>(8)多点触控<br><code>MultiTouch()</code> #多点触控,它只提供了两个方法:一个<code>add()</code>、一个执行<code>perform()</code>。<br>使用前导入MultiAction模块<code>from appium.webdriver.common.multi_action import MultiAction</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from appium.webdriver.common.touch_action import TouchAction</span><br><span class="line">from appium.webdriver.common.multi_action import MultiAction</span><br><span class="line"></span><br><span class="line">action0 = TouchAction().tap(el1)</span><br><span class="line">action1 = TouchAction().tap(el2)</span><br><span class="line">MultiTouch().add(action0).add(action1).perform()</span><br></pre></td></tr></table></figure></blockquote><h3 id="5-上下文操作"><a href="#5-上下文操作" class="headerlink" title="5.上下文操作"></a>5.上下文操作</h3><p>(1)当前会话中的所有上下文，使用后可以识别H5页面的控件<br><code>driver.contexts</code></p><blockquote><p>获取的是一个list列表：</p><blockquote><ul><li>NATIVE_APP:这个就是native，也就是原生的</li><li>WEBVIEW_com.xxxx :这个就是webview</li></ul></blockquote></blockquote><p>(2)当前会话的当前上下文<br><code>driver.current_context</code><br>(3)切换上下文<br><code>driver.switch_to.context(&quot;content_str&quot;)</code></p><blockquote><p>1)切换到webview</p><blockquote><p>方法一：<code>driver.switch_to.context(&#39;webview的context&#39;)</code><br>方法二：<code>driver.switch_to.context(contexts[1])</code> #从contexts列表里取第二个参数</p></blockquote><p>2)切回native</p><blockquote><p>方法一：<code>driver.switch_to.context(&quot;NATIVE_APP&quot;)</code> #这个NATIVE_APP是固定的参数<br>方法二：<code>driver.switch_to.context(contexts[0])</code> #从contexts列表里取第一个参数</p></blockquote></blockquote><p>(4)应用的字符串<br><code>driver.app_strings</code></p><h3 id="6-屏幕操作"><a href="#6-屏幕操作" class="headerlink" title="6.屏幕操作"></a>6.屏幕操作</h3><p>(1)点击<br>1)<code>click()</code></p><blockquote><p><code>driver.find_element_by_id(&quot;com.wuba.zhuanzhuan:id/ae8&quot;).click()</code></p></blockquote><p>2)<code>driver.tap()</code></p><blockquote><p><code>driver.tap([(216,1776)],200)</code></p></blockquote><p>(2)滑动<br><code>driver.swipe(x1, y1, x2, y2,duration)</code> #从坐标(x1,x2)滑动到坐标(x2,y2)，duration非必填项，滑动时间</p><blockquote><p>一个向上下左右滑动的方法封装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#获得屏幕大小宽和高</span><br><span class="line">def getSize(driver):</span><br><span class="line">    x = driver.get_window_size()[&apos;width&apos;]</span><br><span class="line">    y = driver.get_window_size()[&apos;height&apos;]</span><br><span class="line">    return (x, y)</span><br><span class="line"></span><br><span class="line">#屏幕向上滑动</span><br><span class="line">def swipeUp(driver,t=1000):</span><br><span class="line">    l = getSize(driver)</span><br><span class="line">    x1 = int(l[0] * 0.5)    #x坐标</span><br><span class="line">    y1 = int(l[1] * 0.75)   #起始y坐标</span><br><span class="line">    y2 = int(l[1] * 0.25)   #终点y坐标</span><br><span class="line">    driver.swipe(x1, y1, x1, y2,t)</span><br><span class="line"></span><br><span class="line">#屏幕向下滑动</span><br><span class="line">def swipeDown(driver,t=1000):</span><br><span class="line">    l = getSize(driver)</span><br><span class="line">    x1 = int(l[0] * 0.5)  #x坐标</span><br><span class="line">    y1 = int(l[1] * 0.25)   #起始y坐标</span><br><span class="line">    y2 = int(l[1] * 0.75)   #终点y坐标</span><br><span class="line">    driver.swipe(x1, y1, x1, y2,t)</span><br><span class="line">#屏幕向左滑动</span><br><span class="line">def swipLeft(driver,t):</span><br><span class="line">    l=getSize(driver)</span><br><span class="line">    x1=int(l[0]*0.75)</span><br><span class="line">    y1=int(l[1]*0.5)</span><br><span class="line">    x2=int(l[0]*0.05)</span><br><span class="line">    driver.swipe(x1,y1,x2,y1,t)</span><br><span class="line">#屏幕向右滑动</span><br><span class="line">def swipRight(driver,t=1000):</span><br><span class="line">    l=getSize(driver)</span><br><span class="line">    x1=int(l[0]*0.05)</span><br><span class="line">    y1=int(l[1]*0.5)</span><br><span class="line">    x2=int(l[0]*0.75)</span><br><span class="line">    driver.swipe(x1,y1,x2,y1,t)</span><br><span class="line"> </span><br><span class="line">#调用向下滑动的方法</span><br><span class="line">swipeDown(driver)</span><br></pre></td></tr></table></figure></p></blockquote><p>(3)滚动<br><code>driver.scroll(origin_el,destination_el)</code></p><p>(4)拖动<br><code>driver.drag_and_drop(el1,el2)</code></p><p>(5)快速滑动<br><code>driver.flick(start_x, start_y, end_x, end_y)</code></p><p>(6)缩小<br><code>driver.pinch(element)</code></p><p>(7)放大<br><code>driver.zoom(element)</code></p><p>(8)锁屏<br><code>driver.lock()</code> #android不需要传参，ios可以传参锁屏多少秒</p><p>(9)截屏<br><code>get_screenshot_as_file()</code></p><blockquote><p><code>driver.get_screenshot_as_file(&#39;../screenshot/foo.png&#39;)</code>#保存的图片路径和名称</p></blockquote><p>(10)屏幕旋转<br><code>rotate(ScreenOrientation orientation)</code></p><ul><li>landscape：限制界面为横屏，旋转屏幕也不会改变当前状态。</li><li>portrait：限制界面为竖屏，旋转屏幕也不会改变当前状态。</li><li>sensor:根据传感器定位方向，旋转手机90度，180,270,360，界面都会发生变化。</li><li>sensorLandscape：（横屏的旋转，不会出现竖屏的现象）根据传感器定位方向，旋转手机180度界面旋转。一般横屏游戏会是这个属性。</li><li>sensorPortrait：（竖屏的旋转，不会出现横屏的现象）根据传感器定位方向，旋转手机180度界面会旋转。</li><li>unspecified：由系统选择显示方向，不同的设备可能会有所不同。（旋转手机，界面会跟着旋转）</li><li>user: 用户当前的首选方向。</li><li>nosensor：不由传感器确定方向。旋转设备的时候，界面不会跟着旋转。初始界面方向由系统提供。</li></ul><p>(11)获取当前屏幕的方向<br><code>get_orientation()</code></p><h3 id="7-网络设置"><a href="#7-网络设置" class="headerlink" title="7.网络设置"></a>7.网络设置</h3><p>(1)返回网络类型数值<br><code>driver.network_connection</code></p><p>(2)网络设置<br><code>driver.setNetworkConnection(bitmask掩码)</code><br>使用前导入ConnectionType模块<code>from appium.webdriver.connectiontype import ConnectionType</code></p><blockquote><p><code>driver.set_network_connection(2)</code><br><code>driver.set_network_connection(ConnectionType.WIFI_ONLY)</code></p></blockquote><p>网络的bitmask掩码如下：</p><table><thead><tr><th style="text-align:left">值 (别名)</th><th style="text-align:left">数据连接</th><th style="text-align:left">Wifi连接</th><th style="text-align:left">飞行模式</th></tr></thead><tbody><tr><td style="text-align:left">0 (NO_CONNECTION)</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">1 (AIRPLANE_MODE)</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">2 (WIFI_ONLY)</td><td style="text-align:left">0</td><td style="text-align:left">1</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">4 (DATA_ONLY)</td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">6 (ALL_NETWORK_ON)</td><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">0</td></tr></tbody></table><h3 id="8-位置设置"><a href="#8-位置设置" class="headerlink" title="8.位置设置"></a>8.位置设置</h3><p>(1)打开定位设置<br><code>driver.toggle_location_services()</code> </p><p>(2)设置设备的经纬度<br><code>driver.set_location(latitude纬度，longitude经度，altitude海拔高度)</code></p><h3 id="9-文件操作"><a href="#9-文件操作" class="headerlink" title="9.文件操作"></a>9.文件操作</h3><p>(1)把本地文件push到设备上。<br><code>push_file()</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = &quot;some data for the file&quot;</span><br><span class="line">path = &quot;/data/local/tmp/file.txt&quot;</span><br><span class="line">driver.push_file(path, data.encode(&apos;base64&apos;))</span><br></pre></td></tr></table></figure></blockquote><p>(2)将设备上的文件pull到本地硬盘上<br><code>pull_file()</code></p><blockquote><p><code>driver.pull_file(&#39;Library/AddressBook/AddressBook.sqlitedb&#39;)</code></p></blockquote><p>(3)将设备上的文件夹pull到本地硬盘上，一般远程文件为/data/local/tmp下的文件。<br><code>pull_folder()</code></p><h3 id="10-activity操作"><a href="#10-activity操作" class="headerlink" title="10.activity操作"></a>10.activity操作</h3><p>(1)启动activity<br><code>driver.start_activity()</code></p><p>(2)获取当前activity<br><code>driver.current_activity</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">activity = self.driver.current_activity </span><br><span class="line">print(u&quot;当前的activity是:&quot;, activity)</span><br></pre></td></tr></table></figure></blockquote><p>(3)等待activity启动直到x秒超时，每隔y秒扫描一次<br><code>driver.wait_activity(activity, x, y)</code></p><p>(4)检查是否存在某个activity(未找到则返回异常）<br><code>driver.find_element_by_id(activity)</code></p><p>ps:查看包名和activity的方法：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 1)启动应用，输入命令，查看</span><br><span class="line">adb shell dumpsys window | findstr mCurrentFocus </span><br><span class="line"># 2)启动应用，输入命令，查看</span><br><span class="line">adb shell dumpsys activity activities</span><br><span class="line"># 3)有安装包，cmd输入命令，查看</span><br><span class="line">aapt dump badging &lt;file_path.apk&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="11-其他操作"><a href="#11-其他操作" class="headerlink" title="11.其他操作"></a>11.其他操作</h3><p>(1)打开通知栏<br><code>driver.open_notifications()</code></p><p>(2)摇一摇手机<br><code>driver.shake()</code></p><p>(3)获取控件各种属性<br><code>get_attribute()</code><br>可获取的字符串类型：</p><ul><li>name(返回content-desc或text)</li><li>text(返回text)</li><li>className(返回class，只有API=&gt;18才能支持)</li><li>resourceId(返回resource-id，只有API=&gt;18才能支持)</li><li>…uiautomator获得的属性</li></ul><blockquote><p><code>driver.find_element_by_id().get_attribute(name)</code></p></blockquote><p>(4)返回元素是否选择<br><code>element.is_slected()</code></p><p>(5)返回元素是否可用<br><code>element.is_enabled()</code></p><p>(6)返回元素的文本值<br><code>element.text()</code></p><p>(7)清除输入的内容<br><code>element.clear()</code></p><p>(8)获取元素的大小<br><code>driver.element.size</code></p><ul><li>new_size[“height”] = size[“height”]</li><li>new_size[“width”] = size[“width”]</li></ul><p>(9)获取元素左上角的坐标<br><code>driver.element.location</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#返回element的x坐标, int类型</span><br><span class="line">driver.element.location.get(&apos;x&apos;)</span><br><span class="line">#返回element的y坐标, int类型</span><br><span class="line">driver.element.location.get(&apos;y&apos;)</span><br></pre></td></tr></table></figure></blockquote><h3 id="12-unittest断言"><a href="#12-unittest断言" class="headerlink" title="12.unittest断言"></a>12.unittest断言</h3><p>在unittest单元测试框架中，TestCase类提供了一些方法来检查并报告故障：<br>(1)<code>assertEqual(first, second, msg=None)</code>#判断first和second的值是否相等，如果不相等则测试失败，msg用于定义失败后所抛出的异常信息。<br>(2)<code>assertNotEqual(first, second, msg=None)</code>#测试first和second不相等，如果相等，则测试失败。<br>(3)<code>assertTure(expr,msg=None)</code><br>(4)<code>assertFalse(expr,msg=None)</code>#测试expr为Ture（或为False）<br>(5)<code>assertIs(first, second, msg=None)</code><br>(6)<code>assertIsNot(first, second, msg=None)</code>#测试的first和second是（或不是）相同的对象。<br>(7)<code>assertIsNone(expr, msg=None)</code><br>(8)<code>assertIsNotNone(expr, msg=None)</code>#测试expr是（或不是）为None<br>(9)<code>assertIn(first, second, msg=None)</code><br>(10)<code>assertNotIn(first, second, msg=None)</code>#测试first是（或不是）在second中。second包含是否包含first。</p><h3 id="13-脚本设计原则"><a href="#13-脚本设计原则" class="headerlink" title="13.脚本设计原则"></a>13.脚本设计原则</h3><p>(1)LOVE原则(NativeApp)：</p><blockquote><p>1)Locate定位元素<br>2)Operate操作元素<br>3)Verify验证结果<br>4)Exception异常处理</p></blockquote><p>(2)S-LOVE原则(HybridApp)：</p><blockquote><p>1)Switch切换上下文<br>2)Locate定位元素<br>3)Operate操作元素<br>4)Verify验证结果<br>5)Exception异常处理</p></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;appium常用API笔记。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="appium" scheme="http://pythonfood.github.io/categories/appium/"/>
    
    
      <category term="appium" scheme="http://pythonfood.github.io/tags/appium/"/>
    
  </entry>
  
  <entry>
    <title>appium DesiredCapabilities</title>
    <link href="http://pythonfood.github.io/2018/02/01/appium-DesiredCapabilities/"/>
    <id>http://pythonfood.github.io/2018/02/01/appium-DesiredCapabilities/</id>
    <published>2018-02-01T02:00:00.000Z</published>
    <updated>2018-02-26T09:11:31.048Z</updated>
    
    <content type="html"><![CDATA[<p>Appium Desired Capabilities 详解。<br><a id="more"></a></p><h3 id="1-基本参数"><a href="#1-基本参数" class="headerlink" title="1.基本参数"></a>1.基本参数</h3><table><thead><tr><th style="text-align:left">关键字</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">automationName</td><td style="text-align:left">自动化测试引擎</td><td style="text-align:left">Appium或 Selendroid</td></tr><tr><td style="text-align:left">platformName</td><td style="text-align:left">手机操作系统</td><td style="text-align:left">iOS, Android, 或 FirefoxOS</td></tr><tr><td style="text-align:left">platformVersion</td><td style="text-align:left">手机操作系统版本</td><td style="text-align:left">如： 7.1, 4.4；ios的 9.0</td></tr><tr><td style="text-align:left">deviceName</td><td style="text-align:left">手机或模拟器设备名称</td><td style="text-align:left">android的忽略，ios如iPhone Simulator</td></tr><tr><td style="text-align:left">app</td><td style="text-align:left">.ipa .apk文件路径</td><td style="text-align:left">比如/abs/path/to/my.apk或<a href="http://myapp.com/app.ipa" target="_blank" rel="noopener">http://myapp.com/app.ipa</a></td></tr><tr><td style="text-align:left">browserName</td><td style="text-align:left">启动手机浏览器</td><td style="text-align:left">iOS如:Safari，Android如:Chrome,Chromium,Browser</td></tr><tr><td style="text-align:left">newCommandTimeout</td><td style="text-align:left">设置命令超时时间，单位：秒。</td><td style="text-align:left">比如 60</td></tr><tr><td style="text-align:left">autoLaunch</td><td style="text-align:left">Appium是否需要自动安装和启动应用。默认值true</td><td style="text-align:left">true, false</td></tr><tr><td style="text-align:left">language</td><td style="text-align:left">(Sim/Emu-only) 设定模拟器 ( simulator / emulator ) 的语言。</td><td style="text-align:left">如： fr</td></tr><tr><td style="text-align:left">locale</td><td style="text-align:left">(Sim/Emu-only) 设定模拟器 ( simulator / emulator ) 的区域设置。</td><td style="text-align:left">如： fr_CA</td></tr><tr><td style="text-align:left">udid</td><td style="text-align:left">ios真机的唯一设备标识</td><td style="text-align:left">如： 1ae203187fc012g</td></tr><tr><td style="text-align:left">orientation</td><td style="text-align:left">设置横屏或竖屏</td><td style="text-align:left">LANDSCAPE (横向) 或 PORTRAIT (纵向)</td></tr><tr><td style="text-align:left">autoWebview</td><td style="text-align:left">直接转换到 WebView 上下文。 默认值 false、</td><td style="text-align:left">true, false</td></tr><tr><td style="text-align:left">noReset</td><td style="text-align:left">不要在会话前重置应用状态。默认值false。</td><td style="text-align:left">true, false</td></tr><tr><td style="text-align:left">fullReset</td><td style="text-align:left">(iOS) 删除整个模拟器目录。(Android)通过卸载默认值 false</td><td style="text-align:left">true, false</td></tr></tbody></table><h3 id="2-android特有"><a href="#2-android特有" class="headerlink" title="2.android特有"></a>2.android特有</h3><table><thead><tr><th style="text-align:left">关键字</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">appActivity</td><td style="text-align:left">启动app包,一般点开头</td><td style="text-align:left">如：.MainActivity, .Settings</td></tr><tr><td style="text-align:left">appPackage</td><td style="text-align:left">Android应用的包名</td><td style="text-align:left">比如com.example.android.myApp</td></tr><tr><td style="text-align:left">appWaitActivity</td><td style="text-align:left">等待启动的Activity名称</td><td style="text-align:left">SplashActivity</td></tr><tr><td style="text-align:left">deviceReadyTimeout</td><td style="text-align:left">设置超时时间</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left">androidCoverage</td><td style="text-align:left">用于执行测试的 instrumentation类</td><td style="text-align:left">com.my.Pkg/com.my.Pkg.instrumentation.MyInstrumentation</td></tr><tr><td style="text-align:left">enablePerformanceLogging</td><td style="text-align:left">(仅适用于 Chrome 和 webview) 开启 Chromedriver 的性能日志。(默认 false)</td><td style="text-align:left">true, false</td></tr><tr><td style="text-align:left">androidDeviceReadyTimeout</td><td style="text-align:left">等待设备在启动应用后超时时间，单位秒</td><td style="text-align:left">如 30</td></tr><tr><td style="text-align:left">androidDeviceSocket</td><td style="text-align:left">开发工具的 socket 名称。Chromedriver 把它作为开发者工具来进行连接。</td><td style="text-align:left">如 chrome_devtools_remote</td></tr><tr><td style="text-align:left">avd</td><td style="text-align:left">需要启动的 AVD (安卓模拟器设备) 名称。</td><td style="text-align:left">如 api19</td></tr><tr><td style="text-align:left">avdLaunchTimeout</td><td style="text-align:left">以毫秒为单位，等待 AVD 启动并连接到 ADB的超时时间。(默认值 120000)</td><td style="text-align:left">300000</td></tr><tr><td style="text-align:left">avdReadyTimeout</td><td style="text-align:left">以毫秒为单位，等待 AVD 完成启动动画的超时时间。(默认值 120000)</td><td style="text-align:left">300000</td></tr><tr><td style="text-align:left">avdArgs</td><td style="text-align:left">启动 AVD 时需要加入的额外的参数。</td><td style="text-align:left">如 -netfast</td></tr><tr><td style="text-align:left">useKeystore</td><td style="text-align:left">使用一个自定义的 keystore 来对 apk 进行重签名。默认值 false</td><td style="text-align:left">true or false</td></tr><tr><td style="text-align:left">keystorePath</td><td style="text-align:left">自定义keystore路径。默认~/.android/debug.keystore</td><td style="text-align:left">如 /path/to.keystore</td></tr><tr><td style="text-align:left">keystorePassword</td><td style="text-align:left">自定义 keystore 的密码。</td><td style="text-align:left">如 foo</td></tr><tr><td style="text-align:left">keyAlias</td><td style="text-align:left">key 的别名</td><td style="text-align:left">如 androiddebugkey</td></tr><tr><td style="text-align:left">keyPassword</td><td style="text-align:left">key 的密码</td><td style="text-align:left">如 foo</td></tr><tr><td style="text-align:left">chromedriverExecutable</td><td style="text-align:left">webdriver可执行文件的绝对路径 应该用它代替Appium 自带的 webdriver)</td><td style="text-align:left">/abs/path/to/webdriver</td></tr><tr><td style="text-align:left">autoWebviewTimeout</td><td style="text-align:left">毫秒为单位，Webview上下文激活的时间。默认2000</td><td style="text-align:left">如 4</td></tr><tr><td style="text-align:left">intentAction</td><td style="text-align:left">用于启动activity的intent action。(默认值 android.intent.action.MAIN)</td><td style="text-align:left">如 android.intent.action.MAIN, android.intent.action.VIEW</td></tr><tr><td style="text-align:left">intentCategory</td><td style="text-align:left">用于启动 activity 的 intent category。 (默认值 android.intent.category.LAUNCHER)</td><td style="text-align:left">如 android.intent.category.LAUNCHER, android.intent.category.APP_CONTACTS</td></tr><tr><td style="text-align:left">intentFlags</td><td style="text-align:left">用于启动activity的标识(flags) (默认值 0x10200000)</td><td style="text-align:left">如 0x10200000</td></tr><tr><td style="text-align:left">optionalIntentArguments</td><td style="text-align:left">用于启动 activity 的额外 intent 参数。请查看 Intent 参数</td><td style="text-align:left">如 –esn <extra_key>, –ez <extra_key> <extra_boolean_value></extra_boolean_value></extra_key></extra_key></td></tr><tr><td style="text-align:left">dontStopAppOnReset</td><td style="text-align:left">在使用 adb 启动应用时不要停止被测应用的进程。默认值： false</td><td style="text-align:left">true 或 false</td></tr><tr><td style="text-align:left">unicodeKeyboard</td><td style="text-align:left">使用 Unicode 输入法。默认值 false</td><td style="text-align:left">true 或 false</td></tr><tr><td style="text-align:left">resetKeyboard</td><td style="text-align:left">重置输入法到原有状态，默认值 false</td><td style="text-align:left">true 或 false</td></tr><tr><td style="text-align:left">noSign</td><td style="text-align:left">跳过检查和对应用进行 debug 签名的步骤。默认值 false</td><td style="text-align:left">true 或 false</td></tr><tr><td style="text-align:left">ignoreUnimportantViews</td><td style="text-align:left">调用 uiautomator 的函数这个关键字能加快测试执行的速度。默认值 false</td><td style="text-align:left">true 或 false</td></tr><tr><td style="text-align:left">disableAndroidWatchers</td><td style="text-align:left">关闭 android 监测应用无响ANR和崩溃crash的监视器默认值： false。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">chromeOptions</td><td style="text-align:left">允许传入 chrome driver 使用的 chromeOptions 参数。</td><td style="text-align:left">chromeOptions: {args: [‘–disable-popup-blocking‘]}</td></tr></tbody></table><h3 id="3-ios特有"><a href="#3-ios特有" class="headerlink" title="3.ios特有"></a>3.ios特有</h3><table><thead><tr><th style="text-align:left">关键字</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">calendarFormat</td><td style="text-align:left">(Sim-only) 为iOS的模拟器设置日历格式</td><td style="text-align:left">如 gregorian (公历)</td></tr><tr><td style="text-align:left">bundleId</td><td style="text-align:left">被测应用的bundle ID，真机上执行测试时，你可以不提供 app 关键字，但你必须提供udid</td><td style="text-align:left">如 io.appium.TestApp</td></tr><tr><td style="text-align:left">udid</td><td style="text-align:left">连接真机的唯一设备编号 ( Unique device identifier )</td><td style="text-align:left">如 1ae203187fc012g</td></tr><tr><td style="text-align:left">launchTimeout</td><td style="text-align:left">以毫秒为单位，在Appium运行失败之前设置一个等待 instruments的时间</td><td style="text-align:left">比如： 20000</td></tr><tr><td style="text-align:left">locationServicesEnabled</td><td style="text-align:left">(Sim-only) 强制打开或关闭定位服务。默认值是保持当前模拟器的设定</td><td style="text-align:left">true 或 false</td></tr><tr><td style="text-align:left">locationServicesAuthorized</td><td style="text-align:left">使用这个关键字时，你同时需要使用 bundleId 关键字来发送你的应用的 bundle ID。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">autoAcceptAlerts</td><td style="text-align:left">当 iOS 的个人信息访问警告 (如 位置、联系人、图片) 出现时，自动选择接受( Accept )。默认值 false。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">autoDismissAlerts</td><td style="text-align:left">当 iOS 的个人信息访问警告 (如 位置、联系人、图片) 出现时，自动选择不接受( Dismiss )。默认值 false。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">nativeInstrumentsLib</td><td style="text-align:left">使用原生 intruments 库 (即关闭 instruments-without-delay )</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">nativeWebTap</td><td style="text-align:left">(Sim-only) 在Safari中允许”真实的”，默认值： false。注意：取决于 viewport 大小/比例， 点击操作不一定能精确地点中对应的元素。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">safariInitialUrl</td><td style="text-align:left">(Sim-only) (&gt;= 8.1) Safari 的初始地址。默认值是一个本地的欢迎页面</td><td style="text-align:left">例如： <a href="https://www.github.com" target="_blank" rel="noopener">https://www.github.com</a></td></tr><tr><td style="text-align:left">safariAllowPopups</td><td style="text-align:left">(Sim-only) 允许 javascript 在 Safari 中创建新窗口。默认保持模拟器当前设置。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">safariIgnoreFraudWarning</td><td style="text-align:left">(Sim-only) 阻止 Safari 显示此网站可能存在风险的警告。默认保持浏览器当前设置。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">safariOpenLinksInBackground</td><td style="text-align:left">(Sim-only) Safari 是否允许链接在新窗口打开。默认保持浏览器当前设置。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">keepKeyChains</td><td style="text-align:left">(Sim-only) 当 Appium 会话开始/结束时是否保留存放密码存放记录 (keychains) (库(Library)/钥匙串(Keychains))</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">localizableStringsDir</td><td style="text-align:left">从哪里查找本地化字符串。默认值 en.lproj</td><td style="text-align:left">en.lproj</td></tr><tr><td style="text-align:left">processArguments</td><td style="text-align:left">通过 instruments 传递到 AUT 的参数</td><td style="text-align:left">如 -myflag</td></tr><tr><td style="text-align:left">interKeyDelay</td><td style="text-align:left">以毫秒为单位，按下每一个按键之间的延迟时间。</td><td style="text-align:left">如 100</td></tr><tr><td style="text-align:left">showIOSLog</td><td style="text-align:left">是否在 Appium 的日志中显示设备的日志。默认值 false</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">sendKeyStrategy</td><td style="text-align:left">输入文字到文字框的策略。模拟器默认值：oneByOne (一个接着一个) 。真实设备默认值：grouped (分组输入)</td><td style="text-align:left">oneByOne, grouped 或 setValue</td></tr><tr><td style="text-align:left">screenshotWaitTimeout</td><td style="text-align:left">以秒为单位，生成屏幕截图的最长等待时间。默认值： 10。</td><td style="text-align:left">如 5</td></tr><tr><td style="text-align:left">waitForAppScript</td><td style="text-align:left">用于判断 “应用是否被启动” 的 iOS 自动化脚本代码。默认情况下系统等待直到页面内容非空。结果必须是布尔类型。</td><td style="text-align:left">例如 true;, target.elements().length &gt; 0;, $.delay(5000); true;</td></tr></tbody></table><h3 id="4-小示例"><a href="#4-小示例" class="headerlink" title="4.小示例"></a>4.小示例</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from appium import webdriver</span><br><span class="line"></span><br><span class="line">desired_caps=&#123;&#125;</span><br><span class="line">desired_caps[&apos;platformName&apos;]=&apos;Android&apos;</span><br><span class="line">desired_caps[&apos;platformVersion&apos;]=&apos;5.1.1&apos;</span><br><span class="line">desired_caps[&apos;deviceName&apos;]=&apos;172.16.10.26:5555&apos;</span><br><span class="line">desired_caps[&apos;appPackage&apos;]=&apos;com.peng.cloudp.tv&apos;</span><br><span class="line">desired_caps[&apos;appActivity&apos;]=&apos;..activity.StartPageActivity&apos;</span><br><span class="line">desired_caps[&apos;unicodeKeyboard&apos;]=&apos;true&apos;</span><br><span class="line">desired_caps[&apos;resetKeyboard&apos;]=&apos;true&apos;</span><br><span class="line">driver = webdriver.Remote(&apos;http://127.0.0.1:4723/wd/hub&apos;, desired_caps)</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Appium Desired Capabilities 详解。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="appium" scheme="http://pythonfood.github.io/categories/appium/"/>
    
    
      <category term="appium" scheme="http://pythonfood.github.io/tags/appium/"/>
    
  </entry>
  
  <entry>
    <title>appium安装-windows</title>
    <link href="http://pythonfood.github.io/2018/02/01/appium%E5%AE%89%E8%A3%85-windows/"/>
    <id>http://pythonfood.github.io/2018/02/01/appium安装-windows/</id>
    <published>2018-02-01T01:00:00.000Z</published>
    <updated>2018-02-24T01:43:21.725Z</updated>
    
    <content type="html"><![CDATA[<p>appium环境搭建的简单步骤：安装jdk——安装android sdk——安装python——安装node.js——安装appium server——安装appium python客户端。<br><a id="more"></a></p><h3 id="1-安装jdk"><a href="#1-安装jdk" class="headerlink" title="1.安装jdk"></a>1.安装jdk</h3><blockquote><p>(1)下载jdk</p><blockquote><p>官网地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p></blockquote><p>(2)安装jdk</p><blockquote><p>根据提示安装，安装路径自定义：D:\Program Files\Java\jdk1.7.0_80</p></blockquote><p>(3)配置java环境变量</p><blockquote><p>1)系统变量→新建JAVA_HOME变量→变量值：D:\Program Files\Java\jdk1.7.0_80<br>2)系统变量→新建CLASSPATH变量→变量值：<code>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar</code><br>3)系统变量→编辑Path变量→增加：<code>;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</code>   </p></blockquote><p>(4)验证环境</p><blockquote><p>cmd输入<code>java -version</code>命令查看java版本。</p></blockquote></blockquote><h3 id="2-安装android-sdk"><a href="#2-安装android-sdk" class="headerlink" title="2.安装android sdk"></a>2.安装android sdk</h3><blockquote><p>(1)下载android sdk</p><blockquote><p>可以直接下载adt：<a href="http://tools.android-studio.org/index.php/adt-bundle-plugin" target="_blank" rel="noopener">http://tools.android-studio.org/index.php/adt-bundle-plugin</a></p></blockquote><p>(2)安装android sdk</p><blockquote><p>将adt压缩包解压到自定义路径：D:\Program Files\adt-bundle-windows-x86-20130917  </p></blockquote><p>(3)配置android环境变量</p><blockquote><p>1)系统变量→新建ANDROID_HOME变量→变量值：D:\Program Files\adt-bundle-windows-x86-20130917\sdk<br>2)系统变量→编辑Path变量→增加：<code>;%ANDROID_HOME%\tools;%ANDROID_HOME%\platform-tools;</code></p></blockquote><p>(4)验证环境</p><blockquote><p>cmd输入<code>adb</code>命令查看adb版本。</p></blockquote></blockquote><h3 id="3-安装Python"><a href="#3-安装Python" class="headerlink" title="3.安装Python"></a>3.<a href="https://pythonfood.github.io/2017/12/28/python安装-windows/#more">安装Python</a></h3><h3 id="4-安装node-js"><a href="#4-安装node-js" class="headerlink" title="4.安装node.js"></a>4.安装node.js</h3><blockquote><p>(1)下载node.js</p><blockquote><p>官网地址：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></p></blockquote><p>(2)安装node.js</p><blockquote><p>根据提示安装，安装路径自定义，自动添加PATH环境变量。</p></blockquote><p>(3)验证环境</p><blockquote><p>cmd输入<code>node -v</code>命令查看node版本。</p></blockquote></blockquote><h3 id="5-安装appium-server"><a href="#5-安装appium-server" class="headerlink" title="5.安装appium server"></a>5.安装appium server</h3><blockquote><p>方法1：npm安装</p><blockquote><p>(1)cmd输入<code>npm install -g appium</code>命令等待安装完成。（可能会被墙）<br>(2)cmd输入<code>npm install -g appium-doctor</code>命令安装Appium-doctor。<br>(3)cmd输入<code>appium-doctor</code>命令看到’All Checks were successful’则环境搭建成功。</p></blockquote><p>方法2：下载安装</p><blockquote><p>(1)下载地址：<a href="http://appium.io/" target="_blank" rel="noopener">http://appium.io/</a> 或 <a href="https://bitbucket.org/appium/appium.app/downloads/" target="_blank" rel="noopener">https://bitbucket.org/appium/appium.app/downloads/</a><br>(2)根据提示安装，安装路径自定义，自动添加PATH环境变量：<code>;D:\Program Files\Appium\node_modules\.bin;</code><br>(3)打开Appium图标验证安装成功。</p></blockquote><p>ps：appiun的server已经很久没有更新了，目前appium-desktop来继续他的使命。</p></blockquote><h3 id="6-安装appium-python客户端"><a href="#6-安装appium-python客户端" class="headerlink" title="6.安装appium python客户端"></a>6.安装appium python客户端</h3><blockquote><p>方法1：pip安装</p><blockquote><p>cmd输入<code>pip install Appium-Python-Client</code>命令等待安装完成。</p></blockquote><p>方法2：下载源码安装 </p><blockquote><p>(1)下载地址：<a href="https://pypi.python.org/pypi/Appium-Python-Client" target="_blank" rel="noopener">https://pypi.python.org/pypi/Appium-Python-Client</a><br>(2)解压后，cmd输入<code>cd Appium-Python-Client-X.X</code>命令进入目录。<br>(3)cmd输入<code>python setup.py install</code>命令进行安装。</p></blockquote></blockquote><h3 id="7-验证环境-小示例"><a href="#7-验证环境-小示例" class="headerlink" title="7.验证环境(小示例)"></a>7.验证环境(小示例)</h3><blockquote><p>(1)启动服务</p><blockquote><p>1)连接手机。<br>2)cmd输入<code>appium</code>命令启动服务。<br>3)打印日志如下图，则服务启动成功：</p><blockquote><p><img src="/2018/02/01/appium安装-windows/启动appium服务.png" alt="启动appium服务"></p></blockquote></blockquote><p>(2)代码示例</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from appium import webdriver</span><br><span class="line">from time import sleep</span><br><span class="line">import unittest</span><br><span class="line"></span><br><span class="line">class CalTest(unittest.TestCase):</span><br><span class="line">def setUp(self):</span><br><span class="line">desired_caps=&#123;&#125;</span><br><span class="line">desired_caps[&apos;platformName&apos;]=&apos;Android&apos;</span><br><span class="line">desired_caps[&apos;platformVersion&apos;]=&apos;5.0.2&apos;</span><br><span class="line">desired_caps[&apos;deviceName&apos;]=&apos;1ae7be68&apos;</span><br><span class="line">desired_caps[&apos;appPackage&apos;]=&apos;com.android.calculator2&apos;</span><br><span class="line">desired_caps[&apos;appActivity&apos;]=&apos;.Calculator&apos;</span><br><span class="line">self.driver=webdriver.Remote(&apos;http://localhost:4723/wd/hub&apos;,desired_caps)</span><br><span class="line"></span><br><span class="line">def tearDown(self):</span><br><span class="line">self.driver.quit()</span><br><span class="line"></span><br><span class="line">def test_add(self):</span><br><span class="line">driver.find_element_by_name(&quot;8&quot;).click()</span><br><span class="line">driver.find_element_by_id(&apos;digit7&apos;).click()</span><br><span class="line">driver.find_element_by_id(&apos;plus&apos;).click()</span><br><span class="line">driver.find_element_by_id(&apos;digit3&apos;).click()</span><br><span class="line">driver.find_element_by_id(&apos;equal&apos;).click()</span><br><span class="line">sleep(3)</span><br><span class="line">driver.find_element_by_id(&apos;clear&apos;).click()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">       suite = unittest.TestLoader().loadTestsFromTestCase(CalTest)</span><br><span class="line">       unittest.TextTestRunner(verbosity=2).run(suite)</span><br></pre></td></tr></table></figure></blockquote><p>(3)执行脚本    </p></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;appium环境搭建的简单步骤：安装jdk——安装android sdk——安装python——安装node.js——安装appium server——安装appium python客户端。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="appium" scheme="http://pythonfood.github.io/categories/appium/"/>
    
    
      <category term="appium" scheme="http://pythonfood.github.io/tags/appium/"/>
    
  </entry>
  
  <entry>
    <title>selenium常用API</title>
    <link href="http://pythonfood.github.io/2018/01/01/selenium%E5%B8%B8%E7%94%A8API/"/>
    <id>http://pythonfood.github.io/2018/01/01/selenium常用API/</id>
    <published>2018-01-01T02:00:00.000Z</published>
    <updated>2018-02-26T07:13:34.628Z</updated>
    
    <content type="html"><![CDATA[<p>selenium常用API笔记。<br><a id="more"></a></p><h3 id="1-浏览器操作"><a href="#1-浏览器操作" class="headerlink" title="1.浏览器操作"></a>1.浏览器操作</h3><p>(1)浏览器最大化</p><blockquote><p><code>driver.maximize_window()</code> #浏览器最大化</p></blockquote><p>(2)设置浏览器宽、高</p><blockquote><p><code>driver.set_window_size(480, 800)</code> #设置浏览器宽、高</p></blockquote><p>(3)浏览器后退</p><blockquote><p><code>driver.back()</code> #浏览器后退</p></blockquote><p>(4)浏览器前进</p><blockquote><p><code>driver.forward()</code> #浏览器前进</p></blockquote><p>(5)刷新当前页面</p><blockquote><p><code>driver.refresh()</code> #刷新当前页面</p></blockquote><p>(6)退出浏览器</p><blockquote><p><code>driver.quit()</code> #退出浏览器</p></blockquote><p>(7)关闭单个窗口</p><blockquote><p><code>driver.close()</code> #关闭单个窗口</p></blockquote><h3 id="2-元素定位"><a href="#2-元素定位" class="headerlink" title="2.元素定位"></a>2.元素定位</h3><p>(1)id定位 </p><blockquote><p><code>find_element_by_id(&quot;kw&quot;)</code> #一般唯一</p></blockquote><p>(2)name定位 </p><blockquote><p><code>find_element_by_name(&quot;wd&quot;)</code> #一般唯一</p></blockquote><p>(3)class_name定位 </p><blockquote><p><code>find_element_by_class_name(&quot;bg s_btn&quot;)</code> #不唯一</p></blockquote><p>(4)tag_name定位</p><blockquote><p><code>find_element_by_tag_name(&quot;input&quot;)</code> #不唯一</p></blockquote><p>(5)link_text定位</p><blockquote><p><code>find_element_by_link_text(u&quot;这是一条新闻&quot;)</code> #定位文本链接</p></blockquote><p>(6)partial_link_text定位</p><blockquote><p><code>find_element_by_partial_link_text(&quot;这是一条新&quot;)</code> #定位可以唯一标识这个文本链接的一部分</p></blockquote><p>(7)xpath定位</p><blockquote><p>1)绝对路径定位</p><blockquote><p><code>find_element_by_xpath(&quot;/html/body/div[2]/form/span/input&quot;)</code> #从根节点开始绝对路径</p></blockquote><p>2)相对路径定位</p><blockquote><p><code>find_element_by_xpath(&quot;//input[@id=’input’]&quot;)</code> #通过自身的id 属性定位<br><code>find_element_by_xpath(&quot;//span[@id=’input-container’]/input&quot;)</code> #通过上一级目录的id 属性定位<br><code>find_element_by_xpath(&quot;//div[@name=’q’]/form/span[2]/input&quot;)</code> #通过上三级目录的name 属性定位<br><code>find_element_by_xpath(&quot;//div[@id=’hd’ or @name=’q’]/form/span/input&quot;)</code> #通过布尔逻辑运算 属性定位</p></blockquote></blockquote><p>(8)css_selector定位</p><blockquote><p><code>find_element_by_css_selector(&quot;#su&quot;)</code> #通过id属性定位<br><code>find_element_by_css_selector(&quot;.s_ipt&quot;)</code> #通过class属性定位<br><code>find_element_by_css_selector(&quot;input&quot;)</code> #通过标签名定位<br><code>find_element_by_css_selector(&quot;span&gt;input&quot;)</code> #通过父子关系定位<br><code>find_element_by_css_selector(&quot;input[maxlength=&#39;100&#39;]&quot;)</code> #通过属性定位<br><code>find_element_by_css_selector(&quot;span.bgs_ipt_wr&gt;input.s_ipt&quot;)</code> #组合定位</p><blockquote><p><img src="/2018/01/01/selenium常用API/css_selector定位.png" alt="css_selector定位"></p></blockquote></blockquote><p>(9)用By定位<br>需要使用定位方法时，By可以设置定位策略。使用前导入By模块<code>from selenium.webdriver.common.by import By</code>。</p><blockquote><p><code>find_element(By.ID,&quot;kw&quot;)</code><br><code>find_element(By.NAME,&quot;wd&quot;)</code><br><code>find_element(By.CLASS_NAME,&quot;s_ipt&quot;)</code><br><code>find_element(By.TAG_NAME,&quot;input&quot;)</code><br><code>find_element(By.LINK_TEXT,u&quot;新闻&quot;)</code><br><code>find_element(By.PARTIAL_LINK_TEXT,u&quot;新&quot;)</code><br><code>find_element(By.XPATH,&quot;//*[@class=&#39;bgs_btn&#39;]&quot;)</code><br><code>find_element(By.CSS_SELECTOR,&quot;span.bgs_btn_wr&gt;input#su&quot;)</code></p></blockquote><h3 id="3-元素操作"><a href="#3-元素操作" class="headerlink" title="3.元素操作"></a>3.元素操作</h3><p>(1)clear()  #清除输入框内容</p><blockquote><p><code>driver.find_element_by_id(&quot;user_name&quot;).clear()</code></p></blockquote><p>(2)send_keys(“xx”) #输入框里输入xx内容</p><blockquote><p><code>driver.find_element_by_id(&quot;user_name&quot;).send_keys(&quot;username&quot;)</code></p></blockquote><p>(3)click() #单击一个按钮、连接等</p><blockquote><p><code>driver.find_element_by_id(&quot;dl_an_submit&quot;).click()</code></p></blockquote><p>(4)submit() #提交表单</p><blockquote><p><code>driver.find_element_by_id(&quot;dl_an_submit&quot;).submit()</code></p></blockquote><p>(5)size #返回元素的尺寸</p><blockquote><p><code>size=driver.find_element_by_id(&quot;kw&quot;).size</code> #返回百度输入框的宽高</p></blockquote><p>(6)text #获取元素的文本</p><blockquote><p><code>text=driver.find_element_by_id(&quot;cp&quot;).text</code> #返回百度页面底部备案信息</p></blockquote><p>(7)get_attribute(name) #获得属性值</p><blockquote><p><code>attribute=driver.find_element_by_id(&quot;kw&quot;).get_attribute(&#39;type&#39;)</code> #返回元素的属性值，可以是id、name、type 或元素拥有的其它任意属性</p></blockquote><p>(8)is_displayed() #检查该元素是否用户可见    </p><blockquote><p><code>result=driver.find_element_by_id(&quot;kw&quot;).is_displayed()</code> #返回元素的结果是否可见，返回结果为True 或False</p></blockquote><h3 id="4-鼠标事件"><a href="#4-鼠标事件" class="headerlink" title="4.鼠标事件"></a>4.鼠标事件</h3><p>ActionChains用于生成用户的行为，所有的行为都存储在actionchains对象中。通过perform()执行存储的行为。<br>使用前导入ActionChains模块<code>from selenium.webdriver.common.action_chains import ActionChains</code>。</p><p>(1)perform() #顺序执行所有ActionChains中存储的行为</p><blockquote><p><code>ActionChains(driver).context_click(操作对象).perform()</code> #ActionChains方法的书写格式</p></blockquote><p>(2)context_click() #右击 </p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">right =driver.find_element_by_xpath(&quot;xx&quot;) #定位到要右击的元素</span><br><span class="line">ActionChains(driver).context_click(right).perform() #对定位到的元素执行鼠标右键操作</span><br></pre></td></tr></table></figure></blockquote><p>(3)double_click() #双击</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double =driver.find_element_by_xpath(&quot;xxx&quot;) #定位到要双击的元素</span><br><span class="line">ActionChains(driver).double_click(double).perform() #对定位到的元素执行鼠标双击操作</span><br></pre></td></tr></table></figure></blockquote><p>(4)drag_and_drop() #鼠标拖放</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element = driver.find_element_by_name(&quot;xxx&quot;) #定位元素的原位置</span><br><span class="line">target = driver.find_element_by_name(&quot;xxx&quot;) #定位元素要移动到的目标位置</span><br><span class="line">ActionChains(driver).drag_and_drop(element, target).perform() #执行元素的移动操作</span><br></pre></td></tr></table></figure></blockquote><p>(5)move_to_element() #鼠标悬停</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">above = driver.find_element_by_xpath(&quot;xxx&quot;) #定位到鼠标移动到上面的元素</span><br><span class="line">ActionChains(driver).move_to_element(above).perform() #对定位到的元素执行鼠标移动到上面的操作</span><br></pre></td></tr></table></figure></blockquote><p>(6)click_and_hold() #按下鼠标左键    </p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">left=driver.find_element_by_xpath(&quot;xxx&quot;) #定位到鼠标按下左键的元素</span><br><span class="line">ActionChains(driver).click_and_hold(left).perform() #对定位到的元素执行鼠标左键按下的操作</span><br></pre></td></tr></table></figure></blockquote><h3 id="5-键盘事件"><a href="#5-键盘事件" class="headerlink" title="5.键盘事件"></a>5.键盘事件</h3><p>使用前导入keys模块<code>from selenium.webdriver.common.keys import Keys</code>。</p><p>(1)send_keys(Keys.BACK_SPACE) #删除键（BackSpace）</p><p>(2)send_keys(Keys.SPACE) #空格键(Space)</p><p>(3)send_keys(Keys.TAB) #制表键(Tab)</p><p>(4)send_keys(Keys.ESCAPE) #回退键（Esc）</p><p>(5)send_keys(Keys.ENTER) #回车键（Enter）</p><p>(6)send_keys(Keys.F5) #刷新建（F5）</p><p>(7)send_keys(Keys.CONTROL,’a’) #全选（Ctrl+A）</p><p>(8)send_keys(Keys.CONTROL,’c’) #复制（Ctrl+C）</p><p>(9)send_keys(Keys.CONTROL,’x’) #剪切（Ctrl+X）</p><p>(10)send_keys(Keys.CONTROL,’v’) #粘贴（Ctrl+V）</p><h3 id="6-获取验证信息"><a href="#6-获取验证信息" class="headerlink" title="6.获取验证信息"></a>6.获取验证信息</h3><p>(1)获得当前页面title，判断页面跳转是否符合预期</p><blockquote><p><code>title = driver.title</code></p></blockquote><p>(2)获得当前URL，一般用来测试重定向</p><blockquote><p><code>url = driver.current_url</code></p></blockquote><h3 id="7-设置等待时间"><a href="#7-设置等待时间" class="headerlink" title="7.设置等待时间"></a>7.设置等待时间</h3><p>(1)sleep() #休眠等待<br>sleep()方法以秒为单位，假如休眠时间小于 1 秒，可以用小数表示。<br>使用前导入sleep模块<code>from time import sleep</code>。</p><blockquote><p><code>sleep(0.5)</code></p></blockquote><p>(2)implicitly_wait() #隐式等待<br>隐式等待是通过一定的时长等待页面所元素加载完成。<br>如果超出了设置的时长元素还没有被加载测抛NoSuchElementException异常。<br>implicitly_wait()默认参数的单位为秒。</p><blockquote><p><code>driver.implicitly_wait(10)</code> #设置智能等待10秒</p></blockquote><p>(3)WebDriverWait() #显式等待<br>显式等待是等待某个条件成立时继续执行，否则在达到最大时长则抛TimeoutException异常。</p><p>WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None)，参数解释如下：</p><ul><li>driver - WebDriver 的驱动程序(Ie, Firefox, Chrome 或远程)</li><li>timeout - 最长超时时间，默认以秒为单位</li><li>poll_frequency - 休眠时间的间隔（步长）时间，默认为 0.5 秒</li><li>ignored_exceptions - 超时后的异常信息，默认情况下抛 NoSuchElementException 异常。</li></ul><p>使用前导入WebDriverWait模块<code>from selenium.webdriver.support.ui import WebDriverWait</code>。</p><p>WebDriverWai()一般由 unit()或 until_not()方法配合使用，下面是 unit()和 until_not()方法的说明：<br>1)until(method, message=’’)调用该方法提供的驱动程序作为一个参数，直到返回值不为False。</p><blockquote><p><code>element = WebDriverWait(driver, 10).until(lambda x: x.find_element_by_id(“someId”))</code></p></blockquote><p>2)until_not(method, message=’’)调用该方法提供的驱动程序作为一个参数，直到返回值为 False。</p><blockquote><p><code>is_disappeared = WebDriverWait(driver, 30, 1, (ElementNotVisibleException)).until_not(lambda x: x.find_element_by_id(“someId”).is_displayed())</code>    </p></blockquote><h3 id="8-定位一组对象"><a href="#8-定位一组对象" class="headerlink" title="8.定位一组对象"></a>8.定位一组对象</h3><p>(1)find_elements 用于获取一组元素:</p><blockquote><p><code>find_elements_by_id(‘xx’)</code><br><code>find_elements_by_name(‘xx’)</code><br><code>find_elements_by_class_name(‘xx’)</code><br><code>find_elements_by_tag_name(‘xx’)</code><br><code>find_elements_by_link_text(‘xx’)</code><br><code>find_elements_by_partial_link_text(‘xx’)</code><br><code>find_elements_by_xpath(‘xx’)</code><br><code>find_elements_by_css_selector(‘xx’)</code></p></blockquote><p>(2)可以使用for… in …对这一组元素进行遍历:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for checkbox in checkboxes:</span><br><span class="line">checkbox.click()</span><br></pre></td></tr></table></figure></blockquote><p>(3)也可以使用pop（）方法获得这一组元素中的第几个，然后再对该元素进行操作：</p><blockquote><p><code>find_elements_by_id(‘xx’).pop().click()</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pop（）或pop（-1）#默认获取一组元素中的最后一个</span><br><span class="line">pop(0)   #默认获取一组元素的第一个元素</span><br><span class="line">pop(1)   #默认获取一组元素的第二个元素</span><br><span class="line">...... #以此类推</span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="9-层级定位"><a href="#9-层级定位" class="headerlink" title="9.层级定位"></a>9.层级定位</h3><p>经常会有这样的需求：页面上有很多个属性基本相同的元素 ，现在需要具体定位到其中的一个。由于属性基本相当，所以在定位的时候会有些麻烦，这时候就需要用到层级定位。先定位父元素，然后再通过父元素定位子孙元素：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#点击 Link1 链接（弹出下拉列表）</span><br><span class="line">driver.find_element_by_link_text(&apos;Link1&apos;).click() </span><br><span class="line">#在父亲元件下找到 link 为 Action 的子元素</span><br><span class="line">menu=driver.find_element_by_id(&apos;dropdown1&apos;).find_element_by_link_text(&apos;Another action&apos;)</span><br></pre></td></tr></table></figure></blockquote><h3 id="10-表单切换"><a href="#10-表单切换" class="headerlink" title="10.表单切换"></a>10.表单切换</h3><p>在web应用中经常会出现frame/iframe 表单内嵌套的应用，WebDriver只能在一个页面上进行元素识别定位，对于frame/iframe表单内嵌页面上的元素无法直接定位。这时需要通过switch_to.frame()方法将当前定位的主体切换为frame/iframe表单的内嵌页面中。</p><p>(1)switch_to_frame()默认可以直接取表单的id或name属性进行切换：</p><blockquote><p><code>driver.switch_to_frame(&quot;if&quot;)</code> #id = “if”<br><code>driver.switch_to_frame(&quot;nf&quot;)</code> #name = “nf” </p></blockquote><p>(2)如果 iframe 没有可用的 id 和 name 可以通过下面的方式进行定位：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#先通过xpth定位到iframe </span><br><span class="line">xf = driver.find_element_by_xpath(&apos;//*[@class=&quot;if&quot;]&apos;)</span><br><span class="line">#再将定位对象传给switch_to_frame()方法 </span><br><span class="line">driver.switch_to_frame(xf)</span><br></pre></td></tr></table></figure></blockquote><p>(3)如果完成了在当前表单上的操作，跳出当前表单：</p><blockquote><p><code>driver.switch_to.parent_content()</code> #返回到父级表单<br><code>driver.switch_to.default_conent()</code> #返回到主文档页面</p></blockquote><h3 id="11-多窗口切换"><a href="#11-多窗口切换" class="headerlink" title="11.多窗口切换"></a>11.多窗口切换</h3><ul><li><code>current_window_handle</code> #获得当前窗口句柄。</li><li><code>window_handles</code> #返回所有窗口的句柄到当前对话。</li><li><code>switch_to.window</code>(窗口句柄) #切换到对应的窗口。</li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nowhandle=driver.current_window_handle #获得当前窗口句柄。</span><br><span class="line">driver.find_element_by_link_text(u&quot;发表话题&quot;).click()</span><br><span class="line">time.sleep(3)</span><br><span class="line">allhandles=driver.window_handles #返回所有窗口的句柄到当前对话。</span><br><span class="line">for handle in allhandles:</span><br><span class="line">if(handle!=nowhandle):</span><br><span class="line">driver.switch_to.window(handle) #切换到对应的窗口。</span><br></pre></td></tr></table></figure></blockquote><h3 id="12-警告框处理"><a href="#12-警告框处理" class="headerlink" title="12.警告框处理"></a>12.警告框处理</h3><p>处理javascript所生成的alert、confirm、prompt，可以使用switch_to_alert()方法定位到alert/confirm/prompt，然后使用text/accept/dismiss/send_keys等方法进行操作：</p><ul><li><code>text</code> #返回 alert/confirm/prompt 中的文字信息。</li><li><code>accept</code> #点击确认按钮。</li><li><code>dismiss</code> #点击取消按钮，如果有的话。</li><li><code>send_keys</code> #输入值，这个 alert\confirm 没有对话框就不能用了，不然会报错。</li></ul><blockquote><p><code>driver.switch_to_alert().accept()</code></p></blockquote><h3 id="13-上传文件"><a href="#13-上传文件" class="headerlink" title="13.上传文件"></a>13.上传文件</h3><p>(1)查找到input标签，通过send_keys)传入本地文件路径从而模拟上传功能:</p><blockquote><p><code>driver.find_element_by_name(&quot;file&quot;).send_keys(&#39;D:\\upload_file.txt&#39;)</code> #查找到input标签，然后send进去</p></blockquote><p>(2)使用AutoIt识别flash控件和windows控件实现自动上传文件</p><blockquote><p>1)下载安装，官方网站：<a href="https://www.autoitscript.com/site/" target="_blank" rel="noopener">https://www.autoitscript.com/site/</a><br>2)配置编辑AutoIt。<br>3)<code>os.system(&quot;D:\\upfile.exe&quot;)</code> #通过系统调用upfile.exe上传程序 </p></blockquote><h3 id="14-下载文件"><a href="#14-下载文件" class="headerlink" title="14.下载文件"></a>14.下载文件</h3><p>(1)以FireFox为例，为了让FireFox浏览器能实现文件的载，我们需要通过FirefoxProfile()对其参数做一个设置:</p><ul><li><code>browser.download.folderList</code> #设置成0代表下载到浏览器默认下载路径；设置成2则可以保存到指定目录。</li><li><code>browser.download.manager.showWhenStarting</code> #是否显示开始，Ture为显示，Flase为不显示。</li><li><code>browser.download.dir</code> #用于指定你所下载文件的目录。os.getcwd()该函数不需要传递参数，用于返回当前的目录。</li><li><code>browser.helperApps.neverAsk.saveToDisk</code> #指定要下载页面的Content-type值，“application/octet-stream”为文件的类型。HTTP Content-type常用对照表：<a href="http://tool.oschina.net/commons" target="_blank" rel="noopener">http://tool.oschina.net/commons</a></li></ul><p>(2)这些参数的设置可以通过在Firefox浏览器地址栏输入：about:config 进行设置，如图： </p><p><img src="/2018/01/01/selenium常用API/firefox参数设置.png" alt="firefox参数设置"></p><p>(3)浏览器设置代码示例：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8 </span><br><span class="line">from selenium import webdriver </span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">fp = webdriver.FirefoxProfile()</span><br><span class="line">fp.set_preference(&quot;browser.download.folderList&quot;,2) </span><br><span class="line">fp.set_preference(&quot;browser.download.manager.showWhenStarting&quot;,False) </span><br><span class="line">fp.set_preference(&quot;browser.download.dir&quot;, os.getcwd()) </span><br><span class="line">fp.set_preference(&quot;browser.helperApps.neverAsk.saveToDisk&quot;, &quot;application/octet-stream&quot;)</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox(firefox_profile=fp) </span><br><span class="line">driver.get(&quot;http://pypi.Python.org/pypi/selenium&quot;) </span><br><span class="line">driver.find_element_by_partial_link_text(&quot;selenium-2&quot;).click()</span><br></pre></td></tr></table></figure></blockquote><h3 id="15-操作Cookie"><a href="#15-操作Cookie" class="headerlink" title="15.操作Cookie"></a>15.操作Cookie</h3><p>webdriver操作cookie的方法有：</p><ul><li><code>get_cookies()</code> #获得所有cookie信息  </li><li><code>get_cookie(name)</code> #返回有特定name值有cookie信息  </li><li><code>add_cookie(cookie_dict)</code> #添加cookie，必须有name和value值  </li><li><code>delete_cookie(name)</code> #删除特定(部分)的cookie信息  </li><li><code>delete_all_cookies()</code> #删除所有cookie信息</li></ul><p>(1)先通过get_cookies()来获取当前浏览器的cookie信息。<br>通过打印结果可以看出，cookie 是以字典的形式进行存放的，知道了cookie的存放形式，那么我们就可以按照这种形式向浏览器中写入cookie信息。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver.get(&quot;http://www.youdao.com&quot;)</span><br><span class="line">cookie= driver.get_cookies() # 获得cookie信息 </span><br><span class="line">print cookie #将获得cookie的信息打印</span><br></pre></td></tr></table></figure><blockquote><p><img src="/2018/01/01/selenium常用API/cookie打印信息.png" alt="cookie打印信息"></p></blockquote></blockquote><p>(2)再进行cookie的添加、删除等操作。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver.get(&quot;http://www.youdao.com&quot;)</span><br><span class="line">driver.add_cookie(&#123;&apos;name&apos;:&apos;key-aaaaaaa&apos;, &apos;value&apos;:&apos;value-bbbbbb&apos;&#125;) #向cookie的name 和value添加会话信息。</span><br></pre></td></tr></table></figure></blockquote><h3 id="16-调用javascript"><a href="#16-调用javascript" class="headerlink" title="16.调用javascript"></a>16.调用javascript</h3><p>当webdriver遇到没法完成的操作时，可以考虑调用JavaScript来完成。<br>webdriver提供<code>execute_script()</code>方法用来调用js代码：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#修改元素的属性</span><br><span class="line">js = &apos;document.querySelectorAll(&quot;select&quot;)[0].style.display=&quot;block&quot;;&apos;</span><br><span class="line">driver.execute_script(js)</span><br></pre></td></tr></table></figure></blockquote><h3 id="17-控制浏览器滚动条"><a href="#17-控制浏览器滚动条" class="headerlink" title="17.控制浏览器滚动条"></a>17.控制浏览器滚动条</h3><p>(1)上下滚动：<br><code>document.body.scrollTop</code> #网页被卷去的高。置顶设置：scrollTop为0；置底设置：scrollTop大于窗口的高度像素。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#将页面滚动条拖到底部</span><br><span class="line">js=&quot;var q=document.documentElement.scrollTop=10000&quot;</span><br><span class="line">driver.execute_script(js)</span><br><span class="line">time.sleep(3)</span><br><span class="line">#将滚动条移动到页面的顶部</span><br><span class="line">js1=&quot;var q=document.documentElement.scrollTop=0&quot;</span><br><span class="line">driver.execute_script(js1)</span><br><span class="line">time.sleep(3)</span><br></pre></td></tr></table></figure></blockquote><p>(2)左右滚动：<br><code>window.scrollTo(左边距,上边距)</code> #指定左右滚动的坐标即可</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">js=&quot; window.scrollTo(200,1000);&quot; </span><br><span class="line">driver.execute_script(js)</span><br></pre></td></tr></table></figure></blockquote><h3 id="18-窗口截图"><a href="#18-窗口截图" class="headerlink" title="18.窗口截图"></a>18.窗口截图</h3><p>Webdriver提供了截图函数<code>get_screenshot_as_file()</code>来截取当前窗口:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">driver.find_element_by_id(&apos;kw_error&apos;).send_key(&apos;selenium&apos;) </span><br><span class="line">driver.find_element_by_id(&apos;su&apos;).click() </span><br><span class="line">except: </span><br><span class="line">driver.get_screenshot_as_file(&quot;D:\\baidu_error.jpg&quot;) #截图，保存到指定路径</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure></blockquote><h3 id="19-获取对象的属性值"><a href="#19-获取对象的属性值" class="headerlink" title="19.获取对象的属性值"></a>19.获取对象的属性值</h3><p>有时候我们定位页面上的元素发现常用的id、name等属性是相同的。这个时候我们只能通过常规的定位方法定位出一组元素，然后观察通过元素的属性可以定位出单个元素。<br>可使用.get_attribute()方法:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 选择页面上所有的tag name为input的元素</span><br><span class="line">inputs = driver.find_elements_by_tag_name(&apos;input&apos;)</span><br><span class="line">#然后循环遍历出属性data-node值为594434493的元素，单击勾选</span><br><span class="line">for input in inputs:</span><br><span class="line">if input.get_attribute(&apos;data-node&apos;) == &apos;594434493&apos;:</span><br><span class="line">input.click()</span><br></pre></td></tr></table></figure></blockquote><h3 id="20-验证码处理"><a href="#20-验证码处理" class="headerlink" title="20.验证码处理"></a>20.验证码处理</h3><p>(1)去掉验证码。<br>(2)设置万能码。<br>(3)验证码识别技术<br>例如可以通过Python-tesseract来识别图片验证码,能够读取任何常规的图片文件(JPG,GIF,PNG,TIFF 等)。不过，目前市面上的验证码识别技术识别率都不是100% 。<br>(4)记录cookie<br>通过向浏览器中添加cookie可以绕过登录的验证码,这种方式最大的问题是如何从浏览器的Cookie中找到用户名和密码对应的key值，并传传输入对应的登录信息。如果网站登录时根本不将用户名和密码写Cookie，这会存在一定的安全风险。那么这种方式就不起作用了。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#访问xx网站 </span><br><span class="line">driver.get(&quot;http://www.xx.cn&quot;)</span><br><span class="line">#将用户名密码写入浏览器cookie </span><br><span class="line">driver.add_cookie(&#123;&apos;name&apos;:&apos;Login_UserNumber&apos;, &apos;value&apos;:&apos;username&apos;&#125;) </span><br><span class="line">driver.add_cookie(&#123;&apos;name&apos;:&apos;Login_Passwd&apos;, &apos;value&apos;:&apos;password&apos;&#125;)</span><br><span class="line">#再次访问xx网站，将会自动登录 </span><br><span class="line">driver.get(&quot;http://www.xx.cn/&quot;) </span><br><span class="line">time.sleep(3)</span><br></pre></td></tr></table></figure></blockquote><p>(5)内部提供一个接口获得验证码，然后通过js代码把获取的验证码填写进去：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#自动获取验证码并填写</span><br><span class="line">js=&quot;$.getJSON(&apos;http://xxx.xxx.com/util/getCode.jsonp?callback=?&apos;,function(data)&#123;$(&apos;.imgcode&apos;).val(data.code);&#125;)&quot;</span><br><span class="line">driver.execute_script(js)</span><br></pre></td></tr></table></figure></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;selenium常用API笔记。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="selenium" scheme="http://pythonfood.github.io/categories/selenium/"/>
    
    
      <category term="selenium" scheme="http://pythonfood.github.io/tags/selenium/"/>
    
  </entry>
  
  <entry>
    <title>selenium安装-windows</title>
    <link href="http://pythonfood.github.io/2018/01/01/selenium%E5%AE%89%E8%A3%85-windows/"/>
    <id>http://pythonfood.github.io/2018/01/01/selenium安装-windows/</id>
    <published>2018-01-01T01:00:00.000Z</published>
    <updated>2018-02-23T10:18:00.724Z</updated>
    
    <content type="html"><![CDATA[<p>selenium环境搭建的简单步骤：安装Python——安装pip——安装selenium——安装浏览器驱动。<br><a id="more"></a></p><h3 id="1-安装Python"><a href="#1-安装Python" class="headerlink" title="1.安装Python"></a>1.<a href="https://pythonfood.github.io/2017/12/28/python安装-windows/#more">安装Python</a></h3><h3 id="2-安装pip"><a href="#2-安装pip" class="headerlink" title="2.安装pip"></a>2.安装pip</h3><blockquote><p>方法1：自动安装</p><blockquote><p>在第1步安装python时，已经安装了pip。</p></blockquote><p>方法2：手动安装</p><blockquote><p>(1)下载pip压缩包：<a href="https://pypi.python.org/pypi/pip#downloads" target="_blank" rel="noopener">https://pypi.python.org/pypi/pip#downloads</a><br>(2)解压后cmd进入解压目录，执行<code>python setup.py install</code>进行安装。</p></blockquote></blockquote><h3 id="3-安装selenium"><a href="#3-安装selenium" class="headerlink" title="3.安装selenium"></a>3.安装selenium</h3><blockquote><p>方法1：命令行安装</p><blockquote><p>进入cmd输入命令’pip install selenium’。</p></blockquote><p>方法2：下载whl包安装</p><blockquote><p>(1)下载selenium安装包：<a href="https://pypi.python.org/pypi/selenium" target="_blank" rel="noopener">https://pypi.python.org/pypi/selenium</a> 或 <a href="https://www.seleniumhq.org/download/" target="_blank" rel="noopener">https://www.seleniumhq.org/download/</a><br>(2)下载完成后，进入cmd输入命令<code>pip install</code>，再直接将文件拖入cmd窗口，回车即可安装。</p></blockquote></blockquote><h3 id="4-安装浏览器驱动"><a href="#4-安装浏览器驱动" class="headerlink" title="4.安装浏览器驱动"></a>4.安装浏览器驱动</h3><blockquote><p>(1)下载浏览器驱动</p><blockquote><p>不同浏览器需下载不同驱动，不同版本浏览器对应不同版本驱动。这里只给出chrome和firefox的驱动下载地址：<br>1)chrome：<a href="http://npm.taobao.org/mirrors/chromedriver" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver</a> 或 <a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/index.html</a><br>2)firefox：<a href="https://github.com/mozilla/geckodriver/releases" target="_blank" rel="noopener">https://github.com/mozilla/geckodriver/releases</a></p></blockquote><p>(2)安装浏览器驱动</p><blockquote><p>下载完驱动后解压，将驱动放置在可执行路径下。这里给出三种路径：<br>1)将浏览器驱动放到python的Path路径下。<br>2)将浏览器驱动放到浏览器的Path路径下。<br>3)自定义路径，新建driver文件夹，将驱动放在driver文件下，最后将该路径添加到环境变量中。</p></blockquote></blockquote><h3 id="5-验证环境（小示例）"><a href="#5-验证环境（小示例）" class="headerlink" title="5.验证环境（小示例）"></a>5.验证环境（小示例）</h3><blockquote><p>(1)创建python文件selenium_python.py，内容如下：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(&apos;http://www.baidu.com/&apos;)</span><br></pre></td></tr></table></figure></blockquote><p>(2)cmd执行命令<code>python selenium_python.py</code>。<br>(3)脚本自动执行，结果如下：</p><blockquote><p><img src="/2018/01/01/selenium安装-windows/脚本执行结果.png" alt="脚本执行结果"></p></blockquote></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;selenium环境搭建的简单步骤：安装Python——安装pip——安装selenium——安装浏览器驱动。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="selenium" scheme="http://pythonfood.github.io/categories/selenium/"/>
    
    
      <category term="selenium" scheme="http://pythonfood.github.io/tags/selenium/"/>
    
  </entry>
  
  <entry>
    <title>python内置函数</title>
    <link href="http://pythonfood.github.io/2017/12/28/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"/>
    <id>http://pythonfood.github.io/2017/12/28/python内置函数/</id>
    <published>2017-12-28T13:20:00.000Z</published>
    <updated>2018-03-25T11:48:49.765Z</updated>
    
    <content type="html"><![CDATA[<p>人生苦短，我用python。<br><a id="more"></a></p><h2 id="python内置函数"><a href="#python内置函数" class="headerlink" title="python内置函数"></a><a href="https://docs.python.org/3/library/functions.html#next" target="_blank" rel="noopener">python内置函数</a></h2><table><thead><tr><th style="text-align:left"></th><th style="text-align:left"></th><th style="text-align:left">Built-in Functions</th><th style="text-align:left"></th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">abs()</td><td style="text-align:left">dict()</td><td style="text-align:left">help()</td><td style="text-align:left">min()</td><td style="text-align:left">setattr()</td></tr><tr><td style="text-align:left">all()</td><td style="text-align:left">dir()</td><td style="text-align:left">hex()</td><td style="text-align:left">next()</td><td style="text-align:left">slice()</td></tr><tr><td style="text-align:left">any()</td><td style="text-align:left">divmod()</td><td style="text-align:left">id()</td><td style="text-align:left">object()</td><td style="text-align:left">sorted()</td></tr><tr><td style="text-align:left">ascii()</td><td style="text-align:left">enumerate()</td><td style="text-align:left">input()</td><td style="text-align:left">oct()</td><td style="text-align:left">staticmethod()</td></tr><tr><td style="text-align:left">bin()</td><td style="text-align:left">eval()</td><td style="text-align:left">int()</td><td style="text-align:left">open()</td><td style="text-align:left">str()</td></tr><tr><td style="text-align:left">bool()</td><td style="text-align:left">exec()</td><td style="text-align:left">isinstance()</td><td style="text-align:left">ord()</td><td style="text-align:left">sum()</td></tr><tr><td style="text-align:left">bytearray()</td><td style="text-align:left">filter()</td><td style="text-align:left">issubclass()</td><td style="text-align:left">pow()</td><td style="text-align:left">super()</td></tr><tr><td style="text-align:left">bytes()</td><td style="text-align:left">float()</td><td style="text-align:left">iter()</td><td style="text-align:left">print()</td><td style="text-align:left">tuple()</td></tr><tr><td style="text-align:left">callable()</td><td style="text-align:left">format()</td><td style="text-align:left">len()</td><td style="text-align:left">property()</td><td style="text-align:left">type()</td></tr><tr><td style="text-align:left">chr()</td><td style="text-align:left">frozenset()</td><td style="text-align:left">list()</td><td style="text-align:left">range()</td><td style="text-align:left">vars()</td></tr><tr><td style="text-align:left">classmethod()</td><td style="text-align:left">getattr()</td><td style="text-align:left">locals()</td><td style="text-align:left">repr()</td><td style="text-align:left">zip()</td></tr><tr><td style="text-align:left">compile()</td><td style="text-align:left">globals()</td><td style="text-align:left">map()</td><td style="text-align:left">reversed()</td><td style="text-align:left">__import__()</td></tr><tr><td style="text-align:left">complex()</td><td style="text-align:left">hasattr()</td><td style="text-align:left">max()</td><td style="text-align:left">round()</td></tr><tr><td style="text-align:left">delattr()</td><td style="text-align:left">hash()</td><td style="text-align:left">memoryview()</td><td style="text-align:left">set()</td></tr></tbody></table><ol><li><p><code>abs()</code>获取绝对值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; abs(-10)</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; abs(10)</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; abs(0)</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; a = -10</span><br><span class="line">&gt;&gt;&gt; a.__abs__()</span><br><span class="line">10</span><br></pre></td></tr></table></figure></li><li><p><code>all()</code>接受一个迭代器，如果迭代器的所有元素都为真，那么返回True，否则返回False</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tmp_1 = [&apos;python&apos;,123]</span><br><span class="line">&gt;&gt;&gt; all(tmp_1)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; tmp_2 = []</span><br><span class="line">&gt;&gt;&gt; all(tmp_2)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; tmp_3 = [0]</span><br><span class="line">&gt;&gt;&gt; all(tmp_3)</span><br><span class="line">False</span><br></pre></td></tr></table></figure></li><li><p><code>any()</code>接受一个迭代器，如果迭代器里有一个元素为真，那么返回True,否则返回False</p></li><li><p><code>ascii()</code>调用对象的<strong>repr</strong>()方法，获得该方法的返回值</p></li><li><p><code>bin()</code>接收一个十进制，转换成二进制</p></li><li><p><code>oct()</code>接收一个十进制，转换成八进制</p></li><li><p><code>hex()</code>接收一个十进制，转换成十六进制</p></li><li><p><code>bool()</code>测试一个对象是True还是False</p></li><li><p><code>bytes()</code>将一个字符串转换成字节类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = &apos;python&apos;</span><br><span class="line">&gt;&gt;&gt; x = bytes(s, encoding=&apos;utf-8&apos;)</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">b&apos;python&apos;</span><br><span class="line">&gt;&gt;&gt; a = &apos;王&apos;</span><br><span class="line">&gt;&gt;&gt; s = bytes(a, encoding=&apos;utf-8&apos;)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">b&apos;\xe7\x8e\x8b&apos;</span><br></pre></td></tr></table></figure></li><li><p><code>str()</code>将字符类型/数值类型等转换为字符串类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; str(b&apos;\xe7\x8e\x8b&apos;, encoding=&apos;utf-8&apos;)  # 字节转换为字符串</span><br><span class="line">&apos;王&apos;</span><br><span class="line">&gt;&gt;&gt; str(1)   # 整数转换为字符串</span><br><span class="line">&apos;1&apos;</span><br></pre></td></tr></table></figure></li><li><p><code>challable()</code>判断对象是否可以被调用，能被调用的对象就是一个callables对象，比如函数和带有<strong>call</strong>()的实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; callable(max)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; callable([1, 2, 3])</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; callable(None)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; callable(&apos;str&apos;)</span><br><span class="line">False</span><br></pre></td></tr></table></figure></li><li><p><code>char()</code>数字转字母，查看十进制数对应的ASCII字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; chr(-1)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#26&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    chr(-1)</span><br><span class="line">ValueError: chr() arg not in range(0x110000)</span><br><span class="line">&gt;&gt;&gt; chr(0)</span><br><span class="line">&apos;\x00&apos;</span><br></pre></td></tr></table></figure></li><li><p><code>ord()</code>字母转数字，查看某个ASCII对应的十进制数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ord(&apos;\x00&apos;)</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; ord(&apos;7&apos;)</span><br><span class="line">55</span><br></pre></td></tr></table></figure></li><li><p><code>classmethod()</code>用来指定一个方法为类的方法，由类直接调用执行，只有一个cls参数,执行雷的方法时，自动将调用该方法的类赋值给cls.没有此参数指定的类的方法为实例方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Province:</span><br><span class="line">    country = &quot;中国&quot;</span><br><span class="line">      </span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line">      </span><br><span class="line">    @classmethod</span><br><span class="line">    def show(cls):  # 类方法，由类调用，最少要有一个参数cls，调用的时候这个参数不用传值，自动将类名赋值给cls</span><br><span class="line">        print(cls)</span><br><span class="line">      </span><br><span class="line"># 调用方法</span><br><span class="line">Province.show()</span><br></pre></td></tr></table></figure></li><li><p><code>complie()</code>将字符串编译成python能识别或可以执行的代码，也可以将文字读成字符串再编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1)</span><br><span class="line">将source编译为代码或者AST对象。代码对象能过通过exec语句来执行或者eval()进行求值。</span><br><span class="line">参数source：字符串或者AST（abstract syntax trees）对象。</span><br><span class="line">参数filename：代码文件名称，如果不是从文件读取代码则传递一些可辨认的值。</span><br><span class="line">参数model：指定编译代码的种类。可以指定&apos;exec&apos;, &apos;eval&apos;, &apos;single&apos;。</span><br><span class="line">参数flag和dont_inherit：这两个参数为可选参数。</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; s  = &quot;print(&apos;helloworld&apos;)&quot;</span><br><span class="line">&gt;&gt;&gt; r = compile(s, &quot;&lt;string&gt;&quot;, &quot;exec&quot;)</span><br><span class="line">&gt;&gt;&gt; r</span><br><span class="line">&lt;code object &lt;module&gt; at 0x000001C648038390, file &quot;&lt;string&gt;&quot;, line 1&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>complex()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建一个值为real + imag * j的复数或者转化一个字符串或数为复数。如果第一个参数是字符串，则不需要指定第二个参数</span><br><span class="line">参数real：int，long，float或字符串。</span><br><span class="line">参数imag：int，long，float。</span><br></pre></td></tr></table></figure></li><li><p><code>delattr()</code>删除对象的属性</p></li><li><p><code>dict()</code>创建数据字典</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = dict()  空字典</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#123;&#125;</span><br><span class="line">&gt;&gt;&gt; b = dict(one = 1, two =2)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">&#123;&apos;one&apos;: 1, &apos;two&apos;: 2&#125;</span><br><span class="line">&gt;&gt;&gt; c = dict(&#123;&apos;one&apos;:1 ,&apos;two&apos;:2&#125;)</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">&#123;&apos;one&apos;: 1, &apos;two&apos;: 2&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>dir()</code>不带参数时返回当前范围内的变量，方法和定义的类型列表，带参数时返回参数的属性，方法列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dir()</span><br><span class="line">[&apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos;, &apos;li&apos;, &apos;li1&apos;, &apos;li2&apos;, &apos;li_1&apos;]</span><br><span class="line">&gt;&gt;&gt; dir(list)</span><br><span class="line">[&apos;__add__&apos;, &apos;__class__&apos;, &apos;__contains__&apos;, &apos;__delattr__&apos;, &apos;__delitem__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__getitem__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__iadd__&apos;, &apos;__imul__&apos;, &apos;__init__&apos;, &apos;__iter__&apos;, &apos;__le__&apos;, &apos;__len__&apos;, &apos;__lt__&apos;, &apos;__mul__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__reversed__&apos;, &apos;__rmul__&apos;, &apos;__setattr__&apos;, &apos;__setitem__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;append&apos;, &apos;clear&apos;, &apos;copy&apos;, &apos;count&apos;, &apos;extend&apos;, &apos;index&apos;, &apos;insert&apos;, &apos;pop&apos;, &apos;remove&apos;, &apos;reverse&apos;, &apos;sort&apos;]</span><br></pre></td></tr></table></figure></li><li><p><code>divmod()</code>分别取商和余数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; divmod(20,6)</span><br><span class="line">(3, 2)</span><br></pre></td></tr></table></figure></li><li><p><code>enumerate()</code>返回一个可以枚举的对象，该对象的next()方法将返回一个元组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; test = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line">&gt;&gt;&gt; for k,v in enumerate(test):</span><br><span class="line">    print(k,v)</span><br><span class="line"> </span><br><span class="line"># 输出结果： </span><br><span class="line">0 a</span><br><span class="line">1 b</span><br><span class="line">2 c</span><br></pre></td></tr></table></figure></li><li><p><code>eval()</code>将字符串str当成有效的表达式来求值并返回计算结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = &quot;1+2*3&quot;</span><br><span class="line">&gt;&gt;&gt; type(s)</span><br><span class="line">&lt;class &apos;str&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; eval(s)</span><br><span class="line">7</span><br></pre></td></tr></table></figure></li><li><p><code>exec()</code>执行字符串或complie方法编译过的字符串，没有返回值</p></li><li><p><code>filter()</code>过滤器，构造一个序列，等价于[ item for item in iterables if function(item)]，在函数中设定过滤条件，逐一循环迭代器中的元素，将返回值为True时的元素留下，形成一个filter类型数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filter(function, iterable)</span><br><span class="line">参数function：返回值为True或False的函数，可以为None。</span><br><span class="line">参数iterable：序列或可迭代对象。</span><br><span class="line">&gt;&gt;&gt; def bigerthan5(x):</span><br><span class="line">...     return x &gt; 5</span><br><span class="line">&gt;&gt;&gt; filter(bigerthan5, [3, 4, 5, 6, 7, 8])</span><br><span class="line">[6, 7, 8]</span><br></pre></td></tr></table></figure></li><li><p><code>float()</code>讲一个字符串或整数转换为浮点数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; float()</span><br><span class="line">0.0</span><br><span class="line">&gt;&gt;&gt; float(&apos;123&apos;)</span><br><span class="line">123.0</span><br><span class="line">&gt;&gt;&gt; float(1)</span><br><span class="line">1.0</span><br><span class="line">&gt;&gt;&gt; float(&apos;a&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#45&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    float(&apos;a&apos;)</span><br><span class="line">ValueError: could not convert string to float: &apos;a&apos;</span><br></pre></td></tr></table></figure></li><li><p><code>format()</code>格式化输出字符串，format(value, format_spec)实质上是调用了value的<strong>format</strong>(format_spec)方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;I am &#123;0&#125;, I like &#123;1&#125;!&quot;.format(&quot;wang&quot;, &quot;moon&quot;)     </span><br><span class="line">&apos;I am wang, I like moon!&apos;</span><br></pre></td></tr></table></figure></li><li><p><code>frozenset()</code>创建一个不可修改的集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">frozenset([iterable])</span><br><span class="line">set和frozenset最本质的区别是前者是可变的，后者是不可变的。当集合对象会被改变时（例如删除，添加元素），只能使用set，</span><br><span class="line">一般来说使用fronzet的地方都可以使用set。</span><br><span class="line">参数iterable：可迭代对象。</span><br></pre></td></tr></table></figure></li></ol><p>　</p><ol><li><p><code>getattr()</code>获取对象的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">getattr(object, name [, defalut])</span><br><span class="line">获取对象object名为name的特性，如果object不包含名为name的特性，将会抛出AttributeError异常；如果不包含名为name的特性</span><br><span class="line">且提供default参数，将返回default。</span><br><span class="line">参数object：对象</span><br><span class="line">参数name：对象的特性名</span><br><span class="line">参数default：缺省返回值</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; append = getattr(list, &apos;append&apos;)</span><br><span class="line">&gt;&gt;&gt; append</span><br><span class="line">&lt;method &apos;append&apos; of &apos;list&apos; objects&gt;</span><br><span class="line">&gt;&gt;&gt; mylist = [3, 4, 5]</span><br><span class="line">&gt;&gt;&gt; append(mylist, 6)</span><br><span class="line">&gt;&gt;&gt; mylist</span><br><span class="line">[3, 4, 5, 6]</span><br><span class="line">&gt;&gt;&gt; method = getattr(list, &apos;add&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: type object &apos;list&apos; has no attribute &apos;add&apos;</span><br><span class="line">&gt;&gt;&gt; method = getattr(list, &apos;add&apos;, &apos;NoMethod&apos;)</span><br><span class="line">&gt;&gt;&gt; method</span><br><span class="line">&apos;NoMethod&apos;</span><br></pre></td></tr></table></figure></li><li><p><code>globals()</code>返回一个描述当前全局变量的字典</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = 1</span><br><span class="line">&gt;&gt;&gt; globals()</span><br><span class="line">&#123;&apos;__loader__&apos;: &lt;class &apos;_frozen_importlib.BuiltinImporter&apos;&gt;, &apos;a&apos;: 1, &apos;__builtins__&apos;: &lt;module &apos;builtins&apos; (built-in)&gt;, &apos;__doc__&apos;: None, &apos;__name__&apos;: &apos;__main__&apos;, &apos;__package__&apos;: None, &apos;__spec__&apos;: None&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>hasattr()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hasattr(object，name)</span><br><span class="line">判断对象object是否包含名为name的特性（hasattr是通过调用getattr(object，name)）是否抛出异常来实现的。</span><br><span class="line">参数object：对象</span><br><span class="line">参数name：特性名称</span><br><span class="line">&gt;&gt;&gt; hasattr(list, &apos;append&apos;)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; hasattr(list, &apos;add&apos;)</span><br><span class="line">False</span><br></pre></td></tr></table></figure></li><li><p><code>hash()</code>哈希值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hash(object)</span><br><span class="line">如果对象object为哈希表类型，返回对象object的哈希值。哈希值为整数，在字典查找中，哈希值用于快递比价字典的键。</span><br><span class="line">两个数值如果相等，则哈希值也相等。</span><br></pre></td></tr></table></figure></li><li><p><code>help()</code>返回对象的帮助文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用内建的帮助系统，如果不包含参数，交互式帮助系统将在控制台启动。如果参数为字串，则可以是模块，类，方法等名称，并且帮助页面将会在控制台打印。参数也可以为任意对象</span><br></pre></td></tr></table></figure></li><li><p><code>id()</code>返回对象的内存地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = 1</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">1588522800</span><br></pre></td></tr></table></figure></li><li><p><code>input()</code>获取用户输入内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = input(&quot;请输入一个数字：&quot;)</span><br><span class="line"># 用户输入3</span><br><span class="line">print(num)</span><br><span class="line"># 输出结果</span><br><span class="line">3</span><br></pre></td></tr></table></figure></li><li><p><code>int()</code>将一个字符串或数值转换为一个普通整数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int([x[,radix]])</span><br><span class="line">如果参数是字符串，那么它可能包含符号和小数点。参数radix表示转换的基数（默认是10进制）。</span><br><span class="line">它可以是[2,36]范围内的值，或者0。如果是0，系统将根据字符串内容来解析。</span><br><span class="line">如果提供了参数radix，但参数x并不是一个字符串，将抛出TypeError异常；</span><br><span class="line">否则，参数x必须是数值（普通整数，长整数，浮点数）。通过舍去小数点来转换浮点数。</span><br><span class="line">如果超出了普通整数的表示范围，一个长整数被返回。</span><br><span class="line">如果没有提供参数，函数返回0。</span><br></pre></td></tr></table></figure></li><li><p><code>isinstance()</code>检查对象是否是类的对象，返回True或False</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">isinstance(obj, cls)</span><br><span class="line">检查obj是否是类cls的对象, 返回True 或 False</span><br><span class="line">class Foo(object):</span><br><span class="line">    pass</span><br><span class="line">obj = Foo()</span><br><span class="line">isinstance(obj, Foo)</span><br></pre></td></tr></table></figure></li><li><p><code>issubclass()</code>检查一个类是否是另一个类的子类。返回True或False</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">issubclass(sub, super)</span><br><span class="line">检查sub类是否是super类的派生类（子类）。返回True 或 False</span><br><span class="line"> </span><br><span class="line">class Foo(object):</span><br><span class="line">    pass</span><br><span class="line">   </span><br><span class="line">class Bar(Foo):</span><br><span class="line">    pass</span><br><span class="line">   </span><br><span class="line">issubclass(Bar, Foo)</span><br></pre></td></tr></table></figure></li><li><p><code>iter()</code>　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iter(o[, sentinel])</span><br><span class="line">返回一个iterator对象。该函数对于第一个参数的解析依赖于第二个参数。</span><br><span class="line">如果没有提供第二个参数，参数o必须是一个集合对象，支持遍历功能（__iter__()方法）或支持序列功能（__getitem__()方法），</span><br><span class="line">参数为整数，从零开始。如果不支持这两种功能，将处罚TypeError异常。</span><br><span class="line">如果提供了第二个参数，参数o必须是一个可调用对象。在这种情况下创建一个iterator对象，每次调用iterator的next()方法来无</span><br><span class="line">参数的调用o，如果返回值等于参数sentinel，触发StopIteration异常，否则将返回该值。</span><br></pre></td></tr></table></figure></li><li><p><code>len()</code>返回对象长度，参数可以是序列类型（字符串，元组或列表）或映射类型（如字典）</p></li><li><p><code>list()</code>列表构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list([iterable])</span><br><span class="line">list的构造函数。参数iterable是可选的，它可以是序列，支持编译的容器对象，或iterator对象。</span><br><span class="line">该函数创建一个元素值，顺序与参数iterable一致的列表。如果参数iterable是一个列表，将创建</span><br><span class="line">列表的一个拷贝并返回，就像语句iterables[:]。</span><br></pre></td></tr></table></figure></li><li><p><code>locals()</code>打印当前可用的局部变量的字典</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不要修改locals()返回的字典中的内容；改变可能不会影响解析器对局部变量的使用。</span><br><span class="line">在函数体内调用locals()，返回的是自由变量。修改自由变量不会影响解析器对变量的使用。</span><br><span class="line">不能在类区域内返回自由变量。</span><br></pre></td></tr></table></figure></li><li><p><code>map()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">map(function, iterable,...)</span><br><span class="line">对于参数iterable中的每个元素都应用fuction函数，并将结果作为列表返回。</span><br><span class="line">如果有多个iterable参数，那么fuction函数必须接收多个参数，这些iterable中相同索引处的元素将并行的作为function函数的参数。</span><br><span class="line">如果一个iterable中元素的个数比其他少，那么将用None来扩展改iterable使元素个数一致。</span><br><span class="line">如果有多个iterable且function为None，map()将返回由元组组成的列表，每个元组包含所有iterable中对应索引处值。</span><br><span class="line">参数iterable必须是一个序列或任何可遍历对象，函数返回的往往是一个列表(list)。</span><br><span class="line"> </span><br><span class="line">li = [1,2,3]</span><br><span class="line">data = map(lambda x :x*100,li)</span><br><span class="line">print(type(data))</span><br><span class="line">data = list(data)</span><br><span class="line">print(data)</span><br><span class="line"> </span><br><span class="line">运行结果：</span><br><span class="line"> </span><br><span class="line">&lt;class &apos;map&apos;&gt;</span><br><span class="line">[100, 200, 300]</span><br></pre></td></tr></table></figure></li><li><p><code>max()</code>返回给定元素里最大值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">max(iterable [,args...][, key])</span><br><span class="line">如果只提供iterable参数，函数返回可遍历对象（如：字符串，元组或列表）中最大的非空元素。</span><br><span class="line">如果提供多个参数，那么返回值最大的那个参数。</span><br><span class="line">可选参数key是单参数的排序函数。</span><br><span class="line">如果提供key参数，必须是以命名的形式，如：max(a, b, c, key = fun)</span><br></pre></td></tr></table></figure></li><li><p><code>meoryview()</code>查看内存地址</p></li><li><p><code>min()</code>返回给定元素里最小值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">min(iterable [,args...][, key])</span><br><span class="line">如果只提供iterable参数，函数返回可遍历对象（如：字符串，元组或列表）中最小的非空元素。</span><br><span class="line">如果提供多个参数，那么返回值最小的那个参数。</span><br><span class="line">可选参数key是单参数的排序函数。</span><br><span class="line">如果提供key参数，必须是以命名的形式，如：max(a, b, c, key = fun)</span><br></pre></td></tr></table></figure></li><li><p><code>next()</code>返回一个可迭代数据结构（如列表）中的下一项</p></li><li><p><code>object()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取一个新的，无特性(geatureless)对象。Object是所有类的基类。它提供的方法将在所有的类型实例中共享。</span><br><span class="line">该函数时2.2.版本新增，2.3版本之后，该函数不接受任何参数。</span><br></pre></td></tr></table></figure></li><li><p><code>open()</code>打开文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">open(filename [, mode [, bufsize]])</span><br><span class="line">打开一个文件，返回一个file对象。 如果文件无法打开，将处罚IOError异常。</span><br><span class="line">应该使用open()来代替直接使用file类型的构造函数打开文件。</span><br><span class="line">参数filename表示将要被打开的文件的路径字符串；</span><br><span class="line">参数mode表示打开的模式，最常用的模式有：&apos;r&apos;表示读文本，&apos;w&apos;表示写文本文件，&apos;a&apos;表示在文件中追加。</span><br><span class="line">Mode的默认值是&apos;r&apos;。</span><br><span class="line">当操作的是二进制文件时，只要在模式值上添加&apos;b&apos;。这样提高了程序的可移植性。</span><br><span class="line">可选参数bufsize定义了文件缓冲区的大小。0表示不缓冲；1表示行缓冲；任何其他正数表示使用该大小的缓冲区；</span><br><span class="line">负数表示使用系统默认缓冲区大小，对于tty设备它往往是行缓冲，而对于其他文件往往完全缓冲。如果参数值被省却。</span><br><span class="line">使用系统默认值。</span><br></pre></td></tr></table></figure></li><li><p><code>pow()</code>幂函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r = pow(2, 10)  # 2的10次方</span><br><span class="line">print(r)</span><br><span class="line">              </span><br><span class="line"># 输出</span><br><span class="line">1024</span><br></pre></td></tr></table></figure></li><li><p><code>print()</code>输出函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python2中的print语句被python3中的print()函数取代。</span><br><span class="line">如何限制print的默认换行： </span><br><span class="line">1. python2版本下，在print输出的最后加一个逗号&apos;,&apos;</span><br><span class="line">2. python3.4以后，print(value, ...,sep=&apos;&apos;,end=&apos;\n&apos;,file=sys.stdout,flush=False),将end设为空即可。</span><br></pre></td></tr></table></figure></li><li><p><code>property()</code>获取对象的所有属性</p></li><li><p><code>range()</code>根据需要生成一个指定范围的数字，可以提供你需要的控制来迭代指定的次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">用于创建包含连续算术值的列表(list)。常用于for循环。参数必须是普通整数。</span><br><span class="line">参数step默认值为1，参数start的默认值为0。</span><br><span class="line">全参数调用该函数将返回一个普通整数列表。</span><br><span class="line">step 可以是正整数或者负整数。不可以为0，否则将处罚ValueError异常。</span><br><span class="line">range(3)代表0,1,2.等价于range(0,3)</span><br><span class="line">&gt;&gt;&gt; range(0,10,2)  #第一个参数是起始数，第二个是终止数(不包含这个)，第三个数步数</span><br><span class="line">&gt;&gt;&gt;[0,2,4,6,8]</span><br></pre></td></tr></table></figure></li><li><p><code>repr()</code>将任意值转换为字符串，供计时器读取的形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">repr(object)</span><br><span class="line">返回一个对象的字符串表示。有时可以使用这个函数来访问操作。</span><br><span class="line">对于许多类型来说，repr()尝试返回一个字符串，eval()方法可以使用该字符串产生对象；</span><br><span class="line">否则用尖括号括起来的，包含类名称和其他二外信息的字符串被返回。</span><br></pre></td></tr></table></figure></li><li><p><code>reversed()</code>反转，逆序对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reversed(seq)</span><br><span class="line">返回一个逆序的iterator对象。参数seq必须是一个包含__reversed__()方法的对象或支持序列操作(__len__()和__getitem__())</span><br><span class="line">该函数是2.4中新增的</span><br></pre></td></tr></table></figure></li><li><p><code>round()</code>四舍五入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">round(x [, n])</span><br><span class="line">对参数x的第n+1位小数进行四舍五入，返回一个小数位数为n的浮点数。</span><br><span class="line">参数n的默认值是0。结果是一个浮点数。如round(0.5)结果为1.0</span><br><span class="line">&gt;&gt;&gt; round(4,6)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; round(5,6)</span><br><span class="line">5</span><br></pre></td></tr></table></figure></li><li><p><code>set()</code>class set([iterable])  返回一个新的set对象，可以选择从iterable取得的元素，set是一个内置的类</p></li><li><p><code>setattr()</code>与getattr()相对应，setattr(object,name,value) 参数是一个对象，一个字符串和一个任意值。字符串可以命名现有属性或新属性。如果对象允许，该函数将赋值给该属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setattr(x, &apos;foobar&apos;, 123) 相当于x.foobar = 123</span><br></pre></td></tr></table></figure></li><li><p><code>slice()</code>切片功能,  slice(start, stop[, step])</p></li><li><p><code>sorted()</code>排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([36,6,-12,9,-22])  列表排序</span><br><span class="line">[-22, -12, 6, 9, 36]</span><br><span class="line">&gt;&gt;&gt; sorted([36,6,-12,9,-22],key=abs) 高阶函数，以绝对值大小排序</span><br><span class="line">[6, 9, -12, -22, 36]</span><br><span class="line">&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;])  字符串排序，按照ASCII的大小排序</span><br><span class="line">[&apos;Credit&apos;, &apos;Zoo&apos;, &apos;about&apos;, &apos;bob&apos;]</span><br><span class="line">如果需要排序的是一个元组，则需要使用参数key，也就是关键字。</span><br><span class="line">&gt;&gt;&gt; a = [(&apos;b&apos;,2), (&apos;a&apos;,1), (&apos;c&apos;,0)]</span><br><span class="line">&gt;&gt;&gt; list(sorted(a,key=lambda x:x[1]))   按照元组第二个元素排序</span><br><span class="line">[(&apos;c&apos;, 0), (&apos;a&apos;, 1), (&apos;b&apos;, 2)]</span><br><span class="line">&gt;&gt;&gt; list(sorted(a,key=lambda x:x[0]))   按照元组第一个元素排序</span><br><span class="line">[(&apos;a&apos;, 1), (&apos;b&apos;, 2), (&apos;c&apos;, 0)]</span><br><span class="line">&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;],key=str.lower) 忽略大小写排序</span><br><span class="line">[&apos;about&apos;, &apos;bob&apos;, &apos;Credit&apos;, &apos;Zoo&apos;]  </span><br><span class="line">&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;],key=str.lower,reverse=True) 反向排序</span><br><span class="line">[&apos;Zoo&apos;, &apos;Credit&apos;, &apos;bob&apos;, &apos;about&apos;]</span><br></pre></td></tr></table></figure></li><li><p><code>staticmethod()</code>在类中定义一个静态方法的函数，通常@staticmethod 下面接一个函数，如此使用</p></li><li><p><code>str()</code>字符串构造函数</p></li><li><p><code>sum()</code>求和</p></li><li><p><code>super()</code>调用父类的方法</p></li><li><p><code>tuple()</code>元组构造函数</p></li><li><p><code>type()</code>显示对象所属的类型</p></li><li><p><code>vars()</code>vars([object])  使用<strong>dict</strong>属性返回模块，类，实例或任何其他对象的<strong>dict</strong>属性</p></li><li><p><code>zip()</code>将对象逐一配对，相当于制作一个迭代器，用于聚合每个迭代的元素。zip(*iterables)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st_1 = [1,2,3]</span><br><span class="line">list_2 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br><span class="line">s = zip(list_1,list_2)</span><br><span class="line">print(list(s))</span><br><span class="line"> </span><br><span class="line">运行结果：</span><br><span class="line"> </span><br><span class="line">[(1, &apos;a&apos;), (2, &apos;b&apos;), (3, &apos;c&apos;)]</span><br></pre></td></tr></table></figure></li><li><p><code>__import__()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该函数由import 语句调用，它可以被替换（导入builtins模块和分配给builtins.__import__）来改变import语句的语义，但是并不建议如此使用。</span><br></pre></td></tr></table></figure></li></ol><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a>持续更新…</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生苦短，我用python。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://pythonfood.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://pythonfood.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>pythonXML解析</title>
    <link href="http://pythonfood.github.io/2017/12/28/pythonXML%E8%A7%A3%E6%9E%90/"/>
    <id>http://pythonfood.github.io/2017/12/28/pythonXML解析/</id>
    <published>2017-12-28T13:10:00.000Z</published>
    <updated>2018-03-24T16:11:37.341Z</updated>
    
    <content type="html"><![CDATA[<p>人生苦短，我用python。<br><a id="more"></a></p><h2 id="一、XML"><a href="#一、XML" class="headerlink" title="一、XML"></a>一、XML</h2><p>XML 指可扩展标记语言（eXtensible Markup Language），标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言。</p><p>常见的XML编程接口有DOM和SAX，这两种接口处理XML文件的方式不同，使用场合也不同。</p><p>python有三种方法解析XML：SAX(simple API for XML )，DOM(Document Object Model)，ElementTree。</p><p>后面用到的XML实例文件movies.xml内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;collection shelf=&quot;New Arrivals&quot;&gt;</span><br><span class="line">&lt;movie title=&quot;Enemy Behind&quot;&gt;</span><br><span class="line">   &lt;type&gt;War, Thriller&lt;/type&gt;</span><br><span class="line">   &lt;format&gt;DVD&lt;/format&gt;</span><br><span class="line">   &lt;year&gt;2003&lt;/year&gt;</span><br><span class="line">   &lt;rating&gt;PG&lt;/rating&gt;</span><br><span class="line">   &lt;stars&gt;10&lt;/stars&gt;</span><br><span class="line">   &lt;description&gt;Talk about a US-Japan war&lt;/description&gt;</span><br><span class="line">&lt;/movie&gt;</span><br><span class="line">&lt;movie title=&quot;Transformers&quot;&gt;</span><br><span class="line">   &lt;type&gt;Anime, Science Fiction&lt;/type&gt;</span><br><span class="line">   &lt;format&gt;DVD&lt;/format&gt;</span><br><span class="line">   &lt;year&gt;1989&lt;/year&gt;</span><br><span class="line">   &lt;rating&gt;R&lt;/rating&gt;</span><br><span class="line">   &lt;stars&gt;8&lt;/stars&gt;</span><br><span class="line">   &lt;description&gt;A schientific fiction&lt;/description&gt;</span><br><span class="line">&lt;/movie&gt;</span><br><span class="line">   &lt;movie title=&quot;Trigun&quot;&gt;</span><br><span class="line">   &lt;type&gt;Anime, Action&lt;/type&gt;</span><br><span class="line">   &lt;format&gt;DVD&lt;/format&gt;</span><br><span class="line">   &lt;episodes&gt;4&lt;/episodes&gt;</span><br><span class="line">   &lt;rating&gt;PG&lt;/rating&gt;</span><br><span class="line">   &lt;stars&gt;10&lt;/stars&gt;</span><br><span class="line">   &lt;description&gt;Vash the Stampede!&lt;/description&gt;</span><br><span class="line">&lt;/movie&gt;</span><br><span class="line">&lt;movie title=&quot;Ishtar&quot;&gt;</span><br><span class="line">   &lt;type&gt;Comedy&lt;/type&gt;</span><br><span class="line">   &lt;format&gt;VHS&lt;/format&gt;</span><br><span class="line">   &lt;rating&gt;PG&lt;/rating&gt;</span><br><span class="line">   &lt;stars&gt;2&lt;/stars&gt;</span><br><span class="line">   &lt;description&gt;Viewable boredom&lt;/description&gt;</span><br><span class="line">&lt;/movie&gt;</span><br><span class="line">&lt;/collection&gt;</span><br></pre></td></tr></table></figure></p><h3 id="1、SAX"><a href="#1、SAX" class="headerlink" title="1、SAX"></a>1、SAX</h3><p>SAX是流模式，边读边解析，占用内存小，解析快，缺点是我们需要自己处理事件。</p><p>SAX解析XML文档牵涉到两个部分:解析器和事件处理器。</p><ul><li>解析器：负责读取XML文档,并向事件处理器发送事件,如元素开始跟元素结束事件;</li><li>事件处理器：则负责对事件作出相应,对传递的XML数据进行处理。 </li></ul><p>(1)ContentHandler类方法介绍<br>1)<code>characters(content)</code>方法调用时机：</p><ul><li>从行开始，遇到标签之前，存在字符，content的值为这些字符串。</li><li>从一个标签，遇到下一个标签之前， 存在字符，content的值为这些字符串。</li><li>从一个标签，遇到行结束符之前，存在字符，content的值为这些字符串。</li></ul><p>2)<code>startDocument()</code>方法文档启动的时候调用。</p><p>3)<code>endDocument()</code>方法解析器到达文档结尾时调用。</p><p>4)<code>startElement(name, attrs)</code>方法遇到XML开始标签时调用，name是标签的名字，attrs是标签的属性值字典。</p><p>5)endElement(name)方法遇到XML结束标签时调用。 </p><p>(2)make_parser方法创建一个新的解析器对象并返回。<br><code>xml.sax.make_parser( [parser_list] )</code></p><ul><li>parser_list : 可选参数，解析器列表</li></ul><p>(3)parser方法创建一个SAX解析器并解析xml文档：<br><code>xml.sax.parse( xmlfile, contenthandler[, errorhandler])</code></p><ul><li>xmlfile : xml文件名</li><li>contenthandler : 必须是一个ContentHandler的对象</li><li>errorhandler : 如果指定该参数，errorhandler必须是一个SAX ErrorHandler对象</li></ul><p>(4)parseString方法创建一个XML解析器并解析xml字符串：<br><code>xml.sax.parseString(xmlstring, contenthandler[, errorhandler])</code></p><ul><li>xmlstring  : xml字符串</li><li>contenthandler : 必须是一个ContentHandler的对象</li><li>errorhandler : 如果指定该参数，errorhandler必须是一个SAX ErrorHandler对象</li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">import xml.sax</span><br><span class="line"></span><br><span class="line">class MovieHandler( xml.sax.ContentHandler ):</span><br><span class="line">   def __init__(self):</span><br><span class="line">      self.CurrentData = &quot;&quot;</span><br><span class="line">      self.type = &quot;&quot;</span><br><span class="line">      self.format = &quot;&quot;</span><br><span class="line">      self.year = &quot;&quot;</span><br><span class="line">      self.rating = &quot;&quot;</span><br><span class="line">      self.stars = &quot;&quot;</span><br><span class="line">      self.description = &quot;&quot;</span><br><span class="line"></span><br><span class="line">   # 元素开始调用</span><br><span class="line">   def startElement(self, tag, attributes):</span><br><span class="line">      self.CurrentData = tag</span><br><span class="line">      if tag == &quot;movie&quot;:</span><br><span class="line">         print (&quot;*****Movie*****&quot;)</span><br><span class="line">         title = attributes[&quot;title&quot;]</span><br><span class="line">         print (&quot;Title:&quot;, title)</span><br><span class="line"></span><br><span class="line">   # 元素结束调用</span><br><span class="line">   def endElement(self, tag):</span><br><span class="line">      if self.CurrentData == &quot;type&quot;:</span><br><span class="line">         print (&quot;Type:&quot;, self.type)</span><br><span class="line">      elif self.CurrentData == &quot;format&quot;:</span><br><span class="line">         print (&quot;Format:&quot;, self.format)</span><br><span class="line">      elif self.CurrentData == &quot;year&quot;:</span><br><span class="line">         print (&quot;Year:&quot;, self.year)</span><br><span class="line">      elif self.CurrentData == &quot;rating&quot;:</span><br><span class="line">         print (&quot;Rating:&quot;, self.rating)</span><br><span class="line">      elif self.CurrentData == &quot;stars&quot;:</span><br><span class="line">         print (&quot;Stars:&quot;, self.stars)</span><br><span class="line">      elif self.CurrentData == &quot;description&quot;:</span><br><span class="line">         print (&quot;Description:&quot;, self.description)</span><br><span class="line">      self.CurrentData = &quot;&quot;</span><br><span class="line"></span><br><span class="line">   # 读取字符时调用</span><br><span class="line">   def characters(self, content):</span><br><span class="line">      if self.CurrentData == &quot;type&quot;:</span><br><span class="line">         self.type = content</span><br><span class="line">      elif self.CurrentData == &quot;format&quot;:</span><br><span class="line">         self.format = content</span><br><span class="line">      elif self.CurrentData == &quot;year&quot;:</span><br><span class="line">         self.year = content</span><br><span class="line">      elif self.CurrentData == &quot;rating&quot;:</span><br><span class="line">         self.rating = content</span><br><span class="line">      elif self.CurrentData == &quot;stars&quot;:</span><br><span class="line">         self.stars = content</span><br><span class="line">      elif self.CurrentData == &quot;description&quot;:</span><br><span class="line">         self.description = content</span><br><span class="line">  </span><br><span class="line">if ( __name__ == &quot;__main__&quot;):</span><br><span class="line">   </span><br><span class="line">   # 创建一个 XMLReader</span><br><span class="line">   parser = xml.sax.make_parser()</span><br><span class="line">   # turn off namepsaces</span><br><span class="line">   parser.setFeature(xml.sax.handler.feature_namespaces, 0)</span><br><span class="line"></span><br><span class="line">   # 重写 ContextHandler</span><br><span class="line">   Handler = MovieHandler()</span><br><span class="line">   parser.setContentHandler( Handler )</span><br><span class="line">   </span><br><span class="line">   parser.parse(&quot;movies.xml&quot;)</span><br></pre></td></tr></table></figure></blockquote><h3 id="2、DOM"><a href="#2、DOM" class="headerlink" title="2、DOM"></a>2、DOM</h3><p>DOM会把整个XML读入内存，解析为树，因此占用内存大，解析慢，优点是可以任意遍历树的节点。</p><p>一个 DOM 的解析器在解析一个 XML 文档时，一次性读取整个文档，把文档中所有元素保存在内存中的一个树结构里，之后你可以利用DOM 提供的不同的函数来读取或修改文档的内容和结构，也可以把修改过的内容写入xml文件。 </p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from xml.dom.minidom import parse</span><br><span class="line">import xml.dom.minidom</span><br><span class="line"></span><br><span class="line"># 使用minidom解析器打开 XML 文档</span><br><span class="line">DOMTree = xml.dom.minidom.parse(&quot;movies.xml&quot;)</span><br><span class="line">collection = DOMTree.documentElement</span><br><span class="line">if collection.hasAttribute(&quot;shelf&quot;):</span><br><span class="line">   print (&quot;Root element : %s&quot; % collection.getAttribute(&quot;shelf&quot;))</span><br><span class="line"></span><br><span class="line"># 在集合中获取所有电影</span><br><span class="line">movies = collection.getElementsByTagName(&quot;movie&quot;)</span><br><span class="line"></span><br><span class="line"># 打印每部电影的详细信息</span><br><span class="line">for movie in movies:</span><br><span class="line">   print (&quot;*****Movie*****&quot;)</span><br><span class="line">   if movie.hasAttribute(&quot;title&quot;):</span><br><span class="line">      print (&quot;Title: %s&quot; % movie.getAttribute(&quot;title&quot;))</span><br><span class="line"></span><br><span class="line">   type = movie.getElementsByTagName(&apos;type&apos;)[0]</span><br><span class="line">   print (&quot;Type: %s&quot; % type.childNodes[0].data)</span><br><span class="line">   format = movie.getElementsByTagName(&apos;format&apos;)[0]</span><br><span class="line">   print (&quot;Format: %s&quot; % format.childNodes[0].data)</span><br><span class="line">   rating = movie.getElementsByTagName(&apos;rating&apos;)[0]</span><br><span class="line">   print (&quot;Rating: %s&quot; % rating.childNodes[0].data)</span><br><span class="line">   description = movie.getElementsByTagName(&apos;description&apos;)[0]</span><br><span class="line">   print (&quot;Description: %s&quot; % description.childNodes[0].data)</span><br></pre></td></tr></table></figure></blockquote><h3 id="3、ElementTree"><a href="#3、ElementTree" class="headerlink" title="3、ElementTree"></a>3、ElementTree</h3><p>与DOM相比，ET的速度更快，API使用更直接、方便。与SAX相比，ET.iterparse函数同样提供了按需解析的功能，不会一次性在内存中读入整个文档。ET的性能与SAX模块大致相仿，但是它的API更加高层次，用户使用起来更加便捷。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">from xml.etree.ElementTree import parse</span><br><span class="line"></span><br><span class="line">f = open(r&quot;C:\PlatformConfigure\Configure\VideoStreamingServerConfigure.xml&quot;)</span><br><span class="line">et = parse(f)</span><br><span class="line">root = et.getroot()     # 获取根节点</span><br><span class="line">print(root)</span><br><span class="line"># 第一种遍历根节点的子元素（该方法要取消了，不推荐使用）</span><br><span class="line">childs = root.getchildren()</span><br><span class="line">for child in childs:</span><br><span class="line">    print(child.tag)</span><br><span class="line"></span><br><span class="line"># 第二种遍历根节点的子元素</span><br><span class="line">for child in root:</span><br><span class="line">    print(child.tag)</span><br><span class="line"></span><br><span class="line"># 查找当前节点的子元素</span><br><span class="line">print(root.find(&apos;LocalIP&apos;))  # 查找到第一个‘LocalIP’的元素</span><br><span class="line">print(root.findall(&apos;LocalIP&apos;))  # 查找到所有标签是‘LocalIP’的元素，得到的是一个列表</span><br><span class="line">print(root.iterfind(&apos;LocalIP&apos;))  # 查找到所有标签是‘LocalIP’的元素，得到的是迭代对象</span><br><span class="line">for e in root.iterfind(&apos;LocalIP&apos;):</span><br><span class="line">    print(e.tag)</span><br><span class="line"></span><br><span class="line"># 列出所有节点元素</span><br><span class="line">for e in root.iter():</span><br><span class="line">    print(e.tag)</span><br><span class="line"></span><br><span class="line"># 查找指定标签的元素节点</span><br><span class="line">print(root.iter(&apos;LocalIP&apos;))</span><br><span class="line"></span><br><span class="line"># 查找孙子节点</span><br><span class="line">print(root.findall(&apos;connstr/*&apos;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(root.findall(&apos;.//host&apos;))     # 查找任意层次下的指定节点元素</span><br><span class="line">print(root.findall(&apos;.//host/..&apos;))  # 查找任意层次下的指定节点元素的父元素</span><br><span class="line"></span><br><span class="line">print(root.findall(&apos;LocalIP[@age]&apos;))   # 查找包含age属性的LocalIP节点元素</span><br><span class="line">print(root.findall(&apos;LocalIP[@age=&quot;18&quot;]&apos;))   # 查找包含age属性值=18的LocalIP节点元素</span><br><span class="line">print(root.findall(&apos;connstr[host]&apos;))      # 查找包含host节点的connstr节点元素</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for host in root.findall(&apos;.//host&apos;):       # 输出节点的值</span><br><span class="line">    print(host.text)</span><br></pre></td></tr></table></figure></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a>持续更新…</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生苦短，我用python。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://pythonfood.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://pythonfood.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>pythonJSON解析</title>
    <link href="http://pythonfood.github.io/2017/12/28/pythonJSON%E8%A7%A3%E6%9E%90/"/>
    <id>http://pythonfood.github.io/2017/12/28/pythonJSON解析/</id>
    <published>2017-12-28T13:00:00.000Z</published>
    <updated>2018-03-29T09:43:32.372Z</updated>
    
    <content type="html"><![CDATA[<p>人生苦短，我用python。<br><a id="more"></a></p><h2 id="一、json模块"><a href="#一、json模块" class="headerlink" title="一、json模块"></a>一、json模块</h2><p>JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于ECMAScript的一个子集。</p><p>Python3 中可以使用json模块来对JSON数据进行编解码，它主要包含以下四个函数：</p><ul><li><code>json.dumps()</code> ：将python数据对象转换为JSON格式的字符串</li><li><code>json.loads()</code> ：将JSON编码的字符串转换为python的数据结构</li><li><code>json.dump()</code> ：将python数据对象以JSON格式数据流的形式写入到文件</li><li><code>json.load()</code> ：解析包含JSON编码的字符串的文件为python数据对象</li></ul><p>Python编码为JSON类型转换对应表：</p><table><thead><tr><th style="text-align:left">Python</th><th style="text-align:left">JSON</th></tr></thead><tbody><tr><td style="text-align:left">dict</td><td style="text-align:left">object</td></tr><tr><td style="text-align:left">list, tuple</td><td style="text-align:left">array</td></tr><tr><td style="text-align:left">str</td><td style="text-align:left">string</td></tr><tr><td style="text-align:left">int, float, int- &amp; float-derived Enums</td><td style="text-align:left">number</td></tr><tr><td style="text-align:left">True</td><td style="text-align:left">true</td></tr><tr><td style="text-align:left">False</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">None</td><td style="text-align:left">null</td></tr></tbody></table><p>JSON解码为Python类型转换对应表：</p><table><thead><tr><th style="text-align:left">JSON</th><th style="text-align:left">Python</th></tr></thead><tbody><tr><td style="text-align:left">object</td><td style="text-align:left">dict</td></tr><tr><td style="text-align:left">array</td><td style="text-align:left">list</td></tr><tr><td style="text-align:left">string</td><td style="text-align:left">str</td></tr><tr><td style="text-align:left">number (int)</td><td style="text-align:left">int</td></tr><tr><td style="text-align:left">number (real)</td><td style="text-align:left">float</td></tr><tr><td style="text-align:left">true</td><td style="text-align:left">True</td></tr><tr><td style="text-align:left">false</td><td style="text-align:left">False</td></tr><tr><td style="text-align:left">null</td><td style="text-align:left">None</td></tr></tbody></table><h3 id="1、json-dumps"><a href="#1、json-dumps" class="headerlink" title="1、json.dumps()"></a>1、json.dumps()</h3><p><code>json.dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)</code></p><ul><li>obj :python数据对象</li><li>skipkeys :当值为True时，若键不是以下类型（str, int, float, bool, None），则会略过，而不是触发错误</li><li>ensure_ascii :当值为True时，输出时会自动转义所有非ASCII字符</li><li>allow_nan :当值为True时，会将超过浮点数取值范围的数值自动对应于JAVASCRIPT的(NaN, Infinity, -Infinity)，否则会引发错误</li><li>sort_keys :当值为True时，输出结果会按键值排序</li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import json </span><br><span class="line"></span><br><span class="line">py_data = &#123;</span><br><span class="line">&apos;no&apos; : 1,</span><br><span class="line">&apos;name&apos; : &apos;baidu&apos;,</span><br><span class="line">&apos;url&apos; : &apos;http://www.baidu.com&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">json_str = json.dumps(py_data)</span><br><span class="line"></span><br><span class="line">print (&quot;Python原始数据：&quot;, repr(py_data))</span><br><span class="line">print (&quot;JSON对象：&quot;, json_str)</span><br><span class="line"></span><br><span class="line">#输出结果：</span><br><span class="line">#Python原始数据： &#123;&apos;url&apos;: &apos;http://www.baidu.com&apos;, &apos;no&apos;: 1, &apos;name&apos;: &apos;baidu&apos;&#125;</span><br><span class="line">#JSON对象： &#123;&quot;url&quot;: &quot;http://www.baidu.com&quot;, &quot;no&quot;: 1, &quot;name&quot;: &quot;baidu&quot;&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2、json-loads"><a href="#2、json-loads" class="headerlink" title="2、json.loads()"></a>2、json.loads()</h3><p><code>json.loads(s, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)</code></p><ul><li>s :包含JSON的字符串、字节以及字节数组</li><li>object_hook :将传入的字典解析后，再调用用户定义的钩子函数，最终返回钩子函数的返回值</li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">py_data1 = &#123;</span><br><span class="line">&apos;no&apos; : 1,</span><br><span class="line">&apos;name&apos; : &apos;baidu&apos;,</span><br><span class="line">&apos;url&apos; : &apos;http://www.baidu.com&apos;</span><br><span class="line">&#125;</span><br><span class="line">json_str = json.dumps(py_data1)</span><br><span class="line"></span><br><span class="line">py_data2 = json.loads(json_str)</span><br><span class="line"></span><br><span class="line">print(&quot;py_data2[name]:&quot;, py_data2[&apos;name&apos;])</span><br><span class="line">print(&quot;py_data2[url]:&quot;, py_data2[&apos;url&apos;])</span><br><span class="line"></span><br><span class="line">#输出结果：</span><br><span class="line">#py_data2[&apos;name&apos;]:  baidu</span><br><span class="line">#py_data2[&apos;url&apos;]:  http://www.baidu.com</span><br></pre></td></tr></table></figure></blockquote><h3 id="3、json-dump"><a href="#3、json-dump" class="headerlink" title="3、json.dump()"></a>3、json.dump()</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">#Python数据对象以JSON格式写入文件</span><br><span class="line">with open(&apos;data.json&apos;, &apos;w&apos;) as f:</span><br><span class="line">    json.dump(data, f)</span><br></pre></td></tr></table></figure></blockquote><h3 id="4、json-load"><a href="#4、json-load" class="headerlink" title="4、json.load()"></a>4、json.load()</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">#读取JSON编码文件解析为Python数据</span><br><span class="line">with open(&apos;data.json&apos;, &apos;r&apos;) as f:</span><br><span class="line">    data = json.load(f)</span><br></pre></td></tr></table></figure></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a>持续更新…</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生苦短，我用python。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://pythonfood.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://pythonfood.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python网络请求</title>
    <link href="http://pythonfood.github.io/2017/12/28/python%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    <id>http://pythonfood.github.io/2017/12/28/python网络请求/</id>
    <published>2017-12-28T12:50:00.000Z</published>
    <updated>2018-03-24T07:29:10.856Z</updated>
    
    <content type="html"><![CDATA[<p>人生苦短，我用python。<br><a id="more"></a></p><h2 id="一、requests模块"><a href="#一、requests模块" class="headerlink" title="一、requests模块"></a>一、requests模块</h2><p>使用前需安装requests库<code>pip install requests</code>。</p><p>requests库的七个主要方法：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">requests.request()</td><td style="text-align:left">构造一个请求，支持以下各种方法</td></tr><tr><td style="text-align:left">requests.get()</td><td style="text-align:left">获取html的主要方法</td></tr><tr><td style="text-align:left">requests.head()</td><td style="text-align:left">获取html头部信息的主要方法</td></tr><tr><td style="text-align:left">requests.post()</td><td style="text-align:left">向html网页提交post请求的方法</td></tr><tr><td style="text-align:left">requests.put()</td><td style="text-align:left">向html网页提交put请求的方法</td></tr><tr><td style="text-align:left">requests.patch()</td><td style="text-align:left">向html提交局部修改的请求</td></tr><tr><td style="text-align:left">requests.delete()</td><td style="text-align:left">向html提交删除请求</td></tr></tbody></table><p><code>requests.request(method，url,**kwargs)</code>构造一个服务器请求request：</p><ul><li>method: “GET”、”POST”、”HEAD”、”PUT”、”PATCH”、”DELETE”</li><li>url: 请求的网址</li><li>**kwargs: 控制访问的参数<blockquote><ul><li>params：字典或字节序列， 作为参数增加到url中,使用这个参数可以把一些键值对以?key1=value1&amp;key2=value2的模式增加到url中<br>例如：kv = {‘key1: ’ values’, ‘key2’: ‘values’}<br>r = requests.request(‘GET’, ‘http:www.python123.io/ws’, params=kw)</li><li>data：字典，字节序或文件对象，重点作为向服务器提供或提交资源是提交，，作为request的内容，与params不同的是，data提交的数据并不放在url链接里， 而是放在url链接对应位置的地方作为数据来存储。，它也可以接受一个字符串对象。</li><li>json：json格式的数据， json合适在相关的html，http相关的web开发中非常常见， 也是http最经常使用的数据格式， 他是作为内容部分可以向服务器提交。<br>例如：kv = {”key1’: ‘value1’}<br>r = requests.request(‘POST’, ‘<a href="http://python123.io/ws‘" target="_blank" rel="noopener">http://python123.io/ws‘</a>, json=kv)</li><li>headers：字典是http的相关语，对应了向某个url访问时所发起的http的头i字段， 可以用这个字段来定义http的访问的http头，可以用来模拟任何我们想模拟的浏览器来对url发起访问。<br>例子： hd = {‘user-agent’: ‘Chrome/10’}<br>r = requests.request(‘POST’, ‘<a href="http://python123.io/ws‘" target="_blank" rel="noopener">http://python123.io/ws‘</a>, headers=hd)</li><li>cookies：字典或CookieJar，指的是从http中解析cookie</li><li>auth：元组，用来支持http认证功能</li><li>files：字典， 是用来向服务器传输文件时使用的字段。<br>例子：fs = {‘files’: open(‘data.txt’, ‘rb’)}<br>r = requests.request(‘POST’, ‘<a href="http://python123.io/ws‘" target="_blank" rel="noopener">http://python123.io/ws‘</a>, files=fs)</li><li>timeout: 用于设定超时时间， 单位为秒，当发起一个get请求时可以设置一个timeout时间， 如果在timeout时间内请求内容没有返回， 将产生一个timeout的异常。</li><li>proxies：字典， 用来设置访问代理服务器。</li><li>allow_redirects: 开关， 表示是否允许对url进行重定向， 默认为True。</li><li>stream: 开关， 指是否对获取内容进行立即下载， 默认为True。</li><li>verify：开关， 用于认证SSL证书， 默认为True。</li><li>cert： 用于设置保存本地SSL证书路径</li></ul></blockquote></li></ul><p>返回一个包含服务器资源的response对象，具有以下属性和方法：</p><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">r.status_code</td><td style="text-align:left">http请求的返回状态，若为200则表示请求成功。</td></tr><tr><td style="text-align:left">r.text</td><td style="text-align:left">http响应内容的字符串形式，即返回的页面内容</td></tr><tr><td style="text-align:left">r.encoding</td><td style="text-align:left">从http header 中猜测的相应内容编码方式</td></tr><tr><td style="text-align:left">r.apparent_encoding</td><td style="text-align:left">从内容中分析出的响应内容编码方式（备选编码方式）</td></tr><tr><td style="text-align:left">r.content</td><td style="text-align:left">http响应内容的二进制形式</td></tr><tr><td style="text-align:left">r.raw</td><td style="text-align:left">返回原始响应体，使用r.raw.read()读取</td></tr><tr><td style="text-align:left">r.headers</td><td style="text-align:left">以字典对象存储服务器响应头，但是这个字典比较特殊，字典键不区分大小写，若键不存在则返回None</td></tr><tr><td style="text-align:left">r.json()</td><td style="text-align:left">Requests中内置的JSON解码器</td></tr><tr><td style="text-align:left">r.raise_for_status()</td><td style="text-align:left">失败请求(非200响应)抛出异常</td></tr></tbody></table><h3 id="1、发送请求"><a href="#1、发送请求" class="headerlink" title="1、发送请求"></a>1、发送请求</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">#1.发送get请求</span><br><span class="line">res = requests.get(&quot;http://httpbin.org/get&quot;)</span><br><span class="line"></span><br><span class="line">#2.发送post请求</span><br><span class="line">res = requests.post(&quot;http://httpbin.org/post&quot;, data=&#123;&quot;key&quot;:&quot;value&quot;,...&#125;)</span><br><span class="line"></span><br><span class="line">#3.发送head请求</span><br><span class="line">res = requests.head(&quot;http://httpbin.org/get&quot;)</span><br><span class="line"></span><br><span class="line">#4.发送put请求</span><br><span class="line">res = requests.put(&quot;http://httpbin.org/put&quot;,data=&#123;&quot;key&quot;:&quot;value&quot;, ...&#125;)</span><br><span class="line"></span><br><span class="line">#5.发送delete请求</span><br><span class="line">res = requests.delete(&quot;http://httpbin.org/delete&quot;)</span><br><span class="line"></span><br><span class="line">#6.发送patch请求</span><br><span class="line">res = requests.patch(&quot;http://httpbin.org/get&quot;)</span><br></pre></td></tr></table></figure></blockquote><h3 id="2、构造请求参数"><a href="#2、构造请求参数" class="headerlink" title="2、构造请求参数"></a>2、构造请求参数</h3><h4 id="1-get请求参数"><a href="#1-get请求参数" class="headerlink" title="(1)get请求参数"></a>(1)get请求参数</h4><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">def function():</span><br><span class="line">#1.请求参数</span><br><span class="line">payload = &#123;&apos;key1&apos;:&apos;value1&apos;, &apos;key2&apos;:&apos;value2&apos;, &apos;key3&apos;:[&apos;value3&apos;,&apos;value4&apos;]&#125; #注意:请求值可以传入列表</span><br><span class="line"></span><br><span class="line">#2.拼接url= http://httpbin.org/get?key1=value1&amp;key2=value2&amp;key3=value3&amp;key3=value4</span><br><span class="line">res = requests.get(&quot;http://httpbin.org/get&quot;, params=payload) #注意：参数是params</span><br><span class="line"></span><br><span class="line">print(res.text)</span><br></pre></td></tr></table></figure></blockquote><h4 id="2-post请求表单"><a href="#2-post请求表单" class="headerlink" title="(2)post请求表单"></a>(2)post请求表单</h4><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">def function():</span><br><span class="line">#1.表单数据</span><br><span class="line">payload1 = &#123;&apos;key1&apos;:&apos;value1&apos;,&apos;key2&apos;:&apos;key2&apos;&#125; #注意：一键单值用字典</span><br><span class="line">payload2 = &#123;(&apos;key1&apos;, &apos;value1&apos;), (&apos;key1&apos;, &apos;value2&apos;)&#125; #注意：一键多值用元组</span><br><span class="line"></span><br><span class="line">#2.拼接url</span><br><span class="line">res1 = requests.post(&quot;http://httpbin.org/post&quot;,data=payload1) #注意：参数是data</span><br><span class="line">res2 = requests.post(&quot;http://httpbin.org/post&quot;,data=payload2)</span><br><span class="line"></span><br><span class="line">print(res1.text)</span><br><span class="line">print(res2.text)</span><br></pre></td></tr></table></figure></blockquote><h4 id="3-post请求json"><a href="#3-post请求json" class="headerlink" title="(3)post请求json"></a>(3)post请求json</h4><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def function():</span><br><span class="line">#1.post提交json对象数据</span><br><span class="line">payload = &#123;&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;&#125;</span><br><span class="line"></span><br><span class="line">#2.拼接url</span><br><span class="line">res = requests.post(&quot;http://httpbin.org/post&quot;,data=json.dumps(payload))# 方式一</span><br><span class="line">res = requests.post(&quot;http://httpbin.org/post&quot;,json=payload)# 方式二</span><br></pre></td></tr></table></figure></blockquote><h4 id="4-构造请求头headers"><a href="#4-构造请求头headers" class="headerlink" title="(4)构造请求头headers"></a>(4)构造请求头headers</h4><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def function:</span><br><span class="line"></span><br><span class="line">#1.构造请求头</span><br><span class="line">headers = &#123;&apos;user-agent&apos;:&apos;my-app/0.0.1&apos;&#125;</span><br><span class="line">#2.定义url</span><br><span class="line">url = &quot;https://api.github.com/some/endpoint&quot;</span><br><span class="line"></span><br><span class="line">#3.拼接url</span><br><span class="line">res = requests.get(url, headers=headers)</span><br></pre></td></tr></table></figure></blockquote><h4 id="5-构造cookies请求"><a href="#5-构造cookies请求" class="headerlink" title="(5)构造cookies请求"></a>(5)构造cookies请求</h4><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def function():</span><br><span class="line"></span><br><span class="line">#1.构造cookies</span><br><span class="line">cookies = dict(sessionId=&apos;Jsession3123131&apos;)</span><br><span class="line">#2.定义url</span><br><span class="line">url = &quot;http://httpbin.org/cookies&quot;</span><br><span class="line"></span><br><span class="line">#3.拼接url</span><br><span class="line">res = requests.get(url, cookies=cookies)</span><br></pre></td></tr></table></figure></blockquote><h4 id="6-构造请求超时设置"><a href="#6-构造请求超时设置" class="headerlink" title="(6)构造请求超时设置"></a>(6)构造请求超时设置</h4><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def function()</span><br><span class="line"></span><br><span class="line">## 设置请求超时：0.1秒没响应就请求超时失败</span><br><span class="line">requests.get(&apos;http://github.com&apos;,timeout=0.1)</span><br></pre></td></tr></table></figure></blockquote><h4 id="7-基本身份认证"><a href="#7-基本身份认证" class="headerlink" title="(7)基本身份认证"></a>(7)基本身份认证</h4><p>(HTTP Basic Auth)</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">from requests.auth import HTTPBasicAuth</span><br><span class="line"></span><br><span class="line">#身份验证 </span><br><span class="line">r = requests.get(&apos;https://httpbin.org/hidden-basic-auth/user/passwd&apos;, auth=HTTPBasicAuth(&apos;user&apos;, &apos;passwd&apos;))</span><br><span class="line"># r = requests.get(&apos;https://httpbin.org/hidden-basic-auth/user/passwd&apos;, auth=(&apos;user&apos;, &apos;passwd&apos;))    # 简写</span><br><span class="line"></span><br><span class="line">print(r.json())</span><br></pre></td></tr></table></figure></blockquote><h3 id="3、响应内容"><a href="#3、响应内容" class="headerlink" title="3、响应内容"></a>3、响应内容</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">def function()</span><br><span class="line"></span><br><span class="line">#发送请求</span><br><span class="line">url = &quot;https://api.github.com/some/endpoint&quot;</span><br><span class="line">payload = &#123;&apos;key1&apos;:&apos;value1&apos;,&apos;key2&apos;:&apos;key2&apos;&#125;</span><br><span class="line">headers = &#123;&apos;user-agent&apos;:&apos;my-app/0.0.1&apos;&#125;</span><br><span class="line">cookies = dict(sessionId=&apos;Jsession3123131&apos;)</span><br><span class="line">res = requests.post(url,data=payload,headers=headers,cookies=cookies)</span><br><span class="line"></span><br><span class="line">#文本数据信息，大部分情况使用这个方法</span><br><span class="line">text = res.text</span><br><span class="line"></span><br><span class="line">#原始二进制响应数据</span><br><span class="line">content = res.content</span><br><span class="line"></span><br><span class="line"># json响应数据，通常我们使用json模块来处理</span><br><span class="line">json_data = res.json()</span><br><span class="line"></span><br><span class="line"># 响应状态码</span><br><span class="line">status_code= res.status_code</span><br><span class="line"></span><br><span class="line"># 响应头</span><br><span class="line">headers = res.headers</span><br><span class="line"></span><br><span class="line"># 响应cookies</span><br><span class="line">cookies = res.cookies</span><br><span class="line"></span><br><span class="line">#使用响应对象的history方法来追踪重定向</span><br><span class="line">res.history</span><br></pre></td></tr></table></figure></blockquote><h2 id="二、urllib模块"><a href="#二、urllib模块" class="headerlink" title="二、urllib模块"></a>二、urllib模块</h2><p>python内置http请求库urllib：</p><ul><li>urllib.request：用于访问和读取URLS</li><li>urllib.error：包括了所有urllib.request导致的异常</li><li>urllib.parse：用于解析URLS</li><li>urllib.robotparser：用于解析robots.txt文件（网络蜘蛛）</li></ul><h3 id="1、urllib-request"><a href="#1、urllib-request" class="headerlink" title="1、urllib.request"></a>1、urllib.request</h3><p>(1)基本方法<br><code>urllib.request.urlopen(url, data=None, [timeout, ]*, cafile=None, capath=None, cadefault=False, context=None)</code></p><ul><li>url:  需要打开的网址</li><li>data：Post提交的数据</li><li>timeout：设置网站的访问超时时间</li></ul><p>urlopen返回对象提供方法：</p><ul><li><code>geturl()</code>：返回请求的url，通常用于确定是否遵循重定向。</li><li><code>info()</code>：返回HTTPMessage对象，表示远程服务器返回的头信息</li><li><code>getcode()</code>：返回Http状态码。如果是http请求，200请求成功完成;404网址未找到</li><li><code>read()</code> , <code>readline()</code> ,<code>readlines()</code> ：返回页面元素 </li><li><code>fileno()</code> , <code>close()</code> ：对HTTPResponse类型数据进行操作，这些方法的使用方式与文件对象完全一样</li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request </span><br><span class="line"> </span><br><span class="line">page = request.urlopen(&quot;http://www.baidu.com/&quot;)  </span><br><span class="line"></span><br><span class="line">print(page.info())  </span><br><span class="line">print(page.getURL())  </span><br><span class="line">print(page.getcode())  </span><br><span class="line">print(page.read())</span><br></pre></td></tr></table></figure></blockquote><p>(2)设置代理<br><code>urllib.request.build_opener([handler, …])</code><br><code>urllib.request.install_opener(opener)</code></p><p>做爬虫的时候，多都会用到代理IP的，步骤如下：<br>1）利用urllib.request.ProxyHandler准备代理IP或者请求头。<br>2）利用urllib.request.build_opener()封装代理IP或请求头。<br>3）利用urllib.request.instanll_opener()安装成全局。<br>4）利用urllib.request.urlopen访问网页。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request</span><br><span class="line">  </span><br><span class="line">proxy_support = request.ProxyHandler(&#123;&apos;sock5&apos;: &apos;localhost:1080&apos;&#125;)  </span><br><span class="line">opener = request.build_opener(proxy_support)  </span><br><span class="line">request.install_opener(opener)  </span><br><span class="line"></span><br><span class="line">a = request.urlopen(&quot;http://www.baidu.com/ &quot;).read().decode(&quot;utf8&quot;)  </span><br><span class="line"></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure></blockquote><p>(3)使用Request<br><code>urllib.request.Request(url, data=None, headers={}, method=None)</code><br>使用request()来包装请求，再通过urlopen()获取页面。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request  </span><br><span class="line"></span><br><span class="line">url = r&apos;http://www.lagou.com/zhaopin/Python/?labelWords=label&apos;  </span><br><span class="line">headers = &#123;  </span><br><span class="line">    &apos;User-Agent&apos;: r&apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) &apos;  </span><br><span class="line">                  r&apos;Chrome/45.0.2454.85 Safari/537.36 115Browser/6.0.3&apos;,  </span><br><span class="line">    &apos;Referer&apos;: r&apos;http://www.lagou.com/zhaopin/Python/?labelWords=label&apos;,  </span><br><span class="line">    &apos;Connection&apos;: &apos;keep-alive&apos;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">req = request.Request(url, headers=headers)  </span><br><span class="line">page = request.urlopen(req).read()  </span><br><span class="line">page = page.decode(&apos;utf-8&apos;)</span><br></pre></td></tr></table></figure></blockquote><h3 id="2、urllib-error"><a href="#2、urllib-error" class="headerlink" title="2、urllib.error"></a>2、urllib.error</h3><p>常见的由urllib.request导致的异常:</p><ul><li><p>error.URLError: 是OSError的一个子类,URLError可能产生的原因:</p><blockquote><ul><li>网络无连接，即本机无法上网</li><li>连接不到特定的服务器</li><li>服务器不存在</li></ul></blockquote></li><li><p>error.HTTPError: 是URLError的一个子类,对于不能处理对象response的状态码，urlopen会产生一个HTTPError</p><blockquote><ul><li>101： 转换协议 在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。</li><li>102：继续处理 由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</li><li>200：请求成功 处理方式：获得响应的内容，进行处理</li><li>201：请求完成，结果是创建了新资源。新创建资源的URI可在响应的实体中得到 处理方式：爬虫中不会遇到</li><li>202：请求被接受，但处理尚未完成 处理方式：阻塞等待</li><li>204：服务器端已经实现了请求，但是没有返回新的信 息。如果客户是用户代理，则无须为此更新自身的文档视图。 处理方式：丢弃</li><li>300：该状态码不被HTTP/1.0的应用程序直接使用， 只是作为3XX类型回应的默认解释。存在多个可用的被请求资源。 处理方式：若程序中能够处理，则进行进一步处理，如果程序中不能处理，则丢弃</li><li>301：请求到的资源都会分配一个永久的URL，这样就可以在将来通过该URL来访问此资源 处理方式：重定向到分配的URL</li><li>302：请求到的资源在一个不同的URL处临时保存 处理方式：重定向到临时的URL</li><li>304：请求的资源未更新 处理方式：丢弃</li><li>400：非法请求 处理方式：丢弃</li><li>401：未授权 处理方式：丢弃</li><li>403：禁止 处理方式：丢弃</li><li>404：没有找到 处理方式：丢弃</li><li>500：服务器内部错误 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。</li><li>501：服务器无法识别 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</li><li>502：错误网关 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</li><li>503：服务出错 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。</li></ul></blockquote></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request</span><br><span class="line">from urllib import error</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    #一个不存在的连接</span><br><span class="line">    url = &quot;http://www.test1.com/test2.html&quot;</span><br><span class="line">    req = request.Request(url)</span><br><span class="line">    </span><br><span class="line">try:</span><br><span class="line">        responese = request.urlopen(req)</span><br><span class="line">        # html = responese.read()</span><br><span class="line">#想用HTTPError和URLError一起捕获异常,需要将HTTPError放在URLError的前面</span><br><span class="line">    except error.HTTPError as e:</span><br><span class="line">        print(e.code)</span><br><span class="line">except error.URLError as e:</span><br><span class="line">        print(e.reason)</span><br></pre></td></tr></table></figure></blockquote><h3 id="3、urllib-parse"><a href="#3、urllib-parse" class="headerlink" title="3、urllib.parse"></a>3、urllib.parse</h3><p>(1)<code>urllib.parse.urlparse(urlstring, scheme=”, allow_fragments=True)</code><br>用于将一个URL解析成六个部分，返回一个元组，URL的格式为：scheme://netloc/path;parameters?query#fragment</p><p>以下为返回的元组元素：</p><table><thead><tr><th style="text-align:left">元素</th><th style="text-align:left">编号</th><th style="text-align:left">值</th><th style="text-align:left">值不存在时默认值</th></tr></thead><tbody><tr><td style="text-align:left">scheme</td><td style="text-align:left">0</td><td style="text-align:left">请求</td><td style="text-align:left">一定存在</td></tr><tr><td style="text-align:left">netloc</td><td style="text-align:left">1</td><td style="text-align:left">网址</td><td style="text-align:left">空字符串</td></tr><tr><td style="text-align:left">path</td><td style="text-align:left">2</td><td style="text-align:left">分层路径</td><td style="text-align:left">空字符串</td></tr><tr><td style="text-align:left">params</td><td style="text-align:left">3</td><td style="text-align:left">参数</td><td style="text-align:left">空字符串</td></tr><tr><td style="text-align:left">query</td><td style="text-align:left">4</td><td style="text-align:left">查询组件</td><td style="text-align:left">空字符串</td></tr><tr><td style="text-align:left">fragment</td><td style="text-align:left">5</td><td style="text-align:left">标识符</td><td style="text-align:left">空字符串</td></tr><tr><td style="text-align:left">username</td><td style="text-align:left"></td><td style="text-align:left">用户名</td><td style="text-align:left">None</td></tr><tr><td style="text-align:left">password</td><td style="text-align:left"></td><td style="text-align:left">密码</td><td style="text-align:left">None</td></tr><tr><td style="text-align:left">hostname</td><td style="text-align:left"></td><td style="text-align:left">主机名</td><td style="text-align:left">None</td></tr><tr><td style="text-align:left">port</td><td style="text-align:left"></td><td style="text-align:left">端口号</td><td style="text-align:left">None</td></tr></tbody></table><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from urllib import parse</span><br><span class="line"></span><br><span class="line">o = parse.urlparse(&apos;http://www.cwi.nl:80/%7Eguido/Python.html&apos;)</span><br><span class="line"></span><br><span class="line">print(o)</span><br><span class="line"></span><br><span class="line">#对应结果：ParseResult(scheme=&apos;http&apos;, netloc=&apos;www.cwi.nl:80&apos;, path=&apos;/%7Eguido/Python.html&apos;, params=&apos;&apos;, query=&apos;&apos;, fragment=&apos;&apos;)</span><br></pre></td></tr></table></figure></blockquote><p>(2)<code>urllib.parse.urljoin(base, url, allow_fragments=True)</code><br>用于将一个基本的URL和其他的URL组装成成一个完成的URL。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from urllib import parse</span><br><span class="line"></span><br><span class="line">a=arse.urljoin(&apos;http://www.cwi.nl/%7Eguido/Python.html&apos;, &apos;FAQ.html&apos;)</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">#对应结果:http://www.cwi.nl/%7Eguido/FAQ.html</span><br></pre></td></tr></table></figure></blockquote><p>(3)<code>urllib.parse.urlencode(query, doseq=False, safe=&#39;&#39;, encoding=None, errors=None)</code><br>urlencode()主要作用就是将url附上要提交的数据。 </p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from urllib import parse</span><br><span class="line"></span><br><span class="line">data = &#123;  </span><br><span class="line">    &apos;first&apos;: &apos;true&apos;,  </span><br><span class="line">    &apos;pn&apos;: 1,  </span><br><span class="line">    &apos;kd&apos;: &apos;Python&apos;  </span><br><span class="line">&#125;  </span><br><span class="line">data = parse.urlencode(data).encode(&apos;utf-8&apos;)</span><br><span class="line"></span><br><span class="line">#经过urlencode()转换后的data数据为?first=true?pn=1?kd=Python</span><br><span class="line">#最后提交的url为http://www.lagou.com/jobs/positionAjax.json?first=true?pn=1?kd=Python</span><br></pre></td></tr></table></figure></blockquote><h3 id="4、urllib-robotparser"><a href="#4、urllib-robotparser" class="headerlink" title="4、urllib.robotparser"></a>4、urllib.robotparser</h3><p>robotparser为robots.txt文件实现了一个解释器，可以用来读取robots文本的格式和内容，用函数方法检查给定的User-Agent是否可以访问相应的网站资源。如果要编写一个网络蜘蛛，这个模块可以限制一些蜘蛛抓取无用的或者重复的信息，避免蜘蛛掉入动态asp/php网页程序的死循环中。</p><p>简单的来说，robots.txt文件是每个网站都应该有的，指引蜘蛛抓取和禁止抓取的一个文本格式的文件，一些合法的蜘蛛或者叫爬虫，都是遵守这个规则的，可以控制他们的访问。</p><h3 id="5、GET请求"><a href="#5、GET请求" class="headerlink" title="5、GET请求"></a>5、GET请求</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request  </span><br><span class="line">import urllib.parse  </span><br><span class="line">  </span><br><span class="line">data = &#123;&#125;  </span><br><span class="line">data[&apos;word&apos;] = &apos;python3&apos;  </span><br><span class="line">url_values = urllib.parse.urlencode(data)    </span><br><span class="line">  </span><br><span class="line">url = &quot;http://www.baidu.com/s?&quot;  </span><br><span class="line">full_url = url + url_values  </span><br><span class="line">  </span><br><span class="line">data = urllib.request.urlopen(full_url).read()  </span><br><span class="line">z_data = data.decode(&apos;UTF-8&apos;)  </span><br><span class="line">print(z_data)</span><br></pre></td></tr></table></figure></blockquote><h3 id="6、POST数据"><a href="#6、POST数据" class="headerlink" title="6、POST数据"></a>6、POST数据</h3><p><code>urllib.request.urlopen(url, data=None, [timeout, ]*, cafile=None, capath=None, cadefault=False, context=None)</code><br>urlopen()的data参数默认为None，当data参数不为空的时候，urlopen()提交方式为Post。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request  </span><br><span class="line">import urllib.parse</span><br><span class="line"></span><br><span class="line">url = r&apos;http://www.lagou.com/jobs/positionAjax.json?&apos;  </span><br><span class="line">headers = &#123;  </span><br><span class="line">    &apos;User-Agent&apos;: r&apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) &apos;  </span><br><span class="line">                  r&apos;Chrome/45.0.2454.85 Safari/537.36 115Browser/6.0.3&apos;,  </span><br><span class="line">    &apos;Referer&apos;: r&apos;http://www.lagou.com/zhaopin/Python/?labelWords=label&apos;,  </span><br><span class="line">    &apos;Connection&apos;: &apos;keep-alive&apos;  </span><br><span class="line">&#125;  </span><br><span class="line">data = &#123;  </span><br><span class="line">    &apos;first&apos;: &apos;true&apos;,  </span><br><span class="line">    &apos;pn&apos;: 1,  </span><br><span class="line">    &apos;kd&apos;: &apos;Python&apos;  </span><br><span class="line">&#125;  </span><br><span class="line">data = parse.urlencode(data).encode(&apos;utf-8&apos;)  #Post的数据必须是bytes或者iterable of bytes，不能是str，因此需要进行encode()编码</span><br><span class="line"></span><br><span class="line">req = request.Request(url, headers=headers, data=data)  </span><br><span class="line"></span><br><span class="line">page = request.urlopen(req).read()  </span><br><span class="line">page = page.decode(&apos;utf-8&apos;)  </span><br><span class="line">print(page)</span><br></pre></td></tr></table></figure></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a>持续更新…</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生苦短，我用python。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://pythonfood.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://pythonfood.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python数据库</title>
    <link href="http://pythonfood.github.io/2017/12/28/python%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://pythonfood.github.io/2017/12/28/python数据库/</id>
    <published>2017-12-28T12:40:00.000Z</published>
    <updated>2018-03-23T08:43:46.085Z</updated>
    
    <content type="html"><![CDATA[<p>人生苦短，我用python。<br><a id="more"></a></p><h2 id="一、pymysql模块"><a href="#一、pymysql模块" class="headerlink" title="一、pymysql模块"></a>一、pymysql模块</h2><p>PyMySQL是在Python3.x版本中用于连接MySQL服务器的一个库。</p><h3 id="1、pymysql安装"><a href="#1、pymysql安装" class="headerlink" title="1、pymysql安装"></a>1、pymysql安装</h3><p>(1)pip命令安装</p><blockquote><p><code>pip install PyMySQL</code></p></blockquote><p>(2)git命令下载安装</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/PyMySQL/PyMySQL</span><br><span class="line">$ cd PyMySQL/</span><br><span class="line">$ python3 setup.py install</span><br></pre></td></tr></table></figure></blockquote><p>(3)curl命令制定版本号</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L https://github.com/PyMySQL/PyMySQL/tarball/pymysql-X.X | tar xz</span><br><span class="line">$ cd PyMySQL* # 安装完可以删除PyMySQL*目录</span><br><span class="line">$ python3 setup.py install</span><br></pre></td></tr></table></figure></blockquote><h3 id="2、数据库连接"><a href="#2、数据库连接" class="headerlink" title="2、数据库连接"></a>2、数据库连接</h3><p>使用数据库之前确保创建了数据库testdb，用户名”root”，密码”123456”。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line">#1.使用connect()方法连接数据库</span><br><span class="line">db = pymysql.connect(&apos;localhost&apos;, &apos;root&apos;, &apos;123456&apos;, &apos;testdb&apos;)</span><br><span class="line"></span><br><span class="line">#2.使用cursor()方法创建游标对象</span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line">#3.使用execute()方法执行SQL语句</span><br><span class="line">cursor.execute(&apos;SELECT VERSION()&apos;)</span><br><span class="line"></span><br><span class="line">#4.使用fetchone()方法获取表单数据</span><br><span class="line">data = cursor.fetchone()</span><br><span class="line"></span><br><span class="line">print(&quot;Database version : s%&quot; % data)</span><br><span class="line"></span><br><span class="line">#5.使用close()方法关闭数据库连接</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure></blockquote><h3 id="3、创建数据库表"><a href="#3、创建数据库表" class="headerlink" title="3、创建数据库表"></a>3、创建数据库表</h3><p><code>execute()</code>方法执行sql语句为数据库创建表。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line">#1.使用connect()方法连接数据库</span><br><span class="line">db = pymysql.connect(&apos;localhost&apos;, &apos;root&apos;, &apos;123456&apos;, &apos;testdb&apos;)</span><br><span class="line"></span><br><span class="line">#2.使用cursor()方法创建游标对象</span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line">#3.如果user表已经存在，先删除</span><br><span class="line">cursor.execute(&quot;DROP TABLE IF EXISTS user&quot;)</span><br><span class="line"></span><br><span class="line">#4.使用预处理语句创建user表</span><br><span class="line">sql = &quot;&quot;&quot;CREATE TABLE user(</span><br><span class="line"> NAME CHAR(20) NOT NULL,</span><br><span class="line"> AGE INT,</span><br><span class="line"> SEX CHAR(1),</span><br><span class="line"> INCOME FLOAT)&quot;&quot;&quot;</span><br><span class="line">cursor.execute(sql)</span><br><span class="line"></span><br><span class="line">#5.使用close()方法关闭数据库连接</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure></blockquote><h3 id="4、数据库插入操作"><a href="#4、数据库插入操作" class="headerlink" title="4、数据库插入操作"></a>4、数据库插入操作</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line">#1.使用connect()方法连接数据库</span><br><span class="line">db = pymsql.connect(&apos;localhost&apos;, &apos;root&apos;, &apos;123456&apos;, &apos;testdb&apos;)</span><br><span class="line"></span><br><span class="line">#2.使用cursor()方法创建游标对象</span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line">#3.sql插入语句</span><br><span class="line">sql = &quot;&quot;&quot;INSERT INTO user(NAME,AGE,SEX,INCOME)</span><br><span class="line"> VALUES(&apos;Jac&apos;,&apos;20&apos;,&apos;M&apos;,2000)&quot;&quot;&quot;</span><br><span class="line"> </span><br><span class="line">#4.执行sql插入操作</span><br><span class="line">try:</span><br><span class="line">cursor.execute(sql)</span><br><span class="line">db.commit() #注意：提交到数据库执行</span><br><span class="line">except:</span><br><span class="line">db.rollback() #注意：如果发生错误则回滚</span><br><span class="line"></span><br><span class="line">#5.使用close()方法关闭数据库连接</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure></blockquote><p>ps:可以使用变量向SQL语句中传递参数</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">user_id = &quot;test1&quot;</span><br><span class="line">password = &quot;123456&quot;</span><br><span class="line"></span><br><span class="line">con.execute(&apos;insert into Login values(&quot;%s&quot;, &quot;%s&quot;)&apos; % \</span><br><span class="line">             (user_id, password))</span><br></pre></td></tr></table></figure></blockquote><h3 id="5、数据库删除操作"><a href="#5、数据库删除操作" class="headerlink" title="5、数据库删除操作"></a>5、数据库删除操作</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line">#1.使用connect()方法连接数据库</span><br><span class="line">db = pymsql.connect(&apos;localhost&apos;, &apos;root&apos;, &apos;123456&apos;, &apos;testdb&apos;)</span><br><span class="line"></span><br><span class="line">#2.使用cursor()方法创建游标对象</span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line">#3.sql删除语句</span><br><span class="line">sql = &quot;DELETE FROM user WHERE AGE &gt; &apos;%d&apos;&quot; % (20)</span><br><span class="line"></span><br><span class="line">#4.执行sql删除操作</span><br><span class="line">try:</span><br><span class="line">cursor.execute(sql)</span><br><span class="line">db.commite() #注意：提交到数据库执行</span><br><span class="line">except:</span><br><span class="line">db.rollback() #注意：如果发生错误则回滚</span><br><span class="line"></span><br><span class="line">#5.使用close()方法关闭数据库连接</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure></blockquote><h3 id="6、数据库更新操作"><a href="#6、数据库更新操作" class="headerlink" title="6、数据库更新操作"></a>6、数据库更新操作</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line">#1.使用connect()方法连接数据库</span><br><span class="line">db = pymysql.connect(&apos;localhost&apos;, &apos;root&apos;, &apos;123456&apos;,&apos;testdb&apos;)</span><br><span class="line"></span><br><span class="line">#2.使用cursor()方法创建游标对象</span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line">#3.sql删除语句</span><br><span class="line">sql = &quot;UPDATE user SET AGE = AGE + 1 WHERE SEX = &apos;%c&apos;&quot; % (&apos;W&apos;)</span><br><span class="line"></span><br><span class="line">#4.执行sql删除操作</span><br><span class="line">try:</span><br><span class="line">cursor.execute(sql)</span><br><span class="line">db.commite() #注意：提交到数据库执行</span><br><span class="line">except:</span><br><span class="line">db.rollback() #注意：如果发生错误则回滚</span><br><span class="line"></span><br><span class="line">#5.使用close()方法关闭数据库连接</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure></blockquote><h3 id="7、数据库查询操作"><a href="#7、数据库查询操作" class="headerlink" title="7、数据库查询操作"></a>7、数据库查询操作</h3><p>使用fetchone()方法获取单条数据, 使用fetchall()方法获取多条数据。</p><ul><li><code>fetchone()</code>: 该方法获取下一个查询结果集。结果集是一个对象。</li><li><code>fetchall()</code>: 接收全部的返回结果行。</li><li><code>rowcount</code>: 这是一个只读属性，并返回执行execute()方法后影响的行数。</li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line">#1.使用connect()方法连接数据库</span><br><span class="line">db = pymysql.connect(&apos;localhost&apos;, &apos;root&apos;, &apos;123456&apos;, &apos;testdb&apos;)</span><br><span class="line"></span><br><span class="line">#2.使用cursor()方法创建游标对象</span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line">#3.sql查询语句</span><br><span class="line">sql = &quot;SELECT * FROM user \</span><br><span class="line">   WHERE INCOME &gt; &apos;%d&apos;&quot; % (1000)</span><br><span class="line"></span><br><span class="line">#4.执行sql查询操作   </span><br><span class="line">try:</span><br><span class="line">cursor.execute(sql)</span><br><span class="line">results = cursor.fetchall() #查询所有记录列表</span><br><span class="line">for row in results:</span><br><span class="line">name = row[0]</span><br><span class="line">age = row[1]</span><br><span class="line">sex = row[2]</span><br><span class="line">income = row[3]</span><br><span class="line">print(&quot;name=%s,age=%s,sex=%s,income=%d&quot; % \</span><br><span class="line">(name, age, sex, income)) #打印结果</span><br><span class="line">except:</span><br><span class="line">print(&apos;Error: unable to fetch data&apos;)</span><br><span class="line"></span><br><span class="line">#5.使用close()方法关闭数据库连接</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure></blockquote><h3 id="8、执行事务"><a href="#8、执行事务" class="headerlink" title="8、执行事务"></a>8、执行事务</h3><p>事务机制可以确保数据一致性。</p><p>事务具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。</p><ul><li>原子性（atomicity）：一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。</li><li>一致性（consistency）：事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。</li><li>隔离性（isolation）：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li><li>持久性（durability）：持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。 </li></ul><p>Python DB API 2.0的事务提供了两个方法<code>commit()</code>或<code>rollback()</code>。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sql = &quot;DELETE FROM user WHERE INCOME &gt; &apos;%d&apos;&quot; % (1000)</span><br><span class="line">try:</span><br><span class="line">   cursor.execute(sql) # 执行SQL语句</span><br><span class="line">   db.commit()# commit() # 方法游标的所有更新操作</span><br><span class="line">except:</span><br><span class="line">   db.rollback() # rollback() # 方法回滚当前游标的所有操作</span><br></pre></td></tr></table></figure></blockquote><h3 id="9、错误处理"><a href="#9、错误处理" class="headerlink" title="9、错误处理"></a>9、错误处理</h3><table><thead><tr><th style="text-align:left">异常</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Warning</td><td style="text-align:left">当有严重警告时触发，例如插入数据是被截断等等。必须是 StandardError 的子类。</td></tr><tr><td style="text-align:left">Error</td><td style="text-align:left">警告以外所有其他错误类。必须是 StandardError 的子类。</td></tr><tr><td style="text-align:left">InterfaceError</td><td style="text-align:left">当有数据库接口模块本身的错误（而不是数据库的错误）发生时触发。 必须是Error的子类。</td></tr><tr><td style="text-align:left">DatabaseError</td><td style="text-align:left">和数据库有关的错误发生时触发。 必须是Error的子类。</td></tr><tr><td style="text-align:left">DataError</td><td style="text-align:left">当有数据处理时的错误发生时触发，例如：除零错误，数据超范围等等。 必须是DatabaseError的子类。</td></tr><tr><td style="text-align:left">OperationalError</td><td style="text-align:left">指非用户控制的，而是操作数据库时发生的错误。例如：连接意外断开、 数据库名未找到、事务处理失败、内存分配错误等等操作数据库是发生的错误。 必须是DatabaseError的子类。</td></tr><tr><td style="text-align:left">IntegrityError</td><td style="text-align:left">完整性相关的错误，例如外键检查失败等。必须是DatabaseError子类。</td></tr><tr><td style="text-align:left">InternalError</td><td style="text-align:left">数据库的内部错误，例如游标（cursor）失效了、事务同步失败等等。 必须是DatabaseError子类。</td></tr><tr><td style="text-align:left">ProgrammingError</td><td style="text-align:left">程序错误，例如数据表（table）没找到或已存在、SQL语句语法错误、 参数数量错误等等。必须是DatabaseError的子类。</td></tr><tr><td style="text-align:left">NotSupportedError</td><td style="text-align:left">不支持错误，指使用了数据库不支持的函数或API等。例如在连接对象上 使用.rollback()函数，然而数据库并不支持事务或者事务已关闭。 必须是DatabaseError的子类。</td></tr></tbody></table><h2 id="二、sqlite3模块"><a href="#二、sqlite3模块" class="headerlink" title="二、sqlite3模块"></a>二、sqlite3模块</h2><p>SQLite是C写的一种嵌入式数据库，它的数据库就是一个文件，体积很小，经常被集成到各种应用程序中。<br>Python内置SQLite3，使用SQLite不需要安装任何东西，直接使用。</p><p>创建数据库的连接，如果数据库不存在，连接对象会自动创建数据库文件；如果数据库存在，则连接对象直接打开该数据库文件。<br>连接对象可以是硬盘上面的数据库文件，也可以是建立在内存中的：</p><ul><li>创建在硬盘上面： <code>conn = sqlite3.connect(&#39;c:\\test\\test.db&#39;)</code></li><li>创建在内存上面： <code>conn = sqlite3.connect(&#39;&quot;memory:&#39;)</code></li></ul><p>其中conn对象是数据库链接对象，具有以下操作：</p><ul><li><code>cursor()</code> : 创建一个游标</li><li><code>commit()</code> : 事务提交</li><li><code>rollback()</code> : 事务回滚</li><li><code>close()</code> : 关闭数据库链接</li></ul><p>创建了一个游标对象 ：<code>cu = conn.cursor()</code>，具有以下具体操作：</p><ul><li><code>execute()</code> : 执行一条sql语句</li><li><code>executemany()</code> : 执行多条sql语句</li><li><code>close()</code> : 游标关闭</li><li><code>fetchone()</code> : 从结果中取出一条记录</li><li><code>fetchmany()</code> : 从结果中取出多条记录</li><li><code>fetchall()</code> : 从结果中取出所有记录</li><li><code>scroll()</code> : 游标滚动</li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import sqlite3</span><br><span class="line">  </span><br><span class="line">#创建数据库  </span><br><span class="line">conn = sqlite3.connect(&apos;test.db&apos;) </span><br><span class="line">#创建游标 </span><br><span class="line">cur = conn.cursor()  </span><br><span class="line"></span><br><span class="line">#创建数据表</span><br><span class="line">cur.execute(&apos;create table t(id int,v varchar(20));&apos;);   </span><br><span class="line">#数据库操作</span><br><span class="line">cur.execute(&quot;insert into t values(%d,&apos;%s&apos;)&quot; % (1,&apos;xxx&apos;))  </span><br><span class="line">cur.execute(&quot;insert into t values(%d,&apos;%s&apos;)&quot; % (2,&apos;yyy&apos;))    </span><br><span class="line">cur.execute(&quot;update t set v = &apos;%s&apos; where id = %d&quot; % (&apos;zzz&apos;,2))   </span><br><span class="line">cur.execute(&quot;select * from t;&quot;) </span><br><span class="line">#打印结果  </span><br><span class="line">results = cur.fetchall()   </span><br><span class="line">for row in results:  </span><br><span class="line">    print(row)  </span><br><span class="line">#事务提交</span><br><span class="line">conn.commit() </span><br><span class="line"> </span><br><span class="line">#关闭游标 </span><br><span class="line">cur.close() </span><br><span class="line">#关闭数据库连接 </span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a>持续更新…</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生苦短，我用python。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://pythonfood.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://pythonfood.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python发送邮件</title>
    <link href="http://pythonfood.github.io/2017/12/28/python%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"/>
    <id>http://pythonfood.github.io/2017/12/28/python发送邮件/</id>
    <published>2017-12-28T12:30:00.000Z</published>
    <updated>2018-03-29T08:52:58.400Z</updated>
    
    <content type="html"><![CDATA[<p>人生苦短，我用python。<br><a id="more"></a></p><h2 id="一、email模块"><a href="#一、email模块" class="headerlink" title="一、email模块"></a>一、email模块</h2><p>SMTP是发送邮件的协议，Python对SMTP支持有email和smtplib两个模块，email负责构造邮件，smtplib负责发送邮件。</p><ul><li><p><code>email.header.Header(s=None, charset=None, maxlinelen=None, header_name=None, continuation_ws=&#39; &#39;, errors=&#39;strict&#39;)</code>：邮件头</p><blockquote><ul><li><code>s</code>：标头的值，也就是对应From、To、Subject的值。</li><li><code>charset</code>：字符集格式，默认是ASCII，但是一般指定UTF-8格式以兼容更多字符。 </li><li><code>header_name</code>: 标头名，就是From、To、Subject、Time等；</li></ul></blockquote></li><li><p><code>email.mime.base.MIMEBase(_maintype, _subtype, **_params)</code>：这是MIME的一个基类。一般不需要在使用时创建实例。</p><blockquote><ul><li><code>_maintype</code>：是内容类型,如text或者image。</li><li><code>_subtype</code>：是内容的minor type类型，如plain或者gif。</li><li><code>**_params</code>：是一个字典，直接传递给Message.add_header()。</li></ul></blockquote></li><li><p><code>email.mime.multipart.MIMEMultipart([_subtype[, boundary[, _subparts[, _params]]]]</code>：MIMEBase的一个子类,多个MIME对象的集合。</p><blockquote><ul><li><code>_subtype</code>：默认值为mixed。</li><li><code>boundary</code>：是MIMEMultipart的边界,默认边界是可数的。</li></ul></blockquote></li><li><p><code>email.mime.APPLICATION.MIMEApplication(_data[, _subtype[, _encoder[, **_params]]])</code>：MIMEMultipart的一个子类。</p></li><li><p><code>email.mime.audio. MIMEAudio(_audiodata[, _subtype[, _encoder[, **_params]]])</code>：MIME音频对象。</p></li><li><p><code>email.mime.image.MIMEImage(_imagedata[, _subtype[, _encoder[, **_params]]])</code>：MIME二进制文件对象。</p></li><li><p><code>email.mime.text.MIMEText(_text[,_subtype[,_charset]])</code>：MIME文本对象。</p><blockquote><ul><li><code>_text</code>：是邮件内容,</li><li><code>_subtype</code>：邮件类型,可以是text/plain(普通文本邮件),html/plain(html邮件)。</li><li><code>charset</code>：编码,可以是gb2312等等。</li></ul></blockquote></li><li><p><code>email.mime.message.MIMEMessage(_msg[, _subtype])</code>：具体的一个message实例。</p><blockquote><ul><li><code>msg=mail.Message.Message()</code> # 一个实例</li><li><code>msg[&#39;from&#39;]=&#39;me@xxx.com&#39;</code> # 自己的邮件地址</li><li><code>msg[&#39;to&#39;]=&#39;friend@xxx.com&#39;</code> # 发送到哪里</li><li><code>msg[&#39;date&#39;]=&#39;2012-3-16&#39;</code> # 时间日期</li><li><code>msg[&#39;subject&#39;]=&#39;helloworld&#39;</code> # 邮件主题</li></ul></blockquote></li></ul><h2 id="二、smtplib模块"><a href="#二、smtplib模块" class="headerlink" title="二、smtplib模块"></a>二、smtplib模块</h2><p>SMTP是发送邮件的协议，Python对SMTP支持有email和smtplib两个模块，email负责构造邮件，smtplib负责发送邮件。</p><ul><li><p><code>smtplib.SMTP([host[, port[, local_hostname[, timeout]]]])</code>：SMTP类构造函数,表示与SMTP服务器之间的连接,通过这个连接可以向smtp服务器发送指令,执行相关操作(如:登陆、发送邮件)。所有参数都是可选的。</p><blockquote><ul><li><code>host</code>：smtp服务器主机名</li><li><code>port</code>：smtp服务的端口,默认是25;如果在创建SMTP对象的时候提供了这两个参数,在初始化的时候会自动调用connect方法去连接服务器。</li></ul></blockquote></li><li><p>smtplib.SMTP提供的方法:</p><blockquote><ul><li><code>SMTP.set_debuglevel(level)</code>：设置是否为调试模式。默认为False,即非调试模式,表示不输出任何调试信息。</li><li><code>SMTP.connect([host[, port]])</code>：连接到指定的smtp服务器。参数分别表示smpt主机和端口。注意: 也可以在host参数中指定端口号(如:smpt.yeah.net:25),这样就没必要给出port参数。</li><li><code>SMTP.docmd(cmd[, argstring])</code>：向smtp服务器发送指令。可选参数argstring表示指令的参数。</li><li><code>SMTP.helo([hostname])</code>：使用”helo”指令向服务器确认身份。相当于告诉smtp服务器“我是谁”。</li><li><code>SMTP.has_extn(name)</code>：判断指定名称在服务器邮件列表中是否存在。出于安全考虑,smtp服务器往往屏蔽了该指令。</li><li><code>SMTP.verify(address)</code>：判断指定邮件地址是否在服务器中存在。出于安全考虑,smtp服务器往往屏蔽了该指令。</li><li><code>SMTP.login(user, password)</code>：登陆到smtp服务器。现在几乎所有的smtp服务器,都必须在验证用户信息合法之后才允许发送邮件。</li><li><code>SMTP.sendmail(from_addr, to_addrs, msg[, mail_options, rcpt_options])</code>：发送邮件。这里要注意一下第三个参数,msg是字符串,表示邮件。我们知道邮件一般由标题,发信人,收件人,邮件内容,附件等构成,发送邮件的时候,要注意msg的格式。这个格式就是smtp协议中定义的格式。</li><li><code>SMTP.quit()</code>：断开与smtp服务器的连接,相当于发送”quit”指令。(很多程序中都用到了smtp.close())</li></ul></blockquote></li></ul><h2 id="三、发送邮件"><a href="#三、发送邮件" class="headerlink" title="三、发送邮件"></a>三、发送邮件</h2><h3 id="1、发送文本邮件"><a href="#1、发送文本邮件" class="headerlink" title="1、发送文本邮件"></a>1、发送文本邮件</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from email.header import Header</span><br><span class="line">from email.mime.text import MIMEText</span><br><span class="line">import smtplib</span><br><span class="line"></span><br><span class="line">#一.构建邮件内容信息</span><br><span class="line">message = MIMEText(&apos;邮件正文测试...此处省略一万字&apos;, &apos;plain&apos;, &apos;utf-8&apos;) #1.邮件正文，plain表示普通文本</span><br><span class="line">message[&apos;Subject&apos;] = Header(&apos;邮件标题测试&apos;, &apos;utf-8&apos;) #2.邮件标题，中文用Header编码</span><br><span class="line">message[&apos;From&apos;] = Header(&apos;发件人的名称测试&apos;, &apos;utf-8&apos;) #3.发件人名称</span><br><span class="line">message[&apos;To&apos;] = Header(&apos;收件人名称测试&apos;, &apos;utf-8&apos;) #4.收件人名称</span><br><span class="line"></span><br><span class="line">#二.定义邮件服务器信息</span><br><span class="line">mail_host = &apos;smpt.xxx.com&apos; #1.邮件服务器</span><br><span class="line">mail_user = &apos;username&apos; #2.登录服务器的用户名</span><br><span class="line">mail_pass = &apos;password&apos; #3.登录服务器的密码</span><br><span class="line"></span><br><span class="line">#三.定义发件人和收件人</span><br><span class="line">sender = &apos;me@163.com&apos; #1.发件人邮箱</span><br><span class="line">receivers = [&apos;friend@126.com&apos;] #2.收件人邮箱，注意可以是列表</span><br><span class="line"></span><br><span class="line">#四.邮件服务器发送邮件</span><br><span class="line">smtp_server = smtplib.SMTP() #1.声明邮件服务器</span><br><span class="line">smtp_server.connect(mail_host, 25) #2.连接服务器，端口25</span><br><span class="line">smtp_server.login(mail_user, mail_pass) #3.登录服务器</span><br><span class="line">smtp_server.sendmail(sender, receivers, message.as_string()) #4.服务器发送邮件</span><br><span class="line">smtp_server.quit() #5.退出服务器</span><br></pre></td></tr></table></figure></blockquote><h3 id="2、发送html邮件"><a href="#2、发送html邮件" class="headerlink" title="2、发送html邮件"></a>2、发送html邮件</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">from email.header import Header</span><br><span class="line">from email.mime.text import MIMEText</span><br><span class="line">import smtplib</span><br><span class="line"></span><br><span class="line">#一.构建邮件内容信息</span><br><span class="line">#定义html格式内容</span><br><span class="line">msg_html = &quot;&quot;&quot;</span><br><span class="line">&lt;p&gt;邮件正文测试...此处省略一万字&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;a href=&quot;http://www.baidu.com&quot;&gt;点击进入百度&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">message = MIMEText(msg_html, &apos;html&apos;, &apos;utf-8&apos;) #1.邮件正文，html表示html格式</span><br><span class="line">message[&apos;Subject&apos;] = Header(&apos;邮件标题测试&apos;, &apos;utf-8&apos;) #2.邮件标题，中文用Header编码</span><br><span class="line">message[&apos;From&apos;] = Header(&apos;发件人的名称测试&apos;, &apos;utf-8&apos;) #3.发件人名称</span><br><span class="line">message[&apos;To&apos;] = Header(&apos;收件人名称测试&apos;, &apos;utf-8&apos;) #4.收件人名称</span><br><span class="line"></span><br><span class="line">#二.定义邮件服务器信息</span><br><span class="line">mail_host = &apos;smpt.xxx.com&apos; #1.邮件服务器</span><br><span class="line">mail_user = &apos;username&apos; #2.登录服务器的用户名</span><br><span class="line">mail_pass = &apos;password&apos; #3.登录服务器的密码</span><br><span class="line"></span><br><span class="line">#三.定义发件人和收件人邮箱</span><br><span class="line">sender = &apos;me@163.com&apos; #1.发件人邮箱</span><br><span class="line">receivers = [&apos;friend@126.com&apos;] #2.收件人邮箱，注意可以是列表</span><br><span class="line"></span><br><span class="line">#四.邮件服务器发送邮件</span><br><span class="line">smtp_server = smtplib.SMTP() #1.声明邮件服务器</span><br><span class="line">smtp_server.connect(mail_host, 25) #2.连接服务器，端口25</span><br><span class="line">smtp_server.login(mail_user, mail_pass) #3.登录服务器</span><br><span class="line">smtp_server.sendmail(sender, receivers, message.as_string()) #4.服务器发送邮件</span><br><span class="line">smtp_server.quit() #5.退出服务器</span><br></pre></td></tr></table></figure></blockquote><h3 id="3、发送带附件邮件"><a href="#3、发送带附件邮件" class="headerlink" title="3、发送带附件邮件"></a>3、发送带附件邮件</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">from email.header import Header</span><br><span class="line">from email.mime.text import MIMEText</span><br><span class="line">from email.mime.multipart import MIMEMultipart</span><br><span class="line">import smtplib</span><br><span class="line"></span><br><span class="line">#一.构建带附件的实例</span><br><span class="line">message = MIMEMultipart() #1.带附件实例</span><br><span class="line">message[&apos;Subject&apos;] = Header(&apos;邮件标题测试&apos;, &apos;utf-8&apos;) #2.邮件标题，中文用Header编码</span><br><span class="line">message[&apos;From&apos;] = Header(&apos;发件人的名称测试&apos;, &apos;utf-8&apos;) #3.发件人名称</span><br><span class="line">message[&apos;To&apos;] = Header(&apos;收件人名称测试&apos;, &apos;utf-8&apos;) #4.收件人名称</span><br><span class="line"></span><br><span class="line">#二、增加邮件正文内容</span><br><span class="line">message.attach(MIMEText(&apos;邮件正文测试...此处省略一万字&apos;, &apos;plain&apos;, &apos;utf-8&apos;)) #1.邮件正文，plain表示普通文本</span><br><span class="line"></span><br><span class="line">#三、添加附件</span><br><span class="line">with open(&apos;/Users/tester/Downloads/test.xlsx&apos;, &apos;rb&apos;) as xlsxpart: #1.用with打开，防止不能关闭文件</span><br><span class="line">att = MIMEText(xlsxpart.read(), &apos;base64&apos;, &apos;utf-8&apos;) #2.定义附件</span><br><span class="line">att.add_header(&apos;Content-Disposition&apos;, &apos;attachment&apos;, filename=&apos;test.xlsx&apos;) #3.添加必要的头信息</span><br><span class="line">message.attach(att) #4.添加附件</span><br><span class="line"></span><br><span class="line">#四.定义邮件服务器信息</span><br><span class="line">mail_host = &apos;smpt.xxx.com&apos; #1.邮件服务器</span><br><span class="line">mail_user = &apos;username&apos; #2.登录服务器的用户名</span><br><span class="line">mail_pass = &apos;password&apos; #3.登录服务器的密码</span><br><span class="line"></span><br><span class="line">#五.定义发件人和收件人</span><br><span class="line">sender = &apos;me@163.com&apos; #1.发件人邮箱</span><br><span class="line">receivers = [&apos;friend@126.com&apos;] #2.收件人邮箱，注意可以是列表</span><br><span class="line"></span><br><span class="line">#六.邮件服务器发送邮件</span><br><span class="line">smtp_server = smtplib.SMTP() #1.声明邮件服务器</span><br><span class="line">smtp_server.connect(mail_host, 25) #2.连接服务器，端口25</span><br><span class="line">smtp_server.login(mail_user, mail_pass) #3.登录服务器</span><br><span class="line">smtp_server.sendmail(sender, receivers, message.as_string()) #4.服务器发送邮件</span><br><span class="line">smtp_server.quit() #5.退出服务器</span><br></pre></td></tr></table></figure></blockquote><h3 id="4、发送带图片邮件"><a href="#4、发送带图片邮件" class="headerlink" title="4、发送带图片邮件"></a>4、发送带图片邮件</h3><p>按照发送附件的方式，先把邮件作为附件添加进去，然后，在HTML中通过引用<code>src=&quot;cid:0&quot;</code>就可以把附件作为图片嵌入了。如果有多个图片，给它们依次编号，然后引用不同的<code>cid:x</code>即可。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">from email.header import Header</span><br><span class="line">from email.mime.text import MIMEText</span><br><span class="line">from email.mime.image import MIMEImage</span><br><span class="line">from email.mime.multipart import MIMEMultipart</span><br><span class="line">import smtplib</span><br><span class="line"></span><br><span class="line">#一.构建带附件的实例</span><br><span class="line">msgroot = MIMEMultipart(&apos;relate&apos;) #1.带附件实例,relate可以存储图片</span><br><span class="line">msgroot[&apos;Subject&apos;] = Header(&apos;邮件标题测试&apos;, &apos;utf-8&apos;) #2.邮件标题，中文用Header编码</span><br><span class="line">msgroot[&apos;From&apos;] = Header(&apos;发件人的名称测试&apos;, &apos;utf-8&apos;) #3.发件人名称</span><br><span class="line">msgroot[&apos;To&apos;] = Header(&apos;收件人名称测试&apos;, &apos;utf-8&apos;) #4.收件人名称</span><br><span class="line"></span><br><span class="line">#二、构建超文本实例</span><br><span class="line">msgAlternative = MIMEMultipart(&apos;alternative&apos;) #1.arternative邮件可以同时存在纯文本和超文本内容</span><br><span class="line">msgRoot.attach(msgAlternative) #2.添加到附件实例</span><br><span class="line"></span><br><span class="line">#三、超文本实例添加html内容</span><br><span class="line">#html内容，图片cid定义image1</span><br><span class="line">msg_html = &quot;&quot;&quot;</span><br><span class="line">&lt;p&gt;邮件正文测试...此处省略一万字&lt;/p&gt;</span><br><span class="line">&lt;p&gt;图片展示:&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;img src=&quot;cid:image1&quot;&gt;&lt;/p&gt;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">msgAlternative.attach(MIMEText(msg_html, &apos;html&apos;, &apos;utf-8&apos;)) #添加html内容到超文本实例</span><br><span class="line"></span><br><span class="line">#四、附件实例添加邮件正文内容</span><br><span class="line">msgRoot.attach(MIMEText(&apos;邮件正文测试...此处省略一万字&apos;, &apos;plain&apos;, &apos;utf-8&apos;)) #1.邮件正文，plain表示普通文本</span><br><span class="line"></span><br><span class="line">#五、添加图片附件</span><br><span class="line">with open(&apos;/Users/tester/Downloads/test.png&apos;, &apos;rb&apos;) as imagepart: #1.用with打开，防止不能关闭文件</span><br><span class="line">att = MIMEImage(imagepart.read(), &apos;base64&apos;, &apos;utf-8&apos;) #2.定义附件</span><br><span class="line">att.add_header(&apos;Content-Disposition&apos;, &apos;attachment&apos;, filename=&apos;test.png&apos;) #3.添加必要的头信息</span><br><span class="line">att.add_header(&apos;Content-ID&apos;, &apos;&lt;image1&gt;&apos;) #4.头信息添加图片cid</span><br><span class="line">msgRoot.attach(att) #5.添加附件</span><br><span class="line"></span><br><span class="line">#六.定义邮件服务器信息</span><br><span class="line">mail_host = &apos;smpt.xxx.com&apos; #1.邮件服务器</span><br><span class="line">mail_user = &apos;username&apos; #2.登录服务器的用户名</span><br><span class="line">mail_pass = &apos;password&apos; #3.登录服务器的密码</span><br><span class="line"></span><br><span class="line">#七.定义发件人和收件人</span><br><span class="line">sender = &apos;me@163.com&apos; #1.发件人邮箱</span><br><span class="line">receivers = [&apos;friend@126.com&apos;] #2.收件人邮箱，注意可以是列表</span><br><span class="line"></span><br><span class="line">#八.邮件服务器发送邮件</span><br><span class="line">smtp_server = smtplib.SMTP() #1.声明邮件服务器</span><br><span class="line">smtp_server.connect(mail_host, 25) #2.连接服务器，端口25</span><br><span class="line">smtp_server.login(mail_user, mail_pass) #3.登录服务器</span><br><span class="line">smtp_server.sendmail(sender, receivers, msgRoot.as_string()) #4.服务器发送邮件</span><br><span class="line">smtp_server.quit() #5.退出服务器</span><br></pre></td></tr></table></figure></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a>持续更新…</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生苦短，我用python。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://pythonfood.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://pythonfood.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python多进程</title>
    <link href="http://pythonfood.github.io/2017/12/28/python%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    <id>http://pythonfood.github.io/2017/12/28/python多进程/</id>
    <published>2017-12-28T12:20:00.000Z</published>
    <updated>2018-03-21T10:10:29.149Z</updated>
    
    <content type="html"><![CDATA[<p>人生苦短，我用python。<br><a id="more"></a></p><h2 id="一、进程"><a href="#一、进程" class="headerlink" title="一、进程"></a>一、进程</h2><ul><li>定义方面：进程是程序在某个数据集合上的一次运行活动；线程是进程中的一个执行路径。</li><li>角色方面：在支持线程机制的系统中，进程是系统资源分配的单位，线程是系统调度的单位。</li><li>资源共享方面：进程之间不能共享资源，而线程共享所在进程的地址空间和其它资源。同时线程还有自己的栈和栈指针，程序计数器等寄存器。</li><li>独立性方面：进程有自己独立的地址空间，而线程没有，线程必须依赖于进程而存在。</li></ul><h2 id="二、multiprocessing模块"><a href="#二、multiprocessing模块" class="headerlink" title="二、multiprocessing模块"></a>二、multiprocessing模块</h2><p>multiprocessing模块用来开启子进程，并在子进程中执行我们定制的任务（比如函数），该模块与多线程模块threading的编程接口类似。</p><p>multiprocessing模块的功能众多：支持子进程、通信和共享数据、执行不同形式的同步，提供了Process、Queue、Pipe、Lock等组件。</p><p>需要再次强调的一点是：与线程不同，进程没有任何共享状态，进程修改的数据，改动仅限于该进程内。</p><h3 id="1、Process类"><a href="#1、Process类" class="headerlink" title="1、Process类"></a>1、Process类</h3><p>Process类用来描述一个进程对象。创建子进程的时候，只需要传入一个执行函数和函数的参数即可完成Process实例的创建。<br><code>Process([group [, target [, name [, args [, kwargs]]]]])</code></p><p>参数介绍：</p><ul><li>group：参数未使用，值始终为None</li><li>target：表示调用对象，即子进程要执行的任务</li><li>args：表示调用对象的位置参数元组，args=(1,2,’hexin’,)</li><li>kwargs：表示调用对象的字典,kwargs={‘name’:’hexin’,’age’:18}</li><li>name：为子进程的名称</li></ul><p>方法介绍</p><ul><li><code>p.start()</code>：启动进程，并调用该子进程中的p.run() </li><li><code>p.run()</code>:进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法  </li><li><code>p.terminate()</code>:强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁</li><li><code>p.is_alive()</code>:如果p仍然运行，返回True</li><li><code>p.join([timeout])</code>:主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程</li></ul><p>属性介绍</p><ul><li><code>p.daemon</code>：默认值为False，如果设为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须在p.start()之前设置</li><li><code>p.name</code>: 进程的名称</li><li><code>p.pid</code>：进程的pid</li><li><code>p.exitcode</code>: 进程在运行时为None、如果为–N，表示被信号N结束(了解即可)</li><li><code>p.authkey</code>: 进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可）</li></ul><h3 id="2、创建进程"><a href="#2、创建进程" class="headerlink" title="2、创建进程"></a>2、创建进程</h3><p>(1)用multiprocessing.multiprocessing直接创建进程</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">import random</span><br><span class="line">from multiprocessing import Process</span><br><span class="line"></span><br><span class="line">def hello(name):</span><br><span class="line">    print(&apos;%s hello&apos; %name)</span><br><span class="line">    time.sleep(random.randrange(1,5))</span><br><span class="line">    print(&apos;%s bye end&apos; %name)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">p1=Process(target=hello,args=(&apos;e&apos;,)) </span><br><span class="line">p2=Process(target=hello,args=(&apos;a&apos;,))</span><br><span class="line">p3=Process(target=hello,args=(&apos;w&apos;,))</span><br><span class="line">p4=Process(target=hello,args=(&apos;y&apos;,))</span><br><span class="line"></span><br><span class="line">p1.start()</span><br><span class="line">p2.start()</span><br><span class="line">p3.start()</span><br><span class="line">p4.start()</span><br><span class="line">print(&apos;主线程&apos;)</span><br></pre></td></tr></table></figure></blockquote><p>(2)通过继承multiprocessing.multiprocessing类来创建线程</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">mport time</span><br><span class="line">import random</span><br><span class="line">from multiprocessing import Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Hello(Process):</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.name=name</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&apos;%s hello&apos; %self.name)</span><br><span class="line"></span><br><span class="line">        time.sleep(random.randrange(1,5))</span><br><span class="line">        print(&apos;%s bye&apos; %self.name)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">p1=Hello(&apos;e&apos;)</span><br><span class="line">p2=Hello(&apos;a&apos;)</span><br><span class="line">p3=Hello(&apos;w&apos;)</span><br><span class="line">p4=Hello(&apos;y&apos;)</span><br><span class="line"></span><br><span class="line">p1.start() #start会自动调用run</span><br><span class="line">p2.start()</span><br><span class="line">p3.start()</span><br><span class="line">p4.start()</span><br><span class="line">print(&apos;主线程&apos;)</span><br></pre></td></tr></table></figure></blockquote><h2 id="三、进程同步"><a href="#三、进程同步" class="headerlink" title="三、进程同步"></a>三、进程同步</h2><p>进程之间数据不共享,但是共享同一套文件系统,所以访问同一个文件,或同一个打印终端,是没有问题的。</p><p>用文件共享数据，加锁的是为了保证多个进程修改同一块数据时，同一时间只能有一个修改，即串行的修改，牺牲了速度而保证了数据安全。</p><p><code>multiprocessing.Lock</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#文件当做数据库，模拟抢票（Lock互斥锁）</span><br><span class="line">#文件db的内容为：&#123;&quot;count&quot;:2&#125;</span><br><span class="line">#注意一定要用双引号，不然json无法识别</span><br><span class="line">from multiprocessing import Process,Lock</span><br><span class="line">import json</span><br><span class="line">import time</span><br><span class="line">import random</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">def work(filename,lock): #买票</span><br><span class="line">    # lock.acquire()</span><br><span class="line">    with lock:</span><br><span class="line">        with open(filename,encoding=&apos;utf-8&apos;) as f:</span><br><span class="line">            dic=json.loads(f.read())</span><br><span class="line">            # print(&apos;剩余票数: %s&apos; % dic[&apos;count&apos;])</span><br><span class="line">        if dic[&apos;count&apos;] &gt; 0:</span><br><span class="line">            dic[&apos;count&apos;]-=1</span><br><span class="line">            time.sleep(random.randint(1,3)) #模拟网络延迟</span><br><span class="line">            with open(filename,&apos;w&apos;,encoding=&apos;utf-8&apos;) as f:</span><br><span class="line">                f.write(json.dumps(dic))</span><br><span class="line">            print(&apos;%s 购票成功&apos; %os.getpid())</span><br><span class="line">        else:</span><br><span class="line">            print(&apos;%s 购票失败&apos; %os.getpid())</span><br><span class="line">    # lock.release()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    lock=Lock()</span><br><span class="line">    p_l=[]</span><br><span class="line">    for i in range(10):</span><br><span class="line">        p=Process(target=work,args=(&apos;db&apos;,lock))</span><br><span class="line">        p_l.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    for p in p_l:</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">    print(&apos;主线程&apos;)</span><br></pre></td></tr></table></figure></blockquote><h2 id="四、进程池"><a href="#四、进程池" class="headerlink" title="四、进程池"></a>四、进程池</h2><p>Pool可以提供指定数量的进程供用户使用，默认是CPU核数。当有新的请求提交到Poll的时候，如果池子没有满，会创建一个进程来执行，否则就会让该请求等待。<br><code>Pool([numprocess  [,initializer [, initargs]]])</code></p><p>参数介绍：</p><ul><li>numprocess: 要创建的进程数，如果省略，将默认使用cpu_count()的值</li><li>initializer：是每个工作进程启动时要执行的可调用对象，默认为None</li><li>initargs：是要传给initializer的参数组</li></ul><p>方法介绍：</p><ul><li><code>p.apply(func [, args [, kwargs]])</code>:在一个池工作进程中执行func(<em>args,*</em>kwargs),然后返回结果。需要强调的是：此操作并不会在所有池工作进程中并执行func函数。如果要通过不同参数并发地执行func函数，必须从不同线程调用p.apply()函数或者使用p.apply_async()</li><li><code>p.apply_async(func [, args [, kwargs]])</code>:在一个池工作进程中执行func(<em>args,*</em>kwargs),然后返回结果。此方法的结果是AsyncResult类的实例，callback是可调用对象，接收输入参数。当func的结果变为可用时，将理解传递给callback。callback禁止执行任何阻塞操作，否则将接收其他异步操作中的结果。 </li><li><code>p.close()</code>:关闭进程池，防止进一步操作。如果所有操作持续挂起，它们将在工作进程终止前完成</li><li><code>P.jion()</code>:等待所有工作进程退出。此方法只能在close（）或teminate()之后调用</li></ul><p>方法apply_async()和map_async（）的返回值是AsyncResul的实例obj。实例具有以下方法:</p><ul><li><code>obj.get()</code>:返回结果，如果有必要则等待结果到达。timeout是可选的。如果在指定时间内还没有到达，将引发一场。如果远程操作中引发了异常，它将在调用此方法时再次被引发。</li><li><code>obj.ready()</code>:如果调用完成，返回True</li><li><code>obj.successful()</code>:如果调用完成且没有引发异常，返回True，如果在结果就绪之前调用此方法，引发异常</li><li><code>obj.wait([timeout])</code>:等待结果变为可用。</li><li><code>obj.terminate()</code>：立即终止所有工作进程，同时不执行任何清理或结束任何挂起工作。如果p被垃圾回收，将自动调用此函数</li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Pool</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def work(n):</span><br><span class="line">    print(&apos;开工啦...&apos;)</span><br><span class="line">    time.sleep(3)</span><br><span class="line">    return n**2</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    q=Pool()</span><br><span class="line">res_l=[]</span><br><span class="line"></span><br><span class="line">for i in range(3)</span><br><span class="line">#异步apply_async用法：如果使用异步提交的任务，主进程需要使用jion，等待进程池内任务都处理完，然后可以用get收集结果，否则，主进程结束，进程池可能还没来得及执行，也就跟着一起结束了</span><br><span class="line">res=q.apply_async(work,args=(i,))</span><br><span class="line">res_l.append(res)</span><br><span class="line">    </span><br><span class="line">q.close()</span><br><span class="line">    q.join() #join在close之后调用</span><br><span class="line">    </span><br><span class="line">for i in res_l:</span><br><span class="line">        print(i.get())</span><br><span class="line"></span><br><span class="line">    #同步apply用法：主进程一直等apply提交的任务结束后才继续执行后续代码</span><br><span class="line">    # res=q.apply(work,args=(i,))</span><br><span class="line">    # print(res)</span><br></pre></td></tr></table></figure></blockquote><h2 id="五、子进程"><a href="#五、子进程" class="headerlink" title="五、子进程"></a>五、子进程</h2><p>很多时候，子进程并不是自身，而是一个外部进程。我们创建了子进程后，还需要控制子进程的输入和输出。<br><code>subprocess</code>模块可以让我们非常方便地启动一个子进程，然后控制其输入和输出。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#Python代码中运行命令nslookup www.python.org</span><br><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line">print(&apos;$ nslookup www.python.org&apos;)</span><br><span class="line">r = subprocess.call([&apos;nslookup&apos;, &apos;www.python.org&apos;])</span><br><span class="line">print(&apos;Exit code:&apos;, r)</span><br></pre></td></tr></table></figure></blockquote><p>如果子进程还需要输入，则可以通过<code>communicate()</code>方法输入：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line">print(&apos;$ nslookup&apos;)</span><br><span class="line">p = subprocess.Popen([&apos;nslookup&apos;], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">output, err = p.communicate(b&apos;set q=mx\npython.org\nexit\n&apos;)</span><br><span class="line">print(output.decode(&apos;utf-8&apos;))</span><br><span class="line">print(&apos;Exit code:&apos;, p.returncode)</span><br></pre></td></tr></table></figure></blockquote><h2 id="六、进程间通信"><a href="#六、进程间通信" class="headerlink" title="六、进程间通信"></a>六、进程间通信</h2><p>Process之间肯定是需要通信的，Python的multiprocessing模块包装了底层的机制，提供了Queue、Pipes等多种方式来交换数据。<br><code>Queue([maxsize])</code>:创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。</p><ul><li><code>maxsize</code>:是队列中允许最大项数，省略则无大小限制。</li><li><code>q.put()</code>方法用以插入数据到队列中<blockquote><p>put方法还有两个可选参数：blocked和timeout。<br>如果blocked为True（默认值），并且timeout为正值，该方法会阻塞timeout指定的时间，直到该队列有剩余的空间。<br>如果超时，会抛出Queue.Full异常。如果blocked为False，但该Queue已满，会立即抛出Queue.Full异常。</p></blockquote></li><li><code>q.get()</code>方法可以从队列读取并且删除一个元素。<blockquote><p>get方法有两个可选参数：blocked和timeout。<br>如果blocked为True（默认值），并且timeout为正值，那么在等待时间内没有取到任何元素，会抛出Queue.Empty异常。<br>如果blocked为False，有两种情况存在，如果Queue有一个值可用，则立即返回该值，否则，如果队列为空，则立即抛出Queue.Empty异常.</p></blockquote></li><li><code>q.get_nowait()</code>:同q.get(False)</li><li><code>q.put_nowait()</code>:同q.put(False)</li><li><code>q.empty()</code>:调用此方法时q为空则返回True，该结果不可靠，比如在返回True的过程中，如果队列中又加入了项目。</li><li><code>q.full()</code>：调用此方法时q已满则返回True，该结果不可靠，比如在返回True的过程中，如果队列中的项目被取走。</li><li><code>q.qsize()</code>:返回队列中目前项目的正确数量，结果也不可靠，理由同q.empty()和q.full()一样</li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process,Queue</span><br><span class="line">import time,random,os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def consumer(q):</span><br><span class="line">    while True:</span><br><span class="line">        time.sleep(random.randint(1,3))</span><br><span class="line">        res=q.get()</span><br><span class="line">        if res is None:break</span><br><span class="line">        print(&apos;\033[45m消费者拿到了：%s\033[0m&apos; %res)</span><br><span class="line"></span><br><span class="line">def producer(seq,q):</span><br><span class="line">    for item in seq:</span><br><span class="line">        time.sleep(random.randint(1,3))</span><br><span class="line">        print(&apos;\033[46m生产者生产了：%s\033[0m&apos; %item)</span><br><span class="line"></span><br><span class="line">        q.put(item)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    q=Queue()</span><br><span class="line"></span><br><span class="line">    c=Process(target=consumer,args=(q,))</span><br><span class="line">    c.start()</span><br><span class="line"></span><br><span class="line">    producer((&apos;包子%s&apos; %i for i in range(5)),q)</span><br><span class="line">    q.put(None)</span><br><span class="line">    c.join()</span><br><span class="line">    print(&apos;主线程&apos;)</span><br></pre></td></tr></table></figure></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a>持续更新…</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生苦短，我用python。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://pythonfood.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://pythonfood.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python多线程</title>
    <link href="http://pythonfood.github.io/2017/12/28/python%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://pythonfood.github.io/2017/12/28/python多线程/</id>
    <published>2017-12-28T12:10:00.000Z</published>
    <updated>2018-03-21T07:18:13.797Z</updated>
    
    <content type="html"><![CDATA[<p>人生苦短，我用python。<br><a id="more"></a></p><h2 id="一、线程"><a href="#一、线程" class="headerlink" title="一、线程"></a>一、线程</h2><p>线程是CPU分配资源的基本单位。但一个程序开始运行，这个程序就变成了一个进程，而一个进程相当于一个或者多个线程。当没有多线程编程时，一个进程也是一个主线程，但有多线程编程时，一个进程包含多个线程，包括主线程。使用线程可以实现程序的并发。</p><p>Python3通过两个标准库<code>_thread</code>和<code>threading</code>提供对线程的支持:<br>(1)<code>_thread</code>提供了低级别的、原始的线程以及一个简单的锁，它相比于threading模块的功能还是比较有限的。<br>(2)<code>threading</code>模块除了包含_thread 模块中的所有方法外，还提供的其他方法： </p><ul><li>threading.currentThread(): 返回当前的线程变量。 </li><li>threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。 </li><li>threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。<br>除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法:</li><li>run(): 用以表示线程活动的方法。</li><li>start():启动线程活动。</li><li>join([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。</li><li>isAlive(): 返回线程是否活动的。</li><li>getName(): 返回线程名。</li><li>setName(): 设置线程名。</li></ul><h2 id="二、-thread模块"><a href="#二、-thread模块" class="headerlink" title="二、_thread模块"></a>二、_thread模块</h2><p>函数式：调用_thread模块中的start_new_thread()函数来产生新线程。<br><code>_thread.start_new_thread ( function, args[, kwargs] )</code></p><ul><li>function - 线程函数。</li><li>args - 传递给线程函数的参数,他必须是个tuple类型。</li><li>kwargs - 可选参数。</li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import _thread</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 为线程定义一个函数</span><br><span class="line">def print_time(threadName, delay):</span><br><span class="line">count = 0</span><br><span class="line">while count &lt; 5:</span><br><span class="line">time.sleep(delay)</span><br><span class="line">count += 1</span><br><span class="line">print(&apos;s%: s%&apos; % (threadName, time.ctime(time.time())))</span><br><span class="line"></span><br><span class="line"># 创建两个线程</span><br><span class="line">try:</span><br><span class="line">_thread.start_new_thread(print_time, (&apos;thread-1&apos;, 2))</span><br><span class="line">_thread.start_new_thread(print_time, (&apos;thread-2&apos;, 4))</span><br><span class="line">except:</span><br><span class="line">print(&apos;E：无法启动线程&apos;)</span><br><span class="line"></span><br><span class="line">while 1：</span><br><span class="line">pass</span><br></pre></td></tr></table></figure></blockquote><h2 id="三、threading模块"><a href="#三、threading模块" class="headerlink" title="三、threading模块"></a>三、threading模块</h2><p>1、用threading.Thread直接在线程中运行函数</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 为线程定义一个函数</span><br><span class="line">def print_time(threadName, delay):</span><br><span class="line">count = 0</span><br><span class="line">while count &lt; 5:</span><br><span class="line">time.sleep(delay)</span><br><span class="line">count += 1</span><br><span class="line">print(&apos;s%: s%&apos; % (threadName, time.ctime(time.time())))</span><br><span class="line"></span><br><span class="line"># 创建两个线程</span><br><span class="line">t1 = threading.Thread(target=print_time, args=(&apos;thread-1&apos;,&apos;2&apos;))</span><br><span class="line">t2 = threading.Thread(target=print_time, args=(&apos;thread-2&apos;,&apos;4&apos;))</span><br><span class="line"></span><br><span class="line">#调用start()，运行线程</span><br><span class="line">t1.start()   </span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line">调用join()的线程，主线程等待线程结束才继续执行</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br></pre></td></tr></table></figure></blockquote><p>2、通过继承threading.Thread类来创建线程</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">#继承threading.Thread类</span><br><span class="line">class MyThread(threading.Thread):</span><br><span class="line">def __init__(self,name):</span><br><span class="line">super().__init__()</span><br><span class="line">self.name = name</span><br><span class="line">def run(self):</span><br><span class="line">time.sleep(2)</span><br><span class="line">print(&apos;s% say hello&apos; % self.name)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">#创建线程</span><br><span class="line">t1 = MyThread(&apos;t1&apos;)</span><br><span class="line">t2 = MyThread(&apos;t2&apos;)</span><br><span class="line"></span><br><span class="line">#启动线程</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br></pre></td></tr></table></figure></blockquote><h2 id="四、线程同步"><a href="#四、线程同步" class="headerlink" title="四、线程同步"></a>四、线程同步</h2><p>使用Thread对象的<code>Lock()</code>和<code>Rlock()</code>可以实现简单的线程同步，这两个对象都有<code>acquire()</code>方法和<code>release()</code>方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到acquire()和release()方法之间。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">class myThread (threading.Thread):</span><br><span class="line">    def __init__(self, threadID, name, counter):</span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.threadID = threadID</span><br><span class="line">        self.name = name</span><br><span class="line">        self.counter = counter</span><br><span class="line">    def run(self):</span><br><span class="line">        print (&quot;开启线程： &quot; + self.name)</span><br><span class="line">        # 获取锁，用于线程同步</span><br><span class="line">        threadLock.acquire()</span><br><span class="line">        print_time(self.name, self.counter, 3)</span><br><span class="line">        # 释放锁，开启下一个线程</span><br><span class="line">        threadLock.release()</span><br><span class="line"></span><br><span class="line">def print_time(threadName, delay, counter):</span><br><span class="line">    while counter:</span><br><span class="line">        time.sleep(delay)</span><br><span class="line">        print (&quot;%s: %s&quot; % (threadName, time.ctime(time.time())))</span><br><span class="line">        counter -= 1</span><br><span class="line"></span><br><span class="line">threadLock = threading.Lock()</span><br><span class="line">threads = []</span><br><span class="line"></span><br><span class="line"># 创建新线程</span><br><span class="line">thread1 = myThread(1, &quot;Thread-1&quot;, 1)</span><br><span class="line">thread2 = myThread(2, &quot;Thread-2&quot;, 2)</span><br><span class="line"></span><br><span class="line"># 开启新线程</span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line"></span><br><span class="line"># 添加线程到线程列表</span><br><span class="line">threads.append(thread1)</span><br><span class="line">threads.append(thread2)</span><br><span class="line"></span><br><span class="line"># 等待所有线程完成</span><br><span class="line">for t in threads:</span><br><span class="line">    t.join()</span><br><span class="line">print (&quot;退出主线程&quot;)</span><br></pre></td></tr></table></figure></blockquote><p>死锁：是指两个或两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p><p>RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。上面的例子如果使用RLock代替Lock，则不会发生死锁。</p><h2 id="五、全局解释器锁"><a href="#五、全局解释器锁" class="headerlink" title="五、全局解释器锁"></a>五、全局解释器锁</h2><p>Python GIL(Global Interpreter Lock)<br>如果使用多核CPU，在Cpython解释器中，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p><p>GIL是Python解释器设计的历史遗留问题，通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。所以，在Python中，可以使用多线程，但不要指望能有效利用多核。如果一定要通过多线程利用多核，那只能通过C扩展来实现，不过这样就失去了Python简单易用的特点。不过，也不用过于担心，Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。</p><p>面向I/O的（会调用内建的操作系统C代码的）程序来说，GIL会在这个I/O调用之前被释放，以允许其他线程在这个线程等待I/O的时候运行。如果某线程并未使用很多I/O操作，它会在自己的时间片内一直占用处理器和GIL。也就是说，I/O密集型的Python程序比计算密集型的Python程序更能充分利用多线程的好处。</p><p>1、i/o密集型<br>多线程用于IO密集型，如socket，爬虫，web。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from threading import Thread</span><br><span class="line">from multiprocessing import Process</span><br><span class="line">import time</span><br><span class="line">import os</span><br><span class="line">def work():</span><br><span class="line">    time.sleep(2) #模拟I/O操作，可以打开一个文件来测试I/O,与sleep是一个效果</span><br><span class="line">    print(os.getpid())</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    t_l=[]</span><br><span class="line">    start_time=time.time()</span><br><span class="line">    for i in range(1000):</span><br><span class="line">        t=Thread(target=work) #耗时大概为2秒</span><br><span class="line">        # t=Process(target=work) #耗时大概为25秒,创建进程的开销远高于线程，而且对于I/O密集型，多cpu根本不管用</span><br><span class="line">        t_l.append(t)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    for t in t_l:</span><br><span class="line">        t.join()</span><br><span class="line">    stop_time=time.time()</span><br><span class="line">    print(&apos;run time is %s&apos; %(stop_time-start_time))</span><br></pre></td></tr></table></figure></blockquote><p>2、cpu密集型<br>多进程用于计算密集型，如金融分析，视频解码。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">from threading import Thread</span><br><span class="line">from multiprocessing import Process</span><br><span class="line">import os</span><br><span class="line">import time</span><br><span class="line">def work():</span><br><span class="line">    res=0</span><br><span class="line">    for i in range(1000000):</span><br><span class="line">        res+=i</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    t_l=[]</span><br><span class="line">    start_time=time.time()</span><br><span class="line"></span><br><span class="line">    for i in range(300):</span><br><span class="line">        # t=Thread(target=work) #多线程49.64094281196594</span><br><span class="line">        t=Process(target=work) #多进程11.664679050445557</span><br><span class="line">        t_l.append(t)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    for i in t_l:</span><br><span class="line">        i.join()</span><br><span class="line"></span><br><span class="line">    stop_time=time.time()</span><br><span class="line">    print(&apos;run time is %s&apos; %(stop_time-start_time))</span><br><span class="line"></span><br><span class="line">    print(&apos;主线程&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># run time is 49.64094281196594</span><br><span class="line"># 主线程</span><br><span class="line"></span><br><span class="line"># run time is 11.664679050445557</span><br><span class="line"># 主线程</span><br></pre></td></tr></table></figure></blockquote><h2 id="六、线程优先级队列"><a href="#六、线程优先级队列" class="headerlink" title="六、线程优先级队列"></a>六、线程优先级队列</h2><p>Queue模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列 PriorityQueue。 </p><p>这些队列都实现了锁原语，能够在多线程中直接使用，可以使用队列来实现线程间的同步。</p><p>Queue模块中的常用方法:</p><blockquote><ul><li><code>Queue.qsize()</code> 返回队列的大小 </li><li><code>Queue.empty()</code> 如果队列为空，返回True,反之False </li><li><code>Queue.full()</code> 如果队列满了，返回True,反之False</li><li><code>Queue.full</code> 与 maxsize 大小对应 </li><li><code>Queue.get([block[, timeout]])</code>获取队列，timeout等待时间 </li><li><code>Queue.get_nowait()</code> 相当Queue.get(False)</li><li><code>Queue.put(item)</code> 写入队列，timeout等待时间 </li><li><code>Queue.put_nowait(item)</code> 相当Queue.put(item, False)</li><li><code>Queue.task_done()</code> 在完成一项工作之后，Queue.task_done()函数向任务已经完成的队列发送一个信号</li><li><code>Queue.join()</code> 实际上意味着等到队列为空，再执行别的操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">import queue</span><br><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">exitFlag = 0</span><br><span class="line"></span><br><span class="line">class myThread (threading.Thread):</span><br><span class="line">    def __init__(self, threadID, name, q):</span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.threadID = threadID</span><br><span class="line">        self.name = name</span><br><span class="line">        self.q = q</span><br><span class="line">    def run(self):</span><br><span class="line">        print (&quot;开启线程：&quot; + self.name)</span><br><span class="line">        process_data(self.name, self.q)</span><br><span class="line">        print (&quot;退出线程：&quot; + self.name)</span><br><span class="line"></span><br><span class="line">def process_data(threadName, q):</span><br><span class="line">    while not exitFlag:</span><br><span class="line">        queueLock.acquire()</span><br><span class="line">        if not workQueue.empty():</span><br><span class="line">            data = q.get()</span><br><span class="line">            queueLock.release()</span><br><span class="line">            print (&quot;%s processing %s&quot; % (threadName, data))</span><br><span class="line">        else:</span><br><span class="line">            queueLock.release()</span><br><span class="line">        time.sleep(1)</span><br><span class="line"></span><br><span class="line">threadList = [&quot;Thread-1&quot;, &quot;Thread-2&quot;, &quot;Thread-3&quot;]</span><br><span class="line">nameList = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;, &quot;Five&quot;]</span><br><span class="line">queueLock = threading.Lock()</span><br><span class="line">workQueue = queue.Queue(10)</span><br><span class="line">threads = []</span><br><span class="line">threadID = 1</span><br><span class="line"></span><br><span class="line"># 创建新线程</span><br><span class="line">for tName in threadList:</span><br><span class="line">    thread = myThread(threadID, tName, workQueue)</span><br><span class="line">    thread.start()</span><br><span class="line">    threads.append(thread)</span><br><span class="line">    threadID += 1</span><br><span class="line"></span><br><span class="line"># 填充队列</span><br><span class="line">queueLock.acquire()</span><br><span class="line">for word in nameList:</span><br><span class="line">    workQueue.put(word)</span><br><span class="line">queueLock.release()</span><br><span class="line"></span><br><span class="line"># 等待队列清空</span><br><span class="line">while not workQueue.empty():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"># 通知线程是时候退出</span><br><span class="line">exitFlag = 1</span><br><span class="line"></span><br><span class="line"># 等待所有线程完成</span><br><span class="line">for t in threads:</span><br><span class="line">    t.join()</span><br><span class="line">print (&quot;退出主线程&quot;)</span><br></pre></td></tr></table></figure></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a>持续更新…</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生苦短，我用python。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://pythonfood.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://pythonfood.github.io/tags/python/"/>
    
  </entry>
  
</feed>
