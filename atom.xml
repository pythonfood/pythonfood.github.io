<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PythonFood</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://pythonfood.github.io/"/>
  <updated>2018-02-26T09:11:31.048Z</updated>
  <id>http://pythonfood.github.io/</id>
  
  <author>
    <name>Python Food</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>appium DesiredCapabilities</title>
    <link href="http://pythonfood.github.io/2018/02/01/appium-DesiredCapabilities/"/>
    <id>http://pythonfood.github.io/2018/02/01/appium-DesiredCapabilities/</id>
    <published>2018-02-01T02:00:00.000Z</published>
    <updated>2018-02-26T09:11:31.048Z</updated>
    
    <content type="html"><![CDATA[<p>Appium Desired Capabilities 详解。<br><a id="more"></a></p><h3 id="1-基本参数"><a href="#1-基本参数" class="headerlink" title="1.基本参数"></a>1.基本参数</h3><table><thead><tr><th style="text-align:left">关键字</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">automationName</td><td style="text-align:left">自动化测试引擎</td><td style="text-align:left">Appium或 Selendroid</td></tr><tr><td style="text-align:left">platformName</td><td style="text-align:left">手机操作系统</td><td style="text-align:left">iOS, Android, 或 FirefoxOS</td></tr><tr><td style="text-align:left">platformVersion</td><td style="text-align:left">手机操作系统版本</td><td style="text-align:left">如： 7.1, 4.4；ios的 9.0</td></tr><tr><td style="text-align:left">deviceName</td><td style="text-align:left">手机或模拟器设备名称</td><td style="text-align:left">android的忽略，ios如iPhone Simulator</td></tr><tr><td style="text-align:left">app</td><td style="text-align:left">.ipa .apk文件路径</td><td style="text-align:left">比如/abs/path/to/my.apk或<a href="http://myapp.com/app.ipa" target="_blank" rel="noopener">http://myapp.com/app.ipa</a></td></tr><tr><td style="text-align:left">browserName</td><td style="text-align:left">启动手机浏览器</td><td style="text-align:left">iOS如:Safari，Android如:Chrome,Chromium,Browser</td></tr><tr><td style="text-align:left">newCommandTimeout</td><td style="text-align:left">设置命令超时时间，单位：秒。</td><td style="text-align:left">比如 60</td></tr><tr><td style="text-align:left">autoLaunch</td><td style="text-align:left">Appium是否需要自动安装和启动应用。默认值true</td><td style="text-align:left">true, false</td></tr><tr><td style="text-align:left">language</td><td style="text-align:left">(Sim/Emu-only) 设定模拟器 ( simulator / emulator ) 的语言。</td><td style="text-align:left">如： fr</td></tr><tr><td style="text-align:left">locale</td><td style="text-align:left">(Sim/Emu-only) 设定模拟器 ( simulator / emulator ) 的区域设置。</td><td style="text-align:left">如： fr_CA</td></tr><tr><td style="text-align:left">udid</td><td style="text-align:left">ios真机的唯一设备标识</td><td style="text-align:left">如： 1ae203187fc012g</td></tr><tr><td style="text-align:left">orientation</td><td style="text-align:left">设置横屏或竖屏</td><td style="text-align:left">LANDSCAPE (横向) 或 PORTRAIT (纵向)</td></tr><tr><td style="text-align:left">autoWebview</td><td style="text-align:left">直接转换到 WebView 上下文。 默认值 false、</td><td style="text-align:left">true, false</td></tr><tr><td style="text-align:left">noReset</td><td style="text-align:left">不要在会话前重置应用状态。默认值false。</td><td style="text-align:left">true, false</td></tr><tr><td style="text-align:left">fullReset</td><td style="text-align:left">(iOS) 删除整个模拟器目录。(Android)通过卸载默认值 false</td><td style="text-align:left">true, false</td></tr></tbody></table><h3 id="2-android特有"><a href="#2-android特有" class="headerlink" title="2.android特有"></a>2.android特有</h3><table><thead><tr><th style="text-align:left">关键字</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">appActivity</td><td style="text-align:left">启动app包,一般点开头</td><td style="text-align:left">如：.MainActivity, .Settings</td></tr><tr><td style="text-align:left">appPackage</td><td style="text-align:left">Android应用的包名</td><td style="text-align:left">比如com.example.android.myApp</td></tr><tr><td style="text-align:left">appWaitActivity</td><td style="text-align:left">等待启动的Activity名称</td><td style="text-align:left">SplashActivity</td></tr><tr><td style="text-align:left">deviceReadyTimeout</td><td style="text-align:left">设置超时时间</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left">androidCoverage</td><td style="text-align:left">用于执行测试的 instrumentation类</td><td style="text-align:left">com.my.Pkg/com.my.Pkg.instrumentation.MyInstrumentation</td></tr><tr><td style="text-align:left">enablePerformanceLogging</td><td style="text-align:left">(仅适用于 Chrome 和 webview) 开启 Chromedriver 的性能日志。(默认 false)</td><td style="text-align:left">true, false</td></tr><tr><td style="text-align:left">androidDeviceReadyTimeout</td><td style="text-align:left">等待设备在启动应用后超时时间，单位秒</td><td style="text-align:left">如 30</td></tr><tr><td style="text-align:left">androidDeviceSocket</td><td style="text-align:left">开发工具的 socket 名称。Chromedriver 把它作为开发者工具来进行连接。</td><td style="text-align:left">如 chrome_devtools_remote</td></tr><tr><td style="text-align:left">avd</td><td style="text-align:left">需要启动的 AVD (安卓模拟器设备) 名称。</td><td style="text-align:left">如 api19</td></tr><tr><td style="text-align:left">avdLaunchTimeout</td><td style="text-align:left">以毫秒为单位，等待 AVD 启动并连接到 ADB的超时时间。(默认值 120000)</td><td style="text-align:left">300000</td></tr><tr><td style="text-align:left">avdReadyTimeout</td><td style="text-align:left">以毫秒为单位，等待 AVD 完成启动动画的超时时间。(默认值 120000)</td><td style="text-align:left">300000</td></tr><tr><td style="text-align:left">avdArgs</td><td style="text-align:left">启动 AVD 时需要加入的额外的参数。</td><td style="text-align:left">如 -netfast</td></tr><tr><td style="text-align:left">useKeystore</td><td style="text-align:left">使用一个自定义的 keystore 来对 apk 进行重签名。默认值 false</td><td style="text-align:left">true or false</td></tr><tr><td style="text-align:left">keystorePath</td><td style="text-align:left">自定义keystore路径。默认~/.android/debug.keystore</td><td style="text-align:left">如 /path/to.keystore</td></tr><tr><td style="text-align:left">keystorePassword</td><td style="text-align:left">自定义 keystore 的密码。</td><td style="text-align:left">如 foo</td></tr><tr><td style="text-align:left">keyAlias</td><td style="text-align:left">key 的别名</td><td style="text-align:left">如 androiddebugkey</td></tr><tr><td style="text-align:left">keyPassword</td><td style="text-align:left">key 的密码</td><td style="text-align:left">如 foo</td></tr><tr><td style="text-align:left">chromedriverExecutable</td><td style="text-align:left">webdriver可执行文件的绝对路径 应该用它代替Appium 自带的 webdriver)</td><td style="text-align:left">/abs/path/to/webdriver</td></tr><tr><td style="text-align:left">autoWebviewTimeout</td><td style="text-align:left">毫秒为单位，Webview上下文激活的时间。默认2000</td><td style="text-align:left">如 4</td></tr><tr><td style="text-align:left">intentAction</td><td style="text-align:left">用于启动activity的intent action。(默认值 android.intent.action.MAIN)</td><td style="text-align:left">如 android.intent.action.MAIN, android.intent.action.VIEW</td></tr><tr><td style="text-align:left">intentCategory</td><td style="text-align:left">用于启动 activity 的 intent category。 (默认值 android.intent.category.LAUNCHER)</td><td style="text-align:left">如 android.intent.category.LAUNCHER, android.intent.category.APP_CONTACTS</td></tr><tr><td style="text-align:left">intentFlags</td><td style="text-align:left">用于启动activity的标识(flags) (默认值 0x10200000)</td><td style="text-align:left">如 0x10200000</td></tr><tr><td style="text-align:left">optionalIntentArguments</td><td style="text-align:left">用于启动 activity 的额外 intent 参数。请查看 Intent 参数</td><td style="text-align:left">如 –esn <extra_key>, –ez <extra_key> <extra_boolean_value></extra_boolean_value></extra_key></extra_key></td></tr><tr><td style="text-align:left">dontStopAppOnReset</td><td style="text-align:left">在使用 adb 启动应用时不要停止被测应用的进程。默认值： false</td><td style="text-align:left">true 或 false</td></tr><tr><td style="text-align:left">unicodeKeyboard</td><td style="text-align:left">使用 Unicode 输入法。默认值 false</td><td style="text-align:left">true 或 false</td></tr><tr><td style="text-align:left">resetKeyboard</td><td style="text-align:left">重置输入法到原有状态，默认值 false</td><td style="text-align:left">true 或 false</td></tr><tr><td style="text-align:left">noSign</td><td style="text-align:left">跳过检查和对应用进行 debug 签名的步骤。默认值 false</td><td style="text-align:left">true 或 false</td></tr><tr><td style="text-align:left">ignoreUnimportantViews</td><td style="text-align:left">调用 uiautomator 的函数这个关键字能加快测试执行的速度。默认值 false</td><td style="text-align:left">true 或 false</td></tr><tr><td style="text-align:left">disableAndroidWatchers</td><td style="text-align:left">关闭 android 监测应用无响ANR和崩溃crash的监视器默认值： false。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">chromeOptions</td><td style="text-align:left">允许传入 chrome driver 使用的 chromeOptions 参数。</td><td style="text-align:left">chromeOptions: {args: [‘–disable-popup-blocking‘]}</td></tr></tbody></table><h3 id="3-ios特有"><a href="#3-ios特有" class="headerlink" title="3.ios特有"></a>3.ios特有</h3><table><thead><tr><th style="text-align:left">关键字</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">calendarFormat</td><td style="text-align:left">(Sim-only) 为iOS的模拟器设置日历格式</td><td style="text-align:left">如 gregorian (公历)</td></tr><tr><td style="text-align:left">bundleId</td><td style="text-align:left">被测应用的bundle ID，真机上执行测试时，你可以不提供 app 关键字，但你必须提供udid</td><td style="text-align:left">如 io.appium.TestApp</td></tr><tr><td style="text-align:left">udid</td><td style="text-align:left">连接真机的唯一设备编号 ( Unique device identifier )</td><td style="text-align:left">如 1ae203187fc012g</td></tr><tr><td style="text-align:left">launchTimeout</td><td style="text-align:left">以毫秒为单位，在Appium运行失败之前设置一个等待 instruments的时间</td><td style="text-align:left">比如： 20000</td></tr><tr><td style="text-align:left">locationServicesEnabled</td><td style="text-align:left">(Sim-only) 强制打开或关闭定位服务。默认值是保持当前模拟器的设定</td><td style="text-align:left">true 或 false</td></tr><tr><td style="text-align:left">locationServicesAuthorized</td><td style="text-align:left">使用这个关键字时，你同时需要使用 bundleId 关键字来发送你的应用的 bundle ID。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">autoAcceptAlerts</td><td style="text-align:left">当 iOS 的个人信息访问警告 (如 位置、联系人、图片) 出现时，自动选择接受( Accept )。默认值 false。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">autoDismissAlerts</td><td style="text-align:left">当 iOS 的个人信息访问警告 (如 位置、联系人、图片) 出现时，自动选择不接受( Dismiss )。默认值 false。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">nativeInstrumentsLib</td><td style="text-align:left">使用原生 intruments 库 (即关闭 instruments-without-delay )</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">nativeWebTap</td><td style="text-align:left">(Sim-only) 在Safari中允许”真实的”，默认值： false。注意：取决于 viewport 大小/比例， 点击操作不一定能精确地点中对应的元素。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">safariInitialUrl</td><td style="text-align:left">(Sim-only) (&gt;= 8.1) Safari 的初始地址。默认值是一个本地的欢迎页面</td><td style="text-align:left">例如： <a href="https://www.github.com" target="_blank" rel="noopener">https://www.github.com</a></td></tr><tr><td style="text-align:left">safariAllowPopups</td><td style="text-align:left">(Sim-only) 允许 javascript 在 Safari 中创建新窗口。默认保持模拟器当前设置。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">safariIgnoreFraudWarning</td><td style="text-align:left">(Sim-only) 阻止 Safari 显示此网站可能存在风险的警告。默认保持浏览器当前设置。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">safariOpenLinksInBackground</td><td style="text-align:left">(Sim-only) Safari 是否允许链接在新窗口打开。默认保持浏览器当前设置。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">keepKeyChains</td><td style="text-align:left">(Sim-only) 当 Appium 会话开始/结束时是否保留存放密码存放记录 (keychains) (库(Library)/钥匙串(Keychains))</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">localizableStringsDir</td><td style="text-align:left">从哪里查找本地化字符串。默认值 en.lproj</td><td style="text-align:left">en.lproj</td></tr><tr><td style="text-align:left">processArguments</td><td style="text-align:left">通过 instruments 传递到 AUT 的参数</td><td style="text-align:left">如 -myflag</td></tr><tr><td style="text-align:left">interKeyDelay</td><td style="text-align:left">以毫秒为单位，按下每一个按键之间的延迟时间。</td><td style="text-align:left">如 100</td></tr><tr><td style="text-align:left">showIOSLog</td><td style="text-align:left">是否在 Appium 的日志中显示设备的日志。默认值 false</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">sendKeyStrategy</td><td style="text-align:left">输入文字到文字框的策略。模拟器默认值：oneByOne (一个接着一个) 。真实设备默认值：grouped (分组输入)</td><td style="text-align:left">oneByOne, grouped 或 setValue</td></tr><tr><td style="text-align:left">screenshotWaitTimeout</td><td style="text-align:left">以秒为单位，生成屏幕截图的最长等待时间。默认值： 10。</td><td style="text-align:left">如 5</td></tr><tr><td style="text-align:left">waitForAppScript</td><td style="text-align:left">用于判断 “应用是否被启动” 的 iOS 自动化脚本代码。默认情况下系统等待直到页面内容非空。结果必须是布尔类型。</td><td style="text-align:left">例如 true;, target.elements().length &gt; 0;, $.delay(5000); true;</td></tr></tbody></table><h3 id="4-小示例"><a href="#4-小示例" class="headerlink" title="4.小示例"></a>4.小示例</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from appium import webdriver</span><br><span class="line"></span><br><span class="line">desired_caps=&#123;&#125;</span><br><span class="line">desired_caps[&apos;platformName&apos;]=&apos;Android&apos;</span><br><span class="line">desired_caps[&apos;platformVersion&apos;]=&apos;5.1.1&apos;</span><br><span class="line">desired_caps[&apos;deviceName&apos;]=&apos;172.16.10.26:5555&apos;</span><br><span class="line">desired_caps[&apos;appPackage&apos;]=&apos;com.peng.cloudp.tv&apos;</span><br><span class="line">desired_caps[&apos;appActivity&apos;]=&apos;..activity.StartPageActivity&apos;</span><br><span class="line">desired_caps[&apos;unicodeKeyboard&apos;]=&apos;true&apos;</span><br><span class="line">desired_caps[&apos;resetKeyboard&apos;]=&apos;true&apos;</span><br><span class="line">driver = webdriver.Remote(&apos;http://127.0.0.1:4723/wd/hub&apos;, desired_caps)</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Appium Desired Capabilities 详解。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="appium" scheme="http://pythonfood.github.io/categories/appium/"/>
    
    
      <category term="appium" scheme="http://pythonfood.github.io/tags/appium/"/>
    
  </entry>
  
  <entry>
    <title>appium安装-windows</title>
    <link href="http://pythonfood.github.io/2018/02/01/appium%E5%AE%89%E8%A3%85-windows/"/>
    <id>http://pythonfood.github.io/2018/02/01/appium安装-windows/</id>
    <published>2018-02-01T01:00:00.000Z</published>
    <updated>2018-02-24T01:43:21.725Z</updated>
    
    <content type="html"><![CDATA[<p>appium环境搭建的简单步骤：安装jdk——安装android sdk——安装python——安装node.js——安装appium server——安装appium python客户端。<br><a id="more"></a></p><h3 id="1-安装jdk"><a href="#1-安装jdk" class="headerlink" title="1.安装jdk"></a>1.安装jdk</h3><blockquote><p>(1)下载jdk</p><blockquote><p>官网地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p></blockquote><p>(2)安装jdk</p><blockquote><p>根据提示安装，安装路径自定义：D:\Program Files\Java\jdk1.7.0_80</p></blockquote><p>(3)配置java环境变量</p><blockquote><p>1)系统变量→新建JAVA_HOME变量→变量值：D:\Program Files\Java\jdk1.7.0_80<br>2)系统变量→新建CLASSPATH变量→变量值：<code>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar</code><br>3)系统变量→编辑Path变量→增加：<code>;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</code>   </p></blockquote><p>(4)验证环境</p><blockquote><p>cmd输入<code>java -version</code>命令查看java版本。</p></blockquote></blockquote><h3 id="2-安装android-sdk"><a href="#2-安装android-sdk" class="headerlink" title="2.安装android sdk"></a>2.安装android sdk</h3><blockquote><p>(1)下载android sdk</p><blockquote><p>可以直接下载adt：<a href="http://tools.android-studio.org/index.php/adt-bundle-plugin" target="_blank" rel="noopener">http://tools.android-studio.org/index.php/adt-bundle-plugin</a></p></blockquote><p>(2)安装android sdk</p><blockquote><p>将adt压缩包解压到自定义路径：D:\Program Files\adt-bundle-windows-x86-20130917  </p></blockquote><p>(3)配置android环境变量</p><blockquote><p>1)系统变量→新建ANDROID_HOME变量→变量值：D:\Program Files\adt-bundle-windows-x86-20130917\sdk<br>2)系统变量→编辑Path变量→增加：<code>;%ANDROID_HOME%\tools;%ANDROID_HOME%\platform-tools;</code></p></blockquote><p>(4)验证环境</p><blockquote><p>cmd输入<code>adb</code>命令查看adb版本。</p></blockquote></blockquote><h3 id="3-安装Python"><a href="#3-安装Python" class="headerlink" title="3.安装Python"></a>3.<a href="https://pythonfood.github.io/2017/12/28/python安装-windows/#more">安装Python</a></h3><h3 id="4-安装node-js"><a href="#4-安装node-js" class="headerlink" title="4.安装node.js"></a>4.安装node.js</h3><blockquote><p>(1)下载node.js</p><blockquote><p>官网地址：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></p></blockquote><p>(2)安装node.js</p><blockquote><p>根据提示安装，安装路径自定义，自动添加PATH环境变量。</p></blockquote><p>(3)验证环境</p><blockquote><p>cmd输入<code>node -v</code>命令查看node版本。</p></blockquote></blockquote><h3 id="5-安装appium-server"><a href="#5-安装appium-server" class="headerlink" title="5.安装appium server"></a>5.安装appium server</h3><blockquote><p>方法1：npm安装</p><blockquote><p>(1)cmd输入<code>npm install -g appium</code>命令等待安装完成。（可能会被墙）<br>(2)cmd输入<code>npm install -g appium-doctor</code>命令安装Appium-doctor。<br>(3)cmd输入<code>appium-doctor</code>命令看到’All Checks were successful’则环境搭建成功。</p></blockquote><p>方法2：下载安装</p><blockquote><p>(1)下载地址：<a href="http://appium.io/" target="_blank" rel="noopener">http://appium.io/</a> 或 <a href="https://bitbucket.org/appium/appium.app/downloads/" target="_blank" rel="noopener">https://bitbucket.org/appium/appium.app/downloads/</a><br>(2)根据提示安装，安装路径自定义，自动添加PATH环境变量：<code>;D:\Program Files\Appium\node_modules\.bin;</code><br>(3)打开Appium图标验证安装成功。</p></blockquote><p>ps：appiun的server已经很久没有更新了，目前appium-desktop来继续他的使命。</p></blockquote><h3 id="6-安装appium-python客户端"><a href="#6-安装appium-python客户端" class="headerlink" title="6.安装appium python客户端"></a>6.安装appium python客户端</h3><blockquote><p>方法1：pip安装</p><blockquote><p>cmd输入<code>pip install Appium-Python-Client</code>命令等待安装完成。</p></blockquote><p>方法2：下载源码安装 </p><blockquote><p>(1)下载地址：<a href="https://pypi.python.org/pypi/Appium-Python-Client" target="_blank" rel="noopener">https://pypi.python.org/pypi/Appium-Python-Client</a><br>(2)解压后，cmd输入<code>cd Appium-Python-Client-X.X</code>命令进入目录。<br>(3)cmd输入<code>python setup.py install</code>命令进行安装。</p></blockquote></blockquote><h3 id="7-验证环境-小示例"><a href="#7-验证环境-小示例" class="headerlink" title="7.验证环境(小示例)"></a>7.验证环境(小示例)</h3><blockquote><p>(1)启动服务</p><blockquote><p>1)连接手机。<br>2)cmd输入<code>appium</code>命令启动服务。<br>3)打印日志如下图，则服务启动成功：</p><blockquote><p><img src="/2018/02/01/appium安装-windows/启动appium服务.png" alt="启动appium服务"></p></blockquote></blockquote><p>(2)代码示例</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from appium import webdriver</span><br><span class="line">from time import sleep</span><br><span class="line">import unittest</span><br><span class="line"></span><br><span class="line">class CalTest(unittest.TestCase):</span><br><span class="line">def setUp(self):</span><br><span class="line">desired_caps=&#123;&#125;</span><br><span class="line">desired_caps[&apos;platformName&apos;]=&apos;Android&apos;</span><br><span class="line">desired_caps[&apos;platformVersion&apos;]=&apos;5.0.2&apos;</span><br><span class="line">desired_caps[&apos;deviceName&apos;]=&apos;1ae7be68&apos;</span><br><span class="line">desired_caps[&apos;appPackage&apos;]=&apos;com.android.calculator2&apos;</span><br><span class="line">desired_caps[&apos;appActivity&apos;]=&apos;.Calculator&apos;</span><br><span class="line">self.driver=webdriver.Remote(&apos;http://localhost:4723/wd/hub&apos;,desired_caps)</span><br><span class="line"></span><br><span class="line">def tearDown(self):</span><br><span class="line">self.driver.quit()</span><br><span class="line"></span><br><span class="line">def test_add(self):</span><br><span class="line">driver.find_element_by_name(&quot;8&quot;).click()</span><br><span class="line">driver.find_element_by_id(&apos;digit7&apos;).click()</span><br><span class="line">driver.find_element_by_id(&apos;plus&apos;).click()</span><br><span class="line">driver.find_element_by_id(&apos;digit3&apos;).click()</span><br><span class="line">driver.find_element_by_id(&apos;equal&apos;).click()</span><br><span class="line">sleep(3)</span><br><span class="line">driver.find_element_by_id(&apos;clear&apos;).click()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">       suite = unittest.TestLoader().loadTestsFromTestCase(CalTest)</span><br><span class="line">       unittest.TextTestRunner(verbosity=2).run(suite)</span><br></pre></td></tr></table></figure></blockquote><p>(3)执行脚本    </p></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;appium环境搭建的简单步骤：安装jdk——安装android sdk——安装python——安装node.js——安装appium server——安装appium python客户端。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="appium" scheme="http://pythonfood.github.io/categories/appium/"/>
    
    
      <category term="appium" scheme="http://pythonfood.github.io/tags/appium/"/>
    
  </entry>
  
  <entry>
    <title>selenium常用API</title>
    <link href="http://pythonfood.github.io/2018/01/01/selenium%E5%B8%B8%E7%94%A8API/"/>
    <id>http://pythonfood.github.io/2018/01/01/selenium常用API/</id>
    <published>2018-01-01T02:00:00.000Z</published>
    <updated>2018-02-26T07:13:34.628Z</updated>
    
    <content type="html"><![CDATA[<p>selenium常用API笔记。<br><a id="more"></a></p><h3 id="1-浏览器操作"><a href="#1-浏览器操作" class="headerlink" title="1.浏览器操作"></a>1.浏览器操作</h3><p>(1)浏览器最大化</p><blockquote><p><code>driver.maximize_window()</code> #浏览器最大化</p></blockquote><p>(2)设置浏览器宽、高</p><blockquote><p><code>driver.set_window_size(480, 800)</code> #设置浏览器宽、高</p></blockquote><p>(3)浏览器后退</p><blockquote><p><code>driver.back()</code> #浏览器后退</p></blockquote><p>(4)浏览器前进</p><blockquote><p><code>driver.forward()</code> #浏览器前进</p></blockquote><p>(5)刷新当前页面</p><blockquote><p><code>driver.refresh()</code> #刷新当前页面</p></blockquote><p>(6)退出浏览器</p><blockquote><p><code>driver.quit()</code> #退出浏览器</p></blockquote><p>(7)关闭单个窗口</p><blockquote><p><code>driver.close()</code> #关闭单个窗口</p></blockquote><h3 id="2-元素定位"><a href="#2-元素定位" class="headerlink" title="2.元素定位"></a>2.元素定位</h3><p>(1)id定位 </p><blockquote><p><code>find_element_by_id(&quot;kw&quot;)</code> #一般唯一</p></blockquote><p>(2)name定位 </p><blockquote><p><code>find_element_by_name(&quot;wd&quot;)</code> #一般唯一</p></blockquote><p>(3)class_name定位 </p><blockquote><p><code>find_element_by_class_name(&quot;bg s_btn&quot;)</code> #不唯一</p></blockquote><p>(4)tag_name定位</p><blockquote><p><code>find_element_by_tag_name(&quot;input&quot;)</code> #不唯一</p></blockquote><p>(5)link_text定位</p><blockquote><p><code>find_element_by_link_text(u&quot;这是一条新闻&quot;)</code> #定位文本链接</p></blockquote><p>(6)partial_link_text定位</p><blockquote><p><code>find_element_by_partial_link_text(&quot;这是一条新&quot;)</code> #定位可以唯一标识这个文本链接的一部分</p></blockquote><p>(7)xpath定位</p><blockquote><p>1)绝对路径定位</p><blockquote><p><code>find_element_by_xpath(&quot;/html/body/div[2]/form/span/input&quot;)</code> #从根节点开始绝对路径</p></blockquote><p>2)相对路径定位</p><blockquote><p><code>find_element_by_xpath(&quot;//input[@id=’input’]&quot;)</code> #通过自身的id 属性定位<br><code>find_element_by_xpath(&quot;//span[@id=’input-container’]/input&quot;)</code> #通过上一级目录的id 属性定位<br><code>find_element_by_xpath(&quot;//div[@name=’q’]/form/span[2]/input&quot;)</code> #通过上三级目录的name 属性定位<br><code>find_element_by_xpath(&quot;//div[@id=’hd’ or @name=’q’]/form/span/input&quot;)</code> #通过布尔逻辑运算 属性定位</p></blockquote></blockquote><p>(8)css_selector定位</p><blockquote><p><code>find_element_by_css_selector(&quot;#su&quot;)</code> #通过id属性定位<br><code>find_element_by_css_selector(&quot;.s_ipt&quot;)</code> #通过class属性定位<br><code>find_element_by_css_selector(&quot;input&quot;)</code> #通过标签名定位<br><code>find_element_by_css_selector(&quot;span&gt;input&quot;)</code> #通过父子关系定位<br><code>find_element_by_css_selector(&quot;input[maxlength=&#39;100&#39;]&quot;)</code> #通过属性定位<br><code>find_element_by_css_selector(&quot;span.bgs_ipt_wr&gt;input.s_ipt&quot;)</code> #组合定位</p><blockquote><p><img src="/2018/01/01/selenium常用API/css_selector定位.png" alt="css_selector定位"></p></blockquote></blockquote><p>(9)用By定位<br>需要使用定位方法时，By可以设置定位策略。使用前导入By模块<code>from selenium.webdriver.common.by import By</code>。</p><blockquote><p><code>find_element(By.ID,&quot;kw&quot;)</code><br><code>find_element(By.NAME,&quot;wd&quot;)</code><br><code>find_element(By.CLASS_NAME,&quot;s_ipt&quot;)</code><br><code>find_element(By.TAG_NAME,&quot;input&quot;)</code><br><code>find_element(By.LINK_TEXT,u&quot;新闻&quot;)</code><br><code>find_element(By.PARTIAL_LINK_TEXT,u&quot;新&quot;)</code><br><code>find_element(By.XPATH,&quot;//*[@class=&#39;bgs_btn&#39;]&quot;)</code><br><code>find_element(By.CSS_SELECTOR,&quot;span.bgs_btn_wr&gt;input#su&quot;)</code></p></blockquote><h3 id="3-元素操作"><a href="#3-元素操作" class="headerlink" title="3.元素操作"></a>3.元素操作</h3><p>(1)clear()  #清除输入框内容</p><blockquote><p><code>driver.find_element_by_id(&quot;user_name&quot;).clear()</code></p></blockquote><p>(2)send_keys(“xx”) #输入框里输入xx内容</p><blockquote><p><code>driver.find_element_by_id(&quot;user_name&quot;).send_keys(&quot;username&quot;)</code></p></blockquote><p>(3)click() #单击一个按钮、连接等</p><blockquote><p><code>driver.find_element_by_id(&quot;dl_an_submit&quot;).click()</code></p></blockquote><p>(4)submit() #提交表单</p><blockquote><p><code>driver.find_element_by_id(&quot;dl_an_submit&quot;).submit()</code></p></blockquote><p>(5)size #返回元素的尺寸</p><blockquote><p><code>size=driver.find_element_by_id(&quot;kw&quot;).size</code> #返回百度输入框的宽高</p></blockquote><p>(6)text #获取元素的文本</p><blockquote><p><code>text=driver.find_element_by_id(&quot;cp&quot;).text</code> #返回百度页面底部备案信息</p></blockquote><p>(7)get_attribute(name) #获得属性值</p><blockquote><p><code>attribute=driver.find_element_by_id(&quot;kw&quot;).get_attribute(&#39;type&#39;)</code> #返回元素的属性值，可以是id、name、type 或元素拥有的其它任意属性</p></blockquote><p>(8)is_displayed() #检查该元素是否用户可见    </p><blockquote><p><code>result=driver.find_element_by_id(&quot;kw&quot;).is_displayed()</code> #返回元素的结果是否可见，返回结果为True 或False</p></blockquote><h3 id="4-鼠标事件"><a href="#4-鼠标事件" class="headerlink" title="4.鼠标事件"></a>4.鼠标事件</h3><p>ActionChains用于生成用户的行为，所有的行为都存储在actionchains对象中。通过perform()执行存储的行为。<br>使用前导入ActionChains模块<code>from selenium.webdriver.common.action_chains import ActionChains</code>。</p><p>(1)perform() #顺序执行所有ActionChains中存储的行为</p><blockquote><p><code>ActionChains(driver).context_click(操作对象).perform()</code> #ActionChains方法的书写格式</p></blockquote><p>(2)context_click() #右击 </p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">right =driver.find_element_by_xpath(&quot;xx&quot;) #定位到要右击的元素</span><br><span class="line">ActionChains(driver).context_click(right).perform() #对定位到的元素执行鼠标右键操作</span><br></pre></td></tr></table></figure></blockquote><p>(3)double_click() #双击</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double =driver.find_element_by_xpath(&quot;xxx&quot;) #定位到要双击的元素</span><br><span class="line">ActionChains(driver).double_click(double).perform() #对定位到的元素执行鼠标双击操作</span><br></pre></td></tr></table></figure></blockquote><p>(4)drag_and_drop() #鼠标拖放</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element = driver.find_element_by_name(&quot;xxx&quot;) #定位元素的原位置</span><br><span class="line">target = driver.find_element_by_name(&quot;xxx&quot;) #定位元素要移动到的目标位置</span><br><span class="line">ActionChains(driver).drag_and_drop(element, target).perform() #执行元素的移动操作</span><br></pre></td></tr></table></figure></blockquote><p>(5)move_to_element() #鼠标悬停</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">above = driver.find_element_by_xpath(&quot;xxx&quot;) #定位到鼠标移动到上面的元素</span><br><span class="line">ActionChains(driver).move_to_element(above).perform() #对定位到的元素执行鼠标移动到上面的操作</span><br></pre></td></tr></table></figure></blockquote><p>(6)click_and_hold() #按下鼠标左键    </p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">left=driver.find_element_by_xpath(&quot;xxx&quot;) #定位到鼠标按下左键的元素</span><br><span class="line">ActionChains(driver).click_and_hold(left).perform() #对定位到的元素执行鼠标左键按下的操作</span><br></pre></td></tr></table></figure></blockquote><h3 id="5-键盘事件"><a href="#5-键盘事件" class="headerlink" title="5.键盘事件"></a>5.键盘事件</h3><p>使用前导入keys模块<code>from selenium.webdriver.common.keys import Keys</code>。</p><p>(1)send_keys(Keys.BACK_SPACE) #删除键（BackSpace）</p><p>(2)send_keys(Keys.SPACE) #空格键(Space)</p><p>(3)send_keys(Keys.TAB) #制表键(Tab)</p><p>(4)send_keys(Keys.ESCAPE) #回退键（Esc）</p><p>(5)send_keys(Keys.ENTER) #回车键（Enter）</p><p>(6)send_keys(Keys.F5) #刷新建（F5）</p><p>(7)send_keys(Keys.CONTROL,’a’) #全选（Ctrl+A）</p><p>(8)send_keys(Keys.CONTROL,’c’) #复制（Ctrl+C）</p><p>(9)send_keys(Keys.CONTROL,’x’) #剪切（Ctrl+X）</p><p>(10)send_keys(Keys.CONTROL,’v’) #粘贴（Ctrl+V）</p><h3 id="6-获取验证信息"><a href="#6-获取验证信息" class="headerlink" title="6.获取验证信息"></a>6.获取验证信息</h3><p>(1)获得当前页面title，判断页面跳转是否符合预期</p><blockquote><p><code>title = driver.title</code></p></blockquote><p>(2)获得当前URL，一般用来测试重定向</p><blockquote><p><code>url = driver.current_url</code></p></blockquote><h3 id="7-设置等待时间"><a href="#7-设置等待时间" class="headerlink" title="7.设置等待时间"></a>7.设置等待时间</h3><p>(1)sleep() #休眠等待<br>sleep()方法以秒为单位，假如休眠时间小于 1 秒，可以用小数表示。<br>使用前导入sleep模块<code>from time import sleep</code>。</p><blockquote><p><code>sleep(0.5)</code></p></blockquote><p>(2)implicitly_wait() #隐式等待<br>隐式等待是通过一定的时长等待页面所元素加载完成。<br>如果超出了设置的时长元素还没有被加载测抛NoSuchElementException异常。<br>implicitly_wait()默认参数的单位为秒。</p><blockquote><p><code>driver.implicitly_wait(10)</code> #设置智能等待10秒</p></blockquote><p>(3)WebDriverWait() #显式等待<br>显式等待是等待某个条件成立时继续执行，否则在达到最大时长则抛TimeoutException异常。</p><p>WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None)，参数解释如下：</p><ul><li>driver - WebDriver 的驱动程序(Ie, Firefox, Chrome 或远程)</li><li>timeout - 最长超时时间，默认以秒为单位</li><li>poll_frequency - 休眠时间的间隔（步长）时间，默认为 0.5 秒</li><li>ignored_exceptions - 超时后的异常信息，默认情况下抛 NoSuchElementException 异常。</li></ul><p>使用前导入WebDriverWait模块<code>from selenium.webdriver.support.ui import WebDriverWait</code>。</p><p>WebDriverWai()一般由 unit()或 until_not()方法配合使用，下面是 unit()和 until_not()方法的说明：<br>1)until(method, message=’’)调用该方法提供的驱动程序作为一个参数，直到返回值不为False。</p><blockquote><p><code>element = WebDriverWait(driver, 10).until(lambda x: x.find_element_by_id(“someId”))</code></p></blockquote><p>2)until_not(method, message=’’)调用该方法提供的驱动程序作为一个参数，直到返回值为 False。</p><blockquote><p><code>is_disappeared = WebDriverWait(driver, 30, 1, (ElementNotVisibleException)).until_not(lambda x: x.find_element_by_id(“someId”).is_displayed())</code>    </p></blockquote><h3 id="8-定位一组对象"><a href="#8-定位一组对象" class="headerlink" title="8.定位一组对象"></a>8.定位一组对象</h3><p>(1)find_elements 用于获取一组元素:</p><blockquote><p><code>find_elements_by_id(‘xx’)</code><br><code>find_elements_by_name(‘xx’)</code><br><code>find_elements_by_class_name(‘xx’)</code><br><code>find_elements_by_tag_name(‘xx’)</code><br><code>find_elements_by_link_text(‘xx’)</code><br><code>find_elements_by_partial_link_text(‘xx’)</code><br><code>find_elements_by_xpath(‘xx’)</code><br><code>find_elements_by_css_selector(‘xx’)</code></p></blockquote><p>(2)可以使用for… in …对这一组元素进行遍历:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for checkbox in checkboxes:</span><br><span class="line">checkbox.click()</span><br></pre></td></tr></table></figure></blockquote><p>(3)也可以使用pop（）方法获得这一组元素中的第几个，然后再对该元素进行操作：</p><blockquote><p><code>find_elements_by_id(‘xx’).pop().click()</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pop（）或pop（-1）#默认获取一组元素中的最后一个</span><br><span class="line">pop(0)   #默认获取一组元素的第一个元素</span><br><span class="line">pop(1)   #默认获取一组元素的第二个元素</span><br><span class="line">...... #以此类推</span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="9-层级定位"><a href="#9-层级定位" class="headerlink" title="9.层级定位"></a>9.层级定位</h3><p>经常会有这样的需求：页面上有很多个属性基本相同的元素 ，现在需要具体定位到其中的一个。由于属性基本相当，所以在定位的时候会有些麻烦，这时候就需要用到层级定位。先定位父元素，然后再通过父元素定位子孙元素：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#点击 Link1 链接（弹出下拉列表）</span><br><span class="line">driver.find_element_by_link_text(&apos;Link1&apos;).click() </span><br><span class="line">#在父亲元件下找到 link 为 Action 的子元素</span><br><span class="line">menu=driver.find_element_by_id(&apos;dropdown1&apos;).find_element_by_link_text(&apos;Another action&apos;)</span><br></pre></td></tr></table></figure></blockquote><h3 id="10-表单切换"><a href="#10-表单切换" class="headerlink" title="10.表单切换"></a>10.表单切换</h3><p>在web应用中经常会出现frame/iframe 表单内嵌套的应用，WebDriver只能在一个页面上进行元素识别定位，对于frame/iframe表单内嵌页面上的元素无法直接定位。这时需要通过switch_to.frame()方法将当前定位的主体切换为frame/iframe表单的内嵌页面中。</p><p>(1)switch_to_frame()默认可以直接取表单的id或name属性进行切换：</p><blockquote><p><code>driver.switch_to_frame(&quot;if&quot;)</code> #id = “if”<br><code>driver.switch_to_frame(&quot;nf&quot;)</code> #name = “nf” </p></blockquote><p>(2)如果 iframe 没有可用的 id 和 name 可以通过下面的方式进行定位：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#先通过xpth定位到iframe </span><br><span class="line">xf = driver.find_element_by_xpath(&apos;//*[@class=&quot;if&quot;]&apos;)</span><br><span class="line">#再将定位对象传给switch_to_frame()方法 </span><br><span class="line">driver.switch_to_frame(xf)</span><br></pre></td></tr></table></figure></blockquote><p>(3)如果完成了在当前表单上的操作，跳出当前表单：</p><blockquote><p><code>driver.switch_to.parent_content()</code> #返回到父级表单<br><code>driver.switch_to.default_conent()</code> #返回到主文档页面</p></blockquote><h3 id="11-多窗口切换"><a href="#11-多窗口切换" class="headerlink" title="11.多窗口切换"></a>11.多窗口切换</h3><ul><li><code>current_window_handle</code> #获得当前窗口句柄。</li><li><code>window_handles</code> #返回所有窗口的句柄到当前对话。</li><li><code>switch_to.window</code>(窗口句柄) #切换到对应的窗口。</li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nowhandle=driver.current_window_handle #获得当前窗口句柄。</span><br><span class="line">driver.find_element_by_link_text(u&quot;发表话题&quot;).click()</span><br><span class="line">time.sleep(3)</span><br><span class="line">allhandles=driver.window_handles #返回所有窗口的句柄到当前对话。</span><br><span class="line">for handle in allhandles:</span><br><span class="line">if(handle!=nowhandle):</span><br><span class="line">driver.switch_to.window(handle) #切换到对应的窗口。</span><br></pre></td></tr></table></figure></blockquote><h3 id="12-警告框处理"><a href="#12-警告框处理" class="headerlink" title="12.警告框处理"></a>12.警告框处理</h3><p>处理javascript所生成的alert、confirm、prompt，可以使用switch_to_alert()方法定位到alert/confirm/prompt，然后使用text/accept/dismiss/send_keys等方法进行操作：</p><ul><li><code>text</code> #返回 alert/confirm/prompt 中的文字信息。</li><li><code>accept</code> #点击确认按钮。</li><li><code>dismiss</code> #点击取消按钮，如果有的话。</li><li><code>send_keys</code> #输入值，这个 alert\confirm 没有对话框就不能用了，不然会报错。</li></ul><blockquote><p><code>driver.switch_to_alert().accept()</code></p></blockquote><h3 id="13-上传文件"><a href="#13-上传文件" class="headerlink" title="13.上传文件"></a>13.上传文件</h3><p>(1)查找到input标签，通过send_keys)传入本地文件路径从而模拟上传功能:</p><blockquote><p><code>driver.find_element_by_name(&quot;file&quot;).send_keys(&#39;D:\\upload_file.txt&#39;)</code> #查找到input标签，然后send进去</p></blockquote><p>(2)使用AutoIt识别flash控件和windows控件实现自动上传文件</p><blockquote><p>1)下载安装，官方网站：<a href="https://www.autoitscript.com/site/" target="_blank" rel="noopener">https://www.autoitscript.com/site/</a><br>2)配置编辑AutoIt。<br>3)<code>os.system(&quot;D:\\upfile.exe&quot;)</code> #通过系统调用upfile.exe上传程序 </p></blockquote><h3 id="14-下载文件"><a href="#14-下载文件" class="headerlink" title="14.下载文件"></a>14.下载文件</h3><p>(1)以FireFox为例，为了让FireFox浏览器能实现文件的载，我们需要通过FirefoxProfile()对其参数做一个设置:</p><ul><li><code>browser.download.folderList</code> #设置成0代表下载到浏览器默认下载路径；设置成2则可以保存到指定目录。</li><li><code>browser.download.manager.showWhenStarting</code> #是否显示开始，Ture为显示，Flase为不显示。</li><li><code>browser.download.dir</code> #用于指定你所下载文件的目录。os.getcwd()该函数不需要传递参数，用于返回当前的目录。</li><li><code>browser.helperApps.neverAsk.saveToDisk</code> #指定要下载页面的Content-type值，“application/octet-stream”为文件的类型。HTTP Content-type常用对照表：<a href="http://tool.oschina.net/commons" target="_blank" rel="noopener">http://tool.oschina.net/commons</a></li></ul><p>(2)这些参数的设置可以通过在Firefox浏览器地址栏输入：about:config 进行设置，如图： </p><p><img src="/2018/01/01/selenium常用API/firefox参数设置.png" alt="firefox参数设置"></p><p>(3)浏览器设置代码示例：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8 </span><br><span class="line">from selenium import webdriver </span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">fp = webdriver.FirefoxProfile()</span><br><span class="line">fp.set_preference(&quot;browser.download.folderList&quot;,2) </span><br><span class="line">fp.set_preference(&quot;browser.download.manager.showWhenStarting&quot;,False) </span><br><span class="line">fp.set_preference(&quot;browser.download.dir&quot;, os.getcwd()) </span><br><span class="line">fp.set_preference(&quot;browser.helperApps.neverAsk.saveToDisk&quot;, &quot;application/octet-stream&quot;)</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox(firefox_profile=fp) </span><br><span class="line">driver.get(&quot;http://pypi.Python.org/pypi/selenium&quot;) </span><br><span class="line">driver.find_element_by_partial_link_text(&quot;selenium-2&quot;).click()</span><br></pre></td></tr></table></figure></blockquote><h3 id="15-操作Cookie"><a href="#15-操作Cookie" class="headerlink" title="15.操作Cookie"></a>15.操作Cookie</h3><p>webdriver操作cookie的方法有：</p><ul><li><code>get_cookies()</code> #获得所有cookie信息  </li><li><code>get_cookie(name)</code> #返回有特定name值有cookie信息  </li><li><code>add_cookie(cookie_dict)</code> #添加cookie，必须有name和value值  </li><li><code>delete_cookie(name)</code> #删除特定(部分)的cookie信息  </li><li><code>delete_all_cookies()</code> #删除所有cookie信息</li></ul><p>(1)先通过get_cookies()来获取当前浏览器的cookie信息。<br>通过打印结果可以看出，cookie 是以字典的形式进行存放的，知道了cookie的存放形式，那么我们就可以按照这种形式向浏览器中写入cookie信息。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver.get(&quot;http://www.youdao.com&quot;)</span><br><span class="line">cookie= driver.get_cookies() # 获得cookie信息 </span><br><span class="line">print cookie #将获得cookie的信息打印</span><br></pre></td></tr></table></figure><blockquote><p><img src="/2018/01/01/selenium常用API/cookie打印信息.png" alt="cookie打印信息"></p></blockquote></blockquote><p>(2)再进行cookie的添加、删除等操作。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver.get(&quot;http://www.youdao.com&quot;)</span><br><span class="line">driver.add_cookie(&#123;&apos;name&apos;:&apos;key-aaaaaaa&apos;, &apos;value&apos;:&apos;value-bbbbbb&apos;&#125;) #向cookie的name 和value添加会话信息。</span><br></pre></td></tr></table></figure></blockquote><h3 id="16-调用javascript"><a href="#16-调用javascript" class="headerlink" title="16.调用javascript"></a>16.调用javascript</h3><p>当webdriver遇到没法完成的操作时，可以考虑调用JavaScript来完成。<br>webdriver提供<code>execute_script()</code>方法用来调用js代码：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#修改元素的属性</span><br><span class="line">js = &apos;document.querySelectorAll(&quot;select&quot;)[0].style.display=&quot;block&quot;;&apos;</span><br><span class="line">driver.execute_script(js)</span><br></pre></td></tr></table></figure></blockquote><h3 id="17-控制浏览器滚动条"><a href="#17-控制浏览器滚动条" class="headerlink" title="17.控制浏览器滚动条"></a>17.控制浏览器滚动条</h3><p>(1)上下滚动：<br><code>document.body.scrollTop</code> #网页被卷去的高。置顶设置：scrollTop为0；置底设置：scrollTop大于窗口的高度像素。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#将页面滚动条拖到底部</span><br><span class="line">js=&quot;var q=document.documentElement.scrollTop=10000&quot;</span><br><span class="line">driver.execute_script(js)</span><br><span class="line">time.sleep(3)</span><br><span class="line">#将滚动条移动到页面的顶部</span><br><span class="line">js1=&quot;var q=document.documentElement.scrollTop=0&quot;</span><br><span class="line">driver.execute_script(js1)</span><br><span class="line">time.sleep(3)</span><br></pre></td></tr></table></figure></blockquote><p>(2)左右滚动：<br><code>window.scrollTo(左边距,上边距)</code> #指定左右滚动的坐标即可</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">js=&quot; window.scrollTo(200,1000);&quot; </span><br><span class="line">driver.execute_script(js)</span><br></pre></td></tr></table></figure></blockquote><h3 id="18-窗口截图"><a href="#18-窗口截图" class="headerlink" title="18.窗口截图"></a>18.窗口截图</h3><p>Webdriver提供了截图函数<code>get_screenshot_as_file()</code>来截取当前窗口:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">driver.find_element_by_id(&apos;kw_error&apos;).send_key(&apos;selenium&apos;) </span><br><span class="line">driver.find_element_by_id(&apos;su&apos;).click() </span><br><span class="line">except: </span><br><span class="line">driver.get_screenshot_as_file(&quot;D:\\baidu_error.jpg&quot;) #截图，保存到指定路径</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure></blockquote><h3 id="19-获取对象的属性值"><a href="#19-获取对象的属性值" class="headerlink" title="19.获取对象的属性值"></a>19.获取对象的属性值</h3><p>有时候我们定位页面上的元素发现常用的id、name等属性是相同的。这个时候我们只能通过常规的定位方法定位出一组元素，然后观察通过元素的属性可以定位出单个元素。<br>可使用.get_attribute()方法:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 选择页面上所有的tag name为input的元素</span><br><span class="line">inputs = driver.find_elements_by_tag_name(&apos;input&apos;)</span><br><span class="line">#然后循环遍历出属性data-node值为594434493的元素，单击勾选</span><br><span class="line">for input in inputs:</span><br><span class="line">if input.get_attribute(&apos;data-node&apos;) == &apos;594434493&apos;:</span><br><span class="line">input.click()</span><br></pre></td></tr></table></figure></blockquote><h3 id="20-验证码处理"><a href="#20-验证码处理" class="headerlink" title="20.验证码处理"></a>20.验证码处理</h3><p>(1)去掉验证码。<br>(2)设置万能码。<br>(3)验证码识别技术<br>例如可以通过Python-tesseract来识别图片验证码,能够读取任何常规的图片文件(JPG,GIF,PNG,TIFF 等)。不过，目前市面上的验证码识别技术识别率都不是100% 。<br>(4)记录cookie<br>通过向浏览器中添加cookie可以绕过登录的验证码,这种方式最大的问题是如何从浏览器的Cookie中找到用户名和密码对应的key值，并传传输入对应的登录信息。如果网站登录时根本不将用户名和密码写Cookie，这会存在一定的安全风险。那么这种方式就不起作用了。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#访问xx网站 </span><br><span class="line">driver.get(&quot;http://www.xx.cn&quot;)</span><br><span class="line">#将用户名密码写入浏览器cookie </span><br><span class="line">driver.add_cookie(&#123;&apos;name&apos;:&apos;Login_UserNumber&apos;, &apos;value&apos;:&apos;username&apos;&#125;) </span><br><span class="line">driver.add_cookie(&#123;&apos;name&apos;:&apos;Login_Passwd&apos;, &apos;value&apos;:&apos;password&apos;&#125;)</span><br><span class="line">#再次访问xx网站，将会自动登录 </span><br><span class="line">driver.get(&quot;http://www.xx.cn/&quot;) </span><br><span class="line">time.sleep(3)</span><br></pre></td></tr></table></figure></blockquote><p>(5)内部提供一个接口获得验证码，然后通过js代码把获取的验证码填写进去：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#自动获取验证码并填写</span><br><span class="line">js=&quot;$.getJSON(&apos;http://xxx.xxx.com/util/getCode.jsonp?callback=?&apos;,function(data)&#123;$(&apos;.imgcode&apos;).val(data.code);&#125;)&quot;</span><br><span class="line">driver.execute_script(js)</span><br></pre></td></tr></table></figure></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;selenium常用API笔记。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="selenium" scheme="http://pythonfood.github.io/categories/selenium/"/>
    
    
      <category term="selenium" scheme="http://pythonfood.github.io/tags/selenium/"/>
    
  </entry>
  
  <entry>
    <title>selenium安装-windows</title>
    <link href="http://pythonfood.github.io/2018/01/01/selenium%E5%AE%89%E8%A3%85-windows/"/>
    <id>http://pythonfood.github.io/2018/01/01/selenium安装-windows/</id>
    <published>2018-01-01T01:00:00.000Z</published>
    <updated>2018-02-23T10:18:00.724Z</updated>
    
    <content type="html"><![CDATA[<p>selenium环境搭建的简单步骤：安装Python——安装pip——安装selenium——安装浏览器驱动。<br><a id="more"></a></p><h3 id="1-安装Python"><a href="#1-安装Python" class="headerlink" title="1.安装Python"></a>1.<a href="https://pythonfood.github.io/2017/12/28/python安装-windows/#more">安装Python</a></h3><h3 id="2-安装pip"><a href="#2-安装pip" class="headerlink" title="2.安装pip"></a>2.安装pip</h3><blockquote><p>方法1：自动安装</p><blockquote><p>在第1步安装python时，已经安装了pip。</p></blockquote><p>方法2：手动安装</p><blockquote><p>(1)下载pip压缩包：<a href="https://pypi.python.org/pypi/pip#downloads" target="_blank" rel="noopener">https://pypi.python.org/pypi/pip#downloads</a><br>(2)解压后cmd进入解压目录，执行<code>python setup.py install</code>进行安装。</p></blockquote></blockquote><h3 id="3-安装selenium"><a href="#3-安装selenium" class="headerlink" title="3.安装selenium"></a>3.安装selenium</h3><blockquote><p>方法1：命令行安装</p><blockquote><p>进入cmd输入命令’pip install selenium’。</p></blockquote><p>方法2：下载whl包安装</p><blockquote><p>(1)下载selenium安装包：<a href="https://pypi.python.org/pypi/selenium" target="_blank" rel="noopener">https://pypi.python.org/pypi/selenium</a> 或 <a href="https://www.seleniumhq.org/download/" target="_blank" rel="noopener">https://www.seleniumhq.org/download/</a><br>(2)下载完成后，进入cmd输入命令<code>pip install</code>，再直接将文件拖入cmd窗口，回车即可安装。</p></blockquote></blockquote><h3 id="4-安装浏览器驱动"><a href="#4-安装浏览器驱动" class="headerlink" title="4.安装浏览器驱动"></a>4.安装浏览器驱动</h3><blockquote><p>(1)下载浏览器驱动</p><blockquote><p>不同浏览器需下载不同驱动，不同版本浏览器对应不同版本驱动。这里只给出chrome和firefox的驱动下载地址：<br>1)chrome：<a href="http://npm.taobao.org/mirrors/chromedriver" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver</a> 或 <a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/index.html</a><br>2)firefox：<a href="https://github.com/mozilla/geckodriver/releases" target="_blank" rel="noopener">https://github.com/mozilla/geckodriver/releases</a></p></blockquote><p>(2)安装浏览器驱动</p><blockquote><p>下载完驱动后解压，将驱动放置在可执行路径下。这里给出三种路径：<br>1)将浏览器驱动放到python的Path路径下。<br>2)将浏览器驱动放到浏览器的Path路径下。<br>3)自定义路径，新建driver文件夹，将驱动放在driver文件下，最后将该路径添加到环境变量中。</p></blockquote></blockquote><h3 id="5-验证环境（小示例）"><a href="#5-验证环境（小示例）" class="headerlink" title="5.验证环境（小示例）"></a>5.验证环境（小示例）</h3><blockquote><p>(1)创建python文件selenium_python.py，内容如下：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(&apos;http://www.baidu.com/&apos;)</span><br></pre></td></tr></table></figure></blockquote><p>(2)cmd执行命令<code>python selenium_python.py</code>。<br>(3)脚本自动执行，结果如下：</p><blockquote><p><img src="/2018/01/01/selenium安装-windows/脚本执行结果.png" alt="脚本执行结果"></p></blockquote></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;selenium环境搭建的简单步骤：安装Python——安装pip——安装selenium——安装浏览器驱动。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="selenium" scheme="http://pythonfood.github.io/categories/selenium/"/>
    
    
      <category term="selenium" scheme="http://pythonfood.github.io/tags/selenium/"/>
    
  </entry>
  
  <entry>
    <title>python初探</title>
    <link href="http://pythonfood.github.io/2017/12/28/python%E5%88%9D%E6%8E%A2/"/>
    <id>http://pythonfood.github.io/2017/12/28/python初探/</id>
    <published>2017-12-28T10:11:57.000Z</published>
    <updated>2018-02-08T08:03:05.224Z</updated>
    
    <content type="html"><![CDATA[<p>人生苦短，我用python。<br><a id="more"></a></p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><pre><code>#!/usr/bin/python3# -*- coding: utf-8 -*-# 第一个注释# 第二个注释&apos;&apos;&apos;第三注释第四注释&apos;&apos;&apos;&quot;&quot;&quot;第五注释第六注释&quot;&quot;&quot;</code></pre><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><pre><code>第一个字符必须是字母表中字母或下划线&apos;_&apos;。标识符的其他的部分有字母、数字和下划线组成。标识符对大小写敏感。</code></pre><h3 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h3><pre><code>&gt;&gt;&gt; import keyword&gt;&gt;&gt; keyword.kwlist[&apos;False&apos;, &apos;None&apos;, &apos;True&apos;, &apos;and&apos;, &apos;as&apos;, &apos;assert&apos;, &apos;break&apos;, &apos;class&apos;, &apos;continue&apos;, &apos;def&apos;, &apos;del&apos;, &apos;elif&apos;, &apos;else&apos;, &apos;except&apos;, &apos;finally&apos;, &apos;for&apos;, &apos;from&apos;, &apos;global&apos;, &apos;if&apos;, &apos;import&apos;, &apos;in&apos;, &apos;is&apos;, &apos;lambda&apos;, &apos;nonlocal&apos;, &apos;not&apos;, &apos;or&apos;, &apos;pass&apos;, &apos;raise&apos;, &apos;return&apos;, &apos;try&apos;, &apos;while&apos;, &apos;with&apos;, &apos;yield&apos;]</code></pre><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><pre><code>print(&apos;hello world&apos;)input(&apos;\n\n按下 enter 键后退出&apos;)</code></pre><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生苦短，我用python。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://pythonfood.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://pythonfood.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python安装-windows</title>
    <link href="http://pythonfood.github.io/2017/12/28/python%E5%AE%89%E8%A3%85-windows/"/>
    <id>http://pythonfood.github.io/2017/12/28/python安装-windows/</id>
    <published>2017-12-28T10:00:00.000Z</published>
    <updated>2018-02-22T09:00:53.171Z</updated>
    
    <content type="html"><![CDATA[<p>人生苦短，我用python。<br><a id="more"></a></p><h3 id="1-进入python官网，下载最新python安装包"><a href="#1-进入python官网，下载最新python安装包" class="headerlink" title="1. 进入python官网，下载最新python安装包"></a>1. 进入<a href="https://www.python.org/downloads/" target="_blank" rel="noopener">python官网</a>，下载最新python安装包</h3><p><img src="/2017/12/28/python安装-windows/1. 下载最新python安装包.png" alt="1. 下载最新python安装包"></p><h3 id="2-下载完成后进行安装，安装时选自定义安装（customize-installation）"><a href="#2-下载完成后进行安装，安装时选自定义安装（customize-installation）" class="headerlink" title="2. 下载完成后进行安装，安装时选自定义安装（customize installation）"></a>2. 下载完成后进行安装，安装时选自定义安装（customize installation）</h3><p>ps:最好勾选Add python 3.6 to path，如果未勾选，需手动配置环境变量</p><p><img src="/2017/12/28/python安装-windows/2. 下载完成后进行安装.png" alt="2. 下载完成后进行安装">    </p><h3 id="3-一路勾选全部选项，自定义安装路径，完成安装后点击close退出"><a href="#3-一路勾选全部选项，自定义安装路径，完成安装后点击close退出" class="headerlink" title="3. 一路勾选全部选项，自定义安装路径，完成安装后点击close退出"></a>3. 一路勾选全部选项，自定义安装路径，完成安装后点击close退出</h3><p>ps:记得勾选pip安装选项，便于后续安装其他库</p><p><img src="/2017/12/28/python安装-windows/3. 完成安装后点击close退出.png" alt="3. 完成安装后点击close退出"></p><h3 id="4-进入cmd，输入python，测试是否安装成功"><a href="#4-进入cmd，输入python，测试是否安装成功" class="headerlink" title="4. 进入cmd，输入python，测试是否安装成功"></a>4. 进入cmd，输入python，测试是否安装成功</h3><p><img src="/2017/12/28/python安装-windows/4. 测试是否安装成功.png" alt="4. 测试是否安装成功"></p><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生苦短，我用python。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://pythonfood.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://pythonfood.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>monkey</title>
    <link href="http://pythonfood.github.io/2017/12/27/monkey/"/>
    <id>http://pythonfood.github.io/2017/12/27/monkey/</id>
    <published>2017-12-27T12:00:00.000Z</published>
    <updated>2018-02-09T09:35:12.818Z</updated>
    
    <content type="html"><![CDATA[<p>Monkey是Android中的一个命令行工具，可以运行在模拟器里或实际设备中。它向系统发送伪随机的用户事件流(如按键输入、触摸屏输入、手势输入等)，实现对正在开发的应用程序进行压力测试。Monkey测试是一种为了测试软件的稳定性、健壮性的快速有效的方法。<br><a id="more"></a></p><h3 id="常用选项："><a href="#常用选项：" class="headerlink" title="常用选项："></a>常用选项：</h3><blockquote><p><code>--help</code>：打印帮助信息<br><code>-v</code>：指定打印信息的详细级别，一个-v增加一个级别，默认级别为0。</p></blockquote><h3 id="事件选项："><a href="#事件选项：" class="headerlink" title="事件选项："></a>事件选项：</h3><blockquote><p><code>-s</code>：指定产生随机事件种子值，相同的种子值产生相同的事件序列。<br><code>--throttle</code>：每个事件结束后的间隔时间。<br><code>--pct-touch</code>：指定(触摸事件)的百分比<br><code>--pct-motion</code>：（滑动事件)<br><code>--pct-trackball</code>：(轨迹球事件)<br><code>--pct-nav</code>：（导航事件 up/down/left/right）<br><code>--pct-majornav</code>：(主要导航事件 back key 、 menu key)<br><code>--pct-syskeys</code>：(系统按键事件 Home 、Back 、startCall 、 endCall 、 volumeControl)<br><code>--pct-appswitch</code> ：（activity之间的切换）<br><code>--pct-anyevent</code> ：（任意事件）</p></blockquote><h3 id="约束选项："><a href="#约束选项：" class="headerlink" title="约束选项："></a>约束选项：</h3><blockquote><p><code>-p</code>：指定有效的package（如不指定，则对系统中所有package有效），一个-p 对应一个有效package。<br><code>-c</code>：activity必须至少包含一个指定的category，才能被启动，否则启动不了。</p></blockquote><h3 id="调试选项："><a href="#调试选项：" class="headerlink" title="调试选项："></a>调试选项：</h3><blockquote><p><code>--dbg-no-events</code>：初始化启动的activity，但是不产生任何事件。<br><code>--hprof</code>：指定该项后在事件序列发送前后会立即生成分析报告  —— 一般建议指定该项。<br><code>--ignore-crashes</code>：忽略崩溃<br><code>--ignore-timeouts</code>：忽略超时<br><code>--ignore-security-exceptions</code>：忽略安全异常<br><code>--kill-process-after-error</code>：发生错误后直接杀掉进程<br><code>--monitor-native-crashes</code>：跟踪本地方法的崩溃问题<br><code>--wait-dbg</code>：知道连接了调试器才执行monkey测试。</p></blockquote><h3 id="小示例："><a href="#小示例：" class="headerlink" title="小示例："></a>小示例：</h3><pre><code>adb shell monkey -p（指定包名） com.hiveview.cloudscreen.py --throttle（操作延时ms） 1000 -s(指定seed值) 1500859116902 -v -v（信息反馈级别） 1000（执行次数）adb shell monkey -p com.hiveview.cloudscreen.py --throttle 100 --pct-majornav 50 --pct-nav 50 -v -v 1000 &gt;d:\monkey.txtadb shell monkey -p com.hiveview.cloudscreen.py --throttle 100 --ignore-crashes --ignore-timeouts --monitor-native-crashes --pct-majornav 50 --pct-nav 50 -v -v 1000 &gt;d:\monkey_log.txtadb shell monkey -p com.hiveview.cloudscreen.py --throttle 100 --pct-nav 50 --pct-majornav 50 -v -v 1000 &gt;d:\monkey_log.txt</code></pre><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Monkey是Android中的一个命令行工具，可以运行在模拟器里或实际设备中。它向系统发送伪随机的用户事件流(如按键输入、触摸屏输入、手势输入等)，实现对正在开发的应用程序进行压力测试。Monkey测试是一种为了测试软件的稳定性、健壮性的快速有效的方法。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="monkey" scheme="http://pythonfood.github.io/categories/monkey/"/>
    
    
      <category term="monkey" scheme="http://pythonfood.github.io/tags/monkey/"/>
    
  </entry>
  
  <entry>
    <title>安卓专项测试</title>
    <link href="http://pythonfood.github.io/2017/12/27/%E5%AE%89%E5%8D%93%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95/"/>
    <id>http://pythonfood.github.io/2017/12/27/安卓专项测试/</id>
    <published>2017-12-27T11:10:00.000Z</published>
    <updated>2018-02-09T06:04:16.112Z</updated>
    
    <content type="html"><![CDATA[<p>安卓专项测试主要包括：响应时间、cpu、内存、电量、流量、FPS、过度渲染。<br><a id="more"></a></p><h3 id="响应时间："><a href="#响应时间：" class="headerlink" title="响应时间："></a>响应时间：</h3><blockquote><p>1.安装：普通安装、覆盖安装<br>2.启动：冷启动、热启动</p><blockquote><p>(1)adb命令：adb logcat、adb shell am start、adb shell screenrecord等。</p><blockquote><p>小示例：<br>1)adb shell screenrecord /sdcard/demo.mp4<br>2)adb pull /sdcard/demo.mp4 d:\record<br>3)用按帧播放的视频软件播放分析，比如KMplayer。</p></blockquote><p>(2)代码里打点（埋点）。<br>(3)高速相机。<br>(4)秒表。<br>(5)第三方工具或云测平台。</p></blockquote><p>3.跳转：页面之间、控件之间</p></blockquote><h3 id="cpu"><a href="#cpu" class="headerlink" title="cpu:"></a>cpu:</h3><blockquote><p>1.活动状态<br>2.静默状态</p><blockquote><p>(1)第三方工具：腾讯GT、网易Emmagee、阿里易测等。（小白首选）。<br>(2)dumpsys命令：adb shell dumpsys cpuinfo | grep {PackageName}。<br>(3)top命令：adb shell top | grep {PackageName}。</p><blockquote><p>小示例：<br>1)adb shell<br>2)top | grep com.peng.cloudp.tv</p><blockquote><p>第一列PID:进度ID<br>第二列PR:优先级<br>第三列CPU:瞬时CPU占用率<br>第四列进程状态:R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程<br>第五列THR:当前应用所用的线程数<br>第六列VSS:虚拟消耗内存<br>第七列RSS:实际使用物理内存<br>第八列UID:进程所有者的用户ID<br>第九列PR:进程名称</p></blockquote></blockquote></blockquote></blockquote><h3 id="内存："><a href="#内存：" class="headerlink" title="内存："></a>内存：</h3><blockquote><p>1.命令查看内存数据</p><blockquote><p>(1)adb shell dumpsys meminfo {PackageName}查看内存是否是一味上涨的趋势，不会回收或者部分回收。<br>(2)/system/build.prop 查看每个应用分配的最高内存值。<br>adb shell procrank (没有可以从网上下载procrank文件)。</p><blockquote><p>PID:进程ID<br>VSS:虚拟消耗内存<br>RSS:实际使用物理内存，是共享内存+私有内存。<br>PSS:占用私有内存加上平均分配的的共享内存。<br>USS:私有内存，如果应用终止了，这部分内存会释放。如果这个值超过应用被分配的最大值，就会闪退。</p></blockquote></blockquote><p>2.Memory Monitor查看内存风险<br>3.MAT分析内存泄漏<br>4.Zombie辅助检查内存占用</p></blockquote><h3 id="电量："><a href="#电量：" class="headerlink" title="电量："></a>电量：</h3><blockquote><p>1.待机：无网络待机、wifi待机、3G待机等。<br>2.活动状态：不断地进行某些场景操作、看视频、灭屏下载、唤醒等。<br>3.静默状态：打开app后不操作，后台运行。</p><blockquote><p>(1)通过硬件测试：耗电量测试仪、腾讯的电量宝等<br>(2)通过adb shell dumps batterystats命令。（android5.0以上使用）<br>(3)第三方工具或云测平台。<br>(4)android自带的电量统计。</p></blockquote></blockquote><h3 id="流量："><a href="#流量：" class="headerlink" title="流量："></a>流量：</h3><blockquote><p>1.活动状态<br>2.静默状态</p><blockquote><p>(1)通过Tcpdump抓包，然后用Wireshark分析。如果想更自动化，可以用FildderCore二次开发。<br>(2)查看Linux流量统计文件。</p><blockquote><p>小示例：<br>1)ps | grep com.peng.cloudp.tv （获取鹏云视讯的pid为9696）<br>2)cat /proc/9696/status （通过pid值获取uid为10035）<br>3)cat /proc/uid_stat/10035/tcp_snd （通过uid获取发送的流量byte,为15584）<br>4)cat /proc/uid_stat/10035/tcp_rcv （通过uid获取接收的流量byte,为16778）</p></blockquote><p>(3)利用类似DDMS的工具查看流量。（小白首选）<br>(4)通过Android API 的 TrafficStats类来统计。<br>(5)第三方工具或云测平台。</p></blockquote></blockquote><h3 id="FPS："><a href="#FPS：" class="headerlink" title="FPS："></a>FPS：</h3><blockquote><p>1.adb shell dumpsys gfxinfo</p><blockquote><p>小示例：<br>1)adb shell dumpsys gfxinfo com.peng.cloudp.tv &gt;&gt; com.peng.cloudp.tv.txt<br>2)抓取数据后用表格进行分析</p></blockquote><p>2.monitor.bat进行测试</p></blockquote><h3 id="过度渲染："><a href="#过度渲染：" class="headerlink" title="过度渲染："></a>过度渲染：</h3><blockquote><p>1.打开【设置-开发者选项-调试GPU过度绘制-显示过度绘制区域】，开启后点击应用，可以看到各种颜色的区域。</p><blockquote><p>颜色的标识：<br>(1)蓝色1x过度绘制<br>(2)绿色2x过度绘制<br>(3)淡红色3x过度绘制<br>(4)红色超过4x过度绘制</p></blockquote><p>2.颜色越浅越好:蓝-绿-淡红-红。最理想的是一个像素只绘制一次，合格的页面是白色、蓝色为主，绿色以上区域不能超过整个的三分之一。</p><blockquote><p>验收标准：<br>(1)控制过度绘制为2x<br>(2)不允许存在4x过度绘制<br>(3)不允许存在面积超过屏幕1/4区域的3x过度绘制（淡红色区域）</p></blockquote></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安卓专项测试主要包括：响应时间、cpu、内存、电量、流量、FPS、过度渲染。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="专项测试" scheme="http://pythonfood.github.io/categories/%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="专项测试" scheme="http://pythonfood.github.io/tags/%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>流程分析</title>
    <link href="http://pythonfood.github.io/2017/12/27/%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://pythonfood.github.io/2017/12/27/流程分析/</id>
    <published>2017-12-27T09:10:07.000Z</published>
    <updated>2018-02-09T06:21:30.081Z</updated>
    
    <content type="html"><![CDATA[<p>现在的软件几乎都是用事件触发来控制流程的，事件触发时的情景便形成了场景，而同一事件不同的触发顺序和处理结果就形成事件流。这种在软件设计方面的思想也可引入到软件测试中，可以比较生动地描绘出事件触发时的情景，有利于测试设用例场景用来描述流经用例的路径。<br><a id="more"></a></p><h3 id="场景设计法三个流程："><a href="#场景设计法三个流程：" class="headerlink" title="场景设计法三个流程："></a>场景设计法三个流程：</h3><blockquote><p>1.基本流：通过业务流程输入都为正确的，能够最后到达目标的流程<br>2.备选流：通过实现业务流程时，因错误操作或异常输入，导致流程存在反复，但最终能够完成期望业务的流程。<br>3.异常流：通过实现业务流程时，因错误操作或异常输入，导致业务没有正确完成。</p></blockquote><p><img src="/2017/12/27/流程分析/流程图.jpg" alt="流程图"></p><h3 id="流程分析应用步骤："><a href="#流程分析应用步骤：" class="headerlink" title="流程分析应用步骤："></a>流程分析应用步骤：</h3><blockquote><p>1.理解需求，确定业务流程（基本流、备选流、异常流）。<br>2.绘制流程图（再次明确流程路径）。<br>3.根据业务流程图，抽取测试路径（每次路径需包含一个从未走过的路径）。<br>4.细化路径设计测试用例。</p></blockquote><h3 id="流程分析法注意点："><a href="#流程分析法注意点：" class="headerlink" title="流程分析法注意点："></a>流程分析法注意点：</h3><blockquote><p>需使用等价类、边界值、正交试验、判定表、因果图等方法保证单个功能的正确性。</p></blockquote><h4 id="小示例："><a href="#小示例：" class="headerlink" title="小示例："></a>小示例：</h4><p>1.画出流程图<br><img src="/2017/12/27/流程分析/1.画出流程图.png" alt="1.画出流程图"><br>2.流程图类需求<br><img src="/2017/12/27/流程分析/2.流程图类需求.png" alt="2.流程图类需求"><br>3.根据需求画流程图，流程覆盖写用例<br><img src="/2017/12/27/流程分析/3.根据需求画流程图，流程覆盖写用例.png" alt="3.根据需求画流程图，流程覆盖写用例"></p><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在的软件几乎都是用事件触发来控制流程的，事件触发时的情景便形成了场景，而同一事件不同的触发顺序和处理结果就形成事件流。这种在软件设计方面的思想也可引入到软件测试中，可以比较生动地描绘出事件触发时的情景，有利于测试设用例场景用来描述流经用例的路径。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="测试用例" scheme="http://pythonfood.github.io/categories/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
    
      <category term="测试用例" scheme="http://pythonfood.github.io/tags/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>状态迁移</title>
    <link href="http://pythonfood.github.io/2017/12/27/%E7%8A%B6%E6%80%81%E8%BF%81%E7%A7%BB/"/>
    <id>http://pythonfood.github.io/2017/12/27/状态迁移/</id>
    <published>2017-12-27T09:10:06.000Z</published>
    <updated>2018-02-09T06:22:14.322Z</updated>
    
    <content type="html"><![CDATA[<p>状态迁移关注被测对象的状态变化，在需求规格说明书中是否有不可达到的状态和非法的状态，是否产生非法的状态迁移。<br><a id="more"></a></p><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><blockquote><p>被测对象在特定输入条件下所保持的响应形式</p></blockquote><h3 id="状态迁移应用步骤："><a href="#状态迁移应用步骤：" class="headerlink" title="状态迁移应用步骤："></a>状态迁移应用步骤：</h3><blockquote><p>1.根据需求明确状态节点。<br>2.绘制状态迁移图。<br>3.绘制状态迁移树。<br>4.抽取测试用例。</p></blockquote><h4 id="小示例："><a href="#小示例：" class="headerlink" title="小示例："></a>小示例：</h4><p>1.状态迁移类需求<br><img src="/2017/12/27/状态迁移/1.状态迁移类需求.png" alt="1.状态迁移类需求"><br>2.根据需求画状态迁移图案例1<br><img src="/2017/12/27/状态迁移/2.根据需求画状态迁移图案例1.png" alt="2.根据需求画状态迁移图案例1"><br>3.根据需求画状态迁移图案例2<br><img src="/2017/12/27/状态迁移/3.根据需求画状态迁移图案例2.png" alt="3.根据需求画状态迁移图案例2"></p><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;状态迁移关注被测对象的状态变化，在需求规格说明书中是否有不可达到的状态和非法的状态，是否产生非法的状态迁移。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="测试用例" scheme="http://pythonfood.github.io/categories/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
    
      <category term="测试用例" scheme="http://pythonfood.github.io/tags/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>正交试验</title>
    <link href="http://pythonfood.github.io/2017/12/27/%E6%AD%A3%E4%BA%A4%E8%AF%95%E9%AA%8C/"/>
    <id>http://pythonfood.github.io/2017/12/27/正交试验/</id>
    <published>2017-12-27T09:10:05.000Z</published>
    <updated>2018-02-09T06:22:03.782Z</updated>
    
    <content type="html"><![CDATA[<p>正交试验是研究多因素多水平的一种设计方法，它是根据正交性从全面试验中挑选出部分有代表性的点进行试验，这些有代表性的点具备了“均匀分散，齐整可比”的特点，正交试验设计是一种基于正交表的、高效率、快速、经济的试验。<br><a id="more"></a></p><h3 id="正交试验重要概念："><a href="#正交试验重要概念：" class="headerlink" title="正交试验重要概念："></a>正交试验重要概念：</h3><blockquote><p>1.因子：所有参与试验的影响试验结果的条件成为因子。<br>2.水平：影响试验因子的取值或输入称为水平。<br>3.整齐可比：在同一张正交表中，每个因子每个水平出现的次数完全相同。试验中，每个因子的每个水平与其他因子的水平参与试验的机率完全相同。<br>4.均匀分散：同一张正交表中，任意两列水平搭配是完全相同的。</p></blockquote><h3 id="正交试验应用步骤："><a href="#正交试验应用步骤：" class="headerlink" title="正交试验应用步骤："></a>正交试验应用步骤：</h3><blockquote><p>1.分析需求获取因子和水平。<br>2.根据因子和水平选择合适的正交表。<br>3.替换因子和水平，获取试验次数。<br>4.根据试验或其他因素补充试验次数。<br>5.细化输出获取测试用例。</p></blockquote><h3 id="正交试验注意点："><a href="#正交试验注意点：" class="headerlink" title="正交试验注意点："></a>正交试验注意点：</h3><blockquote><p>1.选择正交表的因子与水平恰好与正交表相同。<br>2.根据对象因子与正交表中的因子不同，选择正交表中因子稍大于被测对象因子数，且试验次数最少的，多余的因子弃用。<br>3.被测对象水平与正交表中的水平不同，可根据实际情况进行合并，然后拆分。<br>4.因子水平都不相同，则可选择因子，水平稍大于被测对象的，且实验次数最少的。</p></blockquote><h4 id="小示例："><a href="#小示例：" class="headerlink" title="小示例："></a>小示例：</h4><p>1.提取因子和水平<br><img src="/2017/12/27/正交试验/1.提取因子和水平.png" alt="1.提取因子和水平"><br>2.设计正交试验表，补充缺少的必要用例<br><img src="/2017/12/27/正交试验/2.设计正交试验表，补充缺少的必要用例.png" alt="2.设计正交试验表，补充缺少的必要用例"><br>3.替换因子水平得出用例<br><img src="/2017/12/27/正交试验/3.替换因子水平得出用例.png" alt="3.替换因子水平得出用例"></p><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正交试验是研究多因素多水平的一种设计方法，它是根据正交性从全面试验中挑选出部分有代表性的点进行试验，这些有代表性的点具备了“均匀分散，齐整可比”的特点，正交试验设计是一种基于正交表的、高效率、快速、经济的试验。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="测试用例" scheme="http://pythonfood.github.io/categories/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
    
      <category term="测试用例" scheme="http://pythonfood.github.io/tags/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>因果图</title>
    <link href="http://pythonfood.github.io/2017/12/27/%E5%9B%A0%E6%9E%9C%E5%9B%BE/"/>
    <id>http://pythonfood.github.io/2017/12/27/因果图/</id>
    <published>2017-12-27T09:10:04.000Z</published>
    <updated>2018-02-09T06:21:52.091Z</updated>
    
    <content type="html"><![CDATA[<p>因果图是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，它适合于检查程序输入条件的各种组合情况。<br><a id="more"></a></p><h3 id="输入与输出的关系："><a href="#输入与输出的关系：" class="headerlink" title="输入与输出的关系："></a>输入与输出的关系：</h3><blockquote><p>1.恒等：若ci是1，则ei也是1；否则ei为0。<br>2.非：若ci是1，则ei是0；否则ei是1。<br>3.或：若c1或c2或c3是1，则ei是1；否则ei为0。“或”可有任意个输入。<br>4.与：若c1和c2都是1，则ei为1；否则ei为0。“与”也可有任意个输入。</p></blockquote><p><img src="/2017/12/27/因果图/因果图基本图形符.png" alt="因果图基本图形符"></p><h3 id="输入与输入的关系："><a href="#输入与输入的关系：" class="headerlink" title="输入与输入的关系："></a>输入与输入的关系：</h3><blockquote><p>1.E约束（异）：a和b中至多有一个可能为1，即a和b不能同时为1。<br>2.I约束（或）：a、b和c中至少有一个必须是1，即 a、b 和c不能同时为0。<br>3.O约束（唯一）；a和b必须有一个，且仅有1个为1。<br>4.R约束（要求）：a是1时，b必须是1，即不可能a是1时b是0。</p></blockquote><p><img src="/2017/12/27/因果图/因果图约束条件.png" alt="因果图约束条件"></p><h3 id="输出与输出的关系："><a href="#输出与输出的关系：" class="headerlink" title="输出与输出的关系："></a>输出与输出的关系：</h3><blockquote><p>1.M(屏蔽)：a出现时，b必定不出现；a不出现时，b则不确定。</p></blockquote><h4 id="小示例："><a href="#小示例：" class="headerlink" title="小示例："></a>小示例：</h4><p>1.根据关系画用例的因果图<br><img src="/2017/12/27/因果图/1.根据关系画用例的因果图.png" alt="1.根据关系画用例的因果图"><br>2.根据用例因果图设计判定表<br><img src="/2017/12/27/因果图/2.根据用例因果图设计判定表.png" alt="2.根据用例因果图设计判定表"><br>3.去除因果图判定表的无效项<br><img src="/2017/12/27/因果图/3.去除因果图判定表的无效项.png" alt="3.去除因果图判定表的无效项"></p><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因果图是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，它适合于检查程序输入条件的各种组合情况。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="测试用例" scheme="http://pythonfood.github.io/categories/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
    
      <category term="测试用例" scheme="http://pythonfood.github.io/tags/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>判定表</title>
    <link href="http://pythonfood.github.io/2017/12/27/%E5%88%A4%E5%AE%9A%E8%A1%A8/"/>
    <id>http://pythonfood.github.io/2017/12/27/判定表/</id>
    <published>2017-12-27T09:10:03.000Z</published>
    <updated>2018-02-09T06:21:40.261Z</updated>
    
    <content type="html"><![CDATA[<p>判定表是分析和表达多逻辑条件下执行不同操作的情况的工具。（在遇到复杂业务逻辑时可以利用该表理清业务逻辑关系）<br><a id="more"></a></p><h3 id="判定表重要概念："><a href="#判定表重要概念：" class="headerlink" title="判定表重要概念："></a>判定表重要概念：</h3><blockquote><p>1.条件</p><blockquote><p>条件桩：列出了所有条件，通常认为列出条件的次序无关紧要。<br>条件项：列出了所有条件的取值组合，在所有可能情况下的真假值。</p></blockquote><p>2.动作</p><blockquote><p>动作桩：列出所有可能的操作，这些操作的排列顺序没有约束。<br>动作项：列出在条件项的各种取值情况下应该采取的动作。</p></blockquote><p>3.规则</p><blockquote><p>规则：任何一个条件组合的特定取值及其他相应要执行的操作称为规则。在判定表中贯穿条件项和动作项的一列就是一条规则。</p></blockquote></blockquote><h3 id="判定表的4个组成部分："><a href="#判定表的4个组成部分：" class="headerlink" title="判定表的4个组成部分："></a>判定表的4个组成部分：</h3><p><img src="/2017/12/27/判定表/判定表的4个组成部分.jpg" alt="判定表的4个组成部分"></p><h3 id="判定表应用步骤："><a href="#判定表应用步骤：" class="headerlink" title="判定表应用步骤："></a>判定表应用步骤：</h3><blockquote><p>1.理解需求，列出条件桩和动作桩。<br>2.设计及优化判定表。（2的n次方种）<br>3.填写动作项。<br>4.根据判定表中输出结果的表现，进行判定表的合并（非必须），简化判定表。<br>5.抽取测试用例。</p></blockquote><h4 id="小示例："><a href="#小示例：" class="headerlink" title="小示例："></a>小示例：</h4><p>根据判定条件编写判定表测试用例<br><img src="/2017/12/27/判定表/根据判定条件编写判定表测试用例.png" alt="根据判定条件编写判定表测试用例"></p><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;判定表是分析和表达多逻辑条件下执行不同操作的情况的工具。（在遇到复杂业务逻辑时可以利用该表理清业务逻辑关系）&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="测试用例" scheme="http://pythonfood.github.io/categories/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
    
      <category term="测试用例" scheme="http://pythonfood.github.io/tags/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>边界值</title>
    <link href="http://pythonfood.github.io/2017/12/27/%E8%BE%B9%E7%95%8C%E5%80%BC/"/>
    <id>http://pythonfood.github.io/2017/12/27/边界值/</id>
    <published>2017-12-27T09:10:02.000Z</published>
    <updated>2018-02-09T06:21:09.110Z</updated>
    
    <content type="html"><![CDATA[<p>边界值是对输入或输出的边界值进行测试的一种黑盒测试方法。通常边界值分析法是作为对等价类划分法的补充，这种情况下，其测试用例来自等价类的边界。<br><a id="more"></a></p><h3 id="边界值三点（边值点）："><a href="#边界值三点（边值点）：" class="headerlink" title="边界值三点（边值点）："></a>边界值三点（边值点）：</h3><blockquote><p>1.上点：边界上的点，闭内开外（闭指域的边界是封闭的，即闭区间；开指域的边界是开放的，即开区间）。<br>2.离点：离上点最近的点称为离点。开内闭外。（根据上点的精度确定）<br>3.内点：边界值有效范围内的任意一点。</p></blockquote><h3 id="边界值如何确定离点："><a href="#边界值如何确定离点：" class="headerlink" title="边界值如何确定离点："></a>边界值如何确定离点：</h3><blockquote><p>1.如果边界是闭区间，则离点在外。<br>2.如果边界是开区间，则离点在内。</p></blockquote><h3 id="边界值应用场景："><a href="#边界值应用场景：" class="headerlink" title="边界值应用场景："></a>边界值应用场景：</h3><blockquote><p>1.如果需求规定了取值范围或规定了取值个数时，可利用该范围的边界及边界附近的数据进行测试。<br>2.如果需求规定了取值的个数，则少于个数一个，或多余个数一个的值进行测试。<br>3.如果需求规定了一个有序集合的时候，可使用该集合的第一个和最后一个值进行测试。<br>4.如果程序中使用一个内部数据结构的话，则应该从这个数据结构的边界值进行考虑。</p></blockquote><h3 id="边界值应用步骤："><a href="#边界值应用步骤：" class="headerlink" title="边界值应用步骤："></a>边界值应用步骤：</h3><blockquote><p>1.根据等价类方法划分有效等价类和无效等价类，确定上点、离点及内点，每一个点统一编号。<br>2.设计一个新的测试用例，使其尽可能覆盖所有尚未覆盖的有效等价类，直到所有的有效等价类完全覆盖。<br>3.设计一个新的测试用例，使其仅覆盖一个无效等价类，直到所有的无效等价类完全覆盖。</p></blockquote><h4 id="小示例："><a href="#小示例：" class="headerlink" title="小示例："></a>小示例：</h4><p>在等价类基础上根据输入值编写边界值测试用例<br><img src="/2017/12/27/边界值/在等价类基础上根据输入值编写边界值测试用例.png" alt="在等价类基础上根据输入值编写边界值测试用例"></p><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;边界值是对输入或输出的边界值进行测试的一种黑盒测试方法。通常边界值分析法是作为对等价类划分法的补充，这种情况下，其测试用例来自等价类的边界。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="测试用例" scheme="http://pythonfood.github.io/categories/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
    
      <category term="测试用例" scheme="http://pythonfood.github.io/tags/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>等价类</title>
    <link href="http://pythonfood.github.io/2017/12/27/%E7%AD%89%E4%BB%B7%E7%B1%BB/"/>
    <id>http://pythonfood.github.io/2017/12/27/等价类/</id>
    <published>2017-12-27T09:10:01.000Z</published>
    <updated>2018-02-09T06:21:19.701Z</updated>
    
    <content type="html"><![CDATA[<p>等价类是把所有可能的输入数据,即程序的输入域划分成若干部分（子集）,然后从每一个子集中选取少数具有代表性的数据作为测试用例。<br><a id="more"></a></p><h3 id="等价类划分规则："><a href="#等价类划分规则：" class="headerlink" title="等价类划分规则："></a>等价类划分规则：</h3><blockquote><p>1.如果输入条件规定了一个取值范围，那么就应该确定一个有效等价类以及两个无效等价类。<br>如月份取值在1~12之间，由此可确定一个有效等价类即月份在1~12之间，和两个无效等价类，即月份取值小于1及月份取值大于12.<br>2.规定了输入条件必须如何的情况下可以确定一个有效等价类和一个无效等价类。<br>如输入值必须大于0，则有效等价类为输入值大于0 ，无效等价类为输入值小于或者等于0.<br>3.在输入数据是一个bool常量的情况下，可以确定一个有效等价类和一个无效等价类。<br>4.在规定了输入数据由n个值构成的情况下，并要求定其中的每个值进行测试时，可以确定n个有效等价类和一个无效等价类。<br>如交通工具类型为公共汽车、卡车、出租车、火车或者摩托车，那么就应该为每一个输入值确定一个有效等价类和一个无效等价类例如拖车。<br>5.在规定了输入数据冰箱最受的规则的情况下，可以确定一个有效等价类和若干个无效等价类（从不同角度违反规则）。<br>如输入值必须是数字类型的字符，则可确定一个有效等价类，及输入值为数字类型得字符，和多个无效等价类，即输入值为字母、为专用字符（如+、*、@等）以及为非打印字符（如回车、空格等）。<br>6.在确知已划分的等价类中各元素在程序处理中的方式不同的情况下,则应再将该等价类进一步的划分为更小的等价类。<br>划分等价类之后，应建立等价类表，列出与每一个输入条件对于的有效等价类和无效等价类。</p></blockquote><h3 id="等价类设计测试用例："><a href="#等价类设计测试用例：" class="headerlink" title="等价类设计测试用例："></a>等价类设计测试用例：</h3><blockquote><p>1.根据需求，划分有效等价类和无效等价类，有效等价类统一编号，无效等价类统一编号。<br>2.设计一个新的测试用例,使其尽可能多地覆盖尚未被覆盖地有效等价类,重复这一步，直到所有的有效等价类都被覆盖为止。<br>3.设计一个新的测试用例,使其仅覆盖一个尚未被覆盖的无效等价类,重复这一步，直到所有的无效等价类都被覆盖为止。</p></blockquote><h3 id="等价类四则运算法："><a href="#等价类四则运算法：" class="headerlink" title="等价类四则运算法："></a>等价类四则运算法：</h3><blockquote><p>1.不考虑需求其他子项，细致分解当期测试点及详细需求，做累加。<br>2.根据业务规则减少，排除相关不可能出现的规则，减少不可能出现的组合。<br>3.如果有效等价类中具有互斥条件的需求时，可运用乘得到用例个数。<br>4.排除所有具有重复特性的等价类，尽可能做到有效等价类之间交集为空。</p></blockquote><h4 id="小示例："><a href="#小示例：" class="headerlink" title="小示例："></a>小示例：</h4><p>1.有效等价类一条用例尽量覆盖所有有效等价类<br><img src="/2017/12/27/等价类/1.有效等价类一条用例尽量覆盖所有有效等价类.png" alt="1.有效等价类一条用例尽量覆盖所有有效等价类"><br>2.无效等价类一条用例覆盖一个无效等价类<br><img src="/2017/12/27/等价类/2.无效等价类一条用例覆盖一个无效等价类.png" alt="2.无效等价类一条用例覆盖一个无效等价类"><br>3.根据覆盖条件编写等价类测试用例<br><img src="/2017/12/27/等价类/3.根据覆盖条件编写等价类测试用例.png" alt="3.根据覆盖条件编写等价类测试用例"></p><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;等价类是把所有可能的输入数据,即程序的输入域划分成若干部分（子集）,然后从每一个子集中选取少数具有代表性的数据作为测试用例。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="测试用例" scheme="http://pythonfood.github.io/categories/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
    
      <category term="测试用例" scheme="http://pythonfood.github.io/tags/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>markdown</title>
    <link href="http://pythonfood.github.io/2017/12/27/markdown/"/>
    <id>http://pythonfood.github.io/2017/12/27/markdown/</id>
    <published>2017-12-27T04:48:25.000Z</published>
    <updated>2018-02-08T08:02:56.783Z</updated>
    
    <content type="html"><![CDATA[<p>markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。markdown用于编写说明文档，并且以“README.MD”的文件名保存在软件的目录下面。<br><a id="more"></a></p><h3 id="粗体和斜体"><a href="#粗体和斜体" class="headerlink" title="粗体和斜体"></a>粗体和斜体</h3><pre><code>**粗体*****加粗斜体****斜体*_斜体_~~删除线~~    </code></pre><h3 id="分级标题"><a href="#分级标题" class="headerlink" title="分级标题"></a>分级标题</h3><pre><code># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题这是一个一级标题================这是一个二级标题----------------</code></pre><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><pre><code>+ 无    - 无     * 无+ 序    - 序     * 序+ 列    - 列     * 列+ 表    - 表     * 表1.有2.序3.列4.表</code></pre><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><pre><code>&gt;引用引用一段话</code></pre><h3 id="多层引用"><a href="#多层引用" class="headerlink" title="多层引用"></a>多层引用</h3><pre><code>&gt;&gt;&gt;多&gt;&gt;层&gt;引用</code></pre><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><pre><code>![图片Alt](图片地址 “图片Title”)</code></pre><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><pre><code>[连接文字](连接地址 “连接Title”)</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>`内行代码`两行```包夹多行代码1个tab或4个空格缩进，也可以写多行代码</code></pre><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><pre><code>2个tab键或8个空格键</code></pre><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><pre><code>|学号|姓名|分数||:---|:--:|---:||111|我|70||左对齐|居中|右对齐|</code></pre><h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><pre><code>**** * *******- - -_ _ _ _ _ _    </code></pre><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。markdown用于编写说明文档，并且以“README.MD”的文件名保存在软件的目录下面。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="markdown" scheme="http://pythonfood.github.io/categories/markdown/"/>
    
    
      <category term="markdown" scheme="http://pythonfood.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>hexo</title>
    <link href="http://pythonfood.github.io/2017/12/27/hexo/"/>
    <id>http://pythonfood.github.io/2017/12/27/hexo/</id>
    <published>2017-12-27T04:42:26.000Z</published>
    <updated>2018-02-08T08:02:42.203Z</updated>
    
    <content type="html"><![CDATA[<p>hexo常用命令笔记。<br><a id="more"></a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>npm install hexo -g </code></pre><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><pre><code>npm update hexo -g</code></pre><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre><code>hexo init</code></pre><h3 id="显示Hexo版本号"><a href="#显示Hexo版本号" class="headerlink" title="显示Hexo版本号"></a>显示Hexo版本号</h3><pre><code>hexo version               </code></pre><h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><pre><code>hexo n &quot;postName&quot;hexo new &quot;postName&quot;</code></pre><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><pre><code>hexo g hexo generate</code></pre><h3 id="启动本地服务"><a href="#启动本地服务" class="headerlink" title="启动本地服务"></a>启动本地服务</h3><pre><code>hexo shexo serverhexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP</code></pre><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><pre><code>hexo d hexo deploy </code></pre><h3 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h3><pre><code>hexo phexo publish [layout] &lt;title&gt;</code></pre><h3 id="列出网站资料"><a href="#列出网站资料" class="headerlink" title="列出网站资料"></a>列出网站资料</h3><pre><code>hexo list &lt;type&gt;        </code></pre><h3 id="清除db-json和public"><a href="#清除db-json和public" class="headerlink" title="清除db.json和public"></a>清除db.json和public</h3><pre><code>hexo clean                  </code></pre><h3 id="新建页面"><a href="#新建页面" class="headerlink" title="新建页面"></a>新建页面</h3><pre><code>hexo new page &quot;pageName&quot;</code></pre><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hexo常用命令笔记。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://pythonfood.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://pythonfood.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://pythonfood.github.io/2017/12/25/hello-world/"/>
    <id>http://pythonfood.github.io/2017/12/25/hello-world/</id>
    <published>2017-12-25T07:31:56.646Z</published>
    <updated>2017-12-25T07:31:56.646Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
