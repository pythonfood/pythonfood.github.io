<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PythonFood</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://pythonfood.github.io/"/>
  <updated>2018-03-09T07:39:28.930Z</updated>
  <id>http://pythonfood.github.io/</id>
  
  <author>
    <name>Python Food</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>持续集成-jenkins</title>
    <link href="http://pythonfood.github.io/2018/03/05/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90-jenkins/"/>
    <id>http://pythonfood.github.io/2018/03/05/持续集成-jenkins/</id>
    <published>2018-03-05T01:00:00.000Z</published>
    <updated>2018-03-09T07:39:28.930Z</updated>
    
    <content type="html"><![CDATA[<p>持续集成jenkins使用笔记。<br><a id="more"></a></p><h3 id="1-持续集成流程"><a href="#1-持续集成流程" class="headerlink" title="1.持续集成流程"></a>1.持续集成流程</h3><p>(1)提交代码<br>(2)拉取代码<br>(3)编译<br>(4)打包<br>(5)配置<br>(6)测试<br>(7)反馈问题<br>(8)开发处理<br>(9)回到(1)</p><h3 id="2-持续集成工具"><a href="#2-持续集成工具" class="headerlink" title="2.持续集成工具"></a>2.持续集成工具</h3><p>(1)代码管理工具：</p><blockquote><p>Git：官网下载安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a><br>GitHub：官网地址<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></p></blockquote><p>(2)集成工具：</p><blockquote><p>Jenkins：官网下载安装<a href="https://jenkins.io/download/" target="_blank" rel="noopener">https://jenkins.io/download/</a><br>1)安装后会自动启动浏览器，输入<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a><br>2)根据页面中标红路径找到管理员密码吗<br>3)输入管理员密码，点击【Continue】<br>4)安装插件，默认选项即可<br>5)安装完需要创建用户，此处点击【Continue as admin】使用默认账户即可<br>6)点击【Start using Jekins】启动<br>7)修改密码，进入【admin-设置】，向上拉找到密码处即可修改</p></blockquote><h3 id="3-Jenkins系统配置"><a href="#3-Jenkins系统配置" class="headerlink" title="3.Jenkins系统配置"></a>3.Jenkins系统配置</h3><p>(1)插件管理：</p><blockquote><p>1)进入【系统管理-管理插件-已安装】查看下面插件：</p><blockquote><ul><li>Git Plugin</li><li>GitHub Plugin</li><li>Gradle Plugin</li><li>Android Emulator Plugin</li></ul></blockquote><p>2)未安装的进入【可选插件】里安装即可</p></blockquote><p>(2)Gradle配置：</p><blockquote><p>1)进入【系统管理-全局工具配置】找到【Gradle安装】<br>2)点击【新增Gradle】<br>3)选择自动安装，名称输入和版本一致即可<br>4)再点击【Apply】-【Save】</p></blockquote><p>(3)GitHub配置：</p><blockquote><p>1)进入【系统管理-系统设置】找到【GitHub】<br>2)点击【Add GitHub Server】<br>3)在【GitHub Server】的【API URL】输入(<a href="https://api.github.com" target="_blank" rel="noopener">https://api.github.com</a>)<br>4)再点击【Credentials】右侧的问号设置权限，展开的内容里右键点击【personal access token】新窗口打开github<br>5)在github页面【Token description】输入自定义名称,勾选【repo】,点击【Generate token】<br>6)在github页面生成Personal access tokens后复制<br>7)回到jenkins页面点击【add】-【jenkins】<br>8)在弹出窗口里【Kind】类别选择【Secret text】,将刚才复制的token粘贴到【Secret】，再点击【add】就创建了身份信息<br>9)可以点击【Test connection】验证一下，验证通过后点击【保存】</p></blockquote><h3 id="4-Jenkins-JOB配置"><a href="#4-Jenkins-JOB配置" class="headerlink" title="4.Jenkins JOB配置"></a>4.Jenkins JOB配置</h3><p>创建任务：</p><blockquote><p>1)点击页面中【创建一个新任务】<br>2)输入任务名称，选择【构建一个自由风格的软件项目】，点击【确定】进入设置界面<br>3)进行自定义配置后点击【保存】</p></blockquote><h3 id="5-JOB配置小示例"><a href="#5-JOB配置小示例" class="headerlink" title="5.JOB配置小示例"></a>5.JOB配置小示例</h3><p>进入创建的任务详情界面，点击【配置】进行job配置<br>(1)拉取代码：</p><blockquote><p>1)【源码管理】选择【Git】，输入代码库的URL地址<br>2)点击【Add】-【jenkins】配置github权限<br>3)弹出界面输入github的帐户名和密码，点击【Add】添加<br>4)【Credentials】选择刚添加的github账户</p></blockquote><p>(2)编译、打包：</p><blockquote><p>1)【构建】点击【增加构建步骤】<br>2)选择【Invoke Gradle script】<br>3)【Gradle Version】选择对应版本<br>4)【Tasks】填写“build”等信息</p></blockquote><p>(3)配置：</p><blockquote><p>1)【构建】点击【增加构建步骤】<br>2)选择【Install Android package】<br>3)【APK file】填写生成的apk路径（此处可以先生构建一次4)查看路径，再复制到这里）<br>5)勾选【Uninstall existing APK first】</p></blockquote><p>(4)测试：</p><blockquote><p>1)【构建】点击【增加构建步骤】<br>2)选择【Run Android monkey tester】<br>3)【Package IDs】输入包名<br>4)【Event count】输入执行次数<br>5)【Delay between events】输入间隔时间ms<br>6)点击【Apply】,点击【保存】</p></blockquote><p>(5)立即构建：</p><blockquote><p>1)进入创建的任务详情界面<br>2)点击【立即构建】进行构建<br>3)点击构建的任务可以查看详情<br>4)【Console Output】可以查看日志信息</p></blockquote><p>(6)定时构建：</p><blockquote><p>1)进入创建的任务详情界面<br>2)点击【配置】进行job配置<br>3)【构建触发器】下选择【Build periodically】<br>4)【日程表】里输入规则，例如“H/15 <em> </em> <em> </em>”(每15分钟构建一次)<br>5)点击【日程表】右侧问号，可以查看规则描述<br>6)点击【Apply】,点击【保存】</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;持续集成jenkins使用笔记。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="持续集成" scheme="http://pythonfood.github.io/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    
      <category term="持续集成" scheme="http://pythonfood.github.io/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>接口测试-python</title>
    <link href="http://pythonfood.github.io/2018/03/03/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95-python/"/>
    <id>http://pythonfood.github.io/2018/03/03/接口测试-python/</id>
    <published>2018-03-03T04:00:00.000Z</published>
    <updated>2018-03-08T09:18:59.419Z</updated>
    
    <content type="html"><![CDATA[<p>接口测试python实现脚本测试笔记。<br><a id="more"></a></p><h3 id="1-requests模块"><a href="#1-requests模块" class="headerlink" title="1.requests模块"></a>1.requests模块</h3><p>(1)安装<code>pip install requests</code><br>(2)使用前导入<code>import requests</code></p><h3 id="2-GET请求ddt自动化"><a href="#2-GET请求ddt自动化" class="headerlink" title="2.GET请求ddt自动化"></a>2.GET请求ddt自动化</h3><p>(1)代码结构：</p><blockquote><p>1)构造Header<br>2)构造cookies<br>3)发送Get请求<br>4)获取返回值<br>5)对结果进行校验</p></blockquote><p>(2)代码示例：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line">import unittest</span><br><span class="line">import ddt</span><br><span class="line"></span><br><span class="line">@ddt.ddt</span><br><span class="line">class ApiTestClass(unittest.TestCase):</span><br><span class="line">    </span><br><span class="line">    @ddt.data(&apos;android&apos;,&apos;&apos;,&apos;ios&apos;)</span><br><span class="line">    def test_Get(self,os_phone):</span><br><span class="line">        #header部分配置</span><br><span class="line">        headers = &#123;&apos;User-Agent&apos;:&apos;Dalvik/1.6.0 (Linux; U; Android 4.3; Coolpad 8720L Build/JSS15Q)&apos;,</span><br><span class="line">                   &apos;Host&apos;:&apos;bdsp.x.jd.com&apos;,</span><br><span class="line">                   &apos;Connection&apos;:&apos;Keep-Alive&apos;,</span><br><span class="line">                   &apos;Accept-Encoding&apos;:&apos;gzip&apos;</span><br><span class="line">                   &#125;</span><br><span class="line">        </span><br><span class="line">        #cookies部分配置</span><br><span class="line">        cookies = dict(search_test = &apos;1&apos;)</span><br><span class="line">        </span><br><span class="line">        #get请求获得返回数据</span><br><span class="line">        res = requests.get(&apos;http://bdsp.x.jd.com/app/config?os=&apos;+os_phone+&apos;&amp;key=wx3ebc9e606b4f9242&amp;sdkv=5&apos;, </span><br><span class="line">                           headers = headers,</span><br><span class="line">                           cookies = cookies)</span><br><span class="line">        </span><br><span class="line">        print(res.text)</span><br><span class="line">        print(res.status_code)</span><br><span class="line">        </span><br><span class="line">        #测试点校验</span><br><span class="line">        self.assertTrue(&apos;15*1000&apos; in res.text)</span><br><span class="line">                      </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    cases = unittest.TestLoader().loadTestsFromTestCase(ApiTestClass)</span><br><span class="line">    suite = unittest.TestSuite([cases])</span><br><span class="line">    #suite.addTest(ApiTestClass(&apos;test_Get&apos;))</span><br><span class="line">    </span><br><span class="line">    runner = unittest.TextTestRunner()</span><br><span class="line">    runner.run(suite)</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-POST请求ddt自动化"><a href="#3-POST请求ddt自动化" class="headerlink" title="3.POST请求ddt自动化"></a>3.POST请求ddt自动化</h3><p>(1)代码结构：</p><blockquote><p>1)构造Keyword(即request body)<br>2)构造Header<br>3)构造cookies<br>4)发送Get请求<br>5)获取返回值<br>6)对结果进行校验</p></blockquote><p>(2)代码示例：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import unittest</span><br><span class="line">import ddt</span><br><span class="line"></span><br><span class="line">@ddt.ddt</span><br><span class="line">class ApiTestClass(unittest.TestCase):</span><br><span class="line">    </span><br><span class="line">    @ddt.data((&apos;60.206.137.140&apos;,&apos;hjfwp9VflXZU3FsuM3cu6PBV&apos;),</span><br><span class="line">              (&apos;&apos;,&apos;&apos;)</span><br><span class="line">              )</span><br><span class="line">    @ddt.unpack</span><br><span class="line">    def test_Post(self,m_host,m_accessToken):</span><br><span class="line">        #header部分配置</span><br><span class="line">        headers = &#123;&apos;Content-Type&apos;:&apos;application/x-www-form-urlencoded&apos;,</span><br><span class="line">                   &apos;Content-Length&apos;:&apos;36&apos;,</span><br><span class="line">                   &apos;Host&apos;:m_host,</span><br><span class="line">                   &apos;Connection&apos;:&apos;Keep-Alive&apos;,</span><br><span class="line">                   &apos;Accept-Encoding&apos;:&apos;gzip&apos;,</span><br><span class="line">                   &apos;User-Agent&apos;:&apos;okhttp/3.8.1&apos;</span><br><span class="line">                   &#125;</span><br><span class="line">        </span><br><span class="line">        #cookies部分配置</span><br><span class="line">        cookies = dict(search_test = &apos;1&apos;)</span><br><span class="line">        </span><br><span class="line">        #data部分配置</span><br><span class="line">        keyword = &#123;&apos;accessToken&apos;:m_accessToken&#125;</span><br><span class="line">        </span><br><span class="line">        #post请求获得返回数据</span><br><span class="line">        res = requests.post(&apos;http://60.206.137.140/iot_api/family/queryFamilyList.json&apos;, </span><br><span class="line">                           headers = headers,</span><br><span class="line">                           cookies = cookies,</span><br><span class="line">                           data = keyword</span><br><span class="line">                           )</span><br><span class="line">        </span><br><span class="line">        print(res.text)</span><br><span class="line">        print(res.status_code)</span><br><span class="line">        </span><br><span class="line">        #测试点校验</span><br><span class="line">        self.assertTrue(&apos;北京市北京市&apos; in res.text)</span><br><span class="line">                      </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    cases = unittest.TestLoader().loadTestsFromTestCase(ApiTestClass)</span><br><span class="line">    suite = unittest.TestSuite([cases])</span><br><span class="line">    #suite.addTest(ApiTestClass(&apos;test_Post&apos;))</span><br><span class="line">    </span><br><span class="line">    runner = unittest.TextTestRunner()</span><br><span class="line">    runner.run(suite)</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接口测试python实现脚本测试笔记。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="接口测试" scheme="http://pythonfood.github.io/categories/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="接口测试" scheme="http://pythonfood.github.io/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>接口测试-postman</title>
    <link href="http://pythonfood.github.io/2018/03/03/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95-postman/"/>
    <id>http://pythonfood.github.io/2018/03/03/接口测试-postman/</id>
    <published>2018-03-03T03:00:00.000Z</published>
    <updated>2018-03-08T09:09:33.173Z</updated>
    
    <content type="html"><![CDATA[<p>接口测试postman工具使用笔记。<br><a id="more"></a></p><h3 id="1-适用范围"><a href="#1-适用范围" class="headerlink" title="1.适用范围"></a>1.适用范围</h3><ul><li>PC</li><li>WAP</li><li>APP</li></ul><h3 id="2-环境准备"><a href="#2-环境准备" class="headerlink" title="2.环境准备"></a>2.环境准备</h3><p>(1)下载安装:<a href="https://www.getpostman.com/apps" target="_blank" rel="noopener">https://www.getpostman.com/apps</a><br>(2)注册账户</p><h3 id="3-发送一条http-Get请求"><a href="#3-发送一条http-Get请求" class="headerlink" title="3.发送一条http Get请求"></a>3.发送一条http Get请求</h3><p>(1)GET请求输入URL(可以从fiddler复制)<br>(2)GET请求输入Headers(可以从fiddler复制)<br>(3)点击【Send】可以查看返回信息<br>(4)可以对返回值内容增加校验，GET请求的Tests里设置校验方法和校验字段<br>(5)点击【Send】可以查看返回信息和测试结果<br>(6)可以将以上测试步骤，点击【Save】保存到一个集合<br>(7)可以修改请求的测试参数，点击【Save as】保存到同一个集合<br>(8)以此类推形成一个自动化测试的集合<br>(9)点击该集合的【Run】弹出集合运行界面<br>(10)可以修改循环次数【iterations】、延迟【Delay】等参数<br>(11)点击【Run …】运行脚本，查看测试结果</p><h3 id="4-发送一条http-Post请求"><a href="#4-发送一条http-Post请求" class="headerlink" title="4.发送一条http Post请求"></a>4.发送一条http Post请求</h3><p>(1)POST请求输入URL(可以从fiddler复制)<br>(2)POST请求输入Headers(可以从fiddler复制)<br>(3)POST请求输入Body(可以从fiddler的WebForms里一项一项复制)<br>(4)点击【Send】可以查看返回信息<br>(5)可以对返回值内容增加校验，POST请求的Tests里设置校验方法和校验字段<br>(6)点击【Send】可以查看返回信息和测试结果<br>(7)可以将以上测试步骤，点击【Save】保存到一个集合<br>(8)可以修改请求的测试参数，点击【Save as】保存到同一个集合<br>(9)以此类推形成一个自动化测试的集合<br>(10)点击该集合的【Run】弹出集合运行界面<br>(11)可以修改循环次数【iterations】、延迟【Delay】等参数<br>(12)点击【Run …】运行脚本，查看测试结果</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接口测试postman工具使用笔记。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="接口测试" scheme="http://pythonfood.github.io/categories/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="接口测试" scheme="http://pythonfood.github.io/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>接口测试-fiddler</title>
    <link href="http://pythonfood.github.io/2018/03/03/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95-fiddler/"/>
    <id>http://pythonfood.github.io/2018/03/03/接口测试-fiddler/</id>
    <published>2018-03-03T02:00:00.000Z</published>
    <updated>2018-03-08T09:07:58.801Z</updated>
    
    <content type="html"><![CDATA[<p>接口测试fiddler工具使用笔记。<br><a id="more"></a></p><h3 id="1-Fiddler-环境准备"><a href="#1-Fiddler-环境准备" class="headerlink" title="1.Fiddler 环境准备"></a>1.Fiddler 环境准备</h3><p>(1)官网下载安装:<a href="https://www.telerik.com/download/fiddler" target="_blank" rel="noopener">https://www.telerik.com/download/fiddler</a><br>(2)相关设置:【Tools-options-HTTPS-Connections】,设置好之后退出再启动一次。</p><p><img src="/2018/03/03/接口测试-fiddler/HTTPS设置.png" alt="HTTPS设置"><br><img src="/2018/03/03/接口测试-fiddler/Connections设置.png" alt="Connections设置"></p><h3 id="2-Fiddler-工作原理"><a href="#2-Fiddler-工作原理" class="headerlink" title="2.Fiddler 工作原理"></a>2.Fiddler 工作原理</h3><p><img src="/2018/03/03/接口测试-fiddler/fiddler工作原理.png" alt="fiddler工作原理"></p><h3 id="3-Fiddler-基本界面"><a href="#3-Fiddler-基本界面" class="headerlink" title="3.Fiddler 基本界面"></a>3.Fiddler 基本界面</h3><p>(1)Session部分:</p><blockquote><ul><li>#:id</li><li>Result:服务器返回的状态码</li><li>Protocol:协议</li><li>Host:发送给服务器的host值</li><li>URL:</li></ul></blockquote><p>(2)Inspectors:<br>1)Request部分:</p><blockquote><ul><li>Headers:头部信息<blockquote><ul><li>User-Agent:用户的身份</li><li>Referer:请求的上一个请求来源</li><li>Host:当前的host</li></ul></blockquote></li><li>TextView:</li><li>WebForms:请求的参数值</li><li>HexView:16进制的view</li><li>Cookies:</li><li>Raw:最原始的所有的数据</li><li>JSON:json形式的请求</li><li>XML:xml形式的请求</li></ul></blockquote><p>2)Response部分:</p><blockquote><ul><li>TextView:可以看到整个返回的内容</li><li>Raw:返回所有的相关的内容</li><li>JSON:返回json形式的数据</li><li>XML:返回xml形式的数据</li><li>WebView:返回的html页面</li><li>ImageView:返回的图片内容</li></ul></blockquote><p>(3)Statistics:静态统计</p><p>(4)Composer:构造各种各样的请求发送给服务器</p><p>(5)AutoResponder:配置假数据模拟后端服务器返回的数据</p><h3 id="4-Fiddler-设置断点修改Request"><a href="#4-Fiddler-设置断点修改Request" class="headerlink" title="4.Fiddler 设置断点修改Request"></a>4.Fiddler 设置断点修改Request</h3><p>(1)通过工具栏设置断点(缺点是会拦截所有的请求)</p><blockquote><p>1)设置断点【Rules-Automatic Breakpoints-Before Request F11】<br>2)清除请求区域<br>3)浏览器进行百度搜索“fiddler”<br>4)fiddler对应的请求，点击【Response部分-Run to Completion】<br>5)fiddler新弹出的请求应该就是需要改参数的请求<br>6)fiddler需要修改参数的请求，点击【Request部分-WebForms】<br>7)修改对应的参数<br>8)点击【Repose部分-Run to Completion】<br>9)回到浏览器查看请求是否修改成功</p></blockquote><p>2)通过命令设置断点(可以拦截指定站点)</p><blockquote><p>1)session部分底部输入命令<code>bpu www.baidu.com</code>，其他操作同上。<br>2)清除拦截，输入命令<code>bpu</code></p></blockquote><h3 id="5-Fiddler-设置断点修改Response"><a href="#5-Fiddler-设置断点修改Response" class="headerlink" title="5.Fiddler 设置断点修改Response"></a>5.Fiddler 设置断点修改Response</h3><p>(1)通过工具栏设置断点(缺点是会拦截所有的请求)</p><blockquote><p>1)点击设置【Rules-Automatic Breakpoints-After Response Alt+F11】<br>2)清除请求区域<br>3)浏览器进行百度搜索“哈哈”<br>4)fiddler修改Response部分的参数<br>5)点击【Response部分-Run to Completion】<br>6)回到浏览器查看请求是否修改成功</p></blockquote><p>(2)通过命令设置断点(可以拦截指定站点)</p><blockquote><p>1)session部分底部输入命令<code>bpafter www.baidu.com</code>，其他操作同上。<br>2)清除拦截，输入命令<code>bpafter</code></p></blockquote><p>(3)AutoResponder设置</p><blockquote><p>1)浏览器进行百度搜索“哈哈”<br>2)fiddler对应的请求,点击【AutoResponder-Add Rule】<br>3)勾选【Enable reles】【Unmatched requests passthrough】【Enable Latency】<br>4)下边规则改为模糊匹配，例如改为：<code>regex:(?inx)^https://www.baidu.com/s?.+</code><br>5)下边下拉框返回状态码任意可选，例如选择:404_Plain.dat<br>6)点击【Save】按钮<br>7)回到浏览器重新百度搜索任意字符，看是否返回404<br>ps:可以通过下拉列表的“find a file”自定义规则，文件内容自定义。</p></blockquote><h3 id="6-Fiddler-小工具"><a href="#6-Fiddler-小工具" class="headerlink" title="6.Fiddler 小工具"></a>6.Fiddler 小工具</h3><p>(1)会话的过滤</p><blockquote><p>1)点击【Filters-Use Filters】<br>2)【No Host Filter】下拉框选择【Show only the following Hosts】<br>3)输入要过滤的站点，例如:www.baidu.com<br>4)点击【Actions-Run Filterset now】<br>5)此时session对话框只显示过滤站点请求</p></blockquote><p>(2)会话的比较<br>下载windiff:<a href="https://www.grigsoft.com/download-windiff.htm" target="_blank" rel="noopener">https://www.grigsoft.com/download-windiff.htm</a><br>解压后复制到fiddler安装路径即可</p><blockquote><p>1)选中两个要对比的请求<br>2)右键点击【Compare】<br>3)调起windiff工具进行对比</p></blockquote><p>(3)编码小工具</p><blockquote><p>1)点击【Tools-TextWizard】<br>2)上部分输入原始内容，下部分显示编解码内容<br>3)例如：上面输入(<a href="https://www.grigsoft.com/download-windiff.htm" target="_blank" rel="noopener">https://www.grigsoft.com/download-windiff.htm</a>) ，下面选择URLEecode,即可看到结果。</p></blockquote><h3 id="7-Fiddler-Host设置"><a href="#7-Fiddler-Host设置" class="headerlink" title="7.Fiddler Host设置"></a>7.Fiddler Host设置</h3><blockquote><p>1)点击【Tools-HOSTS…】<br>2)勾选对话框顶部【Enable Remapping of requests for one host to a differenthost or IP,overing DNS】<br>3)点击会话框底部【Import Windows Hosts File】，导入系统host<br>4)任意修改host,点击【Save】host即生效<br>5)不使用修改的host,只需要取消勾选对话框顶部【Enable Remapping of requests for one host to a differenthost or IP,overing DNS】</p></blockquote><h3 id="8-Fiddler-构造HTTP请求"><a href="#8-Fiddler-构造HTTP请求" class="headerlink" title="8.Fiddler 构造HTTP请求"></a>8.Fiddler 构造HTTP请求</h3><p>(1)构造Get请求</p><blockquote><p>1)选择一条Get请求，点击【Inspectors-Headers】<br>2)复制Headers的头部信息，粘贴到【Composer-Parsed】的对话框<br>3)首先删除掉复制信息的“Get”类型<br>4)再剪切复制信息的URL，粘贴到上方的输入框，去掉URL尾部的“HTTP/1.1”协议<br>5)点击【Execute】发送请求<br>6)查看session界面请求是否发送<br>ps:可以任意修改URL进行接口测试</p></blockquote><p>(2)构造Post请求</p><blockquote><p>1)选择一条Post请求，点击【Inspectors-Raw】<br>2)复制所有信息，粘贴到【Composer-Parsed】的对话框，请求方式选择【POST】<br>3)首先删除掉复制信息的“Post”类型<br>4)再剪切复制信息的URL，粘贴到上方的输入框，去掉URL尾部的“HTTP/1.1”协议<br>5)剪切空行以下的request body信息，粘贴到下面的输入框<br>6)点击【Execute】发送请求<br>7)查看session界面请求是否发送<br>ps:可以任意修改URL和request body信息进行接口测试</p></blockquote><h3 id="9-Fiddler-抓取手机包"><a href="#9-Fiddler-抓取手机包" class="headerlink" title="9.Fiddler 抓取手机包"></a>9.Fiddler 抓取手机包</h3><p>(1)配置Fiddler允许监听https<br>(2)配置Fiddler允许远程连接<br>(3)手机端设置代理服务</p><blockquote><p>1)设置【Tools-Options-HTTPS】<br>2)设置【Tools-Options-Connections】<br>3)手机当前连接wifi里设置代理:主机名填写电脑的ip地址，端口填写8888<br>4)手机操作应用，请求就会发送到fiddler,其他操作同PC端操作</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接口测试fiddler工具使用笔记。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="接口测试" scheme="http://pythonfood.github.io/categories/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="接口测试" scheme="http://pythonfood.github.io/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>接口测试</title>
    <link href="http://pythonfood.github.io/2018/03/03/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    <id>http://pythonfood.github.io/2018/03/03/接口测试/</id>
    <published>2018-03-03T01:00:00.000Z</published>
    <updated>2018-03-08T08:38:25.018Z</updated>
    
    <content type="html"><![CDATA[<p>接口测试是测试系统组件间接口的一种测试。接口测试主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。测试的重点是要检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等。<br><a id="more"></a></p><h3 id="1-API种类"><a href="#1-API种类" class="headerlink" title="1.API种类"></a>1.API种类</h3><ul><li>面向对象语言的API</li><li>库与框架的API</li><li>API与协议</li><li>API与设备接口</li><li>Web API(HTTP API)</li></ul><h3 id="2-HTTP-API"><a href="#2-HTTP-API" class="headerlink" title="2.HTTP API"></a>2.HTTP API</h3><ul><li>GET</li><li>POST</li><li>PUT</li><li>DELETE</li><li>OPTIONS</li><li>HEAD</li><li>TRACE</li><li>CONNECT</li></ul><h3 id="3-接口测试流程"><a href="#3-接口测试流程" class="headerlink" title="3.接口测试流程"></a>3.接口测试流程</h3><p>(1)需求讨论<br>(2)需求评审<br>(3)场景设计<br>(4)用例设计<br>(5)数据准备<br>(6)执行</p><h3 id="4-接口用例设计"><a href="#4-接口用例设计" class="headerlink" title="4.接口用例设计"></a>4.接口用例设计</h3><p>(1)功能</p><blockquote><p>1)功能是否正常<br>2)功能是否按照接口文档实现</p></blockquote><p>(2)逻辑业务</p><blockquote><p>1)是否依赖业务</p></blockquote><p>(3)异常</p><blockquote><p>1)参数异常</p><ul><li>关键字参数</li><li>参数为空</li><li>多、少参数</li><li>错误参数</li></ul><p>2)数据异常</p><ul><li>关键字数据</li><li>数据为空</li><li>长度不一致</li><li>错误数据</li></ul></blockquote><p>(4)安全</p><blockquote><p>1)cookie<br>2)header<br>3)唯一识别码</p></blockquote><h3 id="5-接口测试三剑客"><a href="#5-接口测试三剑客" class="headerlink" title="5.接口测试三剑客"></a>5.接口测试三剑客</h3><p>(1)fiddler<br>(2)postman<br>(3)python</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接口测试是测试系统组件间接口的一种测试。接口测试主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。测试的重点是要检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="接口测试" scheme="http://pythonfood.github.io/categories/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="接口测试" scheme="http://pythonfood.github.io/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>unittest测试框架</title>
    <link href="http://pythonfood.github.io/2018/03/01/unittest%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    <id>http://pythonfood.github.io/2018/03/01/unittest测试框架/</id>
    <published>2018-03-01T01:00:00.000Z</published>
    <updated>2018-03-06T08:09:01.697Z</updated>
    
    <content type="html"><![CDATA[<p>unittest中最核心的四个概念是：test fixture, test case, test suite, test runner。<br><a id="more"></a></p><h3 id="1-unittest框架"><a href="#1-unittest框架" class="headerlink" title="1.unittest框架"></a>1.unittest框架</h3><p>(1)Test Fixture</p><ul><li>setup()</li><li>testcase()</li><li>teardown()</li></ul><p>(2)Test Case<br>(3)Test Suite<br>(4)Test Runner</p><h3 id="2-unittest小示例"><a href="#2-unittest小示例" class="headerlink" title="2.unittest小示例"></a>2.unittest小示例</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import unittestdemo1</span><br><span class="line">import unittestdemo2</span><br><span class="line">import unittest</span><br><span class="line">from appium import webdriver</span><br><span class="line"></span><br><span class="line">class MyTestCase(unittest.TestCase):</span><br><span class="line">#初始化setup</span><br><span class="line">def setUp(self):</span><br><span class="line">desired_caps=&#123;&#125;</span><br><span class="line">        desired_caps[&apos;platformName&apos;]=&apos;Android&apos;</span><br><span class="line">        desired_caps[&apos;platformVersion&apos;]=&apos;5.1.1&apos;</span><br><span class="line">        desired_caps[&apos;deviceName&apos;]=&apos;61f9c06a&apos;</span><br><span class="line">        desired_caps[&apos;appPackage&apos;]=&apos;com.android.contacts&apos;</span><br><span class="line">        desired_caps[&apos;appActivity&apos;]=&apos;com.android.contacts.DialtactsContactsEntryActivity&apos;</span><br><span class="line">        desired_caps[&apos;unicodeKeyboard&apos;]=&apos;true&apos;</span><br><span class="line">        desired_caps[&apos;resetKeyboard&apos;]=&apos;true&apos;</span><br><span class="line">        self.driver = webdriver.Remote(&apos;http://127.0.0.1:4723/wd/hub&apos;, desired_caps)</span><br><span class="line"></span><br><span class="line">#测试用例1</span><br><span class="line">def test_something(self):</span><br><span class="line">self.assertEqual(False, True)</span><br><span class="line">print(&apos;test_something&apos;)</span><br><span class="line">#测试用例2</span><br><span class="line">def test_anything(self):</span><br><span class="line">self.assertEqual(True, True)</span><br><span class="line">print(&apos;test_anything&apos;)</span><br><span class="line"></span><br><span class="line">#释放资源teardown</span><br><span class="line">def tearDown(self):</span><br><span class="line">self.driver.quit()</span><br><span class="line"></span><br><span class="line">if __name__ ==&quot;__main__&quot;:</span><br><span class="line">#以类的形式添加测试用例</span><br><span class="line">cases1 = unittest.TestLoader().loadTestsFromTestCase(unittestdemo1.MyTestCase)</span><br><span class="line">cases2 = unittest.TestLoader().loadTestsFromTestCase(unittestdemo2.MyTestCase)</span><br><span class="line">#定义suite</span><br><span class="line">suite = unittest.TestSuite([cases1, cases2])</span><br><span class="line">#以单条测试用例形式装载</span><br><span class="line">    suite.addTest(MyTestCase(&apos;test_something&apos;))</span><br><span class="line">suite.addTest(MyTestCase(&apos;test_anything&apos;))</span><br><span class="line">    </span><br><span class="line">#定义runner</span><br><span class="line">    runner = unittest.TextTestRunner(verbosity=2)</span><br><span class="line">#用runner执行suite</span><br><span class="line">    runner.run(suite)</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-DDT数据驱动模式"><a href="#3-DDT数据驱动模式" class="headerlink" title="3.DDT数据驱动模式"></a>3.DDT数据驱动模式</h3><p>(1)官网下载安装：<a href="https://pypi.python.org/pypi/ddt" target="_blank" rel="noopener">https://pypi.python.org/pypi/ddt</a><br>(2)使用前导入模块<code>from ddt import ddt,data,unpack</code><br>(3)首先说明测试类使用的是ddt测试框架：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@ddt</span><br><span class="line">class MyTestCase(unittest.TestCase)</span><br></pre></td></tr></table></figure></blockquote><p>(4)数据驱动主要是解决带参数的测试用例：<br>1）使用元组存放测试的数据，一个参数的情况：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@data(1,-3,2,0)</span><br><span class="line">def testcase(self, value):</span><br></pre></td></tr></table></figure></blockquote><p>2）使用元组存放测试的数据，多个参数的情况：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@data((3,2),(4,3),(5,3))</span><br><span class="line">@unpack</span><br><span class="line">def testcase(self, value1, value2):</span><br></pre></td></tr></table></figure></blockquote><h3 id="4-DDT小示例"><a href="#4-DDT小示例" class="headerlink" title="4.DDT小示例"></a>4.DDT小示例</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from ddt import ddt,data,unpack</span><br><span class="line"></span><br><span class="line">@ddt</span><br><span class="line">class MyTestCase(unittest.TestCase):</span><br><span class="line"></span><br><span class="line">@data(1,2,3)</span><br><span class="line">def test_something(self, value):</span><br><span class="line">print(value)</span><br><span class="line">self.assertEqual(value, 2)</span><br><span class="line"></span><br><span class="line">@data((1,2),(2,3))</span><br><span class="line">@unpack</span><br><span class="line">def test_anything(self, value1, value2):</span><br><span class="line">print(value1,value2)</span><br><span class="line">self.assertEqual(value2, value1+1)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">unittest.main()</span><br></pre></td></tr></table></figure></blockquote><p>ps:使用ddt框架后，测试用例的名称会改变，所以装载Test Suite时不能使用单条测试用例装载了，尽量使用类的形式装载Test Suite。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;unittest中最核心的四个概念是：test fixture, test case, test suite, test runner。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="测试框架" scheme="http://pythonfood.github.io/categories/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="测试框架" scheme="http://pythonfood.github.io/tags/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>appium键值表</title>
    <link href="http://pythonfood.github.io/2018/02/01/appium%E9%94%AE%E5%80%BC%E8%A1%A8/"/>
    <id>http://pythonfood.github.io/2018/02/01/appium键值表/</id>
    <published>2018-02-01T04:00:00.000Z</published>
    <updated>2018-02-28T07:10:54.877Z</updated>
    
    <content type="html"><![CDATA[<p>appium键值表查询。<br><a id="more"></a></p><h3 id="1-电话键"><a href="#1-电话键" class="headerlink" title="1.电话键"></a>1.电话键</h3><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th><th style="text-align:left">键值</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_CALL</td><td style="text-align:left">拨号键</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left">KEYCODE_ENDCALL</td><td style="text-align:left">挂机键</td><td style="text-align:left">6</td></tr><tr><td style="text-align:left">KEYCODE_HOME</td><td style="text-align:left">按键Home</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">KEYCODE_MENU</td><td style="text-align:left">菜单键</td><td style="text-align:left">82</td></tr><tr><td style="text-align:left">KEYCODE_BACK</td><td style="text-align:left">返回键</td><td style="text-align:left">4</td></tr><tr><td style="text-align:left">KEYCODE_SEARCH</td><td style="text-align:left">搜索键</td><td style="text-align:left">84</td></tr><tr><td style="text-align:left">KEYCODE_CAMERA</td><td style="text-align:left">拍照键</td><td style="text-align:left">27</td></tr><tr><td style="text-align:left">KEYCODE_FOCUS</td><td style="text-align:left">拍照对焦键</td><td style="text-align:left">80</td></tr><tr><td style="text-align:left">KEYCODE_POWER</td><td style="text-align:left">电源键</td><td style="text-align:left">26</td></tr><tr><td style="text-align:left">KEYCODE_NOTIFICATION</td><td style="text-align:left">通知键</td><td style="text-align:left">83</td></tr><tr><td style="text-align:left">KEYCODE_MUTE</td><td style="text-align:left">话筒静音键</td><td style="text-align:left">91</td></tr><tr><td style="text-align:left">KEYCODE_VOLUME_MUTE</td><td style="text-align:left">扬声器静音键</td><td style="text-align:left">164</td></tr><tr><td style="text-align:left">KEYCODE_VOLUME_UP</td><td style="text-align:left">音量增加键</td><td style="text-align:left">24</td></tr><tr><td style="text-align:left">KEYCODE_VOLUME_DOWN</td><td style="text-align:left">音量减小键</td><td style="text-align:left">25</td></tr></tbody></table><h3 id="2-控制键"><a href="#2-控制键" class="headerlink" title="2.控制键"></a>2.控制键</h3><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th><th style="text-align:left">键值</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_ENTER</td><td style="text-align:left">回车键</td><td style="text-align:left">66</td></tr><tr><td style="text-align:left">KEYCODE_ESCAPE</td><td style="text-align:left">ESC键</td><td style="text-align:left">111</td></tr><tr><td style="text-align:left">KEYCODE_DPAD_CENTER</td><td style="text-align:left">导航键 确定键</td><td style="text-align:left">23</td></tr><tr><td style="text-align:left">KEYCODE_DPAD_UP</td><td style="text-align:left">导航键 向上</td><td style="text-align:left">19</td></tr><tr><td style="text-align:left">KEYCODE_DPAD_DOWN</td><td style="text-align:left">导航键 向下</td><td style="text-align:left">20</td></tr><tr><td style="text-align:left">KEYCODE_DPAD_LEFT</td><td style="text-align:left">导航键 向左</td><td style="text-align:left">21</td></tr><tr><td style="text-align:left">KEYCODE_DPAD_RIGHT</td><td style="text-align:left">导航键 向右</td><td style="text-align:left">22</td></tr><tr><td style="text-align:left">KEYCODE_MOVE_HOME</td><td style="text-align:left">光标移动到开始键</td><td style="text-align:left">122</td></tr><tr><td style="text-align:left">KEYCODE_MOVE_END</td><td style="text-align:left">光标移动到末尾键</td><td style="text-align:left">123</td></tr><tr><td style="text-align:left">KEYCODE_PAGE_UP</td><td style="text-align:left">向上翻页键</td><td style="text-align:left">92</td></tr><tr><td style="text-align:left">KEYCODE_PAGE_DOWN</td><td style="text-align:left">向下翻页键</td><td style="text-align:left">93</td></tr><tr><td style="text-align:left">KEYCODE_DEL</td><td style="text-align:left">退格键</td><td style="text-align:left">67</td></tr><tr><td style="text-align:left">KEYCODE_FORWARD_DEL</td><td style="text-align:left">删除键</td><td style="text-align:left">112</td></tr><tr><td style="text-align:left">KEYCODE_INSERT</td><td style="text-align:left">插入键</td><td style="text-align:left">124</td></tr><tr><td style="text-align:left">KEYCODE_TAB</td><td style="text-align:left">Tab键</td><td style="text-align:left">61</td></tr><tr><td style="text-align:left">KEYCODE_NUM_LOCK</td><td style="text-align:left">小键盘锁</td><td style="text-align:left">143</td></tr><tr><td style="text-align:left">KEYCODE_CAPS_LOCK</td><td style="text-align:left">大写锁定键</td><td style="text-align:left">115</td></tr><tr><td style="text-align:left">KEYCODE_BREAK</td><td style="text-align:left">Break/Pause键</td><td style="text-align:left">121</td></tr><tr><td style="text-align:left">KEYCODE_SCROLL_LOCK</td><td style="text-align:left">滚动锁定键</td><td style="text-align:left">116</td></tr><tr><td style="text-align:left">KEYCODE_ZOOM_IN</td><td style="text-align:left">放大键</td><td style="text-align:left">168</td></tr><tr><td style="text-align:left">KEYCODE_ZOOM_OUT</td><td style="text-align:left">缩小键</td><td style="text-align:left">169</td></tr></tbody></table><h3 id="3-组合键"><a href="#3-组合键" class="headerlink" title="3.组合键"></a>3.组合键</h3><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_ALT_LEFT</td><td style="text-align:left">Alt+Left</td></tr><tr><td style="text-align:left">KEYCODE_ALT_RIGHT</td><td style="text-align:left">Alt+Right</td></tr><tr><td style="text-align:left">KEYCODE_CTRL_LEFT</td><td style="text-align:left">Control+Left</td></tr><tr><td style="text-align:left">KEYCODE_CTRL_RIGHT</td><td style="text-align:left">Control+Right</td></tr><tr><td style="text-align:left">KEYCODE_SHIFT_LEFT</td><td style="text-align:left">Shift+Left</td></tr><tr><td style="text-align:left">KEYCODE_SHIFT_RIGHT</td><td style="text-align:left">Shift+Right</td></tr></tbody></table><h3 id="4-基本键"><a href="#4-基本键" class="headerlink" title="4.基本键"></a>4.基本键</h3><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th><th style="text-align:left">键值</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_0</td><td style="text-align:left">按键’0’</td><td style="text-align:left">7</td></tr><tr><td style="text-align:left">KEYCODE_1</td><td style="text-align:left">按键’1’</td><td style="text-align:left">8</td></tr><tr><td style="text-align:left">KEYCODE_2</td><td style="text-align:left">按键’2’</td><td style="text-align:left">9</td></tr><tr><td style="text-align:left">KEYCODE_3</td><td style="text-align:left">按键’3’</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">KEYCODE_4</td><td style="text-align:left">按键’4’</td><td style="text-align:left">11</td></tr><tr><td style="text-align:left">KEYCODE_5</td><td style="text-align:left">按键’5’</td><td style="text-align:left">12</td></tr><tr><td style="text-align:left">KEYCODE_6</td><td style="text-align:left">按键’6’</td><td style="text-align:left">13</td></tr><tr><td style="text-align:left">KEYCODE_7</td><td style="text-align:left">按键’7’</td><td style="text-align:left">14</td></tr><tr><td style="text-align:left">KEYCODE_8</td><td style="text-align:left">按键’8’</td><td style="text-align:left">15</td></tr><tr><td style="text-align:left">KEYCODE_9</td><td style="text-align:left">按键’9’</td><td style="text-align:left">16</td></tr><tr><td style="text-align:left">KEYCODE_A</td><td style="text-align:left">按键’A’</td><td style="text-align:left">29</td></tr><tr><td style="text-align:left">KEYCODE_B</td><td style="text-align:left">按键’B’</td><td style="text-align:left">30</td></tr><tr><td style="text-align:left">KEYCODE_C</td><td style="text-align:left">按键’C’</td><td style="text-align:left">31</td></tr><tr><td style="text-align:left">KEYCODE_D</td><td style="text-align:left">按键’D’</td><td style="text-align:left">32</td></tr><tr><td style="text-align:left">KEYCODE_E</td><td style="text-align:left">按键’E’</td><td style="text-align:left">33</td></tr><tr><td style="text-align:left">KEYCODE_F</td><td style="text-align:left">按键’F’</td><td style="text-align:left">34</td></tr><tr><td style="text-align:left">KEYCODE_G</td><td style="text-align:left">按键’G’</td><td style="text-align:left">35</td></tr><tr><td style="text-align:left">KEYCODE_H</td><td style="text-align:left">按键’H’</td><td style="text-align:left">36</td></tr><tr><td style="text-align:left">KEYCODE_I</td><td style="text-align:left">按键’I’</td><td style="text-align:left">37</td></tr><tr><td style="text-align:left">KEYCODE_J</td><td style="text-align:left">按键’J’</td><td style="text-align:left">38</td></tr><tr><td style="text-align:left">KEYCODE_K</td><td style="text-align:left">按键’K’</td><td style="text-align:left">39</td></tr><tr><td style="text-align:left">KEYCODE_L</td><td style="text-align:left">按键’L’</td><td style="text-align:left">40</td></tr><tr><td style="text-align:left">KEYCODE_M</td><td style="text-align:left">按键’M’</td><td style="text-align:left">41</td></tr><tr><td style="text-align:left">KEYCODE_N</td><td style="text-align:left">按键’N’</td><td style="text-align:left">42</td></tr><tr><td style="text-align:left">KEYCODE_O</td><td style="text-align:left">按键’O’</td><td style="text-align:left">43</td></tr><tr><td style="text-align:left">KEYCODE_P</td><td style="text-align:left">按键’P’</td><td style="text-align:left">44</td></tr><tr><td style="text-align:left">KEYCODE_Q</td><td style="text-align:left">按键’Q’</td><td style="text-align:left">45</td></tr><tr><td style="text-align:left">KEYCODE_R</td><td style="text-align:left">按键’R’</td><td style="text-align:left">46</td></tr><tr><td style="text-align:left">KEYCODE_S</td><td style="text-align:left">按键’S’</td><td style="text-align:left">47</td></tr><tr><td style="text-align:left">KEYCODE_T</td><td style="text-align:left">按键’T’</td><td style="text-align:left">48</td></tr><tr><td style="text-align:left">KEYCODE_U</td><td style="text-align:left">按键’U’</td><td style="text-align:left">49</td></tr><tr><td style="text-align:left">KEYCODE_V</td><td style="text-align:left">按键’V’</td><td style="text-align:left">50</td></tr><tr><td style="text-align:left">KEYCODE_W</td><td style="text-align:left">按键’W’</td><td style="text-align:left">51</td></tr><tr><td style="text-align:left">KEYCODE_X</td><td style="text-align:left">按键’X’</td><td style="text-align:left">52</td></tr><tr><td style="text-align:left">KEYCODE_Y</td><td style="text-align:left">按键’Y’</td><td style="text-align:left">53</td></tr><tr><td style="text-align:left">KEYCODE_Z</td><td style="text-align:left">按键’Z’</td><td style="text-align:left">54</td></tr></tbody></table><h3 id="5-符号键"><a href="#5-符号键" class="headerlink" title="5.符号键"></a>5.符号键</h3><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_PLUS</td><td style="text-align:left">按键’+’</td></tr><tr><td style="text-align:left">KEYCODE_MINUS</td><td style="text-align:left">按键’-‘</td></tr><tr><td style="text-align:left">KEYCODE_STAR</td><td style="text-align:left">按键’*’</td></tr><tr><td style="text-align:left">KEYCODE_SLASH</td><td style="text-align:left">按键’/‘</td></tr><tr><td style="text-align:left">KEYCODE_EQUALS</td><td style="text-align:left">按键’=’</td></tr><tr><td style="text-align:left">KEYCODE_AT</td><td style="text-align:left">按键’@’</td></tr><tr><td style="text-align:left">KEYCODE_POUND</td><td style="text-align:left">按键’#’</td></tr><tr><td style="text-align:left">KEYCODE_APOSTROPHE</td><td style="text-align:left">按键’’’ (单引号)</td></tr><tr><td style="text-align:left">KEYCODE_BACKSLASH</td><td style="text-align:left">按键’\’</td></tr><tr><td style="text-align:left">KEYCODE_COMMA</td><td style="text-align:left">按键’,’</td></tr><tr><td style="text-align:left">KEYCODE_PERIOD</td><td style="text-align:left">按键’.’</td></tr><tr><td style="text-align:left">KEYCODE_LEFT_BRACKET</td><td style="text-align:left">按键’[‘</td></tr><tr><td style="text-align:left">KEYCODE_RIGHT_BRACKET</td><td style="text-align:left">按键’]’</td></tr><tr><td style="text-align:left">KEYCODE_SEMICOLON</td><td style="text-align:left">按键’;’</td></tr><tr><td style="text-align:left">KEYCODE_GRAVE</td><td style="text-align:left">按键’`’</td></tr><tr><td style="text-align:left">KEYCODE_SPACE</td><td style="text-align:left">空格键</td></tr></tbody></table><h3 id="6-小键盘"><a href="#6-小键盘" class="headerlink" title="6.小键盘"></a>6.小键盘</h3><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_NUMPAD_0</td><td style="text-align:left">小键盘按键’0’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_1</td><td style="text-align:left">小键盘按键’1’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_2</td><td style="text-align:left">小键盘按键’2’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_3</td><td style="text-align:left">小键盘按键’3’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_4</td><td style="text-align:left">小键盘按键’4’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_5</td><td style="text-align:left">小键盘按键’5’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_6</td><td style="text-align:left">小键盘按键’6’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_7</td><td style="text-align:left">小键盘按键’7’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_8</td><td style="text-align:left">小键盘按键’8’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_9</td><td style="text-align:left">小键盘按键’9’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_ADD</td><td style="text-align:left">小键盘按键’+’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_SUBTRACT</td><td style="text-align:left">小键盘按键’-‘</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_MULTIPLY</td><td style="text-align:left">小键盘按键’*’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_DIVIDE</td><td style="text-align:left">小键盘按键’/‘</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_EQUALS</td><td style="text-align:left">小键盘按键’=’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_COMMA</td><td style="text-align:left">小键盘按键’,’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_DOT</td><td style="text-align:left">小键盘按键’.’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_LEFT_PAREN</td><td style="text-align:left">小键盘按键’(‘</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_RIGHT_PAREN</td><td style="text-align:left">小键盘按键’)’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_ENTER</td><td style="text-align:left">小键盘按键回车</td></tr></tbody></table><h3 id="7-功能键"><a href="#7-功能键" class="headerlink" title="7.功能键"></a>7.功能键</h3><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_F1</td><td style="text-align:left">按键F1</td></tr><tr><td style="text-align:left">KEYCODE_F2</td><td style="text-align:left">按键F2</td></tr><tr><td style="text-align:left">KEYCODE_F3</td><td style="text-align:left">按键F3</td></tr><tr><td style="text-align:left">KEYCODE_F4</td><td style="text-align:left">按键F4</td></tr><tr><td style="text-align:left">KEYCODE_F5</td><td style="text-align:left">按键F5</td></tr><tr><td style="text-align:left">KEYCODE_F6</td><td style="text-align:left">按键F6</td></tr><tr><td style="text-align:left">KEYCODE_F7</td><td style="text-align:left">按键F7</td></tr><tr><td style="text-align:left">KEYCODE_F8</td><td style="text-align:left">按键F8</td></tr><tr><td style="text-align:left">KEYCODE_F9</td><td style="text-align:left">按键F9</td></tr><tr><td style="text-align:left">KEYCODE_F10</td><td style="text-align:left">按键F10</td></tr><tr><td style="text-align:left">KEYCODE_F11</td><td style="text-align:left">按键F11</td></tr><tr><td style="text-align:left">KEYCODE_F12</td><td style="text-align:left">按键F12</td></tr></tbody></table><h3 id="8-多媒体键"><a href="#8-多媒体键" class="headerlink" title="8.多媒体键"></a>8.多媒体键</h3><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_MEDIA_PLAY</td><td style="text-align:left">播放</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_STOP</td><td style="text-align:left">停止</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_PAUSE</td><td style="text-align:left">暂停</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_PLAY_PAUSE</td><td style="text-align:left">播放/暂停</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_FAST_FORWARD</td><td style="text-align:left">快进</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_REWIND</td><td style="text-align:left">快退</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_NEXT</td><td style="text-align:left">下一首</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_PREVIOUS</td><td style="text-align:left">上一首</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_CLOSE</td><td style="text-align:left">关闭</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_EJECT</td><td style="text-align:left">弹出</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_RECORD</td><td style="text-align:left">录音</td></tr></tbody></table><h3 id="9-手柄按键"><a href="#9-手柄按键" class="headerlink" title="9.手柄按键"></a>9.手柄按键</h3><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_BUTTON_1</td><td style="text-align:left">通用游戏手柄按钮 #1</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_2</td><td style="text-align:left">通用游戏手柄按钮 #2</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_3</td><td style="text-align:left">通用游戏手柄按钮 #3</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_4</td><td style="text-align:left">通用游戏手柄按钮 #4</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_5</td><td style="text-align:left">通用游戏手柄按钮 #5</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_6</td><td style="text-align:left">通用游戏手柄按钮 #6</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_7</td><td style="text-align:left">通用游戏手柄按钮 #7</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_8</td><td style="text-align:left">通用游戏手柄按钮 #8</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_9</td><td style="text-align:left">通用游戏手柄按钮 #9</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_10</td><td style="text-align:left">通用游戏手柄按钮 #10</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_11</td><td style="text-align:left">通用游戏手柄按钮 #11</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_12</td><td style="text-align:left">通用游戏手柄按钮 #12</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_13</td><td style="text-align:left">通用游戏手柄按钮 #13</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_14</td><td style="text-align:left">通用游戏手柄按钮 #14</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_15</td><td style="text-align:left">通用游戏手柄按钮 #15</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_16</td><td style="text-align:left">通用游戏手柄按钮 #16</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_A</td><td style="text-align:left">游戏手柄按钮 A</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_B</td><td style="text-align:left">游戏手柄按钮 B</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_C</td><td style="text-align:left">游戏手柄按钮 C</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_X</td><td style="text-align:left">游戏手柄按钮 X</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_Y</td><td style="text-align:left">游戏手柄按钮 Y</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_Z</td><td style="text-align:left">游戏手柄按钮 Z</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_L1</td><td style="text-align:left">游戏手柄按钮 L1</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_L2</td><td style="text-align:left">游戏手柄按钮 L2</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_R1</td><td style="text-align:left">游戏手柄按钮 R1</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_R2</td><td style="text-align:left">游戏手柄按钮 R2</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_MODE</td><td style="text-align:left">游戏手柄按钮 Mode</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_SELECT</td><td style="text-align:left">游戏手柄按钮 Select</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_START</td><td style="text-align:left">游戏手柄按钮 Start</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_THUMBL</td><td style="text-align:left">Left Thumb Button</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_THUMBR</td><td style="text-align:left">Right Thumb Button</td></tr></tbody></table><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;appium键值表查询。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="appium" scheme="http://pythonfood.github.io/categories/appium/"/>
    
    
      <category term="appium" scheme="http://pythonfood.github.io/tags/appium/"/>
    
  </entry>
  
  <entry>
    <title>appium常用API</title>
    <link href="http://pythonfood.github.io/2018/02/01/appium%E5%B8%B8%E7%94%A8API/"/>
    <id>http://pythonfood.github.io/2018/02/01/appium常用API/</id>
    <published>2018-02-01T03:00:00.000Z</published>
    <updated>2018-03-06T10:08:56.403Z</updated>
    
    <content type="html"><![CDATA[<p>appium常用API笔记。<br><a id="more"></a></p><h3 id="1-元素定位"><a href="#1-元素定位" class="headerlink" title="1.元素定位"></a>1.元素定位</h3><p>(1)id定位<br>find_element_by_id(“resrouce-id”)</p><blockquote><p><code>driver.find_element_by_id(&#39;com.android.calculator2:id/digit8&#39;)</code></p></blockquote><p>(2)name定位<br>find_element_by_name(“text”)</p><blockquote><p><code>driver.find_element_by_name(&quot;昵称&quot;)</code></p></blockquote><p>(3)class_name定位<br>find_element_by_class_name(“class”)</p><blockquote><p><code>driver.find_element_by_class_name(&quot;android.widget.Button&quot;)</code></p></blockquote><p>(4)accessibility_id定位<br>find_element_by_accessibility_id(“content-desc”)</p><blockquote><p><code>driver.find_element_by_accessibility_id(&quot;delete&quot;)</code></p></blockquote><p>(5)xpath定位<br>find_element_by_xpath(“xpath”)</p><blockquote><p><code>driver.find_element_by_xpath(&quot;//android.widget.Button[@text=&#39;8&#39;]&quot;)</code></p></blockquote><p>(6)uiautomator定位<br>find_element_by_android_uiautomator(uia_string)<br>uiautomator可以针对resourceid、Text、description、class、package、index、instance等进行定位。</p><blockquote><p>1)resourceId方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().resourceId(&quot;%s&quot;)&#39;)</code></p></blockquote><p>2)text方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().text(&quot;%s&quot;)&#39;)</code></p></blockquote><p>3)description方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().description(&quot;%s&quot;)&#39;)</code></p></blockquote><p>4)className方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().className(&quot;%s&quot;)&#39;)</code></p></blockquote><p>5)packageName方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().packageName(&quot;%s&quot;)&#39;)</code></p></blockquote><p>6)index方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().index(&quot;%s&quot;)&#39;)</code></p></blockquote><p>7)instance方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().instance(&quot;%s&quot;)&#39;)</code></p></blockquote><p>8)className+index方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().className(&quot;%s&quot;).childSelector(new UiSelector().index(&quot;%d&quot;))&#39;)</code></p></blockquote><p>9)伪xpath方法定位</p><blockquote><p>a.通过同级元素定位同级元素</p><blockquote><p><code>driver.find_element_by_android_uiautomator(‘new UiSelector().text(&quot;Custom View&quot;).fromParent(new UiSelector().text(&quot;Accessibility Service&quot;))‘).click()</code>            </p></blockquote><p>b.通过父级元素定位子集元素</p><blockquote><p><code>driver.find_element_by_android_uiautomator(‘new UiSelector().className(&quot;android.widget.ListView&quot;).childSelector(new UiSelector().text(&quot;Custom View&quot;))‘).click()</code>  </p></blockquote></blockquote></blockquote><p>(7)用By定位</p><ul><li>By.ID   #相当于by_id</li><li>By.NAME   #相当于by_name</li><li>By.CLASS_NAME  #相当于by_class_name</li><li>By.ACCESSIBILITY_ID  #相当于by_accessibility_id</li><li>By.XPATH   #相当于by_xpath</li></ul><blockquote><p><code>find_element(By.ID,&quot;com.android.calculator2:id/digit8&quot;)</code></p></blockquote><h3 id="2-应用操作"><a href="#2-应用操作" class="headerlink" title="2.应用操作"></a>2.应用操作</h3><p>(1)安装应用<br><code>install_app()</code> #安装应用到设备中去。需要apk包的路径。</p><blockquote><p><code>driver.install_app(&quot;path/to/my.apk&quot;)</code><br><code>driver.install_app(&quot;D:\\android\\apk\\ContactManager.apk&quot;)</code></p></blockquote><p>(2)卸载应用<br><code>remove_app()</code> #从设备中删除一个应用。</p><blockquote><p><code>driver.remove_app(&quot;com.example.android.apis&quot;)</code></p></blockquote><p>(3)关闭应用<br><code>close_app()</code> #关闭打开的应用，默认关闭当前打开的应用，所以不需要入参。相当于按home键将应用置于后台，可以通过launch_app()再次启动。</p><blockquote><p><code>driver.close_app()</code></p></blockquote><p>(4)启动应用<br><code>launch_app()</code> #该方法需要配合close_app()使用的。</p><blockquote><p><code>driver.launch_app()</code></p></blockquote><p>(5)检查应用是否安装<br><code>is_app_installed()</code> #检查应用是否已经安装。需要传参应用包的名字。返回结果为Ture或False。</p><blockquote><p><code>driver.is_app_installed(&#39;com.example.android.apis&#39;)</code></p></blockquote><p>(6)将应用置于后台<br><code>background_app()</code> #将当前活跃的应用程序发送到后台。这个方法需要入参，需要指定应用置于后台的时长。</p><blockquote><p><code>driver.background_app(2)</code></p></blockquote><p>(7)应用重置<br><code>reset_app()</code> #重置当前被测程序到出始化状态。该方法不需要入参。</p><blockquote><p><code>driver.reset_app()</code></p></blockquote><p>(8)启动activity<br><code>start_activity()</code> #启动一个app或者在当前app中打开一个新的activity，仅适用于android。</p><blockquote><p><code>driver.start_activity(&#39;com.example.android.apis&#39;, &#39;.Foo&#39;)</code></p></blockquote><h3 id="3-键盘操作"><a href="#3-键盘操作" class="headerlink" title="3.键盘操作"></a>3.键盘操作</h3><p>ps：<a href="https://pythonfood.github.io/2018/02/01/appium键值表/#more">appium键值表</a><br>(1)send_keys()方法</p><blockquote><p><code>driver.find_element_by_name(“Name”).send_keys(&quot;jack&quot;)</code></p></blockquote><p>(2)keyevent()方法</p><blockquote><p><code>`driver.keyevent(4)</code> #点击Android的返回键`</p></blockquote><p>(3)press_keycode()方法</p><blockquote><p><code>driver.press_keycode(3)</code> #点击Android的HOME键</p></blockquote><p>(4)long_press_keycode()方法</p><blockquote><p><code>driver.long_press_keycode(4)</code> #长按Android的返回键</p></blockquote><p>(5)隐藏键盘</p><blockquote><p><code>driver.hide_keyboard()</code> #android不需要参数，ios需要传参key_name</p></blockquote><h3 id="4-TouchAction操作"><a href="#4-TouchAction操作" class="headerlink" title="4.TouchAction操作"></a>4.TouchAction操作</h3><p>使用前导入TouchAction模块<code>from appium.webdriver.common.touch_action import TouchAction</code><br>(1)点击<br><code>tap(self,el=None,x=None,y=None,count=1)</code><br>(2)短按<br><code>press(self, el=None, x=None, y=None)</code><br>(3)长按<br><code>long_press(self, el=None, x=None, y=None, duration=1000(ms))</code><br>(4)释放<br><code>release(self)</code><br>(5)移动到<br><code>move_to(self,el=None,x=None,y=None)</code><br>(6)等待<br><code>wait(self,ms=0)</code><br>(7)执行<br><code>perform(self)</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#关于perform官网给的伪代码中讲</span><br><span class="line">TouchAction().tap(el).perform()</span><br><span class="line">#与</span><br><span class="line">driver.perform(TouchAction().tap(el))</span><br><span class="line">#效果一致</span><br></pre></td></tr></table></figure></blockquote><p>(8)多点触控<br><code>MultiTouch()</code> #多点触控,它只提供了两个方法:一个<code>add()</code>、一个执行<code>perform()</code>。<br>使用前导入MultiAction模块<code>from appium.webdriver.common.multi_action import MultiAction</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from appium.webdriver.common.touch_action import TouchAction</span><br><span class="line">from appium.webdriver.common.multi_action import MultiAction</span><br><span class="line"></span><br><span class="line">action0 = TouchAction().tap(el1)</span><br><span class="line">action1 = TouchAction().tap(el2)</span><br><span class="line">MultiTouch().add(action0).add(action1).perform()</span><br></pre></td></tr></table></figure></blockquote><h3 id="5-上下文操作"><a href="#5-上下文操作" class="headerlink" title="5.上下文操作"></a>5.上下文操作</h3><p>(1)当前会话中的所有上下文，使用后可以识别H5页面的控件<br><code>driver.contexts</code></p><blockquote><p>获取的是一个list列表：</p><blockquote><ul><li>NATIVE_APP:这个就是native，也就是原生的</li><li>WEBVIEW_com.xxxx :这个就是webview</li></ul></blockquote></blockquote><p>(2)当前会话的当前上下文<br><code>driver.current_context</code><br>(3)切换上下文<br><code>driver.switch_to.context(&quot;content_str&quot;)</code></p><blockquote><p>1)切换到webview</p><blockquote><p>方法一：<code>driver.switch_to.context(&#39;webview的context&#39;)</code><br>方法二：<code>driver.switch_to.context(contexts[1])</code> #从contexts列表里取第二个参数</p></blockquote><p>2)切回native</p><blockquote><p>方法一：<code>driver.switch_to.context(&quot;NATIVE_APP&quot;)</code> #这个NATIVE_APP是固定的参数<br>方法二：<code>driver.switch_to.context(contexts[0])</code> #从contexts列表里取第一个参数</p></blockquote></blockquote><p>(4)应用的字符串<br><code>driver.app_strings</code></p><h3 id="6-屏幕操作"><a href="#6-屏幕操作" class="headerlink" title="6.屏幕操作"></a>6.屏幕操作</h3><p>(1)点击<br>1)<code>click()</code></p><blockquote><p><code>driver.find_element_by_id(&quot;com.wuba.zhuanzhuan:id/ae8&quot;).click()</code></p></blockquote><p>2)<code>driver.tap()</code></p><blockquote><p><code>driver.tap([(216,1776)],200)</code></p></blockquote><p>(2)滑动<br><code>driver.swipe(x1, y1, x2, y2,duration)</code> #从坐标(x1,x2)滑动到坐标(x2,y2)，duration非必填项，滑动时间</p><blockquote><p>一个向上下左右滑动的方法封装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#获得屏幕大小宽和高</span><br><span class="line">def getSize(driver):</span><br><span class="line">    x = driver.get_window_size()[&apos;width&apos;]</span><br><span class="line">    y = driver.get_window_size()[&apos;height&apos;]</span><br><span class="line">    return (x, y)</span><br><span class="line"></span><br><span class="line">#屏幕向上滑动</span><br><span class="line">def swipeUp(driver,t=1000):</span><br><span class="line">    l = getSize(driver)</span><br><span class="line">    x1 = int(l[0] * 0.5)    #x坐标</span><br><span class="line">    y1 = int(l[1] * 0.75)   #起始y坐标</span><br><span class="line">    y2 = int(l[1] * 0.25)   #终点y坐标</span><br><span class="line">    driver.swipe(x1, y1, x1, y2,t)</span><br><span class="line"></span><br><span class="line">#屏幕向下滑动</span><br><span class="line">def swipeDown(driver,t=1000):</span><br><span class="line">    l = getSize(driver)</span><br><span class="line">    x1 = int(l[0] * 0.5)  #x坐标</span><br><span class="line">    y1 = int(l[1] * 0.25)   #起始y坐标</span><br><span class="line">    y2 = int(l[1] * 0.75)   #终点y坐标</span><br><span class="line">    driver.swipe(x1, y1, x1, y2,t)</span><br><span class="line">#屏幕向左滑动</span><br><span class="line">def swipLeft(driver,t):</span><br><span class="line">    l=getSize(driver)</span><br><span class="line">    x1=int(l[0]*0.75)</span><br><span class="line">    y1=int(l[1]*0.5)</span><br><span class="line">    x2=int(l[0]*0.05)</span><br><span class="line">    driver.swipe(x1,y1,x2,y1,t)</span><br><span class="line">#屏幕向右滑动</span><br><span class="line">def swipRight(driver,t=1000):</span><br><span class="line">    l=getSize(driver)</span><br><span class="line">    x1=int(l[0]*0.05)</span><br><span class="line">    y1=int(l[1]*0.5)</span><br><span class="line">    x2=int(l[0]*0.75)</span><br><span class="line">    driver.swipe(x1,y1,x2,y1,t)</span><br><span class="line"> </span><br><span class="line">#调用向下滑动的方法</span><br><span class="line">swipeDown(driver)</span><br></pre></td></tr></table></figure></p></blockquote><p>(3)滚动<br><code>driver.scroll(origin_el,destination_el)</code></p><p>(4)拖动<br><code>driver.drag_and_drop(el1,el2)</code></p><p>(5)快速滑动<br><code>driver.flick(start_x, start_y, end_x, end_y)</code></p><p>(6)缩小<br><code>driver.pinch(element)</code></p><p>(7)放大<br><code>driver.zoom(element)</code></p><p>(8)锁屏<br><code>driver.lock()</code> #android不需要传参，ios可以传参锁屏多少秒</p><p>(9)截屏<br><code>get_screenshot_as_file()</code></p><blockquote><p><code>driver.get_screenshot_as_file(&#39;../screenshot/foo.png&#39;)</code>#保存的图片路径和名称</p></blockquote><p>(10)屏幕旋转<br><code>rotate(ScreenOrientation orientation)</code></p><ul><li>landscape：限制界面为横屏，旋转屏幕也不会改变当前状态。</li><li>portrait：限制界面为竖屏，旋转屏幕也不会改变当前状态。</li><li>sensor:根据传感器定位方向，旋转手机90度，180,270,360，界面都会发生变化。</li><li>sensorLandscape：（横屏的旋转，不会出现竖屏的现象）根据传感器定位方向，旋转手机180度界面旋转。一般横屏游戏会是这个属性。</li><li>sensorPortrait：（竖屏的旋转，不会出现横屏的现象）根据传感器定位方向，旋转手机180度界面会旋转。</li><li>unspecified：由系统选择显示方向，不同的设备可能会有所不同。（旋转手机，界面会跟着旋转）</li><li>user: 用户当前的首选方向。</li><li>nosensor：不由传感器确定方向。旋转设备的时候，界面不会跟着旋转。初始界面方向由系统提供。</li></ul><p>(11)获取当前屏幕的方向<br><code>get_orientation()</code></p><h3 id="7-网络设置"><a href="#7-网络设置" class="headerlink" title="7.网络设置"></a>7.网络设置</h3><p>(1)返回网络类型数值<br><code>driver.network_connection</code></p><p>(2)网络设置<br><code>driver.setNetworkConnection(bitmask掩码)</code><br>使用前导入ConnectionType模块<code>from appium.webdriver.connectiontype import ConnectionType</code></p><blockquote><p><code>driver.set_network_connection(2)</code><br><code>driver.set_network_connection(ConnectionType.WIFI_ONLY)</code></p></blockquote><p>网络的bitmask掩码如下：</p><table><thead><tr><th style="text-align:left">值 (别名)</th><th style="text-align:left">数据连接</th><th style="text-align:left">Wifi连接</th><th style="text-align:left">飞行模式</th></tr></thead><tbody><tr><td style="text-align:left">0 (NO_CONNECTION)</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">1 (AIRPLANE_MODE)</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">2 (WIFI_ONLY)</td><td style="text-align:left">0</td><td style="text-align:left">1</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">4 (DATA_ONLY)</td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">6 (ALL_NETWORK_ON)</td><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">0</td></tr></tbody></table><h3 id="8-位置设置"><a href="#8-位置设置" class="headerlink" title="8.位置设置"></a>8.位置设置</h3><p>(1)打开定位设置<br><code>driver.toggle_location_services()</code> </p><p>(2)设置设备的经纬度<br><code>driver.set_location(latitude纬度，longitude经度，altitude海拔高度)</code></p><h3 id="9-文件操作"><a href="#9-文件操作" class="headerlink" title="9.文件操作"></a>9.文件操作</h3><p>(1)把本地文件push到设备上。<br><code>push_file()</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = &quot;some data for the file&quot;</span><br><span class="line">path = &quot;/data/local/tmp/file.txt&quot;</span><br><span class="line">driver.push_file(path, data.encode(&apos;base64&apos;))</span><br></pre></td></tr></table></figure></blockquote><p>(2)将设备上的文件pull到本地硬盘上<br><code>pull_file()</code></p><blockquote><p><code>driver.pull_file(&#39;Library/AddressBook/AddressBook.sqlitedb&#39;)</code></p></blockquote><p>(3)将设备上的文件夹pull到本地硬盘上，一般远程文件为/data/local/tmp下的文件。<br><code>pull_folder()</code></p><h3 id="10-activity操作"><a href="#10-activity操作" class="headerlink" title="10.activity操作"></a>10.activity操作</h3><p>(1)启动activity<br><code>driver.start_activity()</code></p><p>(2)获取当前activity<br><code>driver.current_activity</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">activity = self.driver.current_activity </span><br><span class="line">print(u&quot;当前的activity是:&quot;, activity)</span><br></pre></td></tr></table></figure></blockquote><p>(3)等待activity启动直到x秒超时，每隔y秒扫描一次<br><code>driver.wait_activity(activity, x, y)</code></p><p>(4)检查是否存在某个activity(未找到则返回异常）<br><code>driver.find_element_by_id(activity)</code></p><p>ps:查看包名和activity的方法：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 1)启动应用，输入命令，查看</span><br><span class="line">adb shell dumpsys window | findstr mCurrentFocus </span><br><span class="line"># 2)启动应用，输入命令，查看</span><br><span class="line">adb shell dumpsys activity activities</span><br><span class="line"># 3)有安装包，cmd输入命令，查看</span><br><span class="line">aapt dump badging &lt;file_path.apk&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="11-其他操作"><a href="#11-其他操作" class="headerlink" title="11.其他操作"></a>11.其他操作</h3><p>(1)打开通知栏<br><code>driver.open_notifications()</code></p><p>(2)摇一摇手机<br><code>driver.shake()</code></p><p>(3)获取控件各种属性<br><code>get_attribute()</code><br>可获取的字符串类型：</p><ul><li>name(返回content-desc或text)</li><li>text(返回text)</li><li>className(返回class，只有API=&gt;18才能支持)</li><li>resourceId(返回resource-id，只有API=&gt;18才能支持)</li><li>…uiautomator获得的属性</li></ul><blockquote><p><code>driver.find_element_by_id().get_attribute(name)</code></p></blockquote><p>(4)返回元素是否选择<br><code>element.is_slected()</code></p><p>(5)返回元素是否可用<br><code>element.is_enabled()</code></p><p>(6)返回元素的文本值<br><code>element.text()</code></p><p>(7)清除输入的内容<br><code>element.clear()</code></p><p>(8)获取元素的大小<br><code>driver.element.size</code></p><ul><li>new_size[“height”] = size[“height”]</li><li>new_size[“width”] = size[“width”]</li></ul><p>(9)获取元素左上角的坐标<br><code>driver.element.location</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#返回element的x坐标, int类型</span><br><span class="line">driver.element.location.get(&apos;x&apos;)</span><br><span class="line">#返回element的y坐标, int类型</span><br><span class="line">driver.element.location.get(&apos;y&apos;)</span><br></pre></td></tr></table></figure></blockquote><h3 id="12-unittest断言"><a href="#12-unittest断言" class="headerlink" title="12.unittest断言"></a>12.unittest断言</h3><p>在unittest单元测试框架中，TestCase类提供了一些方法来检查并报告故障：<br>(1)<code>assertEqual(first, second, msg=None)</code>#判断first和second的值是否相等，如果不相等则测试失败，msg用于定义失败后所抛出的异常信息。<br>(2)<code>assertNotEqual(first, second, msg=None)</code>#测试first和second不相等，如果相等，则测试失败。<br>(3)<code>assertTure(expr,msg=None)</code><br>(4)<code>assertFalse(expr,msg=None)</code>#测试expr为Ture（或为False）<br>(5)<code>assertIs(first, second, msg=None)</code><br>(6)<code>assertIsNot(first, second, msg=None)</code>#测试的first和second是（或不是）相同的对象。<br>(7)<code>assertIsNone(expr, msg=None)</code><br>(8)<code>assertIsNotNone(expr, msg=None)</code>#测试expr是（或不是）为None<br>(9)<code>assertIn(first, second, msg=None)</code><br>(10)<code>assertNotIn(first, second, msg=None)</code>#测试first是（或不是）在second中。second包含是否包含first。</p><h3 id="13-脚本设计原则"><a href="#13-脚本设计原则" class="headerlink" title="13.脚本设计原则"></a>13.脚本设计原则</h3><p>(1)LOVE原则(NativeApp)：</p><blockquote><p>1)Locate定位元素<br>2)Operate操作元素<br>3)Verify验证结果<br>4)Exception异常处理</p></blockquote><p>(2)S-LOVE原则(HybridApp)：</p><blockquote><p>1)Switch切换上下文<br>2)Locate定位元素<br>3)Operate操作元素<br>4)Verify验证结果<br>5)Exception异常处理</p></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;appium常用API笔记。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="appium" scheme="http://pythonfood.github.io/categories/appium/"/>
    
    
      <category term="appium" scheme="http://pythonfood.github.io/tags/appium/"/>
    
  </entry>
  
  <entry>
    <title>appium DesiredCapabilities</title>
    <link href="http://pythonfood.github.io/2018/02/01/appium-DesiredCapabilities/"/>
    <id>http://pythonfood.github.io/2018/02/01/appium-DesiredCapabilities/</id>
    <published>2018-02-01T02:00:00.000Z</published>
    <updated>2018-02-26T09:11:31.048Z</updated>
    
    <content type="html"><![CDATA[<p>Appium Desired Capabilities 详解。<br><a id="more"></a></p><h3 id="1-基本参数"><a href="#1-基本参数" class="headerlink" title="1.基本参数"></a>1.基本参数</h3><table><thead><tr><th style="text-align:left">关键字</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">automationName</td><td style="text-align:left">自动化测试引擎</td><td style="text-align:left">Appium或 Selendroid</td></tr><tr><td style="text-align:left">platformName</td><td style="text-align:left">手机操作系统</td><td style="text-align:left">iOS, Android, 或 FirefoxOS</td></tr><tr><td style="text-align:left">platformVersion</td><td style="text-align:left">手机操作系统版本</td><td style="text-align:left">如： 7.1, 4.4；ios的 9.0</td></tr><tr><td style="text-align:left">deviceName</td><td style="text-align:left">手机或模拟器设备名称</td><td style="text-align:left">android的忽略，ios如iPhone Simulator</td></tr><tr><td style="text-align:left">app</td><td style="text-align:left">.ipa .apk文件路径</td><td style="text-align:left">比如/abs/path/to/my.apk或<a href="http://myapp.com/app.ipa" target="_blank" rel="noopener">http://myapp.com/app.ipa</a></td></tr><tr><td style="text-align:left">browserName</td><td style="text-align:left">启动手机浏览器</td><td style="text-align:left">iOS如:Safari，Android如:Chrome,Chromium,Browser</td></tr><tr><td style="text-align:left">newCommandTimeout</td><td style="text-align:left">设置命令超时时间，单位：秒。</td><td style="text-align:left">比如 60</td></tr><tr><td style="text-align:left">autoLaunch</td><td style="text-align:left">Appium是否需要自动安装和启动应用。默认值true</td><td style="text-align:left">true, false</td></tr><tr><td style="text-align:left">language</td><td style="text-align:left">(Sim/Emu-only) 设定模拟器 ( simulator / emulator ) 的语言。</td><td style="text-align:left">如： fr</td></tr><tr><td style="text-align:left">locale</td><td style="text-align:left">(Sim/Emu-only) 设定模拟器 ( simulator / emulator ) 的区域设置。</td><td style="text-align:left">如： fr_CA</td></tr><tr><td style="text-align:left">udid</td><td style="text-align:left">ios真机的唯一设备标识</td><td style="text-align:left">如： 1ae203187fc012g</td></tr><tr><td style="text-align:left">orientation</td><td style="text-align:left">设置横屏或竖屏</td><td style="text-align:left">LANDSCAPE (横向) 或 PORTRAIT (纵向)</td></tr><tr><td style="text-align:left">autoWebview</td><td style="text-align:left">直接转换到 WebView 上下文。 默认值 false、</td><td style="text-align:left">true, false</td></tr><tr><td style="text-align:left">noReset</td><td style="text-align:left">不要在会话前重置应用状态。默认值false。</td><td style="text-align:left">true, false</td></tr><tr><td style="text-align:left">fullReset</td><td style="text-align:left">(iOS) 删除整个模拟器目录。(Android)通过卸载默认值 false</td><td style="text-align:left">true, false</td></tr></tbody></table><h3 id="2-android特有"><a href="#2-android特有" class="headerlink" title="2.android特有"></a>2.android特有</h3><table><thead><tr><th style="text-align:left">关键字</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">appActivity</td><td style="text-align:left">启动app包,一般点开头</td><td style="text-align:left">如：.MainActivity, .Settings</td></tr><tr><td style="text-align:left">appPackage</td><td style="text-align:left">Android应用的包名</td><td style="text-align:left">比如com.example.android.myApp</td></tr><tr><td style="text-align:left">appWaitActivity</td><td style="text-align:left">等待启动的Activity名称</td><td style="text-align:left">SplashActivity</td></tr><tr><td style="text-align:left">deviceReadyTimeout</td><td style="text-align:left">设置超时时间</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left">androidCoverage</td><td style="text-align:left">用于执行测试的 instrumentation类</td><td style="text-align:left">com.my.Pkg/com.my.Pkg.instrumentation.MyInstrumentation</td></tr><tr><td style="text-align:left">enablePerformanceLogging</td><td style="text-align:left">(仅适用于 Chrome 和 webview) 开启 Chromedriver 的性能日志。(默认 false)</td><td style="text-align:left">true, false</td></tr><tr><td style="text-align:left">androidDeviceReadyTimeout</td><td style="text-align:left">等待设备在启动应用后超时时间，单位秒</td><td style="text-align:left">如 30</td></tr><tr><td style="text-align:left">androidDeviceSocket</td><td style="text-align:left">开发工具的 socket 名称。Chromedriver 把它作为开发者工具来进行连接。</td><td style="text-align:left">如 chrome_devtools_remote</td></tr><tr><td style="text-align:left">avd</td><td style="text-align:left">需要启动的 AVD (安卓模拟器设备) 名称。</td><td style="text-align:left">如 api19</td></tr><tr><td style="text-align:left">avdLaunchTimeout</td><td style="text-align:left">以毫秒为单位，等待 AVD 启动并连接到 ADB的超时时间。(默认值 120000)</td><td style="text-align:left">300000</td></tr><tr><td style="text-align:left">avdReadyTimeout</td><td style="text-align:left">以毫秒为单位，等待 AVD 完成启动动画的超时时间。(默认值 120000)</td><td style="text-align:left">300000</td></tr><tr><td style="text-align:left">avdArgs</td><td style="text-align:left">启动 AVD 时需要加入的额外的参数。</td><td style="text-align:left">如 -netfast</td></tr><tr><td style="text-align:left">useKeystore</td><td style="text-align:left">使用一个自定义的 keystore 来对 apk 进行重签名。默认值 false</td><td style="text-align:left">true or false</td></tr><tr><td style="text-align:left">keystorePath</td><td style="text-align:left">自定义keystore路径。默认~/.android/debug.keystore</td><td style="text-align:left">如 /path/to.keystore</td></tr><tr><td style="text-align:left">keystorePassword</td><td style="text-align:left">自定义 keystore 的密码。</td><td style="text-align:left">如 foo</td></tr><tr><td style="text-align:left">keyAlias</td><td style="text-align:left">key 的别名</td><td style="text-align:left">如 androiddebugkey</td></tr><tr><td style="text-align:left">keyPassword</td><td style="text-align:left">key 的密码</td><td style="text-align:left">如 foo</td></tr><tr><td style="text-align:left">chromedriverExecutable</td><td style="text-align:left">webdriver可执行文件的绝对路径 应该用它代替Appium 自带的 webdriver)</td><td style="text-align:left">/abs/path/to/webdriver</td></tr><tr><td style="text-align:left">autoWebviewTimeout</td><td style="text-align:left">毫秒为单位，Webview上下文激活的时间。默认2000</td><td style="text-align:left">如 4</td></tr><tr><td style="text-align:left">intentAction</td><td style="text-align:left">用于启动activity的intent action。(默认值 android.intent.action.MAIN)</td><td style="text-align:left">如 android.intent.action.MAIN, android.intent.action.VIEW</td></tr><tr><td style="text-align:left">intentCategory</td><td style="text-align:left">用于启动 activity 的 intent category。 (默认值 android.intent.category.LAUNCHER)</td><td style="text-align:left">如 android.intent.category.LAUNCHER, android.intent.category.APP_CONTACTS</td></tr><tr><td style="text-align:left">intentFlags</td><td style="text-align:left">用于启动activity的标识(flags) (默认值 0x10200000)</td><td style="text-align:left">如 0x10200000</td></tr><tr><td style="text-align:left">optionalIntentArguments</td><td style="text-align:left">用于启动 activity 的额外 intent 参数。请查看 Intent 参数</td><td style="text-align:left">如 –esn <extra_key>, –ez <extra_key> <extra_boolean_value></extra_boolean_value></extra_key></extra_key></td></tr><tr><td style="text-align:left">dontStopAppOnReset</td><td style="text-align:left">在使用 adb 启动应用时不要停止被测应用的进程。默认值： false</td><td style="text-align:left">true 或 false</td></tr><tr><td style="text-align:left">unicodeKeyboard</td><td style="text-align:left">使用 Unicode 输入法。默认值 false</td><td style="text-align:left">true 或 false</td></tr><tr><td style="text-align:left">resetKeyboard</td><td style="text-align:left">重置输入法到原有状态，默认值 false</td><td style="text-align:left">true 或 false</td></tr><tr><td style="text-align:left">noSign</td><td style="text-align:left">跳过检查和对应用进行 debug 签名的步骤。默认值 false</td><td style="text-align:left">true 或 false</td></tr><tr><td style="text-align:left">ignoreUnimportantViews</td><td style="text-align:left">调用 uiautomator 的函数这个关键字能加快测试执行的速度。默认值 false</td><td style="text-align:left">true 或 false</td></tr><tr><td style="text-align:left">disableAndroidWatchers</td><td style="text-align:left">关闭 android 监测应用无响ANR和崩溃crash的监视器默认值： false。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">chromeOptions</td><td style="text-align:left">允许传入 chrome driver 使用的 chromeOptions 参数。</td><td style="text-align:left">chromeOptions: {args: [‘–disable-popup-blocking‘]}</td></tr></tbody></table><h3 id="3-ios特有"><a href="#3-ios特有" class="headerlink" title="3.ios特有"></a>3.ios特有</h3><table><thead><tr><th style="text-align:left">关键字</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">calendarFormat</td><td style="text-align:left">(Sim-only) 为iOS的模拟器设置日历格式</td><td style="text-align:left">如 gregorian (公历)</td></tr><tr><td style="text-align:left">bundleId</td><td style="text-align:left">被测应用的bundle ID，真机上执行测试时，你可以不提供 app 关键字，但你必须提供udid</td><td style="text-align:left">如 io.appium.TestApp</td></tr><tr><td style="text-align:left">udid</td><td style="text-align:left">连接真机的唯一设备编号 ( Unique device identifier )</td><td style="text-align:left">如 1ae203187fc012g</td></tr><tr><td style="text-align:left">launchTimeout</td><td style="text-align:left">以毫秒为单位，在Appium运行失败之前设置一个等待 instruments的时间</td><td style="text-align:left">比如： 20000</td></tr><tr><td style="text-align:left">locationServicesEnabled</td><td style="text-align:left">(Sim-only) 强制打开或关闭定位服务。默认值是保持当前模拟器的设定</td><td style="text-align:left">true 或 false</td></tr><tr><td style="text-align:left">locationServicesAuthorized</td><td style="text-align:left">使用这个关键字时，你同时需要使用 bundleId 关键字来发送你的应用的 bundle ID。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">autoAcceptAlerts</td><td style="text-align:left">当 iOS 的个人信息访问警告 (如 位置、联系人、图片) 出现时，自动选择接受( Accept )。默认值 false。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">autoDismissAlerts</td><td style="text-align:left">当 iOS 的个人信息访问警告 (如 位置、联系人、图片) 出现时，自动选择不接受( Dismiss )。默认值 false。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">nativeInstrumentsLib</td><td style="text-align:left">使用原生 intruments 库 (即关闭 instruments-without-delay )</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">nativeWebTap</td><td style="text-align:left">(Sim-only) 在Safari中允许”真实的”，默认值： false。注意：取决于 viewport 大小/比例， 点击操作不一定能精确地点中对应的元素。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">safariInitialUrl</td><td style="text-align:left">(Sim-only) (&gt;= 8.1) Safari 的初始地址。默认值是一个本地的欢迎页面</td><td style="text-align:left">例如： <a href="https://www.github.com" target="_blank" rel="noopener">https://www.github.com</a></td></tr><tr><td style="text-align:left">safariAllowPopups</td><td style="text-align:left">(Sim-only) 允许 javascript 在 Safari 中创建新窗口。默认保持模拟器当前设置。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">safariIgnoreFraudWarning</td><td style="text-align:left">(Sim-only) 阻止 Safari 显示此网站可能存在风险的警告。默认保持浏览器当前设置。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">safariOpenLinksInBackground</td><td style="text-align:left">(Sim-only) Safari 是否允许链接在新窗口打开。默认保持浏览器当前设置。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">keepKeyChains</td><td style="text-align:left">(Sim-only) 当 Appium 会话开始/结束时是否保留存放密码存放记录 (keychains) (库(Library)/钥匙串(Keychains))</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">localizableStringsDir</td><td style="text-align:left">从哪里查找本地化字符串。默认值 en.lproj</td><td style="text-align:left">en.lproj</td></tr><tr><td style="text-align:left">processArguments</td><td style="text-align:left">通过 instruments 传递到 AUT 的参数</td><td style="text-align:left">如 -myflag</td></tr><tr><td style="text-align:left">interKeyDelay</td><td style="text-align:left">以毫秒为单位，按下每一个按键之间的延迟时间。</td><td style="text-align:left">如 100</td></tr><tr><td style="text-align:left">showIOSLog</td><td style="text-align:left">是否在 Appium 的日志中显示设备的日志。默认值 false</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">sendKeyStrategy</td><td style="text-align:left">输入文字到文字框的策略。模拟器默认值：oneByOne (一个接着一个) 。真实设备默认值：grouped (分组输入)</td><td style="text-align:left">oneByOne, grouped 或 setValue</td></tr><tr><td style="text-align:left">screenshotWaitTimeout</td><td style="text-align:left">以秒为单位，生成屏幕截图的最长等待时间。默认值： 10。</td><td style="text-align:left">如 5</td></tr><tr><td style="text-align:left">waitForAppScript</td><td style="text-align:left">用于判断 “应用是否被启动” 的 iOS 自动化脚本代码。默认情况下系统等待直到页面内容非空。结果必须是布尔类型。</td><td style="text-align:left">例如 true;, target.elements().length &gt; 0;, $.delay(5000); true;</td></tr></tbody></table><h3 id="4-小示例"><a href="#4-小示例" class="headerlink" title="4.小示例"></a>4.小示例</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from appium import webdriver</span><br><span class="line"></span><br><span class="line">desired_caps=&#123;&#125;</span><br><span class="line">desired_caps[&apos;platformName&apos;]=&apos;Android&apos;</span><br><span class="line">desired_caps[&apos;platformVersion&apos;]=&apos;5.1.1&apos;</span><br><span class="line">desired_caps[&apos;deviceName&apos;]=&apos;172.16.10.26:5555&apos;</span><br><span class="line">desired_caps[&apos;appPackage&apos;]=&apos;com.peng.cloudp.tv&apos;</span><br><span class="line">desired_caps[&apos;appActivity&apos;]=&apos;..activity.StartPageActivity&apos;</span><br><span class="line">desired_caps[&apos;unicodeKeyboard&apos;]=&apos;true&apos;</span><br><span class="line">desired_caps[&apos;resetKeyboard&apos;]=&apos;true&apos;</span><br><span class="line">driver = webdriver.Remote(&apos;http://127.0.0.1:4723/wd/hub&apos;, desired_caps)</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Appium Desired Capabilities 详解。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="appium" scheme="http://pythonfood.github.io/categories/appium/"/>
    
    
      <category term="appium" scheme="http://pythonfood.github.io/tags/appium/"/>
    
  </entry>
  
  <entry>
    <title>appium安装-windows</title>
    <link href="http://pythonfood.github.io/2018/02/01/appium%E5%AE%89%E8%A3%85-windows/"/>
    <id>http://pythonfood.github.io/2018/02/01/appium安装-windows/</id>
    <published>2018-02-01T01:00:00.000Z</published>
    <updated>2018-02-24T01:43:21.725Z</updated>
    
    <content type="html"><![CDATA[<p>appium环境搭建的简单步骤：安装jdk——安装android sdk——安装python——安装node.js——安装appium server——安装appium python客户端。<br><a id="more"></a></p><h3 id="1-安装jdk"><a href="#1-安装jdk" class="headerlink" title="1.安装jdk"></a>1.安装jdk</h3><blockquote><p>(1)下载jdk</p><blockquote><p>官网地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p></blockquote><p>(2)安装jdk</p><blockquote><p>根据提示安装，安装路径自定义：D:\Program Files\Java\jdk1.7.0_80</p></blockquote><p>(3)配置java环境变量</p><blockquote><p>1)系统变量→新建JAVA_HOME变量→变量值：D:\Program Files\Java\jdk1.7.0_80<br>2)系统变量→新建CLASSPATH变量→变量值：<code>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar</code><br>3)系统变量→编辑Path变量→增加：<code>;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</code>   </p></blockquote><p>(4)验证环境</p><blockquote><p>cmd输入<code>java -version</code>命令查看java版本。</p></blockquote></blockquote><h3 id="2-安装android-sdk"><a href="#2-安装android-sdk" class="headerlink" title="2.安装android sdk"></a>2.安装android sdk</h3><blockquote><p>(1)下载android sdk</p><blockquote><p>可以直接下载adt：<a href="http://tools.android-studio.org/index.php/adt-bundle-plugin" target="_blank" rel="noopener">http://tools.android-studio.org/index.php/adt-bundle-plugin</a></p></blockquote><p>(2)安装android sdk</p><blockquote><p>将adt压缩包解压到自定义路径：D:\Program Files\adt-bundle-windows-x86-20130917  </p></blockquote><p>(3)配置android环境变量</p><blockquote><p>1)系统变量→新建ANDROID_HOME变量→变量值：D:\Program Files\adt-bundle-windows-x86-20130917\sdk<br>2)系统变量→编辑Path变量→增加：<code>;%ANDROID_HOME%\tools;%ANDROID_HOME%\platform-tools;</code></p></blockquote><p>(4)验证环境</p><blockquote><p>cmd输入<code>adb</code>命令查看adb版本。</p></blockquote></blockquote><h3 id="3-安装Python"><a href="#3-安装Python" class="headerlink" title="3.安装Python"></a>3.<a href="https://pythonfood.github.io/2017/12/28/python安装-windows/#more">安装Python</a></h3><h3 id="4-安装node-js"><a href="#4-安装node-js" class="headerlink" title="4.安装node.js"></a>4.安装node.js</h3><blockquote><p>(1)下载node.js</p><blockquote><p>官网地址：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></p></blockquote><p>(2)安装node.js</p><blockquote><p>根据提示安装，安装路径自定义，自动添加PATH环境变量。</p></blockquote><p>(3)验证环境</p><blockquote><p>cmd输入<code>node -v</code>命令查看node版本。</p></blockquote></blockquote><h3 id="5-安装appium-server"><a href="#5-安装appium-server" class="headerlink" title="5.安装appium server"></a>5.安装appium server</h3><blockquote><p>方法1：npm安装</p><blockquote><p>(1)cmd输入<code>npm install -g appium</code>命令等待安装完成。（可能会被墙）<br>(2)cmd输入<code>npm install -g appium-doctor</code>命令安装Appium-doctor。<br>(3)cmd输入<code>appium-doctor</code>命令看到’All Checks were successful’则环境搭建成功。</p></blockquote><p>方法2：下载安装</p><blockquote><p>(1)下载地址：<a href="http://appium.io/" target="_blank" rel="noopener">http://appium.io/</a> 或 <a href="https://bitbucket.org/appium/appium.app/downloads/" target="_blank" rel="noopener">https://bitbucket.org/appium/appium.app/downloads/</a><br>(2)根据提示安装，安装路径自定义，自动添加PATH环境变量：<code>;D:\Program Files\Appium\node_modules\.bin;</code><br>(3)打开Appium图标验证安装成功。</p></blockquote><p>ps：appiun的server已经很久没有更新了，目前appium-desktop来继续他的使命。</p></blockquote><h3 id="6-安装appium-python客户端"><a href="#6-安装appium-python客户端" class="headerlink" title="6.安装appium python客户端"></a>6.安装appium python客户端</h3><blockquote><p>方法1：pip安装</p><blockquote><p>cmd输入<code>pip install Appium-Python-Client</code>命令等待安装完成。</p></blockquote><p>方法2：下载源码安装 </p><blockquote><p>(1)下载地址：<a href="https://pypi.python.org/pypi/Appium-Python-Client" target="_blank" rel="noopener">https://pypi.python.org/pypi/Appium-Python-Client</a><br>(2)解压后，cmd输入<code>cd Appium-Python-Client-X.X</code>命令进入目录。<br>(3)cmd输入<code>python setup.py install</code>命令进行安装。</p></blockquote></blockquote><h3 id="7-验证环境-小示例"><a href="#7-验证环境-小示例" class="headerlink" title="7.验证环境(小示例)"></a>7.验证环境(小示例)</h3><blockquote><p>(1)启动服务</p><blockquote><p>1)连接手机。<br>2)cmd输入<code>appium</code>命令启动服务。<br>3)打印日志如下图，则服务启动成功：</p><blockquote><p><img src="/2018/02/01/appium安装-windows/启动appium服务.png" alt="启动appium服务"></p></blockquote></blockquote><p>(2)代码示例</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from appium import webdriver</span><br><span class="line">from time import sleep</span><br><span class="line">import unittest</span><br><span class="line"></span><br><span class="line">class CalTest(unittest.TestCase):</span><br><span class="line">def setUp(self):</span><br><span class="line">desired_caps=&#123;&#125;</span><br><span class="line">desired_caps[&apos;platformName&apos;]=&apos;Android&apos;</span><br><span class="line">desired_caps[&apos;platformVersion&apos;]=&apos;5.0.2&apos;</span><br><span class="line">desired_caps[&apos;deviceName&apos;]=&apos;1ae7be68&apos;</span><br><span class="line">desired_caps[&apos;appPackage&apos;]=&apos;com.android.calculator2&apos;</span><br><span class="line">desired_caps[&apos;appActivity&apos;]=&apos;.Calculator&apos;</span><br><span class="line">self.driver=webdriver.Remote(&apos;http://localhost:4723/wd/hub&apos;,desired_caps)</span><br><span class="line"></span><br><span class="line">def tearDown(self):</span><br><span class="line">self.driver.quit()</span><br><span class="line"></span><br><span class="line">def test_add(self):</span><br><span class="line">driver.find_element_by_name(&quot;8&quot;).click()</span><br><span class="line">driver.find_element_by_id(&apos;digit7&apos;).click()</span><br><span class="line">driver.find_element_by_id(&apos;plus&apos;).click()</span><br><span class="line">driver.find_element_by_id(&apos;digit3&apos;).click()</span><br><span class="line">driver.find_element_by_id(&apos;equal&apos;).click()</span><br><span class="line">sleep(3)</span><br><span class="line">driver.find_element_by_id(&apos;clear&apos;).click()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">       suite = unittest.TestLoader().loadTestsFromTestCase(CalTest)</span><br><span class="line">       unittest.TextTestRunner(verbosity=2).run(suite)</span><br></pre></td></tr></table></figure></blockquote><p>(3)执行脚本    </p></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;appium环境搭建的简单步骤：安装jdk——安装android sdk——安装python——安装node.js——安装appium server——安装appium python客户端。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="appium" scheme="http://pythonfood.github.io/categories/appium/"/>
    
    
      <category term="appium" scheme="http://pythonfood.github.io/tags/appium/"/>
    
  </entry>
  
  <entry>
    <title>selenium常用API</title>
    <link href="http://pythonfood.github.io/2018/01/01/selenium%E5%B8%B8%E7%94%A8API/"/>
    <id>http://pythonfood.github.io/2018/01/01/selenium常用API/</id>
    <published>2018-01-01T02:00:00.000Z</published>
    <updated>2018-02-26T07:13:34.628Z</updated>
    
    <content type="html"><![CDATA[<p>selenium常用API笔记。<br><a id="more"></a></p><h3 id="1-浏览器操作"><a href="#1-浏览器操作" class="headerlink" title="1.浏览器操作"></a>1.浏览器操作</h3><p>(1)浏览器最大化</p><blockquote><p><code>driver.maximize_window()</code> #浏览器最大化</p></blockquote><p>(2)设置浏览器宽、高</p><blockquote><p><code>driver.set_window_size(480, 800)</code> #设置浏览器宽、高</p></blockquote><p>(3)浏览器后退</p><blockquote><p><code>driver.back()</code> #浏览器后退</p></blockquote><p>(4)浏览器前进</p><blockquote><p><code>driver.forward()</code> #浏览器前进</p></blockquote><p>(5)刷新当前页面</p><blockquote><p><code>driver.refresh()</code> #刷新当前页面</p></blockquote><p>(6)退出浏览器</p><blockquote><p><code>driver.quit()</code> #退出浏览器</p></blockquote><p>(7)关闭单个窗口</p><blockquote><p><code>driver.close()</code> #关闭单个窗口</p></blockquote><h3 id="2-元素定位"><a href="#2-元素定位" class="headerlink" title="2.元素定位"></a>2.元素定位</h3><p>(1)id定位 </p><blockquote><p><code>find_element_by_id(&quot;kw&quot;)</code> #一般唯一</p></blockquote><p>(2)name定位 </p><blockquote><p><code>find_element_by_name(&quot;wd&quot;)</code> #一般唯一</p></blockquote><p>(3)class_name定位 </p><blockquote><p><code>find_element_by_class_name(&quot;bg s_btn&quot;)</code> #不唯一</p></blockquote><p>(4)tag_name定位</p><blockquote><p><code>find_element_by_tag_name(&quot;input&quot;)</code> #不唯一</p></blockquote><p>(5)link_text定位</p><blockquote><p><code>find_element_by_link_text(u&quot;这是一条新闻&quot;)</code> #定位文本链接</p></blockquote><p>(6)partial_link_text定位</p><blockquote><p><code>find_element_by_partial_link_text(&quot;这是一条新&quot;)</code> #定位可以唯一标识这个文本链接的一部分</p></blockquote><p>(7)xpath定位</p><blockquote><p>1)绝对路径定位</p><blockquote><p><code>find_element_by_xpath(&quot;/html/body/div[2]/form/span/input&quot;)</code> #从根节点开始绝对路径</p></blockquote><p>2)相对路径定位</p><blockquote><p><code>find_element_by_xpath(&quot;//input[@id=’input’]&quot;)</code> #通过自身的id 属性定位<br><code>find_element_by_xpath(&quot;//span[@id=’input-container’]/input&quot;)</code> #通过上一级目录的id 属性定位<br><code>find_element_by_xpath(&quot;//div[@name=’q’]/form/span[2]/input&quot;)</code> #通过上三级目录的name 属性定位<br><code>find_element_by_xpath(&quot;//div[@id=’hd’ or @name=’q’]/form/span/input&quot;)</code> #通过布尔逻辑运算 属性定位</p></blockquote></blockquote><p>(8)css_selector定位</p><blockquote><p><code>find_element_by_css_selector(&quot;#su&quot;)</code> #通过id属性定位<br><code>find_element_by_css_selector(&quot;.s_ipt&quot;)</code> #通过class属性定位<br><code>find_element_by_css_selector(&quot;input&quot;)</code> #通过标签名定位<br><code>find_element_by_css_selector(&quot;span&gt;input&quot;)</code> #通过父子关系定位<br><code>find_element_by_css_selector(&quot;input[maxlength=&#39;100&#39;]&quot;)</code> #通过属性定位<br><code>find_element_by_css_selector(&quot;span.bgs_ipt_wr&gt;input.s_ipt&quot;)</code> #组合定位</p><blockquote><p><img src="/2018/01/01/selenium常用API/css_selector定位.png" alt="css_selector定位"></p></blockquote></blockquote><p>(9)用By定位<br>需要使用定位方法时，By可以设置定位策略。使用前导入By模块<code>from selenium.webdriver.common.by import By</code>。</p><blockquote><p><code>find_element(By.ID,&quot;kw&quot;)</code><br><code>find_element(By.NAME,&quot;wd&quot;)</code><br><code>find_element(By.CLASS_NAME,&quot;s_ipt&quot;)</code><br><code>find_element(By.TAG_NAME,&quot;input&quot;)</code><br><code>find_element(By.LINK_TEXT,u&quot;新闻&quot;)</code><br><code>find_element(By.PARTIAL_LINK_TEXT,u&quot;新&quot;)</code><br><code>find_element(By.XPATH,&quot;//*[@class=&#39;bgs_btn&#39;]&quot;)</code><br><code>find_element(By.CSS_SELECTOR,&quot;span.bgs_btn_wr&gt;input#su&quot;)</code></p></blockquote><h3 id="3-元素操作"><a href="#3-元素操作" class="headerlink" title="3.元素操作"></a>3.元素操作</h3><p>(1)clear()  #清除输入框内容</p><blockquote><p><code>driver.find_element_by_id(&quot;user_name&quot;).clear()</code></p></blockquote><p>(2)send_keys(“xx”) #输入框里输入xx内容</p><blockquote><p><code>driver.find_element_by_id(&quot;user_name&quot;).send_keys(&quot;username&quot;)</code></p></blockquote><p>(3)click() #单击一个按钮、连接等</p><blockquote><p><code>driver.find_element_by_id(&quot;dl_an_submit&quot;).click()</code></p></blockquote><p>(4)submit() #提交表单</p><blockquote><p><code>driver.find_element_by_id(&quot;dl_an_submit&quot;).submit()</code></p></blockquote><p>(5)size #返回元素的尺寸</p><blockquote><p><code>size=driver.find_element_by_id(&quot;kw&quot;).size</code> #返回百度输入框的宽高</p></blockquote><p>(6)text #获取元素的文本</p><blockquote><p><code>text=driver.find_element_by_id(&quot;cp&quot;).text</code> #返回百度页面底部备案信息</p></blockquote><p>(7)get_attribute(name) #获得属性值</p><blockquote><p><code>attribute=driver.find_element_by_id(&quot;kw&quot;).get_attribute(&#39;type&#39;)</code> #返回元素的属性值，可以是id、name、type 或元素拥有的其它任意属性</p></blockquote><p>(8)is_displayed() #检查该元素是否用户可见    </p><blockquote><p><code>result=driver.find_element_by_id(&quot;kw&quot;).is_displayed()</code> #返回元素的结果是否可见，返回结果为True 或False</p></blockquote><h3 id="4-鼠标事件"><a href="#4-鼠标事件" class="headerlink" title="4.鼠标事件"></a>4.鼠标事件</h3><p>ActionChains用于生成用户的行为，所有的行为都存储在actionchains对象中。通过perform()执行存储的行为。<br>使用前导入ActionChains模块<code>from selenium.webdriver.common.action_chains import ActionChains</code>。</p><p>(1)perform() #顺序执行所有ActionChains中存储的行为</p><blockquote><p><code>ActionChains(driver).context_click(操作对象).perform()</code> #ActionChains方法的书写格式</p></blockquote><p>(2)context_click() #右击 </p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">right =driver.find_element_by_xpath(&quot;xx&quot;) #定位到要右击的元素</span><br><span class="line">ActionChains(driver).context_click(right).perform() #对定位到的元素执行鼠标右键操作</span><br></pre></td></tr></table></figure></blockquote><p>(3)double_click() #双击</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double =driver.find_element_by_xpath(&quot;xxx&quot;) #定位到要双击的元素</span><br><span class="line">ActionChains(driver).double_click(double).perform() #对定位到的元素执行鼠标双击操作</span><br></pre></td></tr></table></figure></blockquote><p>(4)drag_and_drop() #鼠标拖放</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element = driver.find_element_by_name(&quot;xxx&quot;) #定位元素的原位置</span><br><span class="line">target = driver.find_element_by_name(&quot;xxx&quot;) #定位元素要移动到的目标位置</span><br><span class="line">ActionChains(driver).drag_and_drop(element, target).perform() #执行元素的移动操作</span><br></pre></td></tr></table></figure></blockquote><p>(5)move_to_element() #鼠标悬停</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">above = driver.find_element_by_xpath(&quot;xxx&quot;) #定位到鼠标移动到上面的元素</span><br><span class="line">ActionChains(driver).move_to_element(above).perform() #对定位到的元素执行鼠标移动到上面的操作</span><br></pre></td></tr></table></figure></blockquote><p>(6)click_and_hold() #按下鼠标左键    </p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">left=driver.find_element_by_xpath(&quot;xxx&quot;) #定位到鼠标按下左键的元素</span><br><span class="line">ActionChains(driver).click_and_hold(left).perform() #对定位到的元素执行鼠标左键按下的操作</span><br></pre></td></tr></table></figure></blockquote><h3 id="5-键盘事件"><a href="#5-键盘事件" class="headerlink" title="5.键盘事件"></a>5.键盘事件</h3><p>使用前导入keys模块<code>from selenium.webdriver.common.keys import Keys</code>。</p><p>(1)send_keys(Keys.BACK_SPACE) #删除键（BackSpace）</p><p>(2)send_keys(Keys.SPACE) #空格键(Space)</p><p>(3)send_keys(Keys.TAB) #制表键(Tab)</p><p>(4)send_keys(Keys.ESCAPE) #回退键（Esc）</p><p>(5)send_keys(Keys.ENTER) #回车键（Enter）</p><p>(6)send_keys(Keys.F5) #刷新建（F5）</p><p>(7)send_keys(Keys.CONTROL,’a’) #全选（Ctrl+A）</p><p>(8)send_keys(Keys.CONTROL,’c’) #复制（Ctrl+C）</p><p>(9)send_keys(Keys.CONTROL,’x’) #剪切（Ctrl+X）</p><p>(10)send_keys(Keys.CONTROL,’v’) #粘贴（Ctrl+V）</p><h3 id="6-获取验证信息"><a href="#6-获取验证信息" class="headerlink" title="6.获取验证信息"></a>6.获取验证信息</h3><p>(1)获得当前页面title，判断页面跳转是否符合预期</p><blockquote><p><code>title = driver.title</code></p></blockquote><p>(2)获得当前URL，一般用来测试重定向</p><blockquote><p><code>url = driver.current_url</code></p></blockquote><h3 id="7-设置等待时间"><a href="#7-设置等待时间" class="headerlink" title="7.设置等待时间"></a>7.设置等待时间</h3><p>(1)sleep() #休眠等待<br>sleep()方法以秒为单位，假如休眠时间小于 1 秒，可以用小数表示。<br>使用前导入sleep模块<code>from time import sleep</code>。</p><blockquote><p><code>sleep(0.5)</code></p></blockquote><p>(2)implicitly_wait() #隐式等待<br>隐式等待是通过一定的时长等待页面所元素加载完成。<br>如果超出了设置的时长元素还没有被加载测抛NoSuchElementException异常。<br>implicitly_wait()默认参数的单位为秒。</p><blockquote><p><code>driver.implicitly_wait(10)</code> #设置智能等待10秒</p></blockquote><p>(3)WebDriverWait() #显式等待<br>显式等待是等待某个条件成立时继续执行，否则在达到最大时长则抛TimeoutException异常。</p><p>WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None)，参数解释如下：</p><ul><li>driver - WebDriver 的驱动程序(Ie, Firefox, Chrome 或远程)</li><li>timeout - 最长超时时间，默认以秒为单位</li><li>poll_frequency - 休眠时间的间隔（步长）时间，默认为 0.5 秒</li><li>ignored_exceptions - 超时后的异常信息，默认情况下抛 NoSuchElementException 异常。</li></ul><p>使用前导入WebDriverWait模块<code>from selenium.webdriver.support.ui import WebDriverWait</code>。</p><p>WebDriverWai()一般由 unit()或 until_not()方法配合使用，下面是 unit()和 until_not()方法的说明：<br>1)until(method, message=’’)调用该方法提供的驱动程序作为一个参数，直到返回值不为False。</p><blockquote><p><code>element = WebDriverWait(driver, 10).until(lambda x: x.find_element_by_id(“someId”))</code></p></blockquote><p>2)until_not(method, message=’’)调用该方法提供的驱动程序作为一个参数，直到返回值为 False。</p><blockquote><p><code>is_disappeared = WebDriverWait(driver, 30, 1, (ElementNotVisibleException)).until_not(lambda x: x.find_element_by_id(“someId”).is_displayed())</code>    </p></blockquote><h3 id="8-定位一组对象"><a href="#8-定位一组对象" class="headerlink" title="8.定位一组对象"></a>8.定位一组对象</h3><p>(1)find_elements 用于获取一组元素:</p><blockquote><p><code>find_elements_by_id(‘xx’)</code><br><code>find_elements_by_name(‘xx’)</code><br><code>find_elements_by_class_name(‘xx’)</code><br><code>find_elements_by_tag_name(‘xx’)</code><br><code>find_elements_by_link_text(‘xx’)</code><br><code>find_elements_by_partial_link_text(‘xx’)</code><br><code>find_elements_by_xpath(‘xx’)</code><br><code>find_elements_by_css_selector(‘xx’)</code></p></blockquote><p>(2)可以使用for… in …对这一组元素进行遍历:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for checkbox in checkboxes:</span><br><span class="line">checkbox.click()</span><br></pre></td></tr></table></figure></blockquote><p>(3)也可以使用pop（）方法获得这一组元素中的第几个，然后再对该元素进行操作：</p><blockquote><p><code>find_elements_by_id(‘xx’).pop().click()</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pop（）或pop（-1）#默认获取一组元素中的最后一个</span><br><span class="line">pop(0)   #默认获取一组元素的第一个元素</span><br><span class="line">pop(1)   #默认获取一组元素的第二个元素</span><br><span class="line">...... #以此类推</span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="9-层级定位"><a href="#9-层级定位" class="headerlink" title="9.层级定位"></a>9.层级定位</h3><p>经常会有这样的需求：页面上有很多个属性基本相同的元素 ，现在需要具体定位到其中的一个。由于属性基本相当，所以在定位的时候会有些麻烦，这时候就需要用到层级定位。先定位父元素，然后再通过父元素定位子孙元素：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#点击 Link1 链接（弹出下拉列表）</span><br><span class="line">driver.find_element_by_link_text(&apos;Link1&apos;).click() </span><br><span class="line">#在父亲元件下找到 link 为 Action 的子元素</span><br><span class="line">menu=driver.find_element_by_id(&apos;dropdown1&apos;).find_element_by_link_text(&apos;Another action&apos;)</span><br></pre></td></tr></table></figure></blockquote><h3 id="10-表单切换"><a href="#10-表单切换" class="headerlink" title="10.表单切换"></a>10.表单切换</h3><p>在web应用中经常会出现frame/iframe 表单内嵌套的应用，WebDriver只能在一个页面上进行元素识别定位，对于frame/iframe表单内嵌页面上的元素无法直接定位。这时需要通过switch_to.frame()方法将当前定位的主体切换为frame/iframe表单的内嵌页面中。</p><p>(1)switch_to_frame()默认可以直接取表单的id或name属性进行切换：</p><blockquote><p><code>driver.switch_to_frame(&quot;if&quot;)</code> #id = “if”<br><code>driver.switch_to_frame(&quot;nf&quot;)</code> #name = “nf” </p></blockquote><p>(2)如果 iframe 没有可用的 id 和 name 可以通过下面的方式进行定位：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#先通过xpth定位到iframe </span><br><span class="line">xf = driver.find_element_by_xpath(&apos;//*[@class=&quot;if&quot;]&apos;)</span><br><span class="line">#再将定位对象传给switch_to_frame()方法 </span><br><span class="line">driver.switch_to_frame(xf)</span><br></pre></td></tr></table></figure></blockquote><p>(3)如果完成了在当前表单上的操作，跳出当前表单：</p><blockquote><p><code>driver.switch_to.parent_content()</code> #返回到父级表单<br><code>driver.switch_to.default_conent()</code> #返回到主文档页面</p></blockquote><h3 id="11-多窗口切换"><a href="#11-多窗口切换" class="headerlink" title="11.多窗口切换"></a>11.多窗口切换</h3><ul><li><code>current_window_handle</code> #获得当前窗口句柄。</li><li><code>window_handles</code> #返回所有窗口的句柄到当前对话。</li><li><code>switch_to.window</code>(窗口句柄) #切换到对应的窗口。</li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nowhandle=driver.current_window_handle #获得当前窗口句柄。</span><br><span class="line">driver.find_element_by_link_text(u&quot;发表话题&quot;).click()</span><br><span class="line">time.sleep(3)</span><br><span class="line">allhandles=driver.window_handles #返回所有窗口的句柄到当前对话。</span><br><span class="line">for handle in allhandles:</span><br><span class="line">if(handle!=nowhandle):</span><br><span class="line">driver.switch_to.window(handle) #切换到对应的窗口。</span><br></pre></td></tr></table></figure></blockquote><h3 id="12-警告框处理"><a href="#12-警告框处理" class="headerlink" title="12.警告框处理"></a>12.警告框处理</h3><p>处理javascript所生成的alert、confirm、prompt，可以使用switch_to_alert()方法定位到alert/confirm/prompt，然后使用text/accept/dismiss/send_keys等方法进行操作：</p><ul><li><code>text</code> #返回 alert/confirm/prompt 中的文字信息。</li><li><code>accept</code> #点击确认按钮。</li><li><code>dismiss</code> #点击取消按钮，如果有的话。</li><li><code>send_keys</code> #输入值，这个 alert\confirm 没有对话框就不能用了，不然会报错。</li></ul><blockquote><p><code>driver.switch_to_alert().accept()</code></p></blockquote><h3 id="13-上传文件"><a href="#13-上传文件" class="headerlink" title="13.上传文件"></a>13.上传文件</h3><p>(1)查找到input标签，通过send_keys)传入本地文件路径从而模拟上传功能:</p><blockquote><p><code>driver.find_element_by_name(&quot;file&quot;).send_keys(&#39;D:\\upload_file.txt&#39;)</code> #查找到input标签，然后send进去</p></blockquote><p>(2)使用AutoIt识别flash控件和windows控件实现自动上传文件</p><blockquote><p>1)下载安装，官方网站：<a href="https://www.autoitscript.com/site/" target="_blank" rel="noopener">https://www.autoitscript.com/site/</a><br>2)配置编辑AutoIt。<br>3)<code>os.system(&quot;D:\\upfile.exe&quot;)</code> #通过系统调用upfile.exe上传程序 </p></blockquote><h3 id="14-下载文件"><a href="#14-下载文件" class="headerlink" title="14.下载文件"></a>14.下载文件</h3><p>(1)以FireFox为例，为了让FireFox浏览器能实现文件的载，我们需要通过FirefoxProfile()对其参数做一个设置:</p><ul><li><code>browser.download.folderList</code> #设置成0代表下载到浏览器默认下载路径；设置成2则可以保存到指定目录。</li><li><code>browser.download.manager.showWhenStarting</code> #是否显示开始，Ture为显示，Flase为不显示。</li><li><code>browser.download.dir</code> #用于指定你所下载文件的目录。os.getcwd()该函数不需要传递参数，用于返回当前的目录。</li><li><code>browser.helperApps.neverAsk.saveToDisk</code> #指定要下载页面的Content-type值，“application/octet-stream”为文件的类型。HTTP Content-type常用对照表：<a href="http://tool.oschina.net/commons" target="_blank" rel="noopener">http://tool.oschina.net/commons</a></li></ul><p>(2)这些参数的设置可以通过在Firefox浏览器地址栏输入：about:config 进行设置，如图： </p><p><img src="/2018/01/01/selenium常用API/firefox参数设置.png" alt="firefox参数设置"></p><p>(3)浏览器设置代码示例：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8 </span><br><span class="line">from selenium import webdriver </span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">fp = webdriver.FirefoxProfile()</span><br><span class="line">fp.set_preference(&quot;browser.download.folderList&quot;,2) </span><br><span class="line">fp.set_preference(&quot;browser.download.manager.showWhenStarting&quot;,False) </span><br><span class="line">fp.set_preference(&quot;browser.download.dir&quot;, os.getcwd()) </span><br><span class="line">fp.set_preference(&quot;browser.helperApps.neverAsk.saveToDisk&quot;, &quot;application/octet-stream&quot;)</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox(firefox_profile=fp) </span><br><span class="line">driver.get(&quot;http://pypi.Python.org/pypi/selenium&quot;) </span><br><span class="line">driver.find_element_by_partial_link_text(&quot;selenium-2&quot;).click()</span><br></pre></td></tr></table></figure></blockquote><h3 id="15-操作Cookie"><a href="#15-操作Cookie" class="headerlink" title="15.操作Cookie"></a>15.操作Cookie</h3><p>webdriver操作cookie的方法有：</p><ul><li><code>get_cookies()</code> #获得所有cookie信息  </li><li><code>get_cookie(name)</code> #返回有特定name值有cookie信息  </li><li><code>add_cookie(cookie_dict)</code> #添加cookie，必须有name和value值  </li><li><code>delete_cookie(name)</code> #删除特定(部分)的cookie信息  </li><li><code>delete_all_cookies()</code> #删除所有cookie信息</li></ul><p>(1)先通过get_cookies()来获取当前浏览器的cookie信息。<br>通过打印结果可以看出，cookie 是以字典的形式进行存放的，知道了cookie的存放形式，那么我们就可以按照这种形式向浏览器中写入cookie信息。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver.get(&quot;http://www.youdao.com&quot;)</span><br><span class="line">cookie= driver.get_cookies() # 获得cookie信息 </span><br><span class="line">print cookie #将获得cookie的信息打印</span><br></pre></td></tr></table></figure><blockquote><p><img src="/2018/01/01/selenium常用API/cookie打印信息.png" alt="cookie打印信息"></p></blockquote></blockquote><p>(2)再进行cookie的添加、删除等操作。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver.get(&quot;http://www.youdao.com&quot;)</span><br><span class="line">driver.add_cookie(&#123;&apos;name&apos;:&apos;key-aaaaaaa&apos;, &apos;value&apos;:&apos;value-bbbbbb&apos;&#125;) #向cookie的name 和value添加会话信息。</span><br></pre></td></tr></table></figure></blockquote><h3 id="16-调用javascript"><a href="#16-调用javascript" class="headerlink" title="16.调用javascript"></a>16.调用javascript</h3><p>当webdriver遇到没法完成的操作时，可以考虑调用JavaScript来完成。<br>webdriver提供<code>execute_script()</code>方法用来调用js代码：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#修改元素的属性</span><br><span class="line">js = &apos;document.querySelectorAll(&quot;select&quot;)[0].style.display=&quot;block&quot;;&apos;</span><br><span class="line">driver.execute_script(js)</span><br></pre></td></tr></table></figure></blockquote><h3 id="17-控制浏览器滚动条"><a href="#17-控制浏览器滚动条" class="headerlink" title="17.控制浏览器滚动条"></a>17.控制浏览器滚动条</h3><p>(1)上下滚动：<br><code>document.body.scrollTop</code> #网页被卷去的高。置顶设置：scrollTop为0；置底设置：scrollTop大于窗口的高度像素。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#将页面滚动条拖到底部</span><br><span class="line">js=&quot;var q=document.documentElement.scrollTop=10000&quot;</span><br><span class="line">driver.execute_script(js)</span><br><span class="line">time.sleep(3)</span><br><span class="line">#将滚动条移动到页面的顶部</span><br><span class="line">js1=&quot;var q=document.documentElement.scrollTop=0&quot;</span><br><span class="line">driver.execute_script(js1)</span><br><span class="line">time.sleep(3)</span><br></pre></td></tr></table></figure></blockquote><p>(2)左右滚动：<br><code>window.scrollTo(左边距,上边距)</code> #指定左右滚动的坐标即可</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">js=&quot; window.scrollTo(200,1000);&quot; </span><br><span class="line">driver.execute_script(js)</span><br></pre></td></tr></table></figure></blockquote><h3 id="18-窗口截图"><a href="#18-窗口截图" class="headerlink" title="18.窗口截图"></a>18.窗口截图</h3><p>Webdriver提供了截图函数<code>get_screenshot_as_file()</code>来截取当前窗口:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">driver.find_element_by_id(&apos;kw_error&apos;).send_key(&apos;selenium&apos;) </span><br><span class="line">driver.find_element_by_id(&apos;su&apos;).click() </span><br><span class="line">except: </span><br><span class="line">driver.get_screenshot_as_file(&quot;D:\\baidu_error.jpg&quot;) #截图，保存到指定路径</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure></blockquote><h3 id="19-获取对象的属性值"><a href="#19-获取对象的属性值" class="headerlink" title="19.获取对象的属性值"></a>19.获取对象的属性值</h3><p>有时候我们定位页面上的元素发现常用的id、name等属性是相同的。这个时候我们只能通过常规的定位方法定位出一组元素，然后观察通过元素的属性可以定位出单个元素。<br>可使用.get_attribute()方法:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 选择页面上所有的tag name为input的元素</span><br><span class="line">inputs = driver.find_elements_by_tag_name(&apos;input&apos;)</span><br><span class="line">#然后循环遍历出属性data-node值为594434493的元素，单击勾选</span><br><span class="line">for input in inputs:</span><br><span class="line">if input.get_attribute(&apos;data-node&apos;) == &apos;594434493&apos;:</span><br><span class="line">input.click()</span><br></pre></td></tr></table></figure></blockquote><h3 id="20-验证码处理"><a href="#20-验证码处理" class="headerlink" title="20.验证码处理"></a>20.验证码处理</h3><p>(1)去掉验证码。<br>(2)设置万能码。<br>(3)验证码识别技术<br>例如可以通过Python-tesseract来识别图片验证码,能够读取任何常规的图片文件(JPG,GIF,PNG,TIFF 等)。不过，目前市面上的验证码识别技术识别率都不是100% 。<br>(4)记录cookie<br>通过向浏览器中添加cookie可以绕过登录的验证码,这种方式最大的问题是如何从浏览器的Cookie中找到用户名和密码对应的key值，并传传输入对应的登录信息。如果网站登录时根本不将用户名和密码写Cookie，这会存在一定的安全风险。那么这种方式就不起作用了。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#访问xx网站 </span><br><span class="line">driver.get(&quot;http://www.xx.cn&quot;)</span><br><span class="line">#将用户名密码写入浏览器cookie </span><br><span class="line">driver.add_cookie(&#123;&apos;name&apos;:&apos;Login_UserNumber&apos;, &apos;value&apos;:&apos;username&apos;&#125;) </span><br><span class="line">driver.add_cookie(&#123;&apos;name&apos;:&apos;Login_Passwd&apos;, &apos;value&apos;:&apos;password&apos;&#125;)</span><br><span class="line">#再次访问xx网站，将会自动登录 </span><br><span class="line">driver.get(&quot;http://www.xx.cn/&quot;) </span><br><span class="line">time.sleep(3)</span><br></pre></td></tr></table></figure></blockquote><p>(5)内部提供一个接口获得验证码，然后通过js代码把获取的验证码填写进去：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#自动获取验证码并填写</span><br><span class="line">js=&quot;$.getJSON(&apos;http://xxx.xxx.com/util/getCode.jsonp?callback=?&apos;,function(data)&#123;$(&apos;.imgcode&apos;).val(data.code);&#125;)&quot;</span><br><span class="line">driver.execute_script(js)</span><br></pre></td></tr></table></figure></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;selenium常用API笔记。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="selenium" scheme="http://pythonfood.github.io/categories/selenium/"/>
    
    
      <category term="selenium" scheme="http://pythonfood.github.io/tags/selenium/"/>
    
  </entry>
  
  <entry>
    <title>selenium安装-windows</title>
    <link href="http://pythonfood.github.io/2018/01/01/selenium%E5%AE%89%E8%A3%85-windows/"/>
    <id>http://pythonfood.github.io/2018/01/01/selenium安装-windows/</id>
    <published>2018-01-01T01:00:00.000Z</published>
    <updated>2018-02-23T10:18:00.724Z</updated>
    
    <content type="html"><![CDATA[<p>selenium环境搭建的简单步骤：安装Python——安装pip——安装selenium——安装浏览器驱动。<br><a id="more"></a></p><h3 id="1-安装Python"><a href="#1-安装Python" class="headerlink" title="1.安装Python"></a>1.<a href="https://pythonfood.github.io/2017/12/28/python安装-windows/#more">安装Python</a></h3><h3 id="2-安装pip"><a href="#2-安装pip" class="headerlink" title="2.安装pip"></a>2.安装pip</h3><blockquote><p>方法1：自动安装</p><blockquote><p>在第1步安装python时，已经安装了pip。</p></blockquote><p>方法2：手动安装</p><blockquote><p>(1)下载pip压缩包：<a href="https://pypi.python.org/pypi/pip#downloads" target="_blank" rel="noopener">https://pypi.python.org/pypi/pip#downloads</a><br>(2)解压后cmd进入解压目录，执行<code>python setup.py install</code>进行安装。</p></blockquote></blockquote><h3 id="3-安装selenium"><a href="#3-安装selenium" class="headerlink" title="3.安装selenium"></a>3.安装selenium</h3><blockquote><p>方法1：命令行安装</p><blockquote><p>进入cmd输入命令’pip install selenium’。</p></blockquote><p>方法2：下载whl包安装</p><blockquote><p>(1)下载selenium安装包：<a href="https://pypi.python.org/pypi/selenium" target="_blank" rel="noopener">https://pypi.python.org/pypi/selenium</a> 或 <a href="https://www.seleniumhq.org/download/" target="_blank" rel="noopener">https://www.seleniumhq.org/download/</a><br>(2)下载完成后，进入cmd输入命令<code>pip install</code>，再直接将文件拖入cmd窗口，回车即可安装。</p></blockquote></blockquote><h3 id="4-安装浏览器驱动"><a href="#4-安装浏览器驱动" class="headerlink" title="4.安装浏览器驱动"></a>4.安装浏览器驱动</h3><blockquote><p>(1)下载浏览器驱动</p><blockquote><p>不同浏览器需下载不同驱动，不同版本浏览器对应不同版本驱动。这里只给出chrome和firefox的驱动下载地址：<br>1)chrome：<a href="http://npm.taobao.org/mirrors/chromedriver" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver</a> 或 <a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/index.html</a><br>2)firefox：<a href="https://github.com/mozilla/geckodriver/releases" target="_blank" rel="noopener">https://github.com/mozilla/geckodriver/releases</a></p></blockquote><p>(2)安装浏览器驱动</p><blockquote><p>下载完驱动后解压，将驱动放置在可执行路径下。这里给出三种路径：<br>1)将浏览器驱动放到python的Path路径下。<br>2)将浏览器驱动放到浏览器的Path路径下。<br>3)自定义路径，新建driver文件夹，将驱动放在driver文件下，最后将该路径添加到环境变量中。</p></blockquote></blockquote><h3 id="5-验证环境（小示例）"><a href="#5-验证环境（小示例）" class="headerlink" title="5.验证环境（小示例）"></a>5.验证环境（小示例）</h3><blockquote><p>(1)创建python文件selenium_python.py，内容如下：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(&apos;http://www.baidu.com/&apos;)</span><br></pre></td></tr></table></figure></blockquote><p>(2)cmd执行命令<code>python selenium_python.py</code>。<br>(3)脚本自动执行，结果如下：</p><blockquote><p><img src="/2018/01/01/selenium安装-windows/脚本执行结果.png" alt="脚本执行结果"></p></blockquote></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;selenium环境搭建的简单步骤：安装Python——安装pip——安装selenium——安装浏览器驱动。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="selenium" scheme="http://pythonfood.github.io/categories/selenium/"/>
    
    
      <category term="selenium" scheme="http://pythonfood.github.io/tags/selenium/"/>
    
  </entry>
  
  <entry>
    <title>python文件操作</title>
    <link href="http://pythonfood.github.io/2017/12/28/python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>http://pythonfood.github.io/2017/12/28/python文件操作/</id>
    <published>2017-12-28T11:30:00.000Z</published>
    <updated>2018-03-19T01:39:27.168Z</updated>
    
    <content type="html"><![CDATA[<p>人生苦短，我用python。<br><a id="more"></a></p><h2 id="一、file对象"><a href="#一、file对象" class="headerlink" title="一、file对象"></a>一、file对象</h2><p>操作文件首先要创建file对象，file对象使用<code>open()</code>函数来创建。</p><h3 id="1、读取创建"><a href="#1、读取创建" class="headerlink" title="1、读取创建"></a>1、读取创建</h3><p>(1)读取文本文件，UTF-8编码：<br><code>f = open(&#39;/Users/michael/test.txt&#39;, &#39;r&#39;)</code></p><p>(2)读取二进制文件，比如图片、视频等用<code>rb</code>模式打开文件:<br><code>f = open(&#39;/Users/michael/test.jpg&#39;, &#39;rb&#39;)</code></p><p>(3)读取非UTF-8编码的文本文件，需要给open()函数传入<code>encoding</code>参数:<br><code>f = open(&#39;/Users/michael/gbk.txt&#39;, &#39;r&#39;, encoding=&#39;gbk&#39;)</code></p><p>(4)有些编码不规范的文件,遇到编码错误,最简单的方式是直接忽略(<code>errors</code>参数)：<br><code>f = open(&#39;/Users/michael/gbk.txt&#39;, &#39;r&#39;, encoding=&#39;gbk&#39;, errors=&#39;ignore&#39;)</code></p><h3 id="2、写入创建"><a href="#2、写入创建" class="headerlink" title="2、写入创建"></a>2、写入创建</h3><p>(1)写入文本文件，UTF-8编码：<br><code>file = open(&#39;/Users/michael/test.txt&#39;, &#39;w&#39;)</code></p><p>(2)写入二进制文件：<br><code>f = open(&#39;/Users/michael/test.jpg&#39;, &#39;wb&#39;)</code></p><p>(3)写入特定编码的文本文件，请给open()函数传入encoding参数:<br><code>f = open(&#39;/Users/michael/gbk.txt&#39;, &#39;w&#39;, encoding=&#39;gbk&#39;)</code></p><p>(4)在文本末尾追加写入，需要传入<code>a</code>参数(append)：<br><code>file = open(&#39;/Users/michael/test.txt&#39;, &#39;w&#39;, &#39;a&#39;)</code></p><h2 id="二、读文件"><a href="#二、读文件" class="headerlink" title="二、读文件"></a>二、读文件</h2><p>创建file对象后，就可以调取<code>read()</code>方法进行读取内容了。</p><h3 id="1、read-size"><a href="#1、read-size" class="headerlink" title="1、read(size)"></a>1、read(size)</h3><p>从文件读取指定的字节数，如果未给定或为负则读取所有：<br><code>line = f.read()</code> #一次性全部读取<br><code>line = f.read(10)</code> #一次读取10个字节，即5汉字</p><h3 id="2、readline-size"><a href="#2、readline-size" class="headerlink" title="2、readline(size)"></a>2、readline(size)</h3><p>读取整行，包括 “\n” 字符：<br><code>line = f.readline()</code> #一次性读取一整行<br><code>line = f.readline(5)</code> #读取一行中的前5个字节</p><h3 id="3、readlines-sizeint"><a href="#3、readlines-sizeint" class="headerlink" title="3、readlines(sizeint)"></a>3、readlines(sizeint)</h3><p>读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区：<br><code>lines = f.readlines()</code> #一次性读取所有行，返回列表</p><h2 id="三、写文件"><a href="#三、写文件" class="headerlink" title="三、写文件"></a>三、写文件</h2><p>创建file对象后，也可以调取<code>write()</code>方法进行写入内容了。</p><h3 id="1、write-str"><a href="#1、write-str" class="headerlink" title="1、write(str)"></a>1、write(str)</h3><p>将字符串写入文件，没有返回值。<br><code>f.write(&#39;hello world&#39;)</code> #向文件写入</p><h3 id="2、writelines-sequence"><a href="#2、writelines-sequence" class="headerlink" title="2、writelines(sequence)"></a>2、writelines(sequence)</h3><p>向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。<br><code>seq = [&quot;hello\n&quot;, &quot;world\n&quot;]</code><br><code>f.writelines(seq)</code> #向文件写入列表，并换行</p><h2 id="四、关闭文件"><a href="#四、关闭文件" class="headerlink" title="四、关闭文件"></a>四、关闭文件</h2><p>文件使用完毕后必须关闭，关闭后文件不能再进行读写操作。</p><h3 id="1、close"><a href="#1、close" class="headerlink" title="1、close()"></a>1、close()</h3><p><code>f.close()</code><br>由于文件读写时都有可能产生IOError，一旦出错后面的f.close()就不会调用,我们可以使用<code>try...finally</code>来实现</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    f = open(&apos;/path/to/file&apos;, &apos;r&apos;)</span><br><span class="line">    print(f.read())</span><br><span class="line">finally:</span><br><span class="line">    if f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure></blockquote><h3 id="2、with…as…"><a href="#2、with…as…" class="headerlink" title="2、with…as…"></a>2、with…as…</h3><p>Python引入了<code>with</code>语句来自动帮我们调用<code>close()</code>方法：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;/Users/michael/test.txt&apos;, &apos;w&apos;) as f:</span><br><span class="line">    f.write(&apos;Hello, world!&apos;)</span><br></pre></td></tr></table></figure></blockquote><h2 id="五、其他操作"><a href="#五、其他操作" class="headerlink" title="五、其他操作"></a>五、其他操作</h2><h3 id="1、file-flush"><a href="#1、file-flush" class="headerlink" title="1、file.flush()"></a>1、file.flush()</h3><p>刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。</p><h3 id="2、file-next"><a href="#2、file-next" class="headerlink" title="2、file.next()"></a>2、file.next()</h3><p>返回文件下一行。</p><h3 id="3、file-tell"><a href="#3、file-tell" class="headerlink" title="3、file.tell()"></a>3、file.tell()</h3><p>返回文件当前位置。</p><h3 id="4、file-seek-offset-whence"><a href="#4、file-seek-offset-whence" class="headerlink" title="4、file.seek(offset[, whence])"></a>4、file.seek(offset[, whence])</h3><p>设置文件当前位置。<br>offset：开始的偏移量，也就是代表需要移动偏移的字节数。<br>whence：默认值为0，表示要从哪个位置开始偏移，0代表从文件开头开始算起，1代表从当前位置开始算起，2代表从文件末尾算起。</p><h3 id="5、file-truncate-size"><a href="#5、file-truncate-size" class="headerlink" title="5、file.truncate(size)"></a>5、file.truncate(size)</h3><p>从文件的首行首字符开始截断，截断文件为size个字符，无size表示从当前位置截断；截断之后V后面的所有字符被删除，其中Widnows系统下的换行代表2个字符大小。</p><h3 id="6、file-isatty"><a href="#6、file-isatty" class="headerlink" title="6、file.isatty()"></a>6、file.isatty()</h3><p>如果文件连接到一个终端设备返回 True，否则返回 False。</p><h3 id="7、file-fileno"><a href="#7、file-fileno" class="headerlink" title="7、file.fileno()"></a>7、file.fileno()</h3><p>返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。</p><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a>持续更新…</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生苦短，我用python。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://pythonfood.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://pythonfood.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python错误异常</title>
    <link href="http://pythonfood.github.io/2017/12/28/python%E9%94%99%E8%AF%AF%E5%BC%82%E5%B8%B8/"/>
    <id>http://pythonfood.github.io/2017/12/28/python错误异常/</id>
    <published>2017-12-28T11:20:00.000Z</published>
    <updated>2018-03-19T01:29:28.660Z</updated>
    
    <content type="html"><![CDATA[<p>人生苦短，我用python。<br><a id="more"></a></p><h2 id="一、错误和异常"><a href="#一、错误和异常" class="headerlink" title="一、错误和异常"></a>一、错误和异常</h2><h3 id="1、BaseException"><a href="#1、BaseException" class="headerlink" title="1、BaseException"></a>1、BaseException</h3><p>BaseException: 所有错误异常的基类</p><ul><li>KeyboardInterrupt : 用户中断执行</li><li>SystemExit : 解释器请求推出</li><li>GeneratorExit : 生成器(generator)发生异常来通知退出</li><li>Exception : 常规错误的基类</li></ul><h3 id="2、Exception"><a href="#2、Exception" class="headerlink" title="2、Exception"></a>2、Exception</h3><p>Exception: 常规错误异常的基类</p><ul><li>StopIteration : 迭代器没有更多的值</li><li>StandardError : 所有的内建标准异常的基类</li><li>ArithmeticError : 所有数值计算错误的基类</li><li>FloatingPointError : 浮点计算错误</li><li>OverflowError : 数值运算超出最大限制</li><li>ZeroDivisionError : 除(或取模)零 (所有数据类型)</li><li>AssertionError : 断言语句失败</li><li>AttributeError : 对象没有这个属性</li><li>EOFError : 没有内建输入,到达EOF 标记</li><li>EnvironmentError : 操作系统错误的基类</li><li>IOError : 输入/输出操作失败</li><li>OSError : 操作系统错误</li><li>WindowsError : 系统调用失败</li><li>ImportError : 导入模块/对象失败</li><li>LookupError : 无效数据查询的基类</li><li>IndexError : 序列中没有此索引(index)</li><li>KeyError : 映射中没有这个键</li><li>MemoryError : 内存溢出错误(对于Python 解释器不是致命的)</li><li>NameError : 未声明/初始化对象 (没有属性)</li><li>UnboundLocalError : 访问未初始化的本地变量</li><li>ReferenceError : 弱引用(Weak reference)试图访问已经垃圾回收了的对象</li><li>RuntimeError : 一般的运行时错误</li><li>NotImplementedError : 尚未实现的方法</li><li>SyntaxError : Python 语法错误</li><li>IndentationError : 缩进错误</li><li>TabError : Tab 和空格混用</li><li>SystemError : 一般的解释器系统错误</li><li>TypeError : 对类型无效的操作</li><li>ValueError : 传入无效的参数</li><li>UnicodeError : Unicode 相关的错误</li><li>UnicodeDecodeError : Unicode 解码时的错误</li><li>UnicodeEncodeError : Unicode 编码时错误</li><li>UnicodeTranslateError : Unicode 转换时错误</li><li>Warning : 警告的基类</li><li>DeprecationWarning : 关于被弃用的特征的警告</li><li>FutureWarning : 关于构造将来语义会有改变的警告</li><li>OverflowWarning : 旧的关于自动提升为长整型(long)的警告</li><li>PendingDeprecationWarning : 关于特性将会被废弃的警告</li><li>RuntimeWarning : 可疑的运行时行为(runtime behavior)的警告</li><li>SyntaxWarning : 可疑的语法的警告</li><li>UserWarning : 用户代码生成的警告</li></ul><h3 id="3、继承关系"><a href="#3、继承关系" class="headerlink" title="3、继承关系"></a>3、继承关系</h3><p><a href="https://docs.python.org/2/library/exceptions.html#exception-hierarchy" target="_blank" rel="noopener">错误异常继承关系</a></p><h2 id="二、异常处理"><a href="#二、异常处理" class="headerlink" title="二、异常处理"></a>二、异常处理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">try: #需要监测的代码</span><br><span class="line">...</span><br><span class="line">except exception1: #捕获一个异常</span><br><span class="line">...</span><br><span class="line">except (exception2, exception3): #同时处理多个异常，写在元组里</span><br><span class="line">...</span><br><span class="line">except exception4 as e4: #给异常取别名</span><br><span class="line">...</span><br><span class="line">except: #最后一个except可以忽略异常的名称，它将被当作通配符使用</span><br><span class="line">...</span><br><span class="line">else: #可选的else必须放在所有的except之后，将在try没有发生任何异常时执行</span><br><span class="line">...</span><br><span class="line">finally: #不管try里面有没有发生异常，finally都会执行</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def divide(x, y):</span><br><span class="line">        try:</span><br><span class="line">            result = x / y</span><br><span class="line">        except ZeroDivisionError:</span><br><span class="line">            print(&quot;division by zero!&quot;)</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;result is&quot;, result)</span><br><span class="line">        finally:</span><br><span class="line">            print(&quot;executing finally clause&quot;)</span><br><span class="line">divide(2, 1)</span><br></pre></td></tr></table></figure></blockquote><h2 id="三、抛出异常"><a href="#三、抛出异常" class="headerlink" title="三、抛出异常"></a>三、抛出异常</h2><p><code>raise</code>语句抛出一个指定的异常。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    raise NameError(&apos;HiThere&apos;)</span><br><span class="line">except NameError:</span><br><span class="line">    print(&apos;An exception flew by!&apos;)</span><br><span class="line">    raise</span><br></pre></td></tr></table></figure></blockquote><h2 id="四、自定义异常"><a href="#四、自定义异常" class="headerlink" title="四、自定义异常"></a>四、自定义异常</h2><p>你可以通过创建一个新的exception类来拥有自己的异常。异常应该继承自Exception类，或者直接继承，或者间接继承，例如:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class MyError(Exception):</span><br><span class="line">        def __init__(self, value):</span><br><span class="line">            self.value = value</span><br><span class="line">        def __str__(self):</span><br><span class="line">            return repr(self.value)</span><br><span class="line">   </span><br><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">        raise MyError(2*2)</span><br><span class="line">    except MyError as e:</span><br><span class="line">        print(&apos;My exception occurred, value:&apos;, e.value)</span><br></pre></td></tr></table></figure></blockquote><p>当创建一个模块有可能抛出多种不同的异常时，一种通常的做法是为这个包建立一个基础异常类，然后基于这个基础类为不同的错误情况创建不同的子类:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Error(Exception):</span><br><span class="line">    &quot;&quot;&quot;Base class for exceptions in this module.&quot;&quot;&quot;</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class InputError(Error):</span><br><span class="line">    &quot;&quot;&quot;Exception raised for errors in the input.</span><br><span class="line"></span><br><span class="line">    Attributes:</span><br><span class="line">        expression -- input expression in which the error occurred</span><br><span class="line">        message -- explanation of the error</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, expression, message):</span><br><span class="line">        self.expression = expression</span><br><span class="line">        self.message = message</span><br><span class="line"></span><br><span class="line">class TransitionError(Error):</span><br><span class="line">    &quot;&quot;&quot;Raised when an operation attempts a state transition that&apos;s not</span><br><span class="line">    allowed.</span><br><span class="line"></span><br><span class="line">    Attributes:</span><br><span class="line">        previous -- state at beginning of transition</span><br><span class="line">        next -- attempted new state</span><br><span class="line">        message -- explanation of why the specific transition is not allowed</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, previous, next, message):</span><br><span class="line">        self.previous = previous</span><br><span class="line">        self.next = next</span><br><span class="line">        self.message = message</span><br></pre></td></tr></table></figure></blockquote><h2 id="五、清理行为"><a href="#五、清理行为" class="headerlink" title="五、清理行为"></a>五、清理行为</h2><h3 id="1、定义清理行为"><a href="#1、定义清理行为" class="headerlink" title="1、定义清理行为"></a>1、定义清理行为</h3><p><code>try</code>语句有一个可选的<code>finally</code>子句，它定义了无论在任何情况下都会执行的清理行为:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">raise KeyboardInterrupt</span><br><span class="line">finally:</span><br><span class="line">print(&apos;Goodbye, world!&apos;)</span><br></pre></td></tr></table></figure></blockquote><h3 id="2、预定义清理行为"><a href="#2、预定义清理行为" class="headerlink" title="2、预定义清理行为"></a>2、预定义清理行为</h3><p>一些对象定义了标准的清理行为，无论系统是否成功的使用了它，一旦不需要它了，那么这个标准的清理行为就会执行。<br><code>with</code>语句就可以保证诸如文件之类的对象在使用完之后一定会正确的执行他的清理方法:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(&quot;myfile.txt&quot;) as f:</span><br><span class="line">    for line in f:</span><br><span class="line">        print(line, end=&quot;&quot;)</span><br></pre></td></tr></table></figure></blockquote><h2 id="六、调试"><a href="#六、调试" class="headerlink" title="六、调试"></a>六、调试</h2><h3 id="1、print"><a href="#1、print" class="headerlink" title="1、print()"></a>1、print()</h3><p>用<code>print()</code>把可能有问题的变量打印出来看看，用print()最大的坏处是将来还得删掉它，想想程序里到处都是print()，运行结果也会包含很多垃圾信息。</p><h3 id="2、assert"><a href="#2、assert" class="headerlink" title="2、assert"></a>2、assert</h3><p>如果断言失败，assert语句本身就会抛出AssertionError。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def foo(s):</span><br><span class="line">    n = int(s)</span><br><span class="line">    assert n != 0, &apos;n is zero!&apos;</span><br><span class="line">    return 10 / n</span><br></pre></td></tr></table></figure></blockquote><p>程序中如果到处充斥着assert，和print()相比也好不到哪去。不过，启动Python解释器时可以用-O参数来关闭assert<br><code>python -O err.py</code></p><h3 id="3、logging"><a href="#3、logging" class="headerlink" title="3、logging"></a>3、logging</h3><p>logging不会抛出错误，而且可以输出到文件，推荐使用。<br>允许指定记录信息的级别:debug、info、warning、error。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># err.py</span><br><span class="line">import logging #使用前导入包</span><br><span class="line">logging.basicConfig(level=logging.INFO) #配置打印信息级别</span><br><span class="line"></span><br><span class="line">s = &apos;0&apos;</span><br><span class="line">n = int(s)</span><br><span class="line">logging.info(&apos;n = %d&apos; % n) #记录要打印的信息</span><br><span class="line">print(10 / n)</span><br></pre></td></tr></table></figure></blockquote><h3 id="4、pdb"><a href="#4、pdb" class="headerlink" title="4、pdb"></a>4、pdb</h3><p>(1)启动Python的调试器pdb，让程序以单步方式运行：<code>python -m pdb err.py</code><br>(2)pdb定位到下一步要执行的代码，输入命令<code>l</code>来查看代码。<br>(3)输入命令<code>n</code>可以单步执行代码。<br>(4)任何时候都可以输入命令<code>p 变量名</code>来查看变量。<br>(5)输入命令<code>q</code>结束调试，退出程序。</p><h3 id="5、pdb-set-trace"><a href="#5、pdb-set-trace" class="headerlink" title="5、pdb.set_trace()"></a>5、pdb.set_trace()</h3><p>只需要<code>import pdb</code>，然后在可能出错的地方放一个<code>pdb.set_trace()</code>，就可以设置一个断点，用命令<code>p</code>查看变量，用命令<code>c</code>继续运行:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># err.py</span><br><span class="line">import pdb</span><br><span class="line"></span><br><span class="line">s = &apos;0&apos;</span><br><span class="line">n = int(s)</span><br><span class="line">pdb.set_trace() # 运行到这里会自动暂停</span><br><span class="line">print(10 / n)</span><br></pre></td></tr></table></figure></blockquote><h3 id="6、IDE"><a href="#6、IDE" class="headerlink" title="6、IDE"></a>6、IDE</h3><p>如果要比较爽地设置断点、单步执行，就需要一个支持调试功能的IDE</p><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a>持续更新…</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生苦短，我用python。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://pythonfood.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://pythonfood.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python模块和包</title>
    <link href="http://pythonfood.github.io/2017/12/28/python%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/"/>
    <id>http://pythonfood.github.io/2017/12/28/python模块和包/</id>
    <published>2017-12-28T11:10:00.000Z</published>
    <updated>2018-03-19T03:45:10.180Z</updated>
    
    <content type="html"><![CDATA[<p>人生苦短，我用python。<br><a id="more"></a></p><h2 id="一、模块"><a href="#一、模块" class="headerlink" title="一、模块"></a>一、模块</h2><p>模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。</p><p>模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用python标准库的方法。</p><p>模块能定义函数，类和变量，模块里也能包含可执行的代码。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#新建模块文件modle_1.py，内容如下：</span><br><span class="line">def p_func(arg):</span><br><span class="line">    print(&apos;hello&apos;,arg)</span><br><span class="line">    return</span><br><span class="line"></span><br><span class="line">#新建主模块文件main.py，内容如下：</span><br><span class="line">from modle_1 import p_func   #导入模块modle_1中的p_func函数</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:   #判断是否为主程序执行口</span><br><span class="line">    p_func(&apos;python&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#output：</span><br><span class="line">hello python</span><br></pre></td></tr></table></figure></blockquote><p>ps：<strong>自己创建模块时要注意命名，不能和Python自带的模块名称冲突。例如，系统自带了sys模块，自己的模块就不可命名为sys.py，否则将无法导入系统自带的sys模块。 </strong></p><h2 id="二、模块引入"><a href="#二、模块引入" class="headerlink" title="二、模块引入"></a>二、模块引入</h2><h3 id="1、import"><a href="#1、import" class="headerlink" title="1、import"></a>1、import</h3><p><code>import module1[, module2[,... moduleN]</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sys #导入模块</span><br><span class="line"></span><br><span class="line">sys.path.append(&apos;&apos;) #调用模块里的方法</span><br></pre></td></tr></table></figure></blockquote><h3 id="2、from…import"><a href="#2、from…import" class="headerlink" title="2、from…import"></a>2、from…import</h3><p><code>from modname import name1[, name2[, ... nameN]]</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from fibo import fib, fib2 #导入模块里的函数</span><br><span class="line"></span><br><span class="line">fib(500) # 直接使用函数</span><br></pre></td></tr></table></figure></blockquote><h3 id="3、from…import"><a href="#3、from…import" class="headerlink" title="3、from…import *"></a>3、from…import *</h3><p><code>from modname import *</code><br>这样会把模块中的所有内容导入到当前命名空间，一般不建议使用，消耗内存空间，也容易出现未预知的问题。</p><h2 id="三、搜索路径"><a href="#三、搜索路径" class="headerlink" title="三、搜索路径"></a>三、搜索路径</h2><p>1、python解析器对模块位置的搜索顺序是：</p><ul><li>当前目录</li><li>shell变量PYTHONPATH下的每个目录</li><li>python模块路径目录</li></ul><p>2、添加搜索路径<br>方法一：直接修改sys.path，运行结束后失效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.path.append(&apos;&apos;)</span><br></pre></td></tr></table></figure></p><p>方法二：设置环境变量PYTHONPATH，一般不推荐。<br><code>set PYTHONPATH =/usr/local/lib/python</code></p><h2 id="四、作用域"><a href="#四、作用域" class="headerlink" title="四、作用域"></a>四、作用域</h2><h3 id="1、正常变量"><a href="#1、正常变量" class="headerlink" title="1、正常变量"></a>1、正常变量</h3><p>正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等。</p><h3 id="2、特殊变量"><a href="#2、特殊变量" class="headerlink" title="2、特殊变量"></a>2、特殊变量</h3><p>类似<code>__xxx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊用途，我们自己的变量一般不要用这种变量名。<br>比如：<code>__name__</code>属性，个模块都有一个__name__属性，当其值是’__main__‘时，表明该模块自身在运行，否则是被引入。</p><h3 id="3、私有变量"><a href="#3、私有变量" class="headerlink" title="3、私有变量"></a>3、私有变量</h3><p>类似<code>_xxx</code>和<code>__xxx</code>这样的变量是私有变量，（private）函数和变量“不应该”被直接引用。</p><p>ps：内置的函数<code>dir(模块名)</code>可以找到模块内定义的所有名称。以一个字符串列表的形式返回。</p><h2 id="五、包"><a href="#五、包" class="headerlink" title="五、包"></a>五、包</h2><p>目录只有包含一个<code>__init__.py</code>文件，才会被认作是一个包。<br>模块用来组织python代码，包用来组织模块。</p><h3 id="1、包的导入"><a href="#1、包的导入" class="headerlink" title="1、包的导入"></a>1、包的导入</h3><p>(1)import</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#只导入一个包里面的特定模块</span><br><span class="line">import sound.effects.echo </span><br><span class="line"></span><br><span class="line">#访问时必须使用全名</span><br><span class="line">sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)</span><br></pre></td></tr></table></figure></blockquote><p>(2)from…import<br>1)导入子模块</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#导入子模块</span><br><span class="line">from sound.effects import echo</span><br><span class="line"></span><br><span class="line">#访问不需要那些冗长的前缀</span><br><span class="line">echo.echofilter(input, output, delay=0.7, atten=4)</span><br></pre></td></tr></table></figure></blockquote><p>2)直接导入一个函数或者变量</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#导入一个函数</span><br><span class="line">from sound.effects.echo import echofilter</span><br><span class="line"></span><br><span class="line">#直接访问函数</span><br><span class="line">echofilter(input, output, delay=0.7, atten=4)</span><br></pre></td></tr></table></figure></blockquote><p>(3)from…import *<br>这个方法在 Windows平台上工作的就不是非常好，因为Windows是一个大小写不区分的系统。<br>如果非要使用，请使用下面的方法：</p><blockquote><p>1)在<code>file:sounds/effects/__init__.py</code>中包含如下代码<code>__all__ = [&quot;echo&quot;, &quot;surround&quot;, &quot;reverse&quot;]</code>。<br>2)使用<code>from sound.effects import *</code>这种用法时，你只会导入包里面这三个子模块。</p></blockquote><h2 id="六、python标准库"><a href="#六、python标准库" class="headerlink" title="六、python标准库"></a>六、python标准库</h2><p><a href="https://docs.python.org/3.6/library/" target="_blank" rel="noopener">python标准库</a>：</p><blockquote><p>1.介绍<br>2.内置函数<br>3.内置常量<br>3.1、所加入的常量site模块</p><p>4.内置类型</p><blockquote><p>4.1、真值检验<br>4.2、布尔运算 ： and，or，not<br>4.3、比较<br>4.4、数字类型 ： int，float，complex<br>4.5、迭代器类型<br>4.6、序列类型 ： list，tuple，range<br>4.7、文本序列类型 ： str<br>4.8、二进制序列类型： bytes，bytearray，memoryview<br>4.9、设置类型 ： set，frozenset<br>4.10、映射类型 ： dict<br>4.11、上下文管理器类型<br>4.12、其他内置类型<br>4.13、特殊属性</p></blockquote><p>5.内置异常</p><blockquote><p>5.1、基类<br>5.2、具体异常<br>5.3、警告<br>5.4、异常层次结构</p></blockquote><p>6.文本处理服务</p><blockquote><p>6.1、string ： 公共字符串操作<br>6.2、re ： 正则表达式操作<br>6.3、difflib ： 帮助计算增量<br>6.4、textwrap ： 文本包装和填充<br>6.5、unicodedata ： Unicode数据库<br>6.6、stringprep ： 互联网字符串准备<br>6.7、readline ： GNU readline界面<br>6.8、rlcompleter ： GNU readline的完成功能</p></blockquote><p>7.二进制数据服务</p><blockquote><p>7.1、struct ： 将字节解释为打包二进制数据<br>7.2、codecs ： 编解码器注册表和基类   </p></blockquote><p>8.数据类型</p><blockquote><p>8.1、datetime ： 基本日期和时间类型<br>8.2、calendar ： 日历相关功能<br>8.3、collections ： 容器数据类型<br>8.4、collections.abc ： 容器的抽象基类<br>8.5、heapq ： 堆队列算法<br>8.6、bisect ： 数组二分法<br>8.7、array ： 数值的有效数组<br>8.8、weakref ： 弱参考<br>8.9、types ： 动态类型创建和内置类型的名称<br>8.10、copy ： 浅和深复制操作<br>8.11、pprint ： 数据漂亮的打印机<br>8.12、reprlib： 替代repr()实施<br>8.13、enum ： 支持枚举</p></blockquote><p>9.数值和数学模块</p><blockquote><p>9.1、numbers ： 数值抽象基类<br>9.2、math ： 数学函数<br>9.3、cmath ： 复数的数学函数<br>9.4、decimal ： 十进制定点和浮点运算<br>9.5、fractions ： 有理数<br>9.6、random ： 生成伪随机数<br>9.7、statistics ： 数学统计功能</p></blockquote><p>10.功能编程模块</p><blockquote><p>10.1、itertools ： 为高效循环创建迭代器的函数<br>10.2、functools ： 对可调用对象的高阶函数和操作<br>10.3、operator ： 标准操作符作为函数</p></blockquote><p>11.文件和目录访问</p><blockquote><p>11.1、pathlib ： 面向对象的文件系统路径<br>11.2、os.path ： 公共路径名操作<br>11.3、fileinput ： 从多个输入流的线路迭代<br>11.4、stat： 解释stat()结果<br>11.5、filecmp ： 文件和目录比较<br>11.6、tempfile ： 生成临时文件和目录<br>11.7、glob ： Unix样式的路径名模式扩展<br>11.8、fnmatch ： Unix文件名模式匹配<br>11.9、linecache ： 随机访问文本行<br>11.10、shutil ： 高级文件操作<br>11.11、macpath ： Mac OS 9路径处理功能</p></blockquote><p>12.数据持久性<br>12.1、pickle ： Python对象序列化<br>12.2、copyreg ： 注册pickle支持功能<br>12.3、shelve ： Python对象持久化<br>12.4、marshal ： 内部Python对象序列化<br>12.5、dbm ： 接口到Unix“数据库”<br>12.6、sqlite3 ： SQLite数据库的DB：API 2.0接口</p><p>13.数据压缩和归档</p><blockquote><p>13.1、zlib ： 压缩与gzip兼容<br>13.2、gzip ： 支持gzip文件<br>13.3、bz2 ：支持的bzip2压缩<br>13.4、lzma ： 使用LZMA算法的压缩<br>13.5、zipfile ： 使用ZIP存档<br>13.6、tarfile ： 读取和写入tar存档文件</p></blockquote><p>14.文件格式</p><blockquote><p>14.1、csv ： CSV文件读写<br>14.2、configparser ： 配置文件解析器<br>14.3、netrc ： netrc文件处理<br>14.4、xdrlib ： 编码和解码XDR数据<br>14.5、plistlib： 生成和解析Mac OS X .plist文件</p></blockquote><p>15.加密服务</p><blockquote><p>15.1、hashlib ： 安全散列和消息摘要<br>15.2、hmac ： 消息认证的键控散列<br>15.3、secrets ： 生成安全的随机数以管理秘密</p></blockquote><p>16.通用操作系统服务</p><blockquote><p>16.1、os ： 其他操作系统接口<br>16.2、io ： 用于处理流的核心工具<br>16.3、time ： 时间访问和转换<br>16.4、argparse ： 解析器，用于命令行选项，参数和子命令<br>16.5、getopt ： 命令行选项的C样式解析器<br>16.6、logging ： Python的日志记录工具<br>16.7、logging.config ： 日志配置<br>16.8、logging.handlers ： 日志处理程序<br>16.9、getpass ： 便携式密码输入<br>16.10、curses ： 字符单元显示的终端处理<br>16.11、curses.textpad ： curses程序的文本输入小部件<br>16.12、curses.ascii ： ASCII字符的实用程序<br>16.13、curses.panel ： 诅咒的面板栈扩展<br>16.14、platform ： 访问底层平台的标识数据<br>16.15、errno ： 标准errno系统符号<br>16.16、ctypes ： Python的外部函数库</p></blockquote><p>17.并发执行</p><blockquote><p>17.1、threading ： 基于线程的并行性<br>17.2、multiprocessing ： 基于进程的并行性<br>17.3、该concurrent包<br>17.4、concurrent.futures ： 启动并行任务<br>17.5、subprocess ： 子过程管理<br>17.6、sched ： 事件调度器<br>17.7、queue ： 同步队列类<br>17.8、dummy_threading： threading模块的插入式更换<br>17.9、_thread ： 低级线程API<br>17.10、_dummy_thread： _thread模块的插入式更换</p></blockquote><p>18.进程间通信和网络</p><blockquote><p>18.1、socket ： 低级网络接口<br>18.2、ssl ： 套接字对象的TLS / SSL包装器<br>18.3、select ： 等待I / O完成<br>18.4、selectors ： 高级I / O复用<br>18.5、asyncio ： 异步I / O，事件循环，协同程序和任务<br>18.6、asyncore ： 异步套接字处理程序<br>18.7、asynchat ： 异步套接字命令/响应处理程序<br>18.8、signal ： 为异步事件设置处理程序<br>18.9、mmap ： 内存映射文件支持</p></blockquote><p>19.互联网数据处理</p><blockquote><p>19.1、email ： 电子邮件和MIME处理包<br>19.2、json ： JSON编码器和解码器<br>19.3、mailcap ： Mailcap文件处理<br>19.4、mailbox ： 处理各种格式的邮箱<br>19.5、mimetypes ： 将文件名映射到MIME类型<br>19.6、base64 ： Base16，Base32，Base64，Base85数据编码<br>19.7、binhex ： 编码和解码binhex4文件<br>19.8、binascii ： 在二进制和ASCII之间转换<br>19.9、quopri ： 编码和解码MIME引用的可打印数据<br>19.10、uu ： 编码和解码uuencode文件</p></blockquote><p>20.HTML与XML</p><blockquote><p>20.1、html ： 超文本标记语言支持<br>20.2、html.parser ： 简单的HTML和XHTML解析器<br>20.3、html.entities ： HTML一般实体的定义<br>20.4、XML处理模块<br>20.5、xml.etree.ElementTree ： ElementTree XML API<br>20.6、xml.dom ： 文档对象模型API<br>20.7、xml.dom.minidom ： 小DOM实现<br>20.8、xml.dom.pulldom ： 支持构建部分DOM树<br>20.9、xml.sax ： 支持SAX2解析器<br>20.10、xml.sax.handler ： SAX处理程序的基类<br>20.11、xml.sax.saxutils ： SAX实用程序<br>20.12、xml.sax.xmlreader ： XML解析器的接口<br>20.13、xml.parsers.expat ： 快速XML解析使用Expat</p></blockquote><p>21.互联网协议和支持</p><blockquote><p>21.1、webbrowser ： 方便的Web浏览器控制器<br>21.2、cgi ： 公共网关接口支持<br>21.3、cgitb ： CGI脚本的跟踪管理器<br>21.4、wsgiref ： WSGI实用程序和参考实现<br>21.5、urllib ： URL处理模块<br>21.6、urllib.request ： 用于打开网址的可扩展库<br>21.7、urllib.response ： urllib使用的响应类<br>21.8、urllib.parse ： 将URL解析到组件中<br>21.9、urllib.error ： 由urllib.request引发的异常类<br>21.10、urllib.robotparser ： 解析器，用于robots.txt<br>21.11、http ： HTTP模块<br>21.12、http.client ： HTTP协议客户端<br>21.13、ftplib ： FTP协议客户端<br>21.14、poplib ： POP3协议客户端<br>21.15、imaplib ： IMAP4协议客户端<br>21.16、nntplib ： NNTP协议客户端<br>21.17、smtplib ： SMTP协议客户端<br>21.18 smtpd ： SMTP服务器<br>21.19、telnetlib ： Telnet客户端<br>21.20、uuid ： 根据RFC 4122的UUID对象<br>21.21、socketserver ： 网络服务器的框架<br>21.22、http.server ： HTTP服务器<br>21.23、http.cookies ： HTTP状态管理<br>21.24、http.cookiejar ： HTTP客户端的Cookie处理<br>21.25、xmlrpc ： XMLRPC服务器和客户端模块<br>21.26、xmlrpc.client ： XML：RPC客户端访问<br>21.27、xmlrpc.server ： 基本XML：RPC服务器<br>21.28、ipaddress ： IPv4 / IPv6操作库</p></blockquote><p>22.多媒体服务</p><blockquote><p>22.1、audioop ： 处理原始音频数据<br>22.2、aifc ： 读写AIFF和AIFC文件<br>22.3、sunau ： 读写Sun AU文件<br>22.4、wave ： 读写WAV文件<br>22.5、chunk ： 读取IFF分块数据<br>22.6、colorsys ： 颜色系统之间的转换<br>22.7、imghdr ： 确定图像的类型<br>22.8、sndhdr ： 确定声音文件的类型<br>22.9、ossaudiodev ： 访问与OSS兼容的音频设备</p></blockquote><p>23.国际化</p><blockquote><p>23.1、gettext ： 多语言国际化服务<br>23.2、locale ： 国际化服务</p></blockquote><p>24.方案框架</p><blockquote><p>24.1、turtle ： 海龟图形<br>24.2、cmd ： 支持面向行的命令解释器<br>24.3、shlex ： 简单的词汇分析</p></blockquote><p>25.Tk的图形用户接口</p><blockquote><p>25.1、tkinter ： Tcl / Tk的Python接口<br>25.2、tkinter.ttk ： Tk主题小部件<br>25.3、tkinter.tix ： Tk的扩展小部件<br>25.4、tkinter.scrolledtext ： 滚动文本小部件<br>25.5、闲<br>25.6、其他图形用户界面包</p></blockquote><p>26.开发工具</p><blockquote><p>26.1、typing ： 支持类型提示<br>26.2、pydoc ： 文档生成器和在线帮助系统<br>26.3、doctest ： 测试交互式Python示例<br>26.4、unittest ： 单元测试框架<br>26.5、unittest.mock ： 模拟对象库<br>26.6、unittest.mock： 入门<br>26.7、2to3 ： 自动化Python 2到3代码翻译<br>26.8、test ： Python的回归测试包<br>26.9、test.support ： Python测试套件的实用程序</p></blockquote><p>27.调试和分析</p><blockquote><p>27.1、bdb ： 调试器框架<br>27.2、faulthandler ： 转储Python回溯<br>27.3、pdb ： Python调试器<br>27.4、Python分析器<br>27.5、timeit ： 测量小代码片段的执行时间<br>27.6、trace ： 跟踪或跟踪Python语句执行<br>27.7、tracemalloc ： 跟踪内存分配</p></blockquote><p>28.软件包装和分发</p><blockquote><p>28.1、distutils ： 构建和安装Python模块<br>28.2、ensurepip： 引导安装pip程序<br>28.3、venv ： 创建虚拟环境<br>28.4、zipapp ： 管理可执行的python zip档案</p></blockquote><p>29.Python运行时服务</p><blockquote><p>29.1、sys ： 系统特定的参数和功能<br>29.2、sysconfig ： 提供对Python的配置信息的访问<br>29.3、builtins ： 内置对象<br>29.4、__main__ ： 顶级脚本环境<br>29.5、warnings ： 警告控制<br>29.6、contextlib： 用于with语句上下文的实用程序<br>29.7、abc ： 抽象基类<br>29.8、atexit ： 退出处理程序<br>29.9、traceback ： 打印或检索堆栈跟踪<br>29.10、__future__ ： 未来语句定义<br>29.11、gc ： 垃圾收集器接口<br>29.12、inspect ： 检查活对象<br>29.13、site ： 站点特定的配置钩子<br>29.14、fpectl ： 浮点异常控制</p></blockquote><p>30.自定义Python解释器</p><blockquote><p>30.1、code ： 解释器基类<br>30.2、codeop ： 编译Python代码</p></blockquote><p>31.导入模块</p><blockquote><p>31.1、zipimport ： 从Zip档案导入模块<br>31.2、pkgutil ： 软件包扩展实用程序<br>31.3、modulefinder ： 查找脚本使用的模块<br>31.4、runpy ： 定位和执行Python模块<br>31.5、importlib： 实施import</p></blockquote><p>32.Python语言服务</p><blockquote><p>32.1、parser ： 访问Python解析树<br>32.2、ast ： 抽象语法树<br>32.3、symtable ： 访问编译器的符号表<br>32.4、symbol ： 用于Python解析树的常量<br>32.5、token ： 用于Python解析树的常量<br>32.6、keyword ： 测试Python关键字<br>32.7、tokenize ： Tokenizer的Python源代码<br>32.8、tabnanny ： 检测模糊缩进<br>32.9、pyclbr ： Python类浏览器支持<br>32.10、py_compile ： 编译Python源文件<br>32.11、compileall ： 字节编译Python库<br>32.12、dis ： Python字节码的反汇编<br>32.13、pickletools ： 工具的腌菜开发商</p></blockquote><p>33.其他</p><blockquote><p>33.1、formatter ： 通用输出格式</p></blockquote><p>34.MS Windows特定服务</p><blockquote><p>34.1、msilib ： 读取和写入Microsoft Installer文件<br>34.2、msvcrt ： 从MS VC ++运行时的有用的例程<br>34.3、winreg ： Windows注册表访问<br>34.4、winsound ： Windows的声音播放界面</p></blockquote><p>35.Unix特定服务</p><blockquote><p>35.1、posix ： 常见的POSIX系统调用<br>35.2、pwd ： 密码数据库<br>35.3、spwd ： shadow密码数据库<br>35.4、grp ： 组数据库<br>35.5、crypt ： 检查Unix密码的功能<br>35.6、termios ： POSIX样式tty控件<br>35.7、tty ： 端子控制功能<br>35.8、pty ： 伪终端实用程序<br>35.9、fcntl ： fcntl和ioctl系统调用<br>35.10、pipes ： 外壳管道接口<br>35.11、resource ： 资源使用信息<br>35.12、nis ： Sun的NIS接口（黄页）<br>35.13、syslog ： Unix系统日志库例程</p></blockquote><p>36.取代模块</p><blockquote><p>36.1、optparse ： 解析器，用于命令行选项<br>36.2、imp ： 访问import内部</p></blockquote><p>37.未记录的模块</p><blockquote><p>37.1、平台特定模块</p></blockquote></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a>持续更新…</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生苦短，我用python。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://pythonfood.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://pythonfood.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python类和对象</title>
    <link href="http://pythonfood.github.io/2017/12/28/python%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <id>http://pythonfood.github.io/2017/12/28/python类和对象/</id>
    <published>2017-12-28T11:00:00.000Z</published>
    <updated>2018-03-15T07:46:48.385Z</updated>
    
    <content type="html"><![CDATA[<p>人生苦短，我用python。<br><a id="more"></a></p><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><ul><li>类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li><li>对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li><li>类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li><li>实例变量：定义在方法中的变量，只作用于当前实例的类。</li><li>数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。</li><li>方法：类中定义的函数。</li><li>实例化：创建一个类的实例，类的具体对象。</li><li>方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</li><li>封装：将数据与方法放在一个类中就构成了封装。通俗的讲是指隐藏对象的属性和实现细节。</li><li>继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。</li><li>多态：Pyhon不支持多态并且也用不到多态，多态的概念是应用于Java和C#这一类强类型语言中，而Python崇尚“鸭子类型”。</li></ul><h2 id="二、类的结构"><a href="#二、类的结构" class="headerlink" title="二、类的结构"></a>二、类的结构</h2><h3 id="1、类和对象"><a href="#1、类和对象" class="headerlink" title="1、类和对象"></a>1、类和对象</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#类定义</span><br><span class="line">class MyClass:</span><br><span class="line">    i = 12345</span><br><span class="line">    def f(self):</span><br><span class="line">        return &apos;hello world&apos;</span><br><span class="line"> </span><br><span class="line"># 类对象</span><br><span class="line">x = MyClass()</span><br><span class="line"> </span><br><span class="line"># 访问类的属性和方法</span><br><span class="line">print(&quot;MyClass 类的属性 i 为：&quot;, x.i)</span><br><span class="line">print(&quot;MyClass 类的方法 f 输出为：&quot;, x.f())</span><br></pre></td></tr></table></figure></blockquote><h3 id="2、-init-方法"><a href="#2、-init-方法" class="headerlink" title="2、__init__()方法"></a>2、__init__()方法</h3><p>类的实例化操作会自动调用__init__()方法（构造方法），进行初始化。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Complex:</span><br><span class="line">    def __init__(self, realpart, imagpart):</span><br><span class="line">        self.r = realpart</span><br><span class="line">        self.i = imagpart</span><br><span class="line"></span><br><span class="line">x = Complex(3.0, -4.5)</span><br><span class="line">print(x.r, x.i)</span><br></pre></td></tr></table></figure></blockquote><h3 id="3、self参数"><a href="#3、self参数" class="headerlink" title="3、self参数"></a>3、self参数</h3><p><strong>self代表类的实例，而非类。</strong></p><p>类的方法与普通的函数只有一个特别的区别：它们必须有一个额外的第一个参数名称self。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Test:</span><br><span class="line">    def prt(self):</span><br><span class="line">        print(self) #self代表的是类的实例，代表当前对象的地址</span><br><span class="line">        print(self.__class__) # self.class 则指向类</span><br><span class="line"> </span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br></pre></td></tr></table></figure></blockquote><h3 id="4、类的方法"><a href="#4、类的方法" class="headerlink" title="4、类的方法"></a>4、类的方法</h3><p>def关键字来定义一个方法。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#类定义</span><br><span class="line">class people:</span><br><span class="line">    #定义基本属性</span><br><span class="line">    name = &apos;&apos;</span><br><span class="line">    age = 0</span><br><span class="line">    #定义私有属性,私有属性在类外部无法直接进行访问</span><br><span class="line">    __weight = 0</span><br><span class="line"></span><br><span class="line">    #定义构造方法</span><br><span class="line">    def __init__(self,n,a,w):</span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">#定义类的方法</span><br><span class="line">    def speak(self):</span><br><span class="line">        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))</span><br><span class="line"> </span><br><span class="line"># 实例化类</span><br><span class="line">p = people(&apos;dada&apos;,10,30)</span><br><span class="line">p.speak()</span><br></pre></td></tr></table></figure></blockquote><h2 id="三、类的继承"><a href="#三、类的继承" class="headerlink" title="三、类的继承"></a>三、类的继承</h2><h3 id="1、单继承"><a href="#1、单继承" class="headerlink" title="1、单继承"></a>1、单继承</h3><p><code>class DerivedClassName(BaseClassName):</code> #基类与派生类定义在一个作用域内<br><code>class DerivedClassName(modname.BaseClassName):</code> #基类定义在另一个模块中</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#类定义</span><br><span class="line">class people:</span><br><span class="line">    #定义基本属性</span><br><span class="line">    name = &apos;&apos;</span><br><span class="line">    age = 0</span><br><span class="line">    #定义私有属性,私有属性在类外部无法直接进行访问</span><br><span class="line">    __weight = 0</span><br><span class="line">    #定义构造方法</span><br><span class="line">    def __init__(self,n,a,w):</span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    def speak(self):</span><br><span class="line">        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))</span><br><span class="line"> </span><br><span class="line">#单继承示例</span><br><span class="line">class student(people):</span><br><span class="line">    grade = &apos;&apos;</span><br><span class="line">    def __init__(self,n,a,w,g):</span><br><span class="line">        #调用父类的构函</span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    #覆写父类的方法</span><br><span class="line">    def speak(self):</span><br><span class="line">        print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))</span><br><span class="line"> </span><br><span class="line">s = student(&apos;ken&apos;,10,60,3)</span><br><span class="line">s.speak()</span><br></pre></td></tr></table></figure></blockquote><h3 id="2、多继承"><a href="#2、多继承" class="headerlink" title="2、多继承"></a>2、多继承</h3><p><code>class DerivedClassName(Base1, Base2, Base3):</code><br>注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#类定义</span><br><span class="line">class people:</span><br><span class="line">    #定义基本属性</span><br><span class="line">    name = &apos;&apos;</span><br><span class="line">    age = 0</span><br><span class="line">    #定义私有属性,私有属性在类外部无法直接进行访问</span><br><span class="line">    __weight = 0</span><br><span class="line">    #定义构造方法</span><br><span class="line">    def __init__(self,n,a,w):</span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    def speak(self):</span><br><span class="line">        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))</span><br><span class="line"> </span><br><span class="line">#单继承示例</span><br><span class="line">class student(people):</span><br><span class="line">    grade = &apos;&apos;</span><br><span class="line">    def __init__(self,n,a,w,g):</span><br><span class="line">        #调用父类的构函</span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    #覆写父类的方法</span><br><span class="line">    def speak(self):</span><br><span class="line">        print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))</span><br><span class="line"> </span><br><span class="line">#另一个类，多重继承之前的准备</span><br><span class="line">class speaker():</span><br><span class="line">    topic = &apos;&apos;</span><br><span class="line">    name = &apos;&apos;</span><br><span class="line">    def __init__(self,n,t):</span><br><span class="line">        self.name = n</span><br><span class="line">        self.topic = t</span><br><span class="line">    def speak(self):</span><br><span class="line">        print(&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;%(self.name,self.topic))</span><br><span class="line"> </span><br><span class="line">#多重继承</span><br><span class="line">class sample(speaker,student):</span><br><span class="line">    a =&apos;&apos;</span><br><span class="line">    def __init__(self,n,a,w,g,t):</span><br><span class="line">        student.__init__(self,n,a,w,g)</span><br><span class="line">        speaker.__init__(self,n,t)</span><br><span class="line"> </span><br><span class="line">test = sample(&quot;Tim&quot;,25,80,4,&quot;Python&quot;)</span><br><span class="line">test.speak()   #方法名同，默认调用的是在括号中排前地父类的方法</span><br></pre></td></tr></table></figure></blockquote><h3 id="3、方法重写"><a href="#3、方法重写" class="headerlink" title="3、方法重写"></a>3、方法重写</h3><p>如果父类方法的功能不能满足子类的需求，可以在子类重写父类的方法。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Parent:        # 定义父类</span><br><span class="line">   def myMethod(self):</span><br><span class="line">      print (&apos;调用父类方法&apos;)</span><br><span class="line"> </span><br><span class="line">class Child(Parent): # 定义子类</span><br><span class="line">   def myMethod(self):</span><br><span class="line">      print (&apos;调用子类方法&apos;)</span><br><span class="line"> </span><br><span class="line">c = Child()          # 子类实例</span><br><span class="line">c.myMethod()         # 子类调用重写方法</span><br><span class="line">super(Child,c).myMethod() #用子类对象调用父类已被覆盖的方法</span><br></pre></td></tr></table></figure></blockquote><p>ps：<strong>super() 函数是用于调用父类(超类)的一个方法。</strong></p><h2 id="四、类属性与方法"><a href="#四、类属性与方法" class="headerlink" title="四、类属性与方法"></a>四、类属性与方法</h2><h3 id="1、属性与方法"><a href="#1、属性与方法" class="headerlink" title="1、属性与方法"></a>1、属性与方法</h3><ul><li>类的私有属性<code>__private_attrs</code>：两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。</li><li>类的私有方法<code>__private_method()</code>：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类地外部调用。在类内部的方法中使用时 self.__private_method()。</li><li>类的属性<code>attrs</code>：公开变量。</li><li>类的方法<code>method()</code>：公开方法。类方法必须包含参数self，self的名字并不是规定死的，也可以使用this，但是最好还是按照约定是用self。</li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Site:</span><br><span class="line">    def __init__(self, name, url):</span><br><span class="line">        self.name = name       # public</span><br><span class="line">        self.__url = url   # private</span><br><span class="line"> </span><br><span class="line">    def who(self):</span><br><span class="line">        print(&apos;name  : &apos;, self.name)</span><br><span class="line">        print(&apos;url : &apos;, self.__url)</span><br><span class="line"> </span><br><span class="line">    def __foo(self):          # 私有方法</span><br><span class="line">        print(&apos;这是私有方法&apos;)</span><br><span class="line"> </span><br><span class="line">    def foo(self):            # 公共方法</span><br><span class="line">        print(&apos;这是公共方法&apos;)</span><br><span class="line">        self.__foo()</span><br><span class="line"> </span><br><span class="line">x = Site(&apos;baidu&apos;, &apos;www.baidu.com&apos;)</span><br><span class="line">x.who()        # 正常输出</span><br><span class="line">x.foo()        # 正常输出</span><br><span class="line">x.__foo()      # 报错</span><br></pre></td></tr></table></figure></blockquote><h3 id="2、特殊的类属性"><a href="#2、特殊的类属性" class="headerlink" title="2、特殊的类属性"></a>2、特殊的类属性</h3><ul><li><code>类名.__name__</code> #类的名字(字符串)</li><li><code>类名.__doc__</code> #类的文档字符串</li><li><code>类名.__base__</code> #类的第一个父类(在讲继承时会讲)</li><li><code>类名.__bases__</code> #类所有父类构成的元组(在讲继承时会讲)</li><li><code>类名.__dict__</code> #类的字典属性</li><li><code>类名.__module__</code> #类定义所在的模块</li><li><code>类名.__class__</code> #实例对应的类(仅新式类中)</li></ul><p>我们定义的类的属性到底存到哪里了？有两种方式查看：<br>方法一： <code>dir(类名)</code>查出的是一个名字列表<br>方法二： <code>类名.__dict__</code>查出的是一个字典，key为属性名，value为属性值</p><h3 id="3、类的专有方法"><a href="#3、类的专有方法" class="headerlink" title="3、类的专有方法"></a>3、类的专有方法</h3><ul><li><code>__init__()</code> #构造函数，在生成对象时调用</li><li><code>__del__()</code> #析构函数，释放对象时使用</li><li><code>__repr__()</code> #打印，转换</li><li><code>__setitem__()</code> #按照索引赋值</li><li><code>__getitem__()</code> #按照索引获取值</li><li><code>__len__()</code> #获得长度</li><li><code>__cmp__()</code> #比较运算</li><li><code>__call__()</code> #函数调用</li><li><code>__add__()</code> #加运算</li><li><code>__sub__()</code> #减运算</li><li><code>__mul__()</code> #乘运算</li><li><code>__div__()</code> #除运算</li><li><code>__mod__()</code> #求余运算</li><li><code>__pow__()</code> #乘方</li></ul><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a>持续更新…</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生苦短，我用python。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://pythonfood.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://pythonfood.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python函数</title>
    <link href="http://pythonfood.github.io/2017/12/28/python%E5%87%BD%E6%95%B0/"/>
    <id>http://pythonfood.github.io/2017/12/28/python函数/</id>
    <published>2017-12-28T10:50:00.000Z</published>
    <updated>2018-03-14T07:39:54.201Z</updated>
    
    <content type="html"><![CDATA[<p>人生苦短，我用python。<br><a id="more"></a></p><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="1、定义函数"><a href="#1、定义函数" class="headerlink" title="1、定义函数"></a>1、定义函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def 函数名（参数列表）:</span><br><span class="line">    函数体</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def area(width, height):</span><br><span class="line">    return width * height</span><br></pre></td></tr></table></figure></blockquote><h3 id="2、调用函数"><a href="#2、调用函数" class="headerlink" title="2、调用函数"></a>2、调用函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方式一：函数名（参数列表）</span><br><span class="line">方式二：变量名 = 函数名</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#调用方式1</span><br><span class="line">def printme( str ):</span><br><span class="line">   print (str);</span><br><span class="line">   return;</span><br><span class="line">printme(&quot;我要调用函数!&quot;)</span><br><span class="line"></span><br><span class="line">#调用方式2</span><br><span class="line">pr = printme</span><br><span class="line">pr(&quot;我要调用函数!&quot;)</span><br></pre></td></tr></table></figure></blockquote><h3 id="3、参数传递"><a href="#3、参数传递" class="headerlink" title="3、参数传递"></a>3、参数传递</h3><p>(1)可更改(mutable)与不可更改(immutable)对象：<br>在python中，numbers,strings,tuples,是不可更改的对象，而list,dict等则是可以修改的对象。</p><ul><li>传不可变对象：传递的只是不可变对象的值，没有影响不可变对象本身。</li><li>传可变对象：可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。</li></ul><p>(2)参数：</p><ul><li>必需参数</li><li>默认参数</li><li>可变参数</li><li>关键字参数</li></ul><blockquote><p>1)必选参数<br>必选参数就是在调用函数的时候要传入数量一致的参数。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def add(x, y): </span><br><span class="line">print x + y</span><br></pre></td></tr></table></figure></blockquote><p>2)默认参数<br>默认参数是指在定义函数的时候提供一些默认值，如果在调用函数的时候没有传递该参数，则自动使用默认值，否则使用传递时该参数的值。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def add(x, y, z=1): #默认参数要放在所有必选参数的后面,默认参数应该使用不可变对象。</span><br><span class="line">print x + y + z</span><br></pre></td></tr></table></figure></blockquote><p>3)可变参数<br>可变参数允许你将不定数量的参数传递给函数。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def printinfo( arg1, *vartuple ):</span><br><span class="line">print (arg1)</span><br><span class="line">for var in vartuple:</span><br><span class="line">print (var)</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">printinfo( 10 );</span><br><span class="line">printinfo( 70, 60, 50 );</span><br></pre></td></tr></table></figure></blockquote><p>4)关键字参数<br>而关键字参数则允许你将不定长度的键值对, 作为参数传递给一个函数。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def sum(**kwargs):               </span><br><span class="line">sum = 0</span><br><span class="line">for k, v in kwargs.items():</span><br><span class="line">sum += v</span><br><span class="line">return sum</span><br><span class="line"></span><br><span class="line">dict1 = &#123;&apos;x&apos;: 1&#125;</span><br><span class="line">sum(**dict1) </span><br><span class="line"></span><br><span class="line">dict2 = &#123;&apos;x&apos;: 2, &apos;y&apos;: 6&#125; </span><br><span class="line">sum(**dict2)</span><br></pre></td></tr></table></figure></blockquote><p>5)参数组合<br>它们在使用的时候是有顺序的，依次是必选参数、默认参数、可变参数、关键字参数。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def func(x, y, z=0, *args, **kwargs):</span><br><span class="line">    print &apos;x =&apos;, x</span><br><span class="line">    print &apos;y =&apos;, y</span><br><span class="line">    print &apos;z =&apos;, z</span><br><span class="line">    print &apos;args =&apos;, args</span><br><span class="line">    print &apos;kwargs =&apos;, kwargs</span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="4、return语句"><a href="#4、return语句" class="headerlink" title="4、return语句"></a>4、return语句</h3><p>return [表达式] 语句用于退出函数，选择性地向调用方返回一个tuple表达式。</p><p>(1)返回一个值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def sum( arg1, arg2 ):</span><br><span class="line">total = arg1 + arg2</span><br><span class="line">return total</span><br><span class="line"></span><br><span class="line">total = sum( 10, 20 )</span><br></pre></td></tr></table></figure></p><p>(2)返回多个值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line">def move(x, y, step, angle=0):</span><br><span class="line">    nx = x + step * math.cos(angle)</span><br><span class="line">    ny = y - step * math.sin(angle)</span><br><span class="line">    return nx, ny</span><br><span class="line"></span><br><span class="line">x, y = move(100, 100, 60, math.pi / 6)</span><br></pre></td></tr></table></figure></p><h2 id="二、变量作用域"><a href="#二、变量作用域" class="headerlink" title="二、变量作用域"></a>二、变量作用域</h2><h3 id="1、变量作用域"><a href="#1、变量作用域" class="headerlink" title="1、变量作用域"></a>1、变量作用域</h3><p>以 L –&gt; E –&gt; G –&gt;B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。</p><ul><li>L （Local）     局部作用域</li><li>E （Enclosing） 闭包函数外的函数中</li><li>G （Global）    全局作用域</li><li>B （Built-in）  内建作用域</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = int(2.9)  # 内建作用域</span><br><span class="line"> </span><br><span class="line">g_count = 0  # 全局作用域</span><br><span class="line">def outer():</span><br><span class="line">    o_count = 1  # 闭包函数外的函数中</span><br><span class="line">    def inner():</span><br><span class="line">        i_count = 2  # 局部作用域</span><br></pre></td></tr></table></figure><h3 id="2、作用域引入"><a href="#2、作用域引入" class="headerlink" title="2、作用域引入"></a>2、作用域引入</h3><p>Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问</p><p>3、global和nonlocal关键字<br>(1)当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">num = 1</span><br><span class="line">def fun1():</span><br><span class="line">    global num  # 需要使用 global 关键字声明</span><br><span class="line">    print(num) </span><br><span class="line">    num = 123</span><br><span class="line">    print(num)</span><br><span class="line">fun1()</span><br></pre></td></tr></table></figure></p><p>(2)如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要nonlocal关键字了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def outer():</span><br><span class="line">    num = 10</span><br><span class="line">    def inner():</span><br><span class="line">        nonlocal num   # nonlocal关键字声明</span><br><span class="line">        num = 100</span><br><span class="line">        print(num)</span><br><span class="line">    inner()</span><br><span class="line">    print(num)</span><br><span class="line">outer()</span><br></pre></td></tr></table></figure></p><h2 id="三、匿名函数"><a href="#三、匿名函数" class="headerlink" title="三、匿名函数"></a>三、匿名函数</h2><p>使用lambda来创建匿名函数。<br><code>lambda [arg1 [,arg2,.....argn]]:expression</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum = lambda arg1, arg2: arg1 + arg2</span><br><span class="line">print (sum( 10, 20 ))</span><br></pre></td></tr></table></figure></p><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a>持续更新…</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生苦短，我用python。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://pythonfood.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://pythonfood.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python条件循环</title>
    <link href="http://pythonfood.github.io/2017/12/28/python%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <id>http://pythonfood.github.io/2017/12/28/python条件循环/</id>
    <published>2017-12-28T10:40:00.000Z</published>
    <updated>2018-03-14T01:47:44.559Z</updated>
    
    <content type="html"><![CDATA[<p>人生苦短，我用python。<br><a id="more"></a></p><h2 id="一、if语句"><a href="#一、if语句" class="headerlink" title="一、if语句"></a>一、if语句</h2><p>1、if语句的一般形式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if condition_1:</span><br><span class="line">statement_block_1</span><br><span class="line">elif condition_2:</span><br><span class="line">statement_block_2</span><br><span class="line">else:</span><br><span class="line">statement_block_3</span><br></pre></td></tr></table></figure></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">age = int(input(&quot;请输入你家狗狗的年龄: &quot;))</span><br><span class="line">if age &lt; 0:</span><br><span class="line">    print(&quot;你是在逗我吧!&quot;)</span><br><span class="line">elif age == 1:</span><br><span class="line">    print(&quot;相当于 14 岁的人。&quot;)</span><br><span class="line">elif age == 2:</span><br><span class="line">    print(&quot;相当于 22 岁的人。&quot;)</span><br><span class="line">else:</span><br><span class="line">    human = 22 + (age -2)*5</span><br><span class="line">    print(&quot;对应人类年龄: &quot;, human)</span><br></pre></td></tr></table></figure></blockquote><p>2、if嵌套<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if 表达式1:</span><br><span class="line">语句</span><br><span class="line">if 表达式2:</span><br><span class="line">语句</span><br><span class="line">elif 表达式3:</span><br><span class="line">语句</span><br><span class="line">else:</span><br><span class="line">语句</span><br><span class="line">elif 表达式4:</span><br><span class="line">语句</span><br><span class="line">else:</span><br><span class="line">语句</span><br></pre></td></tr></table></figure></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">num=int(input(&quot;输入一个数字：&quot;))</span><br><span class="line">if num%2==0:</span><br><span class="line">    if num%3==0:</span><br><span class="line">        print (&quot;你输入的数字可以整除 2 和 3&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print (&quot;你输入的数字可以整除 2，但不能整除 3&quot;)</span><br><span class="line">else:</span><br><span class="line">    if num%3==0:</span><br><span class="line">        print (&quot;你输入的数字可以整除 3，但不能整除 2&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print  (&quot;你输入的数字不能整除 2 和 3&quot;)</span><br></pre></td></tr></table></figure></blockquote><p>3、if中常用的操作运算符</p><table><thead><tr><th style="text-align:left">操作符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">&lt;</td><td style="text-align:left">小于</td></tr><tr><td style="text-align:left">&lt;=</td><td style="text-align:left">小于或等于</td></tr><tr><td style="text-align:left">&gt;</td><td style="text-align:left">大于</td></tr><tr><td style="text-align:left">&gt;=</td><td style="text-align:left">大于或等于</td></tr><tr><td style="text-align:left">==</td><td style="text-align:left">等于，比较对象是否相等</td></tr><tr><td style="text-align:left">!=</td><td style="text-align:left">不等于</td></tr></tbody></table><p>4、if条件表达式（三目操作符）<br>X if C else Y<br><code>smaller = x if x&lt;y else y</code></p><h2 id="二、while循环"><a href="#二、while循环" class="headerlink" title="二、while循环"></a>二、while循环</h2><p>1、while语句的一般形式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while 判断条件：</span><br><span class="line">语句</span><br></pre></td></tr></table></figure></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = 100</span><br><span class="line">sum = 0</span><br><span class="line">counter = 1</span><br><span class="line">while counter &lt;= n:</span><br><span class="line">    sum = sum + counter</span><br><span class="line">    counter += 1</span><br><span class="line">print(&quot;1 到 %d 之和为: %d&quot; % (n,sum))</span><br></pre></td></tr></table></figure></blockquote><p>2、while … else … 在条件语句为false时执行else的语句块。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">count = 0</span><br><span class="line">while count &lt; 5:</span><br><span class="line">   print (count, &quot; 小于 5&quot;)</span><br><span class="line">   count = count + 1</span><br><span class="line">else:</span><br><span class="line">   print (count, &quot; 大于或等于 5&quot;)</span><br></pre></td></tr></table></figure></blockquote><h2 id="三、for循环"><a href="#三、for循环" class="headerlink" title="三、for循环"></a>三、for循环</h2><p>1、for循环的一般格式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for &lt;variable&gt; in &lt;sequence&gt;:</span><br><span class="line">&lt;statements&gt;</span><br><span class="line">else:</span><br><span class="line">&lt;statements&gt;</span><br></pre></td></tr></table></figure></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">languages = [&quot;C&quot;, &quot;C++&quot;, &quot;Perl&quot;, &quot;Python&quot;] </span><br><span class="line">for x in languages:</span><br><span class="line">print (x)</span><br></pre></td></tr></table></figure></blockquote><p>2、for … else … 在条件语句为false时执行else的语句块。break语句会跳过else。</p><p>3、range()函数<br>(1)range生成数列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i in range(5):</span><br><span class="line">print(i)</span><br></pre></td></tr></table></figure></p><p>(2)range指定区间的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i in range(5,9) :</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure></p><p>(3)range指定步长。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i in range(0, 10, 3) :</span><br><span class="line">print(i)</span><br></pre></td></tr></table></figure></p><p>(4)range指定负数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i in range(-10, -100, -30) :</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure></p><p>(5)range()和len()函数以遍历一个序列的索引。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [&apos;Google&apos;, &apos;Baidu&apos;, &apos;Runoob&apos;, &apos;Taobao&apos;, &apos;QQ&apos;]</span><br><span class="line">for i in range(len(a)):</span><br><span class="line">print(i, a[i])</span><br></pre></td></tr></table></figure></p><p>(6)range()函数来创建一个列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(range(5))</span><br></pre></td></tr></table></figure></p><h2 id="四、循环控制"><a href="#四、循环控制" class="headerlink" title="四、循环控制"></a>四、循环控制</h2><p>1、break语句<br>可以跳出for和while的循环体，停止整个循环。</p><p>2、continue语句<br>跳过本次循环，进入到下一次循环。</p><p>3、pass语句<br>是空语句，是为了保持程序结构的完整性。</p><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a>持续更新…</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生苦短，我用python。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://pythonfood.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://pythonfood.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python运算符</title>
    <link href="http://pythonfood.github.io/2017/12/28/python%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://pythonfood.github.io/2017/12/28/python运算符/</id>
    <published>2017-12-28T10:30:00.000Z</published>
    <updated>2018-03-12T07:58:42.502Z</updated>
    
    <content type="html"><![CDATA[<p>人生苦短，我用python。<br><a id="more"></a></p><h3 id="一、算术运算符"><a href="#一、算术运算符" class="headerlink" title="一、算术运算符"></a>一、算术运算符</h3><p>以下假设变量a为10，变量b为21：</p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:center">+</td><td style="text-align:left">加 - 两个对象相加</td><td style="text-align:left">a + b 输出结果 31</td></tr><tr><td style="text-align:center">-</td><td style="text-align:left">减 - 得到负数或是一个数减去另一个数</td><td style="text-align:left">a - b 输出结果 -11</td></tr><tr><td style="text-align:center">*</td><td style="text-align:left">乘 - 两个数相乘或是返回一个被重复若干次的字符串</td><td style="text-align:left">a * b 输出结果 210</td></tr><tr><td style="text-align:center">/</td><td style="text-align:left">除 - x 除以 y</td><td style="text-align:left">b / a 输出结果 2.1</td></tr><tr><td style="text-align:center">%</td><td style="text-align:left">取模 - 返回除法的余数</td><td style="text-align:left">b % a 输出结果 1</td></tr><tr><td style="text-align:center">**</td><td style="text-align:left">幂 - 返回x的y次幂</td><td style="text-align:left">a**b 为10的21次方</td></tr><tr><td style="text-align:center">//</td><td style="text-align:left">取整除 - 返回商的整数部分</td><td style="text-align:left">9//2 输出结果 4 , 9.0//2.0 输出结果 4.0</td></tr></tbody></table><h3 id="二、比较运算符"><a href="#二、比较运算符" class="headerlink" title="二、比较运算符"></a>二、比较运算符</h3><p>以下假设变量a为10，变量b为20：</p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:center">==</td><td style="text-align:left">等于 - 比较对象是否相等</td><td style="text-align:left">(a == b) 返回 False。</td></tr><tr><td style="text-align:center">!=</td><td style="text-align:left">不等于 - 比较两个对象是否不相等</td><td style="text-align:left">(a != b) 返回 True。</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:left">大于 - 返回x是否大于y</td><td style="text-align:left">(a &gt; b) 返回 False。</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:left">小于 - 返回x是否小于y。</td><td style="text-align:left">(a &lt; b) 返回 True。</td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:left">大于等于 - 返回x是否大于等于y。</td><td style="text-align:left">(a &gt;= b) 返回 False。</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:left">小于等于 - 返回x是否小于等于y。</td><td style="text-align:left">(a &lt;= b) 返回 True。</td></tr></tbody></table><p>ps:所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。</p><h3 id="三、赋值运算符"><a href="#三、赋值运算符" class="headerlink" title="三、赋值运算符"></a>三、赋值运算符</h3><p>以下假设变量a为10，变量b为20：</p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:center">=</td><td style="text-align:left">简单的赋值运算符</td><td style="text-align:left">c = a + b 将 a + b 的运算结果赋值为 c</td></tr><tr><td style="text-align:center">+=</td><td style="text-align:left">加法赋值运算符</td><td style="text-align:left">c += a 等效于 c = c + a</td></tr><tr><td style="text-align:center">-=</td><td style="text-align:left">减法赋值运算符</td><td style="text-align:left">c -= a 等效于 c = c - a</td></tr><tr><td style="text-align:center">*=</td><td style="text-align:left">乘法赋值运算符</td><td style="text-align:left">c *= a 等效于 c = c * a</td></tr><tr><td style="text-align:center">/=</td><td style="text-align:left">除法赋值运算符</td><td style="text-align:left">c /= a 等效于 c = c / a</td></tr><tr><td style="text-align:center">%=</td><td style="text-align:left">取模赋值运算符</td><td style="text-align:left">c %= a 等效于 c = c % a</td></tr><tr><td style="text-align:center">**=</td><td style="text-align:left">幂赋值运算符</td><td style="text-align:left">c **= a 等效于 c = c ** a</td></tr><tr><td style="text-align:center">//=</td><td style="text-align:left">取整除赋值运算符</td><td style="text-align:left">c //= a 等效于 c = c // a</td></tr></tbody></table><h3 id="四、逻辑运算符"><a href="#四、逻辑运算符" class="headerlink" title="四、逻辑运算符"></a>四、逻辑运算符</h3><p>以下假设变量 a 为 10, b为 20:</p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">逻辑表达式</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:center">and</td><td style="text-align:center">x and y</td><td style="text-align:left">布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。</td><td style="text-align:left">(a and b) 返回 20。</td></tr><tr><td style="text-align:center">or</td><td style="text-align:center">x or y</td><td style="text-align:left">布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。</td><td style="text-align:left">(a or b) 返回 10。</td></tr><tr><td style="text-align:center">not</td><td style="text-align:center">not x</td><td style="text-align:left">布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td><td style="text-align:left">not(a and b) 返回 False</td></tr></tbody></table><h3 id="五、位运算符"><a href="#五、位运算符" class="headerlink" title="五、位运算符"></a>五、位运算符</h3><p>下表中变量 a 为 60，b 为 13二进制格式如下：<code>a = 0011 1100</code> <code>b = 0000 1101</code></p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:center">&amp;</td><td style="text-align:left">按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</td><td style="text-align:left">(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100</td></tr><tr><td style="text-align:center">&#124;</td><td style="text-align:left">按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。</td><td style="text-align:left">(a &#124; b) 输出结果 61 ，二进制解释： 0011 1101</td></tr><tr><td style="text-align:center">^</td><td style="text-align:left">按位异或运算符：当两对应的二进位相异时，结果为1</td><td style="text-align:left">(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td></tr><tr><td style="text-align:center">~</td><td style="text-align:left">按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。~x 类似于 -x-1</td><td style="text-align:left">(~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。</td></tr><tr><td style="text-align:center">&lt;&lt;</td><td style="text-align:left">左移动运算符：运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。</td><td style="text-align:left">a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000</td></tr><tr><td style="text-align:center">&gt;&gt;</td><td style="text-align:left">右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数</td><td style="text-align:left">a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111</td></tr></tbody></table><h3 id="六、成员运算符"><a href="#六、成员运算符" class="headerlink" title="六、成员运算符"></a>六、成员运算符</h3><p>Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:center">in</td><td style="text-align:left">如果在指定的序列中找到值返回 True，否则返回 False。</td><td style="text-align:left">x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td></tr><tr><td style="text-align:center">not in</td><td style="text-align:left">如果在指定的序列中没有找到值返回 True，否则返回 False。</td><td style="text-align:left">x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td></tr></tbody></table><h3 id="七、身份运算符"><a href="#七、身份运算符" class="headerlink" title="七、身份运算符"></a>七、身份运算符</h3><p>身份运算符用于比较两个对象的存储单元。</p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:center">is</td><td style="text-align:left">is 是判断两个标识符是不是引用自一个对象</td><td style="text-align:left">x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False</td></tr><tr><td style="text-align:center">is not</td><td style="text-align:left">is not 是判断两个标识符是不是引用自不同对象</td><td style="text-align:left">x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td></tr></tbody></table><p>ps:<code>id()</code>函数用于获取对象内存地址。</p><p>is 与 == 区别：is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。</p><h3 id="八、运算符优先级"><a href="#八、运算符优先级" class="headerlink" title="八、运算符优先级"></a>八、运算符优先级</h3><p>以下表格列出了从最高到最低优先级的所有运算符：</p><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">**</td><td style="text-align:left">指数 (最高优先级)</td></tr><tr><td style="text-align:left">~ + -</td><td style="text-align:left">按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</td></tr><tr><td style="text-align:left">* / % //</td><td style="text-align:left">乘，除，取模和取整除</td></tr><tr><td style="text-align:left">+ -</td><td style="text-align:left">加法减法</td></tr><tr><td style="text-align:left">&gt;&gt; &lt;&lt;</td><td style="text-align:left">右移，左移运算符</td></tr><tr><td style="text-align:left">&amp;</td><td style="text-align:left">位 ‘AND’</td></tr><tr><td style="text-align:left">^ &#124;</td><td style="text-align:left">位运算符</td></tr><tr><td style="text-align:left">&lt;= &lt; &gt; &gt;=</td><td style="text-align:left">比较运算符</td></tr><tr><td style="text-align:left">&lt;&gt; == !=</td><td style="text-align:left">等于运算符</td></tr><tr><td style="text-align:left">= %= /= //= -= += <em>= *</em>=</td><td style="text-align:left">赋值运算符</td></tr><tr><td style="text-align:left">is is not</td><td style="text-align:left">身份运算符</td></tr><tr><td style="text-align:left">in not in</td><td style="text-align:left">成员运算符</td></tr><tr><td style="text-align:left">not or and</td><td style="text-align:left">逻辑运算符</td></tr></tbody></table><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a>持续更新…</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生苦短，我用python。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://pythonfood.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://pythonfood.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python数据类型</title>
    <link href="http://pythonfood.github.io/2017/12/28/python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://pythonfood.github.io/2017/12/28/python数据类型/</id>
    <published>2017-12-28T10:20:00.000Z</published>
    <updated>2018-03-13T07:41:02.867Z</updated>
    
    <content type="html"><![CDATA[<p>人生苦短，我用python。<br><a id="more"></a></p><h2 id="一、Number-数字"><a href="#一、Number-数字" class="headerlink" title="一、Number 数字"></a>一、Number 数字</h2><p>1、Python3支持int、float、bool（True/False）、complex（复数）。<br><code>a, b, c, d = 20, 5.5, True, 4+3j</code><br>2、type() 查询变量所指的对象类型，不会认为子类是一种父类类型。<br><code>print(type(a))</code><br>3、isinstance() 查询变量所指的对象类型，会认为子类是一种父类类型。<br><code>isinstance(a, int)</code><br>4、del语句删除一些对象引用。<br><code>del var_a, var_b</code><br>5、不同类型的数混合运算时会将整数转换为浮点数。<br><code>3 * 3.75 / 1.5</code></p><h3 id="数字类型转换"><a href="#数字类型转换" class="headerlink" title="数字类型转换"></a>数字类型转换</h3><blockquote><ul><li><code>int(x)</code> #将x转换为一个整数。</li><li><code>float(x)</code> #将x转换到一个浮点数。</li><li><code>complex(x)</code> #将x转换到一个复数，实数部分为 x，虚数部分为 0。</li><li><code>complex(x, y)</code> #将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。</li></ul></blockquote><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">返回值 ( 描述 )</th></tr></thead><tbody><tr><td style="text-align:left">abs(x)</td><td style="text-align:left">返回数字的绝对值，如abs(-10) 返回 10</td></tr><tr><td style="text-align:left">ceil(x)</td><td style="text-align:left">返回数字的上入整数，如math.ceil(4.1) 返回 5</td></tr><tr><td style="text-align:left">cmp(x, y)</td><td style="text-align:left">如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。 Python 3 已废弃 。使用 使用 (x&gt;y)-(x&lt;y) 替换。</td></tr><tr><td style="text-align:left">exp(x)</td><td style="text-align:left">返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045</td></tr><tr><td style="text-align:left">fabs(x)</td><td style="text-align:left">返回数字的绝对值，如math.fabs(-10) 返回10.0</td></tr><tr><td style="text-align:left">floor(x)</td><td style="text-align:left">返回数字的下舍整数，如math.floor(4.9)返回 4</td></tr><tr><td style="text-align:left">log(x)</td><td style="text-align:left">如math.log(math.e)返回1.0,math.log(100,10)返回2.0</td></tr><tr><td style="text-align:left">log10(x)</td><td style="text-align:left">返回以10为基数的x的对数，如math.log10(100)返回 2.0</td></tr><tr><td style="text-align:left">max(x1, x2,…)</td><td style="text-align:left">返回给定参数的最大值，参数可以为序列。</td></tr><tr><td style="text-align:left">min(x1, x2,…)</td><td style="text-align:left">返回给定参数的最小值，参数可以为序列。</td></tr><tr><td style="text-align:left">modf(x)</td><td style="text-align:left">返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</td></tr><tr><td style="text-align:left">pow(x, y)</td><td style="text-align:left">x**y 运算后的值。</td></tr><tr><td style="text-align:left">round(x [,n])</td><td style="text-align:left">返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。</td></tr><tr><td style="text-align:left">sqrt(x)</td><td style="text-align:left">返回数字x的平方根。</td></tr></tbody></table><h3 id="随机数函数"><a href="#随机数函数" class="headerlink" title="随机数函数"></a>随机数函数</h3><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">choice(seq)</td><td style="text-align:left">从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。</td></tr><tr><td style="text-align:left">randrange</td><td style="text-align:left">([start,] stop [,step])     从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值为1</td></tr><tr><td style="text-align:left">random()</td><td style="text-align:left">随机生成下一个实数，它在[0,1)范围内。</td></tr><tr><td style="text-align:left">seed([x])</td><td style="text-align:left">改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。</td></tr><tr><td style="text-align:left">shuffle(lst)</td><td style="text-align:left">将序列的所有元素随机排序</td></tr><tr><td style="text-align:left">uniform(x, y)</td><td style="text-align:left">随机生成下一个实数，它在[x,y]范围内。</td></tr></tbody></table><h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">acos(x)</td><td style="text-align:left">返回x的反余弦弧度值。</td></tr><tr><td style="text-align:left">asin(x)</td><td style="text-align:left">返回x的反正弦弧度值。</td></tr><tr><td style="text-align:left">atan(x)</td><td style="text-align:left">返回x的反正切弧度值。</td></tr><tr><td style="text-align:left">atan2(y, x)</td><td style="text-align:left">返回给定的 X 及 Y 坐标值的反正切值。</td></tr><tr><td style="text-align:left">cos(x)</td><td style="text-align:left">返回x的弧度的余弦值。</td></tr><tr><td style="text-align:left">hypot(x, y)</td><td style="text-align:left">返回欧几里德范数 sqrt(x<em>x + y</em>y)。</td></tr><tr><td style="text-align:left">sin(x)</td><td style="text-align:left">返回的x弧度的正弦值。</td></tr><tr><td style="text-align:left">tan(x)</td><td style="text-align:left">返回x弧度的正切值。</td></tr><tr><td style="text-align:left">degrees(x)</td><td style="text-align:left">将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0</td></tr><tr><td style="text-align:left">radians(x)</td><td style="text-align:left">将角度转换为弧度</td></tr></tbody></table><h2 id="二、String-‘字符串’"><a href="#二、String-‘字符串’" class="headerlink" title="二、String ‘字符串’"></a>二、String ‘字符串’</h2><p>1、字符串用单引号’或双引号”括起来。<br><code>str = &#39;pythonfood&#39;</code><br>2、Python中的字符串不能改变。<br><code>print (str)</code><br>3、使用反斜杠\转义特殊字符<br><code>print(&#39;pytho\nfoob&#39;)</code><br>4、使用r表示原始字符串<br><code>print(r&#39;pytho\nfoob&#39;)</code><br>5、用+运算符连接字符串<br><code>print (str + &quot;TEST&quot;)</code><br>6、用*运算符重复字符串<br> <code>print (str * 2)</code><br>7、截取变量[头下标:尾下标]<br><code>print (str[2:5])</code> #截取从第三个开始到第五个的字符<br>8、字符串更新可以截取字符串的一部分并与其他字段拼接<br><code>var1 = &#39;Hello World!&#39;</code><br><code>var1 = var1[:6] + &#39;Runoob!&#39;</code><br>9、python三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">para_str = &quot;&quot;&quot;这是一个多行字符串的实例</span><br><span class="line">多行字符串可以使用制表符</span><br><span class="line">TAB ( \t )。</span><br><span class="line">也可以使用换行符 [ \n ]。</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure></p><p>10、Unicode字符串的语法是在字符串前面加上前缀<code>u</code>。在Python3中所有的字符串都是Unicode字符串。 </p><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><table><thead><tr><th style="text-align:left">转义字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">\(在行尾时)</td><td style="text-align:left">续行符</td></tr><tr><td style="text-align:left">\\</td><td style="text-align:left">反斜杠符号</td></tr><tr><td style="text-align:left">\’</td><td style="text-align:left">单引号</td></tr><tr><td style="text-align:left">\”</td><td style="text-align:left">双引号</td></tr><tr><td style="text-align:left">\a</td><td style="text-align:left">响铃</td></tr><tr><td style="text-align:left">\b</td><td style="text-align:left">退格(Backspace)</td></tr><tr><td style="text-align:left">\e</td><td style="text-align:left">转义</td></tr><tr><td style="text-align:left">\000</td><td style="text-align:left">空</td></tr><tr><td style="text-align:left">\n</td><td style="text-align:left">换行</td></tr><tr><td style="text-align:left">\v</td><td style="text-align:left">纵向制表符</td></tr><tr><td style="text-align:left">\t</td><td style="text-align:left">横向制表符</td></tr><tr><td style="text-align:left">\r</td><td style="text-align:left">回车</td></tr><tr><td style="text-align:left">\f</td><td style="text-align:left">换页</td></tr><tr><td style="text-align:left">\oyy</td><td style="text-align:left">八进制数，yy代表的字符，例如：\o12代表换行</td></tr><tr><td style="text-align:left">\xyy</td><td style="text-align:left">十六进制数，yy代表的字符，例如：\x0a代表换行</td></tr><tr><td style="text-align:left">\other</td><td style="text-align:left">其它的字符以普通格式输出</td></tr></tbody></table><h3 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h3><table><thead><tr><th style="text-align:left">操作符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">+</td><td style="text-align:left">字符串连接</td><td style="text-align:left">a + b 输出结果： HelloPython</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">重复输出字符串</td><td style="text-align:left">a*2 输出结果：HelloHello</td></tr><tr><td style="text-align:left">[]</td><td style="text-align:left">通过索引获取字符串中字符</td><td style="text-align:left">a[1] 输出结果 e</td></tr><tr><td style="text-align:left">[ : ]</td><td style="text-align:left">截取字符串中的一部分</td><td style="text-align:left">a[1:4] 输出结果 ell</td></tr><tr><td style="text-align:left">in</td><td style="text-align:left">成员运算符 - 如果字符串中包含给定的字符返回 True</td><td style="text-align:left">‘H’ in a 输出结果 1</td></tr><tr><td style="text-align:left">not in</td><td style="text-align:left">成员运算符 - 如果字符串中不包含给定的字符返回 True</td><td style="text-align:left">‘M’ not in a 输出结果 1</td></tr><tr><td style="text-align:left">r/R</td><td style="text-align:left">原始字符串 -  原始字符串除在字符串的第一个引号前加上字母 r（可以大小写）以外，与普通字符串有着几乎完全相同的语法。</td><td style="text-align:left">print( r’\n’ )print( R’\n’ )</td></tr><tr><td style="text-align:left">%</td><td style="text-align:left">格式字符串</td><td style="text-align:left">请看下一节内容。</td></tr></tbody></table><h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p><code>print (&quot;我叫 %s 今年 %d 岁!&quot; % (&#39;小明&#39;, 10))</code></p><p>（1）字符串格式化符号</p><table><thead><tr><th style="text-align:left">符号</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">%c</td><td style="text-align:left">格式化字符及其ASCII码</td></tr><tr><td style="text-align:left">%s</td><td style="text-align:left">格式化字符串</td></tr><tr><td style="text-align:left">%d</td><td style="text-align:left">格式化整数</td></tr><tr><td style="text-align:left">%u</td><td style="text-align:left">格式化无符号整型</td></tr><tr><td style="text-align:left">%o</td><td style="text-align:left">格式化无符号八进制数</td></tr><tr><td style="text-align:left">%x</td><td style="text-align:left">格式化无符号十六进制数</td></tr><tr><td style="text-align:left">%X</td><td style="text-align:left">格式化无符号十六进制数（大写）</td></tr><tr><td style="text-align:left">%f</td><td style="text-align:left">格式化浮点数字，可指定小数点后的精度</td></tr><tr><td style="text-align:left">%e</td><td style="text-align:left">用科学计数法格式化浮点数</td></tr><tr><td style="text-align:left">%E</td><td style="text-align:left">作用同%e，用科学计数法格式化浮点数</td></tr><tr><td style="text-align:left">%g</td><td style="text-align:left">%f和%e的简写</td></tr><tr><td style="text-align:left">%G</td><td style="text-align:left">%f 和 %E 的简写</td></tr><tr><td style="text-align:left">%p</td><td style="text-align:left">用十六进制数格式化变量的地址</td></tr></tbody></table><p>（2）格式化操作符辅助指令</p><table><thead><tr><th style="text-align:left">符号</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">*</td><td style="text-align:left">定义宽度或者小数点精度</td></tr><tr><td style="text-align:left">-</td><td style="text-align:left">用做左对齐</td></tr><tr><td style="text-align:left">+</td><td style="text-align:left">在正数前面显示加号( + )</td></tr><tr><td style="text-align:left"><sp></sp></td><td style="text-align:left">在正数前面显示空格</td></tr><tr><td style="text-align:left">#</td><td style="text-align:left">在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’)</td></tr><tr><td style="text-align:left">0</td><td style="text-align:left">显示的数字前面填充’0’而不是默认的空格</td></tr><tr><td style="text-align:left">%</td><td style="text-align:left">‘%%’输出一个单一的’%’</td></tr><tr><td style="text-align:left">(var)</td><td style="text-align:left">映射变量(字典参数)</td></tr><tr><td style="text-align:left">m.n.</td><td style="text-align:left">m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)</td></tr></tbody></table><p>（3）format() 格式化函数</p><blockquote><p>1)不设置指定位置，按默认顺序</p><blockquote><p><code>&quot;{} {}&quot;.format(&quot;hello&quot;, &quot;world&quot;)</code></p></blockquote><p>2)设置指定位置</p><blockquote><p><code>&quot;{0} {1}&quot;.format(&quot;hello&quot;, &quot;world&quot;)</code><br><code>&quot;{1} {0} {1}&quot;.format(&quot;hello&quot;, &quot;world&quot;)</code></p></blockquote><p>3)设置参数</p><blockquote><p><code>print(&quot;网站名：{name}, 地址 {url}&quot;.format(name=&quot;百度&quot;, url=&quot;www.baidu.com&quot;))</code></p></blockquote><p>4)通过字典设置参数</p><blockquote><p><code>site = {&quot;name&quot;: &quot;百度&quot;, &quot;url&quot;: &quot;www.baidu.com&quot;}</code><br>print(“网站名：{name}, 地址 {url}”.format(**site))</p></blockquote><p>5)通过列表索引设置参数</p><blockquote><p><code>my_list = [&#39;百度&#39;, &#39;www.baidu.com&#39;]</code><br><code>print(&quot;网站名：{0[0]}, 地址 {0[1]}&quot;.format(my_list))</code>  # “0” 是必须的</p></blockquote><p>6)可以向 str.format()传入对象</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class AssignValue(object):</span><br><span class="line">    def __init__(self, value):</span><br><span class="line">        self.value = value</span><br><span class="line">my_value = AssignValue(6)</span><br><span class="line">print(&apos;value 为: &#123;0.value&#125;&apos;.format(my_value))  # &quot;0&quot; 是可选的</span><br></pre></td></tr></table></figure></blockquote><p>7)str.format() 格式化数字</p><blockquote><p><code>print(&quot;{:.2f}&quot;.format(3.1415926))</code></p><blockquote><p><img src="/2017/12/28/python数据类型/format格式化数字字符.png" alt="format格式化数字字符"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">^, &lt;, &gt; 分别是居中、左对齐、右对齐，后面带宽度。</span><br><span class="line"> : 号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。</span><br><span class="line">+号表示在正数前显示 +，负数前显示 -；（空格）表示在正数前加空格。</span><br><span class="line">b、d、o、x 分别是二进制、十进制、八进制、十六进制。</span><br></pre></td></tr></table></figure></p></blockquote></blockquote></blockquote><h3 id="字符串内建函数"><a href="#字符串内建函数" class="headerlink" title="字符串内建函数"></a>字符串内建函数</h3><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">capitalize()</td><td style="text-align:left">将字符串的第一个字符转换为大写</td></tr><tr><td style="text-align:left">center(width, fillchar)</td><td style="text-align:left">返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。</td></tr><tr><td style="text-align:left">count(str, beg= 0,end=len(string))</td><td style="text-align:left">返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</td></tr><tr><td style="text-align:left">bytes.decode(encoding=”utf-8”, errors=”strict”)</td><td style="text-align:left">Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。</td></tr><tr><td style="text-align:left">encode(encoding=’UTF-8’,errors=’strict’)</td><td style="text-align:left">以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</td></tr><tr><td style="text-align:left">endswith(suffix, beg=0, end=len(string))</td><td style="text-align:left">检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</td></tr><tr><td style="text-align:left">expandtabs(tabsize=8)</td><td style="text-align:left">把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。</td></tr><tr><td style="text-align:left">find(str, beg=0 end=len(string))</td><td style="text-align:left">检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1</td></tr><tr><td style="text-align:left">index(str, beg=0, end=len(string))</td><td style="text-align:left">跟find()方法一样，只不过如果str不在字符串中会报一个异常.</td></tr><tr><td style="text-align:left">isalnum()</td><td style="text-align:left">如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True,否则返回 False</td></tr><tr><td style="text-align:left">isalpha()</td><td style="text-align:left">如果字符串至少有一个字符并且所有字符都是字母则返回 True, 否则返回 False</td></tr><tr><td style="text-align:left">isdigit()</td><td style="text-align:left">如果字符串只包含数字则返回 True 否则返回 False..</td></tr><tr><td style="text-align:left">islower()</td><td style="text-align:left">如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</td></tr><tr><td style="text-align:left">isnumeric()</td><td style="text-align:left">如果字符串中只包含数字字符，则返回 True，否则返回 False</td></tr><tr><td style="text-align:left">isspace()</td><td style="text-align:left">如果字符串中只包含空白，则返回 True，否则返回 False.</td></tr><tr><td style="text-align:left">istitle()</td><td style="text-align:left">如果字符串是标题化的(见 title())则返回 True，否则返回 False</td></tr><tr><td style="text-align:left">isupper()</td><td style="text-align:left">如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</td></tr><tr><td style="text-align:left">join(seq)</td><td style="text-align:left">以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</td></tr><tr><td style="text-align:left">len(string)</td><td style="text-align:left">返回字符串长度</td></tr><tr><td style="text-align:left">ljust(width[, fillchar])</td><td style="text-align:left">返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。</td></tr><tr><td style="text-align:left">lower()</td><td style="text-align:left">转换字符串中所有大写字符为小写.</td></tr><tr><td style="text-align:left">lstrip()</td><td style="text-align:left">截掉字符串左边的空格或指定字符。</td></tr><tr><td style="text-align:left">maketrans()</td><td style="text-align:left">创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</td></tr><tr><td style="text-align:left">max(str)</td><td style="text-align:left">返回字符串 str 中最大的字母。</td></tr><tr><td style="text-align:left">min(str)</td><td style="text-align:left">返回字符串 str 中最小的字母。</td></tr><tr><td style="text-align:left">replace(old, new [, max])</td><td style="text-align:left">把旧字符串中的 str1 替换成 str2,如果 max 指定，则替换不超过 max 次。</td></tr><tr><td style="text-align:left">rfind(str, beg=0,end=len(string))</td><td style="text-align:left">类似于 find()函数，不过是从右边开始查找.</td></tr><tr><td style="text-align:left">rindex( str, beg=0, end=len(string))</td><td style="text-align:left">类似于 index()，不过是从右边开始.</td></tr><tr><td style="text-align:left">rjust(width,[, fillchar])</td><td style="text-align:left">返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串</td></tr><tr><td style="text-align:left">rstrip()</td><td style="text-align:left">删除字符串字符串末尾的空格.</td></tr><tr><td style="text-align:left">split(str=””, num=string.count(str))</td><td style="text-align:left">num=string.count(str)) 以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num 个子字符串</td></tr><tr><td style="text-align:left">splitlines([keepends])</td><td style="text-align:left">按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</td></tr><tr><td style="text-align:left">startswith(str, beg=0,end=len(string))</td><td style="text-align:left">检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。</td></tr><tr><td style="text-align:left">strip([chars])</td><td style="text-align:left">在字符串上执行 lstrip()和 rstrip()</td></tr><tr><td style="text-align:left">swapcase()</td><td style="text-align:left">将字符串中大写转换为小写，小写转换为大写</td></tr><tr><td style="text-align:left">title()</td><td style="text-align:left">返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</td></tr><tr><td style="text-align:left">translate(table, deletechars=””)</td><td style="text-align:left">根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中</td></tr><tr><td style="text-align:left">upper()</td><td style="text-align:left">转换字符串中的小写字母为大写</td></tr><tr><td style="text-align:left">zfill (width)</td><td style="text-align:left">返回长度为 width 的字符串，原字符串右对齐，前面填充0</td></tr><tr><td style="text-align:left">isdecimal()</td><td style="text-align:left">检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。</td></tr></tbody></table><h2 id="三、List-列表"><a href="#三、List-列表" class="headerlink" title="三、List [列表]"></a>三、List [列表]</h2><p>1、List写在方括号之间，元素用逗号隔开。<br><code>list = [ &#39;abcd&#39;, 786 , 2.23, &#39;baidu&#39;, 70.2 ]</code><br>2、和字符串一样，list可以被索引和切片。<br><code>print (list[0])</code><br><code>print (list[1:3])</code><br>3、加号（+）是列表连接运算符。<br><code>tinylist = [123, &#39;baidu&#39;]</code><br><code>print (list + tinylist)</code><br>4、星号（*）是重复操作。<br><code>tinylist = [123, &#39;baidu&#39;]</code><br><code>print (tinylist\*2)</code><br>5、List中的元素是可以改变的。<br>6、更新列表<br><code>list = [&#39;Google&#39;, &#39;baidu&#39;, 2000]</code><br><code>list[1] = &#39;firefox&#39;</code><br>7、删除列表元素del<br><code>list = [&#39;Google&#39;, &#39;baidu&#39;, 2000]</code><br><code>del list[2]</code></p><h3 id="列表操作符"><a href="#列表操作符" class="headerlink" title="列表操作符"></a>列表操作符</h3><table><thead><tr><th style="text-align:left">Python表达式</th><th style="text-align:left">结果</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">len([1, 2, 3])</td><td style="text-align:left">3</td><td style="text-align:left">长度</td></tr><tr><td style="text-align:left">[1, 2, 3] + [4, 5, 6]</td><td style="text-align:left">[1, 2, 3, 4, 5, 6]</td><td style="text-align:left">组合</td></tr><tr><td style="text-align:left">[‘Hi!’] * 4</td><td style="text-align:left">[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td><td style="text-align:left">重复</td></tr><tr><td style="text-align:left">3 in [1, 2, 3]</td><td style="text-align:left">TRUE</td><td style="text-align:left">元素是否存在于列表中</td></tr><tr><td style="text-align:left">for x in [1, 2, 3]: print(x, end=” “)</td><td style="text-align:left">1 2 3</td><td style="text-align:left">迭代</td></tr></tbody></table><h3 id="列表函数"><a href="#列表函数" class="headerlink" title="列表函数"></a>列表函数</h3><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">len(list)</td><td style="text-align:left">列表元素个数</td></tr><tr><td style="text-align:left">max(list)</td><td style="text-align:left">返回列表元素最大值</td></tr><tr><td style="text-align:left">min(list)</td><td style="text-align:left">返回列表元素最小值</td></tr><tr><td style="text-align:left">list(seq)</td><td style="text-align:left">将元组转换为列表</td></tr></tbody></table><h3 id="列表方法"><a href="#列表方法" class="headerlink" title="列表方法"></a>列表方法</h3><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">list.append(obj)</td><td style="text-align:left">在列表末尾添加新的对象</td></tr><tr><td style="text-align:left">list.count(obj)</td><td style="text-align:left">统计某个元素在列表中出现的次数</td></tr><tr><td style="text-align:left">list.extend(seq)</td><td style="text-align:left">在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td></tr><tr><td style="text-align:left">list.index(obj)</td><td style="text-align:left">从列表中找出某个值第一个匹配项的索引位置</td></tr><tr><td style="text-align:left">list.insert(index, obj)</td><td style="text-align:left">将对象插入列表</td></tr><tr><td style="text-align:left">list.pop(obj=list[-1])</td><td style="text-align:left">移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td></tr><tr><td style="text-align:left">list.remove(obj)</td><td style="text-align:left">移除列表中某个值的第一个匹配项</td></tr><tr><td style="text-align:left">list.reverse()</td><td style="text-align:left">反向列表中元素</td></tr><tr><td style="text-align:left">list.sort([func])</td><td style="text-align:left">对原列表进行排序</td></tr><tr><td style="text-align:left">list.clear()</td><td style="text-align:left">清空列表</td></tr><tr><td style="text-align:left">list.copy()</td><td style="text-align:left">复制列表</td></tr></tbody></table><h2 id="四、Tuple（元组-）"><a href="#四、Tuple（元组-）" class="headerlink" title="四、Tuple（元组,）"></a>四、Tuple（元组,）</h2><p>1、元组写在小括号()里，元素之间用逗号隔开。<br><code>tuple = (&#39;abcd&#39;, 786 , 2.23, &#39;baidu&#39;, 70.2)</code><br>2、与字符串一样，元组的元素不能修改。<br>3、元组也可以被索引和切片。<br><code>print (tuple[0])</code><br><code>print (tuple[1:3])</code><br>4、注意构造包含0或1个元素的元组的特殊语法规则。<br><code>tup1 = ()</code><br><code>tup2 = (20,)</code><br>5、加号（+）是列表连接运算符。<br><code>tinytuple = (123, &#39;baidu&#39;)</code><br><code>print (tuple + tinytuple)</code><br>6、星号（*）是重复操作。<br><code>tinytuple = [123, &#39;baidu&#39;]</code><br><code>print (tinytuple\*2)</code><br>7、修改元组<br>元组中的元素值是不允许修改的，但我们可以对元组进行连接组合：<br><code>tup1 = (12, 34.56)</code><br><code>tup2 = (&#39;abc&#39;, &#39;xyz&#39;)</code><br><code>tup3 = tup1 + tup2</code><br>8、删除元组<br>元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组：<br><code>tup = (&#39;Google&#39;, &#39;Runoob&#39;, 1997, 2000)</code><br><code>del tup</code></p><h3 id="元组运算符"><a href="#元组运算符" class="headerlink" title="元组运算符"></a>元组运算符</h3><table><thead><tr><th style="text-align:left">Python表达式</th><th style="text-align:left">结果</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">len((1, 2, 3))</td><td style="text-align:left">3</td><td style="text-align:left">计算元素个数</td></tr><tr><td style="text-align:left">(1, 2, 3) + (4, 5, 6)</td><td style="text-align:left">(1, 2, 3, 4, 5, 6)</td><td style="text-align:left">连接</td></tr><tr><td style="text-align:left">(‘Hi!’,) * 4</td><td style="text-align:left">(‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’)</td><td style="text-align:left">复制</td></tr><tr><td style="text-align:left">3 in (1, 2, 3)</td><td style="text-align:left">TRUE</td><td style="text-align:left">元素是否存在</td></tr><tr><td style="text-align:left">for x in (1, 2, 3): print x,</td><td style="text-align:left">1 2 3</td><td style="text-align:left">迭代</td></tr></tbody></table><h3 id="元组内置函数"><a href="#元组内置函数" class="headerlink" title="元组内置函数"></a>元组内置函数</h3><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">len(tuple)</td><td style="text-align:left">计算元组元素个数。</td></tr><tr><td style="text-align:left">max(tuple)</td><td style="text-align:left">返回元组中元素最大值。</td></tr><tr><td style="text-align:left">min(tuple)</td><td style="text-align:left">返回元组中元素最小值。</td></tr><tr><td style="text-align:left">tuple(seq)</td><td style="text-align:left">将列表转换为元组。</td></tr></tbody></table><h2 id="五、Dictionary-‘字’-’典’"><a href="#五、Dictionary-‘字’-’典’" class="headerlink" title="五、Dictionary {‘字’:’典’}"></a>五、Dictionary {‘字’:’典’}</h2><p>1、字典是一种映射类型，字典用”{ }”标识，它是一个无序的键(key) : 值(value)对集合。<br><code>tinydict = {&#39;name&#39;: &#39;baidu&#39;,&#39;code&#39;:1, &#39;site&#39;: &#39;www.baidu.com&#39;}</code><br>2、键(key)必须使用不可变类型，如字符串，数字或元组。<br>3、在同一个字典中，键(key)必须是唯一的。<br>4、创建空字典使用 { }。<br>5、构造函数 dict()可以直接从键值对序列中构建字典。<br><code>dict([(&#39;baidu&#39;, 1), (&#39;Google&#39;, 2), (&#39;Taobao&#39;, 3)])</code><br>6、访问字典里的值。<br><code>dict = {&#39;Name&#39;: &#39;baidu&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;}</code><br><code>print ( dict[&#39;Name&#39;])</code><br>7、修改字典。<br><code>dict = {&#39;Name&#39;:&#39;baidu&#39;,&#39;Age&#39;:&#39;7&#39;,&#39;Class&#39;:&#39;First&#39;}</code><br><code>dict[&#39;Name&#39;] = &#39;google&#39;</code> #更新信息<br><code>dict[&#39;School&#39;] = &#39;QingHua&#39;</code> #增加信息<br>8、删除字典元素。<br><code>dict = {&#39;Name&#39;:&#39;baidu&#39;,&#39;Age&#39;:&#39;7&#39;,&#39;Class&#39;:&#39;First&#39;}</code><br><code>del dict[&#39;Name&#39;]</code> #删除元素<br><code>dict.clear()</code> #清空字典<br><code>del dict</code> #删除字典</p><h3 id="字典内置函数"><a href="#字典内置函数" class="headerlink" title="字典内置函数"></a>字典内置函数</h3><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">len(dict)</td><td style="text-align:left">计算字典元素个数，即键的总数。</td></tr><tr><td style="text-align:left">str(dict)</td><td style="text-align:left">输出字典，以可打印的字符串表示。</td></tr><tr><td style="text-align:left">type(variable)</td><td style="text-align:left">返回输入的变量类型，如果变量是字典就返回字典类型。</td></tr></tbody></table><h3 id="字典内置方法"><a href="#字典内置方法" class="headerlink" title="字典内置方法"></a>字典内置方法</h3><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">radiansdict.clear()</td><td style="text-align:left">删除字典内所有元素</td></tr><tr><td style="text-align:left">radiansdict.copy()</td><td style="text-align:left">返回一个字典的浅复制</td></tr><tr><td style="text-align:left">radiansdict.fromkeys()</td><td style="text-align:left">创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值</td></tr><tr><td style="text-align:left">radiansdict.get(key, default=None)</td><td style="text-align:left">返回指定键的值，如果值不在字典中返回default值</td></tr><tr><td style="text-align:left">key in dict</td><td style="text-align:left">如果键在字典dict里返回true，否则返回false</td></tr><tr><td style="text-align:left">radiansdict.items()</td><td style="text-align:left">以列表返回可遍历的(键, 值) 元组数组</td></tr><tr><td style="text-align:left">radiansdict.keys()</td><td style="text-align:left">以列表返回一个字典所有的键</td></tr><tr><td style="text-align:left">radiansdict.setdefault(key, default=None)</td><td style="text-align:left">和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td></tr><tr><td style="text-align:left">radiansdict.update(dict2)</td><td style="text-align:left">把字典dict2的键/值对更新到dict里</td></tr><tr><td style="text-align:left">radiansdict.values()</td><td style="text-align:left">以列表返回字典中的所有值</td></tr><tr><td style="text-align:left">pop(key[,default])</td><td style="text-align:left">删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</td></tr><tr><td style="text-align:left">popitem()</td><td style="text-align:left">随机返回并删除字典中的一对键和值(一般删除末尾对)。</td></tr></tbody></table><h2 id="六、Set-集合"><a href="#六、Set-集合" class="headerlink" title="六、Set {集合}"></a>六、Set {集合}</h2><p>1、集合（set）是一个无序不重复元素的序列。<br><code>student = {&#39;Tom&#39;, &#39;Jim&#39;, &#39;Mary&#39;, &#39;Tom&#39;, &#39;Jack&#39;, &#39;Rose&#39;}</code><br><code>print(student)</code> # 重复的元素被自动去掉<br>2、可以使用大括号{ }或者set()函数创建集合。<br><code>parame = {value01,value02,...}</code><br><code>set(value)</code><br>3、创建一个空集合必须用set()，而不是{ }，因为 { } 是用来创建一个空字典。<br><code>set()</code></p><h3 id="python数据类型转换"><a href="#python数据类型转换" class="headerlink" title="python数据类型转换"></a>python数据类型转换</h3><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">int(x [,base])</td><td style="text-align:left">将x转换为一个整数</td></tr><tr><td style="text-align:left">float(x)</td><td style="text-align:left">将x转换到一个浮点数</td></tr><tr><td style="text-align:left">complex(real [,imag])</td><td style="text-align:left">创建一个复数</td></tr><tr><td style="text-align:left">str(x)</td><td style="text-align:left">将对象 x 转换为字符串</td></tr><tr><td style="text-align:left">repr(x)</td><td style="text-align:left">将对象 x 转换为表达式字符串</td></tr><tr><td style="text-align:left">eval(str)</td><td style="text-align:left">用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td style="text-align:left">tuple(s)</td><td style="text-align:left">将序列 s 转换为一个元组</td></tr><tr><td style="text-align:left">list(s)</td><td style="text-align:left">将序列 s 转换为一个列表</td></tr><tr><td style="text-align:left">set(s)</td><td style="text-align:left">转换为可变集合</td></tr><tr><td style="text-align:left">dict(d)</td><td style="text-align:left">创建一个字典。d 必须是一个序列 (key,value)元组。</td></tr><tr><td style="text-align:left">frozenset(s)</td><td style="text-align:left">转换为不可变集合</td></tr><tr><td style="text-align:left">chr(x)</td><td style="text-align:left">将一个整数转换为一个字符</td></tr><tr><td style="text-align:left">ord(x)</td><td style="text-align:left">将一个字符转换为它的整数值</td></tr><tr><td style="text-align:left">hex(x)</td><td style="text-align:left">将一个整数转换为一个十六进制字符串</td></tr><tr><td style="text-align:left">oct(x)</td><td style="text-align:left">将一个整数转换为一个八进制字符串</td></tr></tbody></table><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a>持续更新…</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生苦短，我用python。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://pythonfood.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://pythonfood.github.io/tags/python/"/>
    
  </entry>
  
</feed>
