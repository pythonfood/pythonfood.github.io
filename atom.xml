<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PythonFood</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://pythonfood.github.io/"/>
  <updated>2018-02-28T07:10:54.877Z</updated>
  <id>http://pythonfood.github.io/</id>
  
  <author>
    <name>Python Food</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>appium键值表</title>
    <link href="http://pythonfood.github.io/2018/02/01/appium%E9%94%AE%E5%80%BC%E8%A1%A8/"/>
    <id>http://pythonfood.github.io/2018/02/01/appium键值表/</id>
    <published>2018-02-01T04:00:00.000Z</published>
    <updated>2018-02-28T07:10:54.877Z</updated>
    
    <content type="html"><![CDATA[<p>appium键值表查询。<br><a id="more"></a></p><h3 id="1-电话键"><a href="#1-电话键" class="headerlink" title="1.电话键"></a>1.电话键</h3><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th><th style="text-align:left">键值</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_CALL</td><td style="text-align:left">拨号键</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left">KEYCODE_ENDCALL</td><td style="text-align:left">挂机键</td><td style="text-align:left">6</td></tr><tr><td style="text-align:left">KEYCODE_HOME</td><td style="text-align:left">按键Home</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">KEYCODE_MENU</td><td style="text-align:left">菜单键</td><td style="text-align:left">82</td></tr><tr><td style="text-align:left">KEYCODE_BACK</td><td style="text-align:left">返回键</td><td style="text-align:left">4</td></tr><tr><td style="text-align:left">KEYCODE_SEARCH</td><td style="text-align:left">搜索键</td><td style="text-align:left">84</td></tr><tr><td style="text-align:left">KEYCODE_CAMERA</td><td style="text-align:left">拍照键</td><td style="text-align:left">27</td></tr><tr><td style="text-align:left">KEYCODE_FOCUS</td><td style="text-align:left">拍照对焦键</td><td style="text-align:left">80</td></tr><tr><td style="text-align:left">KEYCODE_POWER</td><td style="text-align:left">电源键</td><td style="text-align:left">26</td></tr><tr><td style="text-align:left">KEYCODE_NOTIFICATION</td><td style="text-align:left">通知键</td><td style="text-align:left">83</td></tr><tr><td style="text-align:left">KEYCODE_MUTE</td><td style="text-align:left">话筒静音键</td><td style="text-align:left">91</td></tr><tr><td style="text-align:left">KEYCODE_VOLUME_MUTE</td><td style="text-align:left">扬声器静音键</td><td style="text-align:left">164</td></tr><tr><td style="text-align:left">KEYCODE_VOLUME_UP</td><td style="text-align:left">音量增加键</td><td style="text-align:left">24</td></tr><tr><td style="text-align:left">KEYCODE_VOLUME_DOWN</td><td style="text-align:left">音量减小键</td><td style="text-align:left">25</td></tr></tbody></table><h3 id="2-控制键"><a href="#2-控制键" class="headerlink" title="2.控制键"></a>2.控制键</h3><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th><th style="text-align:left">键值</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_ENTER</td><td style="text-align:left">回车键</td><td style="text-align:left">66</td></tr><tr><td style="text-align:left">KEYCODE_ESCAPE</td><td style="text-align:left">ESC键</td><td style="text-align:left">111</td></tr><tr><td style="text-align:left">KEYCODE_DPAD_CENTER</td><td style="text-align:left">导航键 确定键</td><td style="text-align:left">23</td></tr><tr><td style="text-align:left">KEYCODE_DPAD_UP</td><td style="text-align:left">导航键 向上</td><td style="text-align:left">19</td></tr><tr><td style="text-align:left">KEYCODE_DPAD_DOWN</td><td style="text-align:left">导航键 向下</td><td style="text-align:left">20</td></tr><tr><td style="text-align:left">KEYCODE_DPAD_LEFT</td><td style="text-align:left">导航键 向左</td><td style="text-align:left">21</td></tr><tr><td style="text-align:left">KEYCODE_DPAD_RIGHT</td><td style="text-align:left">导航键 向右</td><td style="text-align:left">22</td></tr><tr><td style="text-align:left">KEYCODE_MOVE_HOME</td><td style="text-align:left">光标移动到开始键</td><td style="text-align:left">122</td></tr><tr><td style="text-align:left">KEYCODE_MOVE_END</td><td style="text-align:left">光标移动到末尾键</td><td style="text-align:left">123</td></tr><tr><td style="text-align:left">KEYCODE_PAGE_UP</td><td style="text-align:left">向上翻页键</td><td style="text-align:left">92</td></tr><tr><td style="text-align:left">KEYCODE_PAGE_DOWN</td><td style="text-align:left">向下翻页键</td><td style="text-align:left">93</td></tr><tr><td style="text-align:left">KEYCODE_DEL</td><td style="text-align:left">退格键</td><td style="text-align:left">67</td></tr><tr><td style="text-align:left">KEYCODE_FORWARD_DEL</td><td style="text-align:left">删除键</td><td style="text-align:left">112</td></tr><tr><td style="text-align:left">KEYCODE_INSERT</td><td style="text-align:left">插入键</td><td style="text-align:left">124</td></tr><tr><td style="text-align:left">KEYCODE_TAB</td><td style="text-align:left">Tab键</td><td style="text-align:left">61</td></tr><tr><td style="text-align:left">KEYCODE_NUM_LOCK</td><td style="text-align:left">小键盘锁</td><td style="text-align:left">143</td></tr><tr><td style="text-align:left">KEYCODE_CAPS_LOCK</td><td style="text-align:left">大写锁定键</td><td style="text-align:left">115</td></tr><tr><td style="text-align:left">KEYCODE_BREAK</td><td style="text-align:left">Break/Pause键</td><td style="text-align:left">121</td></tr><tr><td style="text-align:left">KEYCODE_SCROLL_LOCK</td><td style="text-align:left">滚动锁定键</td><td style="text-align:left">116</td></tr><tr><td style="text-align:left">KEYCODE_ZOOM_IN</td><td style="text-align:left">放大键</td><td style="text-align:left">168</td></tr><tr><td style="text-align:left">KEYCODE_ZOOM_OUT</td><td style="text-align:left">缩小键</td><td style="text-align:left">169</td></tr></tbody></table><h3 id="3-组合键"><a href="#3-组合键" class="headerlink" title="3.组合键"></a>3.组合键</h3><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_ALT_LEFT</td><td style="text-align:left">Alt+Left</td></tr><tr><td style="text-align:left">KEYCODE_ALT_RIGHT</td><td style="text-align:left">Alt+Right</td></tr><tr><td style="text-align:left">KEYCODE_CTRL_LEFT</td><td style="text-align:left">Control+Left</td></tr><tr><td style="text-align:left">KEYCODE_CTRL_RIGHT</td><td style="text-align:left">Control+Right</td></tr><tr><td style="text-align:left">KEYCODE_SHIFT_LEFT</td><td style="text-align:left">Shift+Left</td></tr><tr><td style="text-align:left">KEYCODE_SHIFT_RIGHT</td><td style="text-align:left">Shift+Right</td></tr></tbody></table><h3 id="4-基本键"><a href="#4-基本键" class="headerlink" title="4.基本键"></a>4.基本键</h3><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th><th style="text-align:left">键值</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_0</td><td style="text-align:left">按键’0’</td><td style="text-align:left">7</td></tr><tr><td style="text-align:left">KEYCODE_1</td><td style="text-align:left">按键’1’</td><td style="text-align:left">8</td></tr><tr><td style="text-align:left">KEYCODE_2</td><td style="text-align:left">按键’2’</td><td style="text-align:left">9</td></tr><tr><td style="text-align:left">KEYCODE_3</td><td style="text-align:left">按键’3’</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">KEYCODE_4</td><td style="text-align:left">按键’4’</td><td style="text-align:left">11</td></tr><tr><td style="text-align:left">KEYCODE_5</td><td style="text-align:left">按键’5’</td><td style="text-align:left">12</td></tr><tr><td style="text-align:left">KEYCODE_6</td><td style="text-align:left">按键’6’</td><td style="text-align:left">13</td></tr><tr><td style="text-align:left">KEYCODE_7</td><td style="text-align:left">按键’7’</td><td style="text-align:left">14</td></tr><tr><td style="text-align:left">KEYCODE_8</td><td style="text-align:left">按键’8’</td><td style="text-align:left">15</td></tr><tr><td style="text-align:left">KEYCODE_9</td><td style="text-align:left">按键’9’</td><td style="text-align:left">16</td></tr><tr><td style="text-align:left">KEYCODE_A</td><td style="text-align:left">按键’A’</td><td style="text-align:left">29</td></tr><tr><td style="text-align:left">KEYCODE_B</td><td style="text-align:left">按键’B’</td><td style="text-align:left">30</td></tr><tr><td style="text-align:left">KEYCODE_C</td><td style="text-align:left">按键’C’</td><td style="text-align:left">31</td></tr><tr><td style="text-align:left">KEYCODE_D</td><td style="text-align:left">按键’D’</td><td style="text-align:left">32</td></tr><tr><td style="text-align:left">KEYCODE_E</td><td style="text-align:left">按键’E’</td><td style="text-align:left">33</td></tr><tr><td style="text-align:left">KEYCODE_F</td><td style="text-align:left">按键’F’</td><td style="text-align:left">34</td></tr><tr><td style="text-align:left">KEYCODE_G</td><td style="text-align:left">按键’G’</td><td style="text-align:left">35</td></tr><tr><td style="text-align:left">KEYCODE_H</td><td style="text-align:left">按键’H’</td><td style="text-align:left">36</td></tr><tr><td style="text-align:left">KEYCODE_I</td><td style="text-align:left">按键’I’</td><td style="text-align:left">37</td></tr><tr><td style="text-align:left">KEYCODE_J</td><td style="text-align:left">按键’J’</td><td style="text-align:left">38</td></tr><tr><td style="text-align:left">KEYCODE_K</td><td style="text-align:left">按键’K’</td><td style="text-align:left">39</td></tr><tr><td style="text-align:left">KEYCODE_L</td><td style="text-align:left">按键’L’</td><td style="text-align:left">40</td></tr><tr><td style="text-align:left">KEYCODE_M</td><td style="text-align:left">按键’M’</td><td style="text-align:left">41</td></tr><tr><td style="text-align:left">KEYCODE_N</td><td style="text-align:left">按键’N’</td><td style="text-align:left">42</td></tr><tr><td style="text-align:left">KEYCODE_O</td><td style="text-align:left">按键’O’</td><td style="text-align:left">43</td></tr><tr><td style="text-align:left">KEYCODE_P</td><td style="text-align:left">按键’P’</td><td style="text-align:left">44</td></tr><tr><td style="text-align:left">KEYCODE_Q</td><td style="text-align:left">按键’Q’</td><td style="text-align:left">45</td></tr><tr><td style="text-align:left">KEYCODE_R</td><td style="text-align:left">按键’R’</td><td style="text-align:left">46</td></tr><tr><td style="text-align:left">KEYCODE_S</td><td style="text-align:left">按键’S’</td><td style="text-align:left">47</td></tr><tr><td style="text-align:left">KEYCODE_T</td><td style="text-align:left">按键’T’</td><td style="text-align:left">48</td></tr><tr><td style="text-align:left">KEYCODE_U</td><td style="text-align:left">按键’U’</td><td style="text-align:left">49</td></tr><tr><td style="text-align:left">KEYCODE_V</td><td style="text-align:left">按键’V’</td><td style="text-align:left">50</td></tr><tr><td style="text-align:left">KEYCODE_W</td><td style="text-align:left">按键’W’</td><td style="text-align:left">51</td></tr><tr><td style="text-align:left">KEYCODE_X</td><td style="text-align:left">按键’X’</td><td style="text-align:left">52</td></tr><tr><td style="text-align:left">KEYCODE_Y</td><td style="text-align:left">按键’Y’</td><td style="text-align:left">53</td></tr><tr><td style="text-align:left">KEYCODE_Z</td><td style="text-align:left">按键’Z’</td><td style="text-align:left">54</td></tr></tbody></table><h3 id="5-符号键"><a href="#5-符号键" class="headerlink" title="5.符号键"></a>5.符号键</h3><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_PLUS</td><td style="text-align:left">按键’+’</td></tr><tr><td style="text-align:left">KEYCODE_MINUS</td><td style="text-align:left">按键’-‘</td></tr><tr><td style="text-align:left">KEYCODE_STAR</td><td style="text-align:left">按键’*’</td></tr><tr><td style="text-align:left">KEYCODE_SLASH</td><td style="text-align:left">按键’/‘</td></tr><tr><td style="text-align:left">KEYCODE_EQUALS</td><td style="text-align:left">按键’=’</td></tr><tr><td style="text-align:left">KEYCODE_AT</td><td style="text-align:left">按键’@’</td></tr><tr><td style="text-align:left">KEYCODE_POUND</td><td style="text-align:left">按键’#’</td></tr><tr><td style="text-align:left">KEYCODE_APOSTROPHE</td><td style="text-align:left">按键’’’ (单引号)</td></tr><tr><td style="text-align:left">KEYCODE_BACKSLASH</td><td style="text-align:left">按键’\’</td></tr><tr><td style="text-align:left">KEYCODE_COMMA</td><td style="text-align:left">按键’,’</td></tr><tr><td style="text-align:left">KEYCODE_PERIOD</td><td style="text-align:left">按键’.’</td></tr><tr><td style="text-align:left">KEYCODE_LEFT_BRACKET</td><td style="text-align:left">按键’[‘</td></tr><tr><td style="text-align:left">KEYCODE_RIGHT_BRACKET</td><td style="text-align:left">按键’]’</td></tr><tr><td style="text-align:left">KEYCODE_SEMICOLON</td><td style="text-align:left">按键’;’</td></tr><tr><td style="text-align:left">KEYCODE_GRAVE</td><td style="text-align:left">按键’`’</td></tr><tr><td style="text-align:left">KEYCODE_SPACE</td><td style="text-align:left">空格键</td></tr></tbody></table><h3 id="6-小键盘"><a href="#6-小键盘" class="headerlink" title="6.小键盘"></a>6.小键盘</h3><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_NUMPAD_0</td><td style="text-align:left">小键盘按键’0’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_1</td><td style="text-align:left">小键盘按键’1’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_2</td><td style="text-align:left">小键盘按键’2’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_3</td><td style="text-align:left">小键盘按键’3’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_4</td><td style="text-align:left">小键盘按键’4’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_5</td><td style="text-align:left">小键盘按键’5’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_6</td><td style="text-align:left">小键盘按键’6’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_7</td><td style="text-align:left">小键盘按键’7’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_8</td><td style="text-align:left">小键盘按键’8’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_9</td><td style="text-align:left">小键盘按键’9’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_ADD</td><td style="text-align:left">小键盘按键’+’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_SUBTRACT</td><td style="text-align:left">小键盘按键’-‘</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_MULTIPLY</td><td style="text-align:left">小键盘按键’*’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_DIVIDE</td><td style="text-align:left">小键盘按键’/‘</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_EQUALS</td><td style="text-align:left">小键盘按键’=’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_COMMA</td><td style="text-align:left">小键盘按键’,’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_DOT</td><td style="text-align:left">小键盘按键’.’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_LEFT_PAREN</td><td style="text-align:left">小键盘按键’(‘</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_RIGHT_PAREN</td><td style="text-align:left">小键盘按键’)’</td></tr><tr><td style="text-align:left">KEYCODE_NUMPAD_ENTER</td><td style="text-align:left">小键盘按键回车</td></tr></tbody></table><h3 id="7-功能键"><a href="#7-功能键" class="headerlink" title="7.功能键"></a>7.功能键</h3><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_F1</td><td style="text-align:left">按键F1</td></tr><tr><td style="text-align:left">KEYCODE_F2</td><td style="text-align:left">按键F2</td></tr><tr><td style="text-align:left">KEYCODE_F3</td><td style="text-align:left">按键F3</td></tr><tr><td style="text-align:left">KEYCODE_F4</td><td style="text-align:left">按键F4</td></tr><tr><td style="text-align:left">KEYCODE_F5</td><td style="text-align:left">按键F5</td></tr><tr><td style="text-align:left">KEYCODE_F6</td><td style="text-align:left">按键F6</td></tr><tr><td style="text-align:left">KEYCODE_F7</td><td style="text-align:left">按键F7</td></tr><tr><td style="text-align:left">KEYCODE_F8</td><td style="text-align:left">按键F8</td></tr><tr><td style="text-align:left">KEYCODE_F9</td><td style="text-align:left">按键F9</td></tr><tr><td style="text-align:left">KEYCODE_F10</td><td style="text-align:left">按键F10</td></tr><tr><td style="text-align:left">KEYCODE_F11</td><td style="text-align:left">按键F11</td></tr><tr><td style="text-align:left">KEYCODE_F12</td><td style="text-align:left">按键F12</td></tr></tbody></table><h3 id="8-多媒体键"><a href="#8-多媒体键" class="headerlink" title="8.多媒体键"></a>8.多媒体键</h3><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_MEDIA_PLAY</td><td style="text-align:left">播放</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_STOP</td><td style="text-align:left">停止</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_PAUSE</td><td style="text-align:left">暂停</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_PLAY_PAUSE</td><td style="text-align:left">播放/暂停</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_FAST_FORWARD</td><td style="text-align:left">快进</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_REWIND</td><td style="text-align:left">快退</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_NEXT</td><td style="text-align:left">下一首</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_PREVIOUS</td><td style="text-align:left">上一首</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_CLOSE</td><td style="text-align:left">关闭</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_EJECT</td><td style="text-align:left">弹出</td></tr><tr><td style="text-align:left">KEYCODE_MEDIA_RECORD</td><td style="text-align:left">录音</td></tr></tbody></table><h3 id="9-手柄按键"><a href="#9-手柄按键" class="headerlink" title="9.手柄按键"></a>9.手柄按键</h3><table><thead><tr><th style="text-align:left">键名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">KEYCODE_BUTTON_1</td><td style="text-align:left">通用游戏手柄按钮 #1</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_2</td><td style="text-align:left">通用游戏手柄按钮 #2</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_3</td><td style="text-align:left">通用游戏手柄按钮 #3</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_4</td><td style="text-align:left">通用游戏手柄按钮 #4</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_5</td><td style="text-align:left">通用游戏手柄按钮 #5</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_6</td><td style="text-align:left">通用游戏手柄按钮 #6</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_7</td><td style="text-align:left">通用游戏手柄按钮 #7</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_8</td><td style="text-align:left">通用游戏手柄按钮 #8</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_9</td><td style="text-align:left">通用游戏手柄按钮 #9</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_10</td><td style="text-align:left">通用游戏手柄按钮 #10</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_11</td><td style="text-align:left">通用游戏手柄按钮 #11</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_12</td><td style="text-align:left">通用游戏手柄按钮 #12</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_13</td><td style="text-align:left">通用游戏手柄按钮 #13</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_14</td><td style="text-align:left">通用游戏手柄按钮 #14</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_15</td><td style="text-align:left">通用游戏手柄按钮 #15</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_16</td><td style="text-align:left">通用游戏手柄按钮 #16</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_A</td><td style="text-align:left">游戏手柄按钮 A</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_B</td><td style="text-align:left">游戏手柄按钮 B</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_C</td><td style="text-align:left">游戏手柄按钮 C</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_X</td><td style="text-align:left">游戏手柄按钮 X</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_Y</td><td style="text-align:left">游戏手柄按钮 Y</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_Z</td><td style="text-align:left">游戏手柄按钮 Z</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_L1</td><td style="text-align:left">游戏手柄按钮 L1</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_L2</td><td style="text-align:left">游戏手柄按钮 L2</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_R1</td><td style="text-align:left">游戏手柄按钮 R1</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_R2</td><td style="text-align:left">游戏手柄按钮 R2</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_MODE</td><td style="text-align:left">游戏手柄按钮 Mode</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_SELECT</td><td style="text-align:left">游戏手柄按钮 Select</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_START</td><td style="text-align:left">游戏手柄按钮 Start</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_THUMBL</td><td style="text-align:left">Left Thumb Button</td></tr><tr><td style="text-align:left">KEYCODE_BUTTON_THUMBR</td><td style="text-align:left">Right Thumb Button</td></tr></tbody></table><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;appium键值表查询。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="appium" scheme="http://pythonfood.github.io/categories/appium/"/>
    
    
      <category term="appium" scheme="http://pythonfood.github.io/tags/appium/"/>
    
  </entry>
  
  <entry>
    <title>appium常用API</title>
    <link href="http://pythonfood.github.io/2018/02/01/appium%E5%B8%B8%E7%94%A8API/"/>
    <id>http://pythonfood.github.io/2018/02/01/appium常用API/</id>
    <published>2018-02-01T03:00:00.000Z</published>
    <updated>2018-02-28T06:24:02.379Z</updated>
    
    <content type="html"><![CDATA[<p>appium常用API笔记。<br><a id="more"></a></p><h3 id="1-元素定位"><a href="#1-元素定位" class="headerlink" title="1.元素定位"></a>1.元素定位</h3><p>(1)id定位<br>find_element_by_id(“resrouce-id”)</p><blockquote><p><code>driver.find_element_by_id(&#39;com.android.calculator2:id/digit8&#39;)</code></p></blockquote><p>(2)name定位<br>find_element_by_name(“text”)</p><blockquote><p><code>driver.find_element_by_name(&quot;昵称&quot;)</code></p></blockquote><p>(3)class_name定位<br>find_element_by_class_name(“class”)</p><blockquote><p><code>driver.find_element_by_class_name(&quot;android.widget.Button&quot;)</code></p></blockquote><p>(4)accessibility_id定位<br>find_element_by_accessibility_id(“content-desc”)</p><blockquote><p><code>driver.find_element_by_accessibility_id(&quot;delete&quot;)</code></p></blockquote><p>(5)xpath定位<br>find_element_by_xpath(“xpath”)</p><blockquote><p><code>driver.find_element_by_xpath(&quot;//android.widget.Button[@text=&#39;8&#39;]&quot;)</code></p></blockquote><p>(6)uiautomator定位<br>find_element_by_android_uiautomator(uia_string)<br>uiautomator可以针对resourceid、Text、description、class、package、index、instance等进行定位。</p><blockquote><p>1)resourceId方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().resourceId(&quot;%s&quot;)&#39;)</code></p></blockquote><p>2)text方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().text(&quot;%s&quot;)&#39;)</code></p></blockquote><p>3)description方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().description(&quot;%s&quot;)&#39;)</code></p></blockquote><p>4)className方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().className(&quot;%s&quot;)&#39;)</code></p></blockquote><p>5)packageName方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().packageName(&quot;%s&quot;)&#39;)</code></p></blockquote><p>6)index方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().index(&quot;%s&quot;)&#39;)</code></p></blockquote><p>7)instance方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().instance(&quot;%s&quot;)&#39;)</code></p></blockquote><p>8)className+index方式</p><blockquote><p><code>driver.find_element_by_android_uiautomator(&#39;new UiSelector().className(&quot;%s&quot;).childSelector(new UiSelector().index(&quot;%d&quot;))&#39;)</code></p></blockquote><p>9)伪xpath方法定位</p><blockquote><p>a.通过同级元素定位同级元素</p><blockquote><p><code>driver.find_element_by_android_uiautomator(‘new UiSelector().text(&quot;Custom View&quot;).fromParent(new UiSelector().text(&quot;Accessibility Service&quot;))‘).click()</code>            </p></blockquote><p>b.通过父级元素定位子集元素</p><blockquote><p><code>driver.find_element_by_android_uiautomator(‘new UiSelector().className(&quot;android.widget.ListView&quot;).childSelector(new UiSelector().text(&quot;Custom View&quot;))‘).click()</code>  </p></blockquote></blockquote></blockquote><p>(7)用By定位</p><ul><li>By.ID   #相当于by_id</li><li>By.NAME   #相当于by_name</li><li>By.CLASS_NAME  #相当于by_class_name</li><li>By.ACCESSIBILITY_ID  #相当于by_accessibility_id</li><li>By.XPATH   #相当于by_xpath</li></ul><blockquote><p><code>find_element(By.ID,&quot;com.android.calculator2:id/digit8&quot;)</code></p></blockquote><h3 id="2-应用操作"><a href="#2-应用操作" class="headerlink" title="2.应用操作"></a>2.应用操作</h3><p>(1)安装应用<br><code>installApp()</code> #安装应用到设备中去。需要apk包的路径。</p><blockquote><p><code>driver.installApp(&quot;path/to/my.apk&quot;)</code><br><code>driver.installApp(&quot;D:\\android\\apk\\ContactManager.apk&quot;)</code></p></blockquote><p>(2)卸载应用<br><code>remove_app()</code> #从设备中删除一个应用。</p><blockquote><p><code>driver.remove_app(&quot;com.example.android.apis&quot;)</code></p></blockquote><p>(3)关闭应用<br><code>close_app()</code> #关闭打开的应用，默认关闭当前打开的应用，所以不需要入参。相当于按home键将应用置于后台，可以通过launch_app()再次启动。</p><blockquote><p><code>driver.close_app()</code></p></blockquote><p>(4)启动应用<br><code>launch_app()</code> #该方法需要配合close_app()使用的。</p><blockquote><p><code>driver.launch_app()</code></p></blockquote><p>(5)检查应用是否安装<br><code>is_app_installed()</code> #检查应用是否已经安装。需要传参应用包的名字。返回结果为Ture或False。</p><blockquote><p><code>driver.is_app_installed(&#39;com.example.android.apis&#39;)</code></p></blockquote><p>(6)将应用置于后台<br><code>background_app()</code> #将当前活跃的应用程序发送到后台。这个方法需要入参，需要指定应用置于后台的时长。</p><blockquote><p><code>driver.background_app(2)</code></p></blockquote><p>(7)应用重置<br><code>reset_app()</code> #重置当前被测程序到出始化状态。该方法不需要入参。</p><blockquote><p><code>driver.reset_app()</code></p></blockquote><p>(8)启动activity<br><code>start_activity()</code> #启动一个app或者在当前app中打开一个新的activity，仅适用于android。</p><blockquote><p><code>driver.start_activity(&#39;com.example.android.apis&#39;, &#39;.Foo&#39;)</code></p></blockquote><h3 id="3-键盘操作"><a href="#3-键盘操作" class="headerlink" title="3.键盘操作"></a>3.键盘操作</h3><p>ps：<a href="https://pythonfood.github.io/2018/02/01/appium键值表/#more">appium键值表</a><br>(1)send_keys()方法</p><blockquote><p><code>driver.find_element_by_name(“Name”).send_keys(&quot;jack&quot;)</code></p></blockquote><p>(2)keyevent()方法</p><blockquote><p><code>`driver.keyevent(4)</code> #点击Android的返回键`</p></blockquote><p>(3)press_keycode()方法</p><blockquote><p><code>driver.press_keycode(3)</code> #点击Android的HOME键</p></blockquote><p>(4)long_press_keycode()方法</p><blockquote><p><code>driver.long_press_keycode(4)</code> #长按Android的返回键</p></blockquote><p>(5)隐藏键盘</p><blockquote><p><code>driver.hide_keyboard()</code> #android不需要参数，ios需要传参key_name</p></blockquote><h3 id="4-TouchAction操作"><a href="#4-TouchAction操作" class="headerlink" title="4.TouchAction操作"></a>4.TouchAction操作</h3><p>使用前导入TouchAction模块<code>from appium.webdriver.common.touch_action import TouchAction</code><br>(1)点击<br><code>tap(self,el=None,x=None,y=None,count=1)</code><br>(2)短按<br><code>press(self, el=None, x=None, y=None)</code><br>(3)长按<br><code>long_press(self, el=None, x=None, y=None, duration=1000(ms))</code><br>(4)释放<br><code>release(self)</code><br>(5)移动到<br><code>move_to(self,el=None,x=None,y=None)</code><br>(6)等待<br><code>wait(self,ms=0)</code><br>(7)执行<br><code>perform(self)</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#关于perform官网给的伪代码中讲</span><br><span class="line">TouchAction().tap(el).perform()</span><br><span class="line">#与</span><br><span class="line">driver.perform(TouchAction().tap(el))</span><br><span class="line">#效果一致</span><br></pre></td></tr></table></figure></blockquote><p>(8)多点触控<br><code>MultiTouch()</code> #多点触控,它只提供了两个方法:一个<code>add()</code>、一个执行<code>perform()</code>。<br>使用前导入MultiAction模块<code>from appium.webdriver.common.multi_action import MultiAction</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from appium.webdriver.common.touch_action import TouchAction</span><br><span class="line">from appium.webdriver.common.multi_action import MultiAction</span><br><span class="line"></span><br><span class="line">action0 = TouchAction().tap(el1)</span><br><span class="line">action1 = TouchAction().tap(el2)</span><br><span class="line">MultiTouch().add(action0).add(action1).perform()</span><br></pre></td></tr></table></figure></blockquote><h3 id="5-上下文操作"><a href="#5-上下文操作" class="headerlink" title="5.上下文操作"></a>5.上下文操作</h3><p>(1)当前会话中的所有上下文，使用后可以识别H5页面的控件<br><code>driver.contexts</code></p><blockquote><p>获取的是一个list列表：</p><blockquote><ul><li>NATIVE_APP:这个就是native，也就是原生的</li><li>WEBVIEW_com.xxxx :这个就是webview</li></ul></blockquote></blockquote><p>(2)当前会话的当前上下文<br><code>driver.current_context</code><br>(3)切换上下文<br><code>driver.switch_to.context(&quot;content_str&quot;)</code></p><blockquote><p>1)切换到webview</p><blockquote><p>方法一：<code>driver.switch_to.context(&#39;webview的context&#39;)</code><br>方法二：<code>driver.switch_to.context(contexts[1])</code> #从contexts列表里取第二个参数</p></blockquote><p>2)切回native</p><blockquote><p>方法一：<code>driver.switch_to.context(&quot;NATIVE_APP&quot;)</code> #这个NATIVE_APP是固定的参数<br>方法二：<code>driver.switch_to.context(contexts[0])</code> #从contexts列表里取第一个参数</p></blockquote></blockquote><p>(4)应用的字符串<br><code>driver.app_strings</code></p><h3 id="6-屏幕操作"><a href="#6-屏幕操作" class="headerlink" title="6.屏幕操作"></a>6.屏幕操作</h3><p>(1)点击<br>1)<code>click()</code></p><blockquote><p><code>driver.find_element_by_id(&quot;com.wuba.zhuanzhuan:id/ae8&quot;).click()</code></p></blockquote><p>2)<code>driver.tap()</code></p><blockquote><p><code>driver.tap([(216,1776)],200)</code></p></blockquote><p>(2)滑动<br><code>driver.swipe(x1, y1, x2, y2,duration)</code> #从坐标(x1,x2)滑动到坐标(x2,y2)，duration非必填项，滑动时间</p><blockquote><p>一个向上下左右滑动的方法封装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#获得屏幕大小宽和高</span><br><span class="line">def getSize(driver):</span><br><span class="line">    x = driver.get_window_size()[&apos;width&apos;]</span><br><span class="line">    y = driver.get_window_size()[&apos;height&apos;]</span><br><span class="line">    return (x, y)</span><br><span class="line"></span><br><span class="line">#屏幕向上滑动</span><br><span class="line">def swipeUp(driver,t=1000):</span><br><span class="line">    l = getSize(driver)</span><br><span class="line">    x1 = int(l[0] * 0.5)    #x坐标</span><br><span class="line">    y1 = int(l[1] * 0.75)   #起始y坐标</span><br><span class="line">    y2 = int(l[1] * 0.25)   #终点y坐标</span><br><span class="line">    driver.swipe(x1, y1, x1, y2,t)</span><br><span class="line"></span><br><span class="line">#屏幕向下滑动</span><br><span class="line">def swipeDown(driver,t=1000):</span><br><span class="line">    l = getSize(driver)</span><br><span class="line">    x1 = int(l[0] * 0.5)  #x坐标</span><br><span class="line">    y1 = int(l[1] * 0.25)   #起始y坐标</span><br><span class="line">    y2 = int(l[1] * 0.75)   #终点y坐标</span><br><span class="line">    driver.swipe(x1, y1, x1, y2,t)</span><br><span class="line">#屏幕向左滑动</span><br><span class="line">def swipLeft(driver,t):</span><br><span class="line">    l=getSize(driver)</span><br><span class="line">    x1=int(l[0]*0.75)</span><br><span class="line">    y1=int(l[1]*0.5)</span><br><span class="line">    x2=int(l[0]*0.05)</span><br><span class="line">    driver.swipe(x1,y1,x2,y1,t)</span><br><span class="line">#屏幕向右滑动</span><br><span class="line">def swipRight(driver,t=1000):</span><br><span class="line">    l=getSize(driver)</span><br><span class="line">    x1=int(l[0]*0.05)</span><br><span class="line">    y1=int(l[1]*0.5)</span><br><span class="line">    x2=int(l[0]*0.75)</span><br><span class="line">    driver.swipe(x1,y1,x2,y1,t)</span><br><span class="line"> </span><br><span class="line">#调用向下滑动的方法</span><br><span class="line">swipeDown(driver)</span><br></pre></td></tr></table></figure></p></blockquote><p>(3)滚动<br><code>driver.scroll(origin_el,destination_el)</code></p><p>(4)拖动<br><code>driver.drag_and_drop(el1,el2)</code></p><p>(5)快速滑动<br><code>driver.flick(start_x, start_y, end_x, end_y)</code></p><p>(6)缩小<br><code>driver.pinch(element)</code></p><p>(7)放大<br><code>driver.zoom(element)</code></p><p>(8)锁屏<br><code>driver.lock()</code> #android不需要传参，ios可以传参锁屏多少秒</p><p>(9)截屏<br><code>get_screenshot_as_file()</code></p><blockquote><p><code>driver.get_screenshot_as_file(&#39;../screenshot/foo.png&#39;)</code>#保存的图片路径和名称</p></blockquote><p>(10)屏幕旋转<br><code>rotate(ScreenOrientation orientation)</code></p><ul><li>landscape：限制界面为横屏，旋转屏幕也不会改变当前状态。</li><li>portrait：限制界面为竖屏，旋转屏幕也不会改变当前状态。</li><li>sensor:根据传感器定位方向，旋转手机90度，180,270,360，界面都会发生变化。</li><li>sensorLandscape：（横屏的旋转，不会出现竖屏的现象）根据传感器定位方向，旋转手机180度界面旋转。一般横屏游戏会是这个属性。</li><li>sensorPortrait：（竖屏的旋转，不会出现横屏的现象）根据传感器定位方向，旋转手机180度界面会旋转。</li><li>unspecified：由系统选择显示方向，不同的设备可能会有所不同。（旋转手机，界面会跟着旋转）</li><li>user: 用户当前的首选方向。</li><li>nosensor：不由传感器确定方向。旋转设备的时候，界面不会跟着旋转。初始界面方向由系统提供。</li></ul><p>(11)获取当前屏幕的方向<br><code>get_orientation()</code></p><h3 id="7-网络设置"><a href="#7-网络设置" class="headerlink" title="7.网络设置"></a>7.网络设置</h3><p>(1)返回网络类型数值<br><code>driver.network_connection</code></p><p>(2)网络设置<br><code>driver.setNetworkConnection(bitmask掩码)</code><br>使用前导入ConnectionType模块<code>from appium.webdriver.connectiontype import ConnectionType</code></p><blockquote><p><code>driver.set_network_connection(2)</code><br><code>driver.set_network_connection(ConnectionType.WIFI_ONLY)</code></p></blockquote><p>网络的bitmask掩码如下：</p><table><thead><tr><th style="text-align:left">值 (别名)</th><th style="text-align:left">数据连接</th><th style="text-align:left">Wifi连接</th><th style="text-align:left">飞行模式</th></tr></thead><tbody><tr><td style="text-align:left">0 (NO_CONNECTION)</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">1 (AIRPLANE_MODE)</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">2 (WIFI_ONLY)</td><td style="text-align:left">0</td><td style="text-align:left">1</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">4 (DATA_ONLY)</td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">6 (ALL_NETWORK_ON)</td><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">0</td></tr></tbody></table><h3 id="8-位置设置"><a href="#8-位置设置" class="headerlink" title="8.位置设置"></a>8.位置设置</h3><p>(1)打开定位设置<br><code>driver.toggle_location_services()</code> </p><p>(2)设置设备的经纬度<br><code>driver.set_location(latitude纬度，longitude经度，altitude海拔高度)</code></p><h3 id="9-文件操作"><a href="#9-文件操作" class="headerlink" title="9.文件操作"></a>9.文件操作</h3><p>(1)把本地文件push到设备上。<br><code>push_file()</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = &quot;some data for the file&quot;</span><br><span class="line">path = &quot;/data/local/tmp/file.txt&quot;</span><br><span class="line">driver.push_file(path, data.encode(&apos;base64&apos;))</span><br></pre></td></tr></table></figure></blockquote><p>(2)将设备上的文件pull到本地硬盘上<br><code>pull_file()</code></p><blockquote><p><code>driver.pull_file(&#39;Library/AddressBook/AddressBook.sqlitedb&#39;)</code></p></blockquote><p>(3)将设备上的文件夹pull到本地硬盘上，一般远程文件为/data/local/tmp下的文件。<br><code>pull_folder()</code></p><h3 id="10-activity操作"><a href="#10-activity操作" class="headerlink" title="10.activity操作"></a>10.activity操作</h3><p>(1)启动activity<br><code>driver.start_activity()</code></p><p>(2)获取当前activity<br><code>driver.current_activity</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">activity = self.driver.current_activity </span><br><span class="line">print(u&quot;当前的activity是:&quot;, activity)</span><br></pre></td></tr></table></figure></blockquote><p>(3)等待activity启动直到x秒超时，每隔y秒扫描一次<br><code>driver.wait_activity(activity, x, y)</code></p><p>(4)检查是否存在某个activity(未找到则返回异常）<br><code>driver.find_element_by_id(activity)</code></p><p>ps:查看包名和activity的方法：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 1)启动应用，输入命令，查看</span><br><span class="line">adb shell dumpsys window | findstr mCurrentFocus </span><br><span class="line"># 2)启动应用，输入命令，查看</span><br><span class="line">adb shell dumpsys activity activities</span><br><span class="line"># 3)有安装包，cmd输入命令，查看</span><br><span class="line">aapt dump badging &lt;file_path.apk&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="11-其他操作"><a href="#11-其他操作" class="headerlink" title="11.其他操作"></a>11.其他操作</h3><p>(1)打开通知栏<br><code>driver.open_notifications()</code></p><p>(2)摇一摇手机<br><code>driver.shake()</code></p><p>(3)获取控件各种属性<br><code>get_attribute()</code><br>可获取的字符串类型：</p><ul><li>name(返回content-desc或text)</li><li>text(返回text)</li><li>className(返回class，只有API=&gt;18才能支持)</li><li>resourceId(返回resource-id，只有API=&gt;18才能支持)</li><li>…uiautomator获得的属性</li></ul><blockquote><p><code>driver.find_element_by_id().get_attribute(name)</code></p></blockquote><p>(4)返回元素是否选择<br><code>element.is_slected()</code></p><p>(5)返回元素是否可用<br><code>element.is_enabled()</code></p><p>(6)返回元素的文本值<br><code>element.text()</code></p><p>(7)清除输入的内容<br><code>element.clear()</code></p><p>(8)获取元素的大小<br><code>driver.element.size</code></p><ul><li>new_size[“height”] = size[“height”]</li><li>new_size[“width”] = size[“width”]</li></ul><p>(9)获取元素左上角的坐标<br><code>driver.element.location</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#返回element的x坐标, int类型</span><br><span class="line">driver.element.location.get(&apos;x&apos;)</span><br><span class="line">#返回element的y坐标, int类型</span><br><span class="line">driver.element.location.get(&apos;y&apos;)</span><br></pre></td></tr></table></figure></blockquote><h3 id="12-unittest断言"><a href="#12-unittest断言" class="headerlink" title="12.unittest断言"></a>12.unittest断言</h3><p>在unittest单元测试框架中，TestCase类提供了一些方法来检查并报告故障：<br>(1)<code>assertEqual(first, second, msg=None)</code>#判断first和second的值是否相等，如果不相等则测试失败，msg用于定义失败后所抛出的异常信息。<br>(2)<code>assertNotEqual(first, second, msg=None)</code>#测试first和second不相等，如果相等，则测试失败。<br>(3)<code>assertTure(expr,msg=None)</code><br>(4)<code>assertFalse(expr,msg=None)</code>#测试expr为Ture（或为False）<br>(5)<code>assertIs(first, second, msg=None)</code><br>(6)<code>assertIsNot(first, second, msg=None)</code>#测试的first和second是（或不是）相同的对象。<br>(7)<code>assertIsNone(expr, msg=None)</code><br>(8)<code>assertIsNotNone(expr, msg=None)</code>#测试expr是（或不是）为None<br>(9)<code>assertIn(first, second, msg=None)</code><br>(10)<code>assertNotIn(first, second, msg=None)</code>#测试first是（或不是）在second中。second包含是否包含first。</p><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;appium常用API笔记。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="appium" scheme="http://pythonfood.github.io/categories/appium/"/>
    
    
      <category term="appium" scheme="http://pythonfood.github.io/tags/appium/"/>
    
  </entry>
  
  <entry>
    <title>appium DesiredCapabilities</title>
    <link href="http://pythonfood.github.io/2018/02/01/appium-DesiredCapabilities/"/>
    <id>http://pythonfood.github.io/2018/02/01/appium-DesiredCapabilities/</id>
    <published>2018-02-01T02:00:00.000Z</published>
    <updated>2018-02-26T09:11:31.048Z</updated>
    
    <content type="html"><![CDATA[<p>Appium Desired Capabilities 详解。<br><a id="more"></a></p><h3 id="1-基本参数"><a href="#1-基本参数" class="headerlink" title="1.基本参数"></a>1.基本参数</h3><table><thead><tr><th style="text-align:left">关键字</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">automationName</td><td style="text-align:left">自动化测试引擎</td><td style="text-align:left">Appium或 Selendroid</td></tr><tr><td style="text-align:left">platformName</td><td style="text-align:left">手机操作系统</td><td style="text-align:left">iOS, Android, 或 FirefoxOS</td></tr><tr><td style="text-align:left">platformVersion</td><td style="text-align:left">手机操作系统版本</td><td style="text-align:left">如： 7.1, 4.4；ios的 9.0</td></tr><tr><td style="text-align:left">deviceName</td><td style="text-align:left">手机或模拟器设备名称</td><td style="text-align:left">android的忽略，ios如iPhone Simulator</td></tr><tr><td style="text-align:left">app</td><td style="text-align:left">.ipa .apk文件路径</td><td style="text-align:left">比如/abs/path/to/my.apk或<a href="http://myapp.com/app.ipa" target="_blank" rel="noopener">http://myapp.com/app.ipa</a></td></tr><tr><td style="text-align:left">browserName</td><td style="text-align:left">启动手机浏览器</td><td style="text-align:left">iOS如:Safari，Android如:Chrome,Chromium,Browser</td></tr><tr><td style="text-align:left">newCommandTimeout</td><td style="text-align:left">设置命令超时时间，单位：秒。</td><td style="text-align:left">比如 60</td></tr><tr><td style="text-align:left">autoLaunch</td><td style="text-align:left">Appium是否需要自动安装和启动应用。默认值true</td><td style="text-align:left">true, false</td></tr><tr><td style="text-align:left">language</td><td style="text-align:left">(Sim/Emu-only) 设定模拟器 ( simulator / emulator ) 的语言。</td><td style="text-align:left">如： fr</td></tr><tr><td style="text-align:left">locale</td><td style="text-align:left">(Sim/Emu-only) 设定模拟器 ( simulator / emulator ) 的区域设置。</td><td style="text-align:left">如： fr_CA</td></tr><tr><td style="text-align:left">udid</td><td style="text-align:left">ios真机的唯一设备标识</td><td style="text-align:left">如： 1ae203187fc012g</td></tr><tr><td style="text-align:left">orientation</td><td style="text-align:left">设置横屏或竖屏</td><td style="text-align:left">LANDSCAPE (横向) 或 PORTRAIT (纵向)</td></tr><tr><td style="text-align:left">autoWebview</td><td style="text-align:left">直接转换到 WebView 上下文。 默认值 false、</td><td style="text-align:left">true, false</td></tr><tr><td style="text-align:left">noReset</td><td style="text-align:left">不要在会话前重置应用状态。默认值false。</td><td style="text-align:left">true, false</td></tr><tr><td style="text-align:left">fullReset</td><td style="text-align:left">(iOS) 删除整个模拟器目录。(Android)通过卸载默认值 false</td><td style="text-align:left">true, false</td></tr></tbody></table><h3 id="2-android特有"><a href="#2-android特有" class="headerlink" title="2.android特有"></a>2.android特有</h3><table><thead><tr><th style="text-align:left">关键字</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">appActivity</td><td style="text-align:left">启动app包,一般点开头</td><td style="text-align:left">如：.MainActivity, .Settings</td></tr><tr><td style="text-align:left">appPackage</td><td style="text-align:left">Android应用的包名</td><td style="text-align:left">比如com.example.android.myApp</td></tr><tr><td style="text-align:left">appWaitActivity</td><td style="text-align:left">等待启动的Activity名称</td><td style="text-align:left">SplashActivity</td></tr><tr><td style="text-align:left">deviceReadyTimeout</td><td style="text-align:left">设置超时时间</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left">androidCoverage</td><td style="text-align:left">用于执行测试的 instrumentation类</td><td style="text-align:left">com.my.Pkg/com.my.Pkg.instrumentation.MyInstrumentation</td></tr><tr><td style="text-align:left">enablePerformanceLogging</td><td style="text-align:left">(仅适用于 Chrome 和 webview) 开启 Chromedriver 的性能日志。(默认 false)</td><td style="text-align:left">true, false</td></tr><tr><td style="text-align:left">androidDeviceReadyTimeout</td><td style="text-align:left">等待设备在启动应用后超时时间，单位秒</td><td style="text-align:left">如 30</td></tr><tr><td style="text-align:left">androidDeviceSocket</td><td style="text-align:left">开发工具的 socket 名称。Chromedriver 把它作为开发者工具来进行连接。</td><td style="text-align:left">如 chrome_devtools_remote</td></tr><tr><td style="text-align:left">avd</td><td style="text-align:left">需要启动的 AVD (安卓模拟器设备) 名称。</td><td style="text-align:left">如 api19</td></tr><tr><td style="text-align:left">avdLaunchTimeout</td><td style="text-align:left">以毫秒为单位，等待 AVD 启动并连接到 ADB的超时时间。(默认值 120000)</td><td style="text-align:left">300000</td></tr><tr><td style="text-align:left">avdReadyTimeout</td><td style="text-align:left">以毫秒为单位，等待 AVD 完成启动动画的超时时间。(默认值 120000)</td><td style="text-align:left">300000</td></tr><tr><td style="text-align:left">avdArgs</td><td style="text-align:left">启动 AVD 时需要加入的额外的参数。</td><td style="text-align:left">如 -netfast</td></tr><tr><td style="text-align:left">useKeystore</td><td style="text-align:left">使用一个自定义的 keystore 来对 apk 进行重签名。默认值 false</td><td style="text-align:left">true or false</td></tr><tr><td style="text-align:left">keystorePath</td><td style="text-align:left">自定义keystore路径。默认~/.android/debug.keystore</td><td style="text-align:left">如 /path/to.keystore</td></tr><tr><td style="text-align:left">keystorePassword</td><td style="text-align:left">自定义 keystore 的密码。</td><td style="text-align:left">如 foo</td></tr><tr><td style="text-align:left">keyAlias</td><td style="text-align:left">key 的别名</td><td style="text-align:left">如 androiddebugkey</td></tr><tr><td style="text-align:left">keyPassword</td><td style="text-align:left">key 的密码</td><td style="text-align:left">如 foo</td></tr><tr><td style="text-align:left">chromedriverExecutable</td><td style="text-align:left">webdriver可执行文件的绝对路径 应该用它代替Appium 自带的 webdriver)</td><td style="text-align:left">/abs/path/to/webdriver</td></tr><tr><td style="text-align:left">autoWebviewTimeout</td><td style="text-align:left">毫秒为单位，Webview上下文激活的时间。默认2000</td><td style="text-align:left">如 4</td></tr><tr><td style="text-align:left">intentAction</td><td style="text-align:left">用于启动activity的intent action。(默认值 android.intent.action.MAIN)</td><td style="text-align:left">如 android.intent.action.MAIN, android.intent.action.VIEW</td></tr><tr><td style="text-align:left">intentCategory</td><td style="text-align:left">用于启动 activity 的 intent category。 (默认值 android.intent.category.LAUNCHER)</td><td style="text-align:left">如 android.intent.category.LAUNCHER, android.intent.category.APP_CONTACTS</td></tr><tr><td style="text-align:left">intentFlags</td><td style="text-align:left">用于启动activity的标识(flags) (默认值 0x10200000)</td><td style="text-align:left">如 0x10200000</td></tr><tr><td style="text-align:left">optionalIntentArguments</td><td style="text-align:left">用于启动 activity 的额外 intent 参数。请查看 Intent 参数</td><td style="text-align:left">如 –esn <extra_key>, –ez <extra_key> <extra_boolean_value></extra_boolean_value></extra_key></extra_key></td></tr><tr><td style="text-align:left">dontStopAppOnReset</td><td style="text-align:left">在使用 adb 启动应用时不要停止被测应用的进程。默认值： false</td><td style="text-align:left">true 或 false</td></tr><tr><td style="text-align:left">unicodeKeyboard</td><td style="text-align:left">使用 Unicode 输入法。默认值 false</td><td style="text-align:left">true 或 false</td></tr><tr><td style="text-align:left">resetKeyboard</td><td style="text-align:left">重置输入法到原有状态，默认值 false</td><td style="text-align:left">true 或 false</td></tr><tr><td style="text-align:left">noSign</td><td style="text-align:left">跳过检查和对应用进行 debug 签名的步骤。默认值 false</td><td style="text-align:left">true 或 false</td></tr><tr><td style="text-align:left">ignoreUnimportantViews</td><td style="text-align:left">调用 uiautomator 的函数这个关键字能加快测试执行的速度。默认值 false</td><td style="text-align:left">true 或 false</td></tr><tr><td style="text-align:left">disableAndroidWatchers</td><td style="text-align:left">关闭 android 监测应用无响ANR和崩溃crash的监视器默认值： false。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">chromeOptions</td><td style="text-align:left">允许传入 chrome driver 使用的 chromeOptions 参数。</td><td style="text-align:left">chromeOptions: {args: [‘–disable-popup-blocking‘]}</td></tr></tbody></table><h3 id="3-ios特有"><a href="#3-ios特有" class="headerlink" title="3.ios特有"></a>3.ios特有</h3><table><thead><tr><th style="text-align:left">关键字</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">calendarFormat</td><td style="text-align:left">(Sim-only) 为iOS的模拟器设置日历格式</td><td style="text-align:left">如 gregorian (公历)</td></tr><tr><td style="text-align:left">bundleId</td><td style="text-align:left">被测应用的bundle ID，真机上执行测试时，你可以不提供 app 关键字，但你必须提供udid</td><td style="text-align:left">如 io.appium.TestApp</td></tr><tr><td style="text-align:left">udid</td><td style="text-align:left">连接真机的唯一设备编号 ( Unique device identifier )</td><td style="text-align:left">如 1ae203187fc012g</td></tr><tr><td style="text-align:left">launchTimeout</td><td style="text-align:left">以毫秒为单位，在Appium运行失败之前设置一个等待 instruments的时间</td><td style="text-align:left">比如： 20000</td></tr><tr><td style="text-align:left">locationServicesEnabled</td><td style="text-align:left">(Sim-only) 强制打开或关闭定位服务。默认值是保持当前模拟器的设定</td><td style="text-align:left">true 或 false</td></tr><tr><td style="text-align:left">locationServicesAuthorized</td><td style="text-align:left">使用这个关键字时，你同时需要使用 bundleId 关键字来发送你的应用的 bundle ID。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">autoAcceptAlerts</td><td style="text-align:left">当 iOS 的个人信息访问警告 (如 位置、联系人、图片) 出现时，自动选择接受( Accept )。默认值 false。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">autoDismissAlerts</td><td style="text-align:left">当 iOS 的个人信息访问警告 (如 位置、联系人、图片) 出现时，自动选择不接受( Dismiss )。默认值 false。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">nativeInstrumentsLib</td><td style="text-align:left">使用原生 intruments 库 (即关闭 instruments-without-delay )</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">nativeWebTap</td><td style="text-align:left">(Sim-only) 在Safari中允许”真实的”，默认值： false。注意：取决于 viewport 大小/比例， 点击操作不一定能精确地点中对应的元素。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">safariInitialUrl</td><td style="text-align:left">(Sim-only) (&gt;= 8.1) Safari 的初始地址。默认值是一个本地的欢迎页面</td><td style="text-align:left">例如： <a href="https://www.github.com" target="_blank" rel="noopener">https://www.github.com</a></td></tr><tr><td style="text-align:left">safariAllowPopups</td><td style="text-align:left">(Sim-only) 允许 javascript 在 Safari 中创建新窗口。默认保持模拟器当前设置。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">safariIgnoreFraudWarning</td><td style="text-align:left">(Sim-only) 阻止 Safari 显示此网站可能存在风险的警告。默认保持浏览器当前设置。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">safariOpenLinksInBackground</td><td style="text-align:left">(Sim-only) Safari 是否允许链接在新窗口打开。默认保持浏览器当前设置。</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">keepKeyChains</td><td style="text-align:left">(Sim-only) 当 Appium 会话开始/结束时是否保留存放密码存放记录 (keychains) (库(Library)/钥匙串(Keychains))</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">localizableStringsDir</td><td style="text-align:left">从哪里查找本地化字符串。默认值 en.lproj</td><td style="text-align:left">en.lproj</td></tr><tr><td style="text-align:left">processArguments</td><td style="text-align:left">通过 instruments 传递到 AUT 的参数</td><td style="text-align:left">如 -myflag</td></tr><tr><td style="text-align:left">interKeyDelay</td><td style="text-align:left">以毫秒为单位，按下每一个按键之间的延迟时间。</td><td style="text-align:left">如 100</td></tr><tr><td style="text-align:left">showIOSLog</td><td style="text-align:left">是否在 Appium 的日志中显示设备的日志。默认值 false</td><td style="text-align:left">true 或者 false</td></tr><tr><td style="text-align:left">sendKeyStrategy</td><td style="text-align:left">输入文字到文字框的策略。模拟器默认值：oneByOne (一个接着一个) 。真实设备默认值：grouped (分组输入)</td><td style="text-align:left">oneByOne, grouped 或 setValue</td></tr><tr><td style="text-align:left">screenshotWaitTimeout</td><td style="text-align:left">以秒为单位，生成屏幕截图的最长等待时间。默认值： 10。</td><td style="text-align:left">如 5</td></tr><tr><td style="text-align:left">waitForAppScript</td><td style="text-align:left">用于判断 “应用是否被启动” 的 iOS 自动化脚本代码。默认情况下系统等待直到页面内容非空。结果必须是布尔类型。</td><td style="text-align:left">例如 true;, target.elements().length &gt; 0;, $.delay(5000); true;</td></tr></tbody></table><h3 id="4-小示例"><a href="#4-小示例" class="headerlink" title="4.小示例"></a>4.小示例</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from appium import webdriver</span><br><span class="line"></span><br><span class="line">desired_caps=&#123;&#125;</span><br><span class="line">desired_caps[&apos;platformName&apos;]=&apos;Android&apos;</span><br><span class="line">desired_caps[&apos;platformVersion&apos;]=&apos;5.1.1&apos;</span><br><span class="line">desired_caps[&apos;deviceName&apos;]=&apos;172.16.10.26:5555&apos;</span><br><span class="line">desired_caps[&apos;appPackage&apos;]=&apos;com.peng.cloudp.tv&apos;</span><br><span class="line">desired_caps[&apos;appActivity&apos;]=&apos;..activity.StartPageActivity&apos;</span><br><span class="line">desired_caps[&apos;unicodeKeyboard&apos;]=&apos;true&apos;</span><br><span class="line">desired_caps[&apos;resetKeyboard&apos;]=&apos;true&apos;</span><br><span class="line">driver = webdriver.Remote(&apos;http://127.0.0.1:4723/wd/hub&apos;, desired_caps)</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Appium Desired Capabilities 详解。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="appium" scheme="http://pythonfood.github.io/categories/appium/"/>
    
    
      <category term="appium" scheme="http://pythonfood.github.io/tags/appium/"/>
    
  </entry>
  
  <entry>
    <title>appium安装-windows</title>
    <link href="http://pythonfood.github.io/2018/02/01/appium%E5%AE%89%E8%A3%85-windows/"/>
    <id>http://pythonfood.github.io/2018/02/01/appium安装-windows/</id>
    <published>2018-02-01T01:00:00.000Z</published>
    <updated>2018-02-24T01:43:21.725Z</updated>
    
    <content type="html"><![CDATA[<p>appium环境搭建的简单步骤：安装jdk——安装android sdk——安装python——安装node.js——安装appium server——安装appium python客户端。<br><a id="more"></a></p><h3 id="1-安装jdk"><a href="#1-安装jdk" class="headerlink" title="1.安装jdk"></a>1.安装jdk</h3><blockquote><p>(1)下载jdk</p><blockquote><p>官网地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p></blockquote><p>(2)安装jdk</p><blockquote><p>根据提示安装，安装路径自定义：D:\Program Files\Java\jdk1.7.0_80</p></blockquote><p>(3)配置java环境变量</p><blockquote><p>1)系统变量→新建JAVA_HOME变量→变量值：D:\Program Files\Java\jdk1.7.0_80<br>2)系统变量→新建CLASSPATH变量→变量值：<code>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar</code><br>3)系统变量→编辑Path变量→增加：<code>;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</code>   </p></blockquote><p>(4)验证环境</p><blockquote><p>cmd输入<code>java -version</code>命令查看java版本。</p></blockquote></blockquote><h3 id="2-安装android-sdk"><a href="#2-安装android-sdk" class="headerlink" title="2.安装android sdk"></a>2.安装android sdk</h3><blockquote><p>(1)下载android sdk</p><blockquote><p>可以直接下载adt：<a href="http://tools.android-studio.org/index.php/adt-bundle-plugin" target="_blank" rel="noopener">http://tools.android-studio.org/index.php/adt-bundle-plugin</a></p></blockquote><p>(2)安装android sdk</p><blockquote><p>将adt压缩包解压到自定义路径：D:\Program Files\adt-bundle-windows-x86-20130917  </p></blockquote><p>(3)配置android环境变量</p><blockquote><p>1)系统变量→新建ANDROID_HOME变量→变量值：D:\Program Files\adt-bundle-windows-x86-20130917\sdk<br>2)系统变量→编辑Path变量→增加：<code>;%ANDROID_HOME%\tools;%ANDROID_HOME%\platform-tools;</code></p></blockquote><p>(4)验证环境</p><blockquote><p>cmd输入<code>adb</code>命令查看adb版本。</p></blockquote></blockquote><h3 id="3-安装Python"><a href="#3-安装Python" class="headerlink" title="3.安装Python"></a>3.<a href="https://pythonfood.github.io/2017/12/28/python安装-windows/#more">安装Python</a></h3><h3 id="4-安装node-js"><a href="#4-安装node-js" class="headerlink" title="4.安装node.js"></a>4.安装node.js</h3><blockquote><p>(1)下载node.js</p><blockquote><p>官网地址：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></p></blockquote><p>(2)安装node.js</p><blockquote><p>根据提示安装，安装路径自定义，自动添加PATH环境变量。</p></blockquote><p>(3)验证环境</p><blockquote><p>cmd输入<code>node -v</code>命令查看node版本。</p></blockquote></blockquote><h3 id="5-安装appium-server"><a href="#5-安装appium-server" class="headerlink" title="5.安装appium server"></a>5.安装appium server</h3><blockquote><p>方法1：npm安装</p><blockquote><p>(1)cmd输入<code>npm install -g appium</code>命令等待安装完成。（可能会被墙）<br>(2)cmd输入<code>npm install -g appium-doctor</code>命令安装Appium-doctor。<br>(3)cmd输入<code>appium-doctor</code>命令看到’All Checks were successful’则环境搭建成功。</p></blockquote><p>方法2：下载安装</p><blockquote><p>(1)下载地址：<a href="http://appium.io/" target="_blank" rel="noopener">http://appium.io/</a> 或 <a href="https://bitbucket.org/appium/appium.app/downloads/" target="_blank" rel="noopener">https://bitbucket.org/appium/appium.app/downloads/</a><br>(2)根据提示安装，安装路径自定义，自动添加PATH环境变量：<code>;D:\Program Files\Appium\node_modules\.bin;</code><br>(3)打开Appium图标验证安装成功。</p></blockquote><p>ps：appiun的server已经很久没有更新了，目前appium-desktop来继续他的使命。</p></blockquote><h3 id="6-安装appium-python客户端"><a href="#6-安装appium-python客户端" class="headerlink" title="6.安装appium python客户端"></a>6.安装appium python客户端</h3><blockquote><p>方法1：pip安装</p><blockquote><p>cmd输入<code>pip install Appium-Python-Client</code>命令等待安装完成。</p></blockquote><p>方法2：下载源码安装 </p><blockquote><p>(1)下载地址：<a href="https://pypi.python.org/pypi/Appium-Python-Client" target="_blank" rel="noopener">https://pypi.python.org/pypi/Appium-Python-Client</a><br>(2)解压后，cmd输入<code>cd Appium-Python-Client-X.X</code>命令进入目录。<br>(3)cmd输入<code>python setup.py install</code>命令进行安装。</p></blockquote></blockquote><h3 id="7-验证环境-小示例"><a href="#7-验证环境-小示例" class="headerlink" title="7.验证环境(小示例)"></a>7.验证环境(小示例)</h3><blockquote><p>(1)启动服务</p><blockquote><p>1)连接手机。<br>2)cmd输入<code>appium</code>命令启动服务。<br>3)打印日志如下图，则服务启动成功：</p><blockquote><p><img src="/2018/02/01/appium安装-windows/启动appium服务.png" alt="启动appium服务"></p></blockquote></blockquote><p>(2)代码示例</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from appium import webdriver</span><br><span class="line">from time import sleep</span><br><span class="line">import unittest</span><br><span class="line"></span><br><span class="line">class CalTest(unittest.TestCase):</span><br><span class="line">def setUp(self):</span><br><span class="line">desired_caps=&#123;&#125;</span><br><span class="line">desired_caps[&apos;platformName&apos;]=&apos;Android&apos;</span><br><span class="line">desired_caps[&apos;platformVersion&apos;]=&apos;5.0.2&apos;</span><br><span class="line">desired_caps[&apos;deviceName&apos;]=&apos;1ae7be68&apos;</span><br><span class="line">desired_caps[&apos;appPackage&apos;]=&apos;com.android.calculator2&apos;</span><br><span class="line">desired_caps[&apos;appActivity&apos;]=&apos;.Calculator&apos;</span><br><span class="line">self.driver=webdriver.Remote(&apos;http://localhost:4723/wd/hub&apos;,desired_caps)</span><br><span class="line"></span><br><span class="line">def tearDown(self):</span><br><span class="line">self.driver.quit()</span><br><span class="line"></span><br><span class="line">def test_add(self):</span><br><span class="line">driver.find_element_by_name(&quot;8&quot;).click()</span><br><span class="line">driver.find_element_by_id(&apos;digit7&apos;).click()</span><br><span class="line">driver.find_element_by_id(&apos;plus&apos;).click()</span><br><span class="line">driver.find_element_by_id(&apos;digit3&apos;).click()</span><br><span class="line">driver.find_element_by_id(&apos;equal&apos;).click()</span><br><span class="line">sleep(3)</span><br><span class="line">driver.find_element_by_id(&apos;clear&apos;).click()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">       suite = unittest.TestLoader().loadTestsFromTestCase(CalTest)</span><br><span class="line">       unittest.TextTestRunner(verbosity=2).run(suite)</span><br></pre></td></tr></table></figure></blockquote><p>(3)执行脚本    </p></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;appium环境搭建的简单步骤：安装jdk——安装android sdk——安装python——安装node.js——安装appium server——安装appium python客户端。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="appium" scheme="http://pythonfood.github.io/categories/appium/"/>
    
    
      <category term="appium" scheme="http://pythonfood.github.io/tags/appium/"/>
    
  </entry>
  
  <entry>
    <title>selenium常用API</title>
    <link href="http://pythonfood.github.io/2018/01/01/selenium%E5%B8%B8%E7%94%A8API/"/>
    <id>http://pythonfood.github.io/2018/01/01/selenium常用API/</id>
    <published>2018-01-01T02:00:00.000Z</published>
    <updated>2018-02-26T07:13:34.628Z</updated>
    
    <content type="html"><![CDATA[<p>selenium常用API笔记。<br><a id="more"></a></p><h3 id="1-浏览器操作"><a href="#1-浏览器操作" class="headerlink" title="1.浏览器操作"></a>1.浏览器操作</h3><p>(1)浏览器最大化</p><blockquote><p><code>driver.maximize_window()</code> #浏览器最大化</p></blockquote><p>(2)设置浏览器宽、高</p><blockquote><p><code>driver.set_window_size(480, 800)</code> #设置浏览器宽、高</p></blockquote><p>(3)浏览器后退</p><blockquote><p><code>driver.back()</code> #浏览器后退</p></blockquote><p>(4)浏览器前进</p><blockquote><p><code>driver.forward()</code> #浏览器前进</p></blockquote><p>(5)刷新当前页面</p><blockquote><p><code>driver.refresh()</code> #刷新当前页面</p></blockquote><p>(6)退出浏览器</p><blockquote><p><code>driver.quit()</code> #退出浏览器</p></blockquote><p>(7)关闭单个窗口</p><blockquote><p><code>driver.close()</code> #关闭单个窗口</p></blockquote><h3 id="2-元素定位"><a href="#2-元素定位" class="headerlink" title="2.元素定位"></a>2.元素定位</h3><p>(1)id定位 </p><blockquote><p><code>find_element_by_id(&quot;kw&quot;)</code> #一般唯一</p></blockquote><p>(2)name定位 </p><blockquote><p><code>find_element_by_name(&quot;wd&quot;)</code> #一般唯一</p></blockquote><p>(3)class_name定位 </p><blockquote><p><code>find_element_by_class_name(&quot;bg s_btn&quot;)</code> #不唯一</p></blockquote><p>(4)tag_name定位</p><blockquote><p><code>find_element_by_tag_name(&quot;input&quot;)</code> #不唯一</p></blockquote><p>(5)link_text定位</p><blockquote><p><code>find_element_by_link_text(u&quot;这是一条新闻&quot;)</code> #定位文本链接</p></blockquote><p>(6)partial_link_text定位</p><blockquote><p><code>find_element_by_partial_link_text(&quot;这是一条新&quot;)</code> #定位可以唯一标识这个文本链接的一部分</p></blockquote><p>(7)xpath定位</p><blockquote><p>1)绝对路径定位</p><blockquote><p><code>find_element_by_xpath(&quot;/html/body/div[2]/form/span/input&quot;)</code> #从根节点开始绝对路径</p></blockquote><p>2)相对路径定位</p><blockquote><p><code>find_element_by_xpath(&quot;//input[@id=’input’]&quot;)</code> #通过自身的id 属性定位<br><code>find_element_by_xpath(&quot;//span[@id=’input-container’]/input&quot;)</code> #通过上一级目录的id 属性定位<br><code>find_element_by_xpath(&quot;//div[@name=’q’]/form/span[2]/input&quot;)</code> #通过上三级目录的name 属性定位<br><code>find_element_by_xpath(&quot;//div[@id=’hd’ or @name=’q’]/form/span/input&quot;)</code> #通过布尔逻辑运算 属性定位</p></blockquote></blockquote><p>(8)css_selector定位</p><blockquote><p><code>find_element_by_css_selector(&quot;#su&quot;)</code> #通过id属性定位<br><code>find_element_by_css_selector(&quot;.s_ipt&quot;)</code> #通过class属性定位<br><code>find_element_by_css_selector(&quot;input&quot;)</code> #通过标签名定位<br><code>find_element_by_css_selector(&quot;span&gt;input&quot;)</code> #通过父子关系定位<br><code>find_element_by_css_selector(&quot;input[maxlength=&#39;100&#39;]&quot;)</code> #通过属性定位<br><code>find_element_by_css_selector(&quot;span.bgs_ipt_wr&gt;input.s_ipt&quot;)</code> #组合定位</p><blockquote><p><img src="/2018/01/01/selenium常用API/css_selector定位.png" alt="css_selector定位"></p></blockquote></blockquote><p>(9)用By定位<br>需要使用定位方法时，By可以设置定位策略。使用前导入By模块<code>from selenium.webdriver.common.by import By</code>。</p><blockquote><p><code>find_element(By.ID,&quot;kw&quot;)</code><br><code>find_element(By.NAME,&quot;wd&quot;)</code><br><code>find_element(By.CLASS_NAME,&quot;s_ipt&quot;)</code><br><code>find_element(By.TAG_NAME,&quot;input&quot;)</code><br><code>find_element(By.LINK_TEXT,u&quot;新闻&quot;)</code><br><code>find_element(By.PARTIAL_LINK_TEXT,u&quot;新&quot;)</code><br><code>find_element(By.XPATH,&quot;//*[@class=&#39;bgs_btn&#39;]&quot;)</code><br><code>find_element(By.CSS_SELECTOR,&quot;span.bgs_btn_wr&gt;input#su&quot;)</code></p></blockquote><h3 id="3-元素操作"><a href="#3-元素操作" class="headerlink" title="3.元素操作"></a>3.元素操作</h3><p>(1)clear()  #清除输入框内容</p><blockquote><p><code>driver.find_element_by_id(&quot;user_name&quot;).clear()</code></p></blockquote><p>(2)send_keys(“xx”) #输入框里输入xx内容</p><blockquote><p><code>driver.find_element_by_id(&quot;user_name&quot;).send_keys(&quot;username&quot;)</code></p></blockquote><p>(3)click() #单击一个按钮、连接等</p><blockquote><p><code>driver.find_element_by_id(&quot;dl_an_submit&quot;).click()</code></p></blockquote><p>(4)submit() #提交表单</p><blockquote><p><code>driver.find_element_by_id(&quot;dl_an_submit&quot;).submit()</code></p></blockquote><p>(5)size #返回元素的尺寸</p><blockquote><p><code>size=driver.find_element_by_id(&quot;kw&quot;).size</code> #返回百度输入框的宽高</p></blockquote><p>(6)text #获取元素的文本</p><blockquote><p><code>text=driver.find_element_by_id(&quot;cp&quot;).text</code> #返回百度页面底部备案信息</p></blockquote><p>(7)get_attribute(name) #获得属性值</p><blockquote><p><code>attribute=driver.find_element_by_id(&quot;kw&quot;).get_attribute(&#39;type&#39;)</code> #返回元素的属性值，可以是id、name、type 或元素拥有的其它任意属性</p></blockquote><p>(8)is_displayed() #检查该元素是否用户可见    </p><blockquote><p><code>result=driver.find_element_by_id(&quot;kw&quot;).is_displayed()</code> #返回元素的结果是否可见，返回结果为True 或False</p></blockquote><h3 id="4-鼠标事件"><a href="#4-鼠标事件" class="headerlink" title="4.鼠标事件"></a>4.鼠标事件</h3><p>ActionChains用于生成用户的行为，所有的行为都存储在actionchains对象中。通过perform()执行存储的行为。<br>使用前导入ActionChains模块<code>from selenium.webdriver.common.action_chains import ActionChains</code>。</p><p>(1)perform() #顺序执行所有ActionChains中存储的行为</p><blockquote><p><code>ActionChains(driver).context_click(操作对象).perform()</code> #ActionChains方法的书写格式</p></blockquote><p>(2)context_click() #右击 </p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">right =driver.find_element_by_xpath(&quot;xx&quot;) #定位到要右击的元素</span><br><span class="line">ActionChains(driver).context_click(right).perform() #对定位到的元素执行鼠标右键操作</span><br></pre></td></tr></table></figure></blockquote><p>(3)double_click() #双击</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double =driver.find_element_by_xpath(&quot;xxx&quot;) #定位到要双击的元素</span><br><span class="line">ActionChains(driver).double_click(double).perform() #对定位到的元素执行鼠标双击操作</span><br></pre></td></tr></table></figure></blockquote><p>(4)drag_and_drop() #鼠标拖放</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element = driver.find_element_by_name(&quot;xxx&quot;) #定位元素的原位置</span><br><span class="line">target = driver.find_element_by_name(&quot;xxx&quot;) #定位元素要移动到的目标位置</span><br><span class="line">ActionChains(driver).drag_and_drop(element, target).perform() #执行元素的移动操作</span><br></pre></td></tr></table></figure></blockquote><p>(5)move_to_element() #鼠标悬停</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">above = driver.find_element_by_xpath(&quot;xxx&quot;) #定位到鼠标移动到上面的元素</span><br><span class="line">ActionChains(driver).move_to_element(above).perform() #对定位到的元素执行鼠标移动到上面的操作</span><br></pre></td></tr></table></figure></blockquote><p>(6)click_and_hold() #按下鼠标左键    </p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">left=driver.find_element_by_xpath(&quot;xxx&quot;) #定位到鼠标按下左键的元素</span><br><span class="line">ActionChains(driver).click_and_hold(left).perform() #对定位到的元素执行鼠标左键按下的操作</span><br></pre></td></tr></table></figure></blockquote><h3 id="5-键盘事件"><a href="#5-键盘事件" class="headerlink" title="5.键盘事件"></a>5.键盘事件</h3><p>使用前导入keys模块<code>from selenium.webdriver.common.keys import Keys</code>。</p><p>(1)send_keys(Keys.BACK_SPACE) #删除键（BackSpace）</p><p>(2)send_keys(Keys.SPACE) #空格键(Space)</p><p>(3)send_keys(Keys.TAB) #制表键(Tab)</p><p>(4)send_keys(Keys.ESCAPE) #回退键（Esc）</p><p>(5)send_keys(Keys.ENTER) #回车键（Enter）</p><p>(6)send_keys(Keys.F5) #刷新建（F5）</p><p>(7)send_keys(Keys.CONTROL,’a’) #全选（Ctrl+A）</p><p>(8)send_keys(Keys.CONTROL,’c’) #复制（Ctrl+C）</p><p>(9)send_keys(Keys.CONTROL,’x’) #剪切（Ctrl+X）</p><p>(10)send_keys(Keys.CONTROL,’v’) #粘贴（Ctrl+V）</p><h3 id="6-获取验证信息"><a href="#6-获取验证信息" class="headerlink" title="6.获取验证信息"></a>6.获取验证信息</h3><p>(1)获得当前页面title，判断页面跳转是否符合预期</p><blockquote><p><code>title = driver.title</code></p></blockquote><p>(2)获得当前URL，一般用来测试重定向</p><blockquote><p><code>url = driver.current_url</code></p></blockquote><h3 id="7-设置等待时间"><a href="#7-设置等待时间" class="headerlink" title="7.设置等待时间"></a>7.设置等待时间</h3><p>(1)sleep() #休眠等待<br>sleep()方法以秒为单位，假如休眠时间小于 1 秒，可以用小数表示。<br>使用前导入sleep模块<code>from time import sleep</code>。</p><blockquote><p><code>sleep(0.5)</code></p></blockquote><p>(2)implicitly_wait() #隐式等待<br>隐式等待是通过一定的时长等待页面所元素加载完成。<br>如果超出了设置的时长元素还没有被加载测抛NoSuchElementException异常。<br>implicitly_wait()默认参数的单位为秒。</p><blockquote><p><code>driver.implicitly_wait(10)</code> #设置智能等待10秒</p></blockquote><p>(3)WebDriverWait() #显式等待<br>显式等待是等待某个条件成立时继续执行，否则在达到最大时长则抛TimeoutException异常。</p><p>WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None)，参数解释如下：</p><ul><li>driver - WebDriver 的驱动程序(Ie, Firefox, Chrome 或远程)</li><li>timeout - 最长超时时间，默认以秒为单位</li><li>poll_frequency - 休眠时间的间隔（步长）时间，默认为 0.5 秒</li><li>ignored_exceptions - 超时后的异常信息，默认情况下抛 NoSuchElementException 异常。</li></ul><p>使用前导入WebDriverWait模块<code>from selenium.webdriver.support.ui import WebDriverWait</code>。</p><p>WebDriverWai()一般由 unit()或 until_not()方法配合使用，下面是 unit()和 until_not()方法的说明：<br>1)until(method, message=’’)调用该方法提供的驱动程序作为一个参数，直到返回值不为False。</p><blockquote><p><code>element = WebDriverWait(driver, 10).until(lambda x: x.find_element_by_id(“someId”))</code></p></blockquote><p>2)until_not(method, message=’’)调用该方法提供的驱动程序作为一个参数，直到返回值为 False。</p><blockquote><p><code>is_disappeared = WebDriverWait(driver, 30, 1, (ElementNotVisibleException)).until_not(lambda x: x.find_element_by_id(“someId”).is_displayed())</code>    </p></blockquote><h3 id="8-定位一组对象"><a href="#8-定位一组对象" class="headerlink" title="8.定位一组对象"></a>8.定位一组对象</h3><p>(1)find_elements 用于获取一组元素:</p><blockquote><p><code>find_elements_by_id(‘xx’)</code><br><code>find_elements_by_name(‘xx’)</code><br><code>find_elements_by_class_name(‘xx’)</code><br><code>find_elements_by_tag_name(‘xx’)</code><br><code>find_elements_by_link_text(‘xx’)</code><br><code>find_elements_by_partial_link_text(‘xx’)</code><br><code>find_elements_by_xpath(‘xx’)</code><br><code>find_elements_by_css_selector(‘xx’)</code></p></blockquote><p>(2)可以使用for… in …对这一组元素进行遍历:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for checkbox in checkboxes:</span><br><span class="line">checkbox.click()</span><br></pre></td></tr></table></figure></blockquote><p>(3)也可以使用pop（）方法获得这一组元素中的第几个，然后再对该元素进行操作：</p><blockquote><p><code>find_elements_by_id(‘xx’).pop().click()</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pop（）或pop（-1）#默认获取一组元素中的最后一个</span><br><span class="line">pop(0)   #默认获取一组元素的第一个元素</span><br><span class="line">pop(1)   #默认获取一组元素的第二个元素</span><br><span class="line">...... #以此类推</span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="9-层级定位"><a href="#9-层级定位" class="headerlink" title="9.层级定位"></a>9.层级定位</h3><p>经常会有这样的需求：页面上有很多个属性基本相同的元素 ，现在需要具体定位到其中的一个。由于属性基本相当，所以在定位的时候会有些麻烦，这时候就需要用到层级定位。先定位父元素，然后再通过父元素定位子孙元素：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#点击 Link1 链接（弹出下拉列表）</span><br><span class="line">driver.find_element_by_link_text(&apos;Link1&apos;).click() </span><br><span class="line">#在父亲元件下找到 link 为 Action 的子元素</span><br><span class="line">menu=driver.find_element_by_id(&apos;dropdown1&apos;).find_element_by_link_text(&apos;Another action&apos;)</span><br></pre></td></tr></table></figure></blockquote><h3 id="10-表单切换"><a href="#10-表单切换" class="headerlink" title="10.表单切换"></a>10.表单切换</h3><p>在web应用中经常会出现frame/iframe 表单内嵌套的应用，WebDriver只能在一个页面上进行元素识别定位，对于frame/iframe表单内嵌页面上的元素无法直接定位。这时需要通过switch_to.frame()方法将当前定位的主体切换为frame/iframe表单的内嵌页面中。</p><p>(1)switch_to_frame()默认可以直接取表单的id或name属性进行切换：</p><blockquote><p><code>driver.switch_to_frame(&quot;if&quot;)</code> #id = “if”<br><code>driver.switch_to_frame(&quot;nf&quot;)</code> #name = “nf” </p></blockquote><p>(2)如果 iframe 没有可用的 id 和 name 可以通过下面的方式进行定位：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#先通过xpth定位到iframe </span><br><span class="line">xf = driver.find_element_by_xpath(&apos;//*[@class=&quot;if&quot;]&apos;)</span><br><span class="line">#再将定位对象传给switch_to_frame()方法 </span><br><span class="line">driver.switch_to_frame(xf)</span><br></pre></td></tr></table></figure></blockquote><p>(3)如果完成了在当前表单上的操作，跳出当前表单：</p><blockquote><p><code>driver.switch_to.parent_content()</code> #返回到父级表单<br><code>driver.switch_to.default_conent()</code> #返回到主文档页面</p></blockquote><h3 id="11-多窗口切换"><a href="#11-多窗口切换" class="headerlink" title="11.多窗口切换"></a>11.多窗口切换</h3><ul><li><code>current_window_handle</code> #获得当前窗口句柄。</li><li><code>window_handles</code> #返回所有窗口的句柄到当前对话。</li><li><code>switch_to.window</code>(窗口句柄) #切换到对应的窗口。</li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nowhandle=driver.current_window_handle #获得当前窗口句柄。</span><br><span class="line">driver.find_element_by_link_text(u&quot;发表话题&quot;).click()</span><br><span class="line">time.sleep(3)</span><br><span class="line">allhandles=driver.window_handles #返回所有窗口的句柄到当前对话。</span><br><span class="line">for handle in allhandles:</span><br><span class="line">if(handle!=nowhandle):</span><br><span class="line">driver.switch_to.window(handle) #切换到对应的窗口。</span><br></pre></td></tr></table></figure></blockquote><h3 id="12-警告框处理"><a href="#12-警告框处理" class="headerlink" title="12.警告框处理"></a>12.警告框处理</h3><p>处理javascript所生成的alert、confirm、prompt，可以使用switch_to_alert()方法定位到alert/confirm/prompt，然后使用text/accept/dismiss/send_keys等方法进行操作：</p><ul><li><code>text</code> #返回 alert/confirm/prompt 中的文字信息。</li><li><code>accept</code> #点击确认按钮。</li><li><code>dismiss</code> #点击取消按钮，如果有的话。</li><li><code>send_keys</code> #输入值，这个 alert\confirm 没有对话框就不能用了，不然会报错。</li></ul><blockquote><p><code>driver.switch_to_alert().accept()</code></p></blockquote><h3 id="13-上传文件"><a href="#13-上传文件" class="headerlink" title="13.上传文件"></a>13.上传文件</h3><p>(1)查找到input标签，通过send_keys)传入本地文件路径从而模拟上传功能:</p><blockquote><p><code>driver.find_element_by_name(&quot;file&quot;).send_keys(&#39;D:\\upload_file.txt&#39;)</code> #查找到input标签，然后send进去</p></blockquote><p>(2)使用AutoIt识别flash控件和windows控件实现自动上传文件</p><blockquote><p>1)下载安装，官方网站：<a href="https://www.autoitscript.com/site/" target="_blank" rel="noopener">https://www.autoitscript.com/site/</a><br>2)配置编辑AutoIt。<br>3)<code>os.system(&quot;D:\\upfile.exe&quot;)</code> #通过系统调用upfile.exe上传程序 </p></blockquote><h3 id="14-下载文件"><a href="#14-下载文件" class="headerlink" title="14.下载文件"></a>14.下载文件</h3><p>(1)以FireFox为例，为了让FireFox浏览器能实现文件的载，我们需要通过FirefoxProfile()对其参数做一个设置:</p><ul><li><code>browser.download.folderList</code> #设置成0代表下载到浏览器默认下载路径；设置成2则可以保存到指定目录。</li><li><code>browser.download.manager.showWhenStarting</code> #是否显示开始，Ture为显示，Flase为不显示。</li><li><code>browser.download.dir</code> #用于指定你所下载文件的目录。os.getcwd()该函数不需要传递参数，用于返回当前的目录。</li><li><code>browser.helperApps.neverAsk.saveToDisk</code> #指定要下载页面的Content-type值，“application/octet-stream”为文件的类型。HTTP Content-type常用对照表：<a href="http://tool.oschina.net/commons" target="_blank" rel="noopener">http://tool.oschina.net/commons</a></li></ul><p>(2)这些参数的设置可以通过在Firefox浏览器地址栏输入：about:config 进行设置，如图： </p><p><img src="/2018/01/01/selenium常用API/firefox参数设置.png" alt="firefox参数设置"></p><p>(3)浏览器设置代码示例：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8 </span><br><span class="line">from selenium import webdriver </span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">fp = webdriver.FirefoxProfile()</span><br><span class="line">fp.set_preference(&quot;browser.download.folderList&quot;,2) </span><br><span class="line">fp.set_preference(&quot;browser.download.manager.showWhenStarting&quot;,False) </span><br><span class="line">fp.set_preference(&quot;browser.download.dir&quot;, os.getcwd()) </span><br><span class="line">fp.set_preference(&quot;browser.helperApps.neverAsk.saveToDisk&quot;, &quot;application/octet-stream&quot;)</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox(firefox_profile=fp) </span><br><span class="line">driver.get(&quot;http://pypi.Python.org/pypi/selenium&quot;) </span><br><span class="line">driver.find_element_by_partial_link_text(&quot;selenium-2&quot;).click()</span><br></pre></td></tr></table></figure></blockquote><h3 id="15-操作Cookie"><a href="#15-操作Cookie" class="headerlink" title="15.操作Cookie"></a>15.操作Cookie</h3><p>webdriver操作cookie的方法有：</p><ul><li><code>get_cookies()</code> #获得所有cookie信息  </li><li><code>get_cookie(name)</code> #返回有特定name值有cookie信息  </li><li><code>add_cookie(cookie_dict)</code> #添加cookie，必须有name和value值  </li><li><code>delete_cookie(name)</code> #删除特定(部分)的cookie信息  </li><li><code>delete_all_cookies()</code> #删除所有cookie信息</li></ul><p>(1)先通过get_cookies()来获取当前浏览器的cookie信息。<br>通过打印结果可以看出，cookie 是以字典的形式进行存放的，知道了cookie的存放形式，那么我们就可以按照这种形式向浏览器中写入cookie信息。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver.get(&quot;http://www.youdao.com&quot;)</span><br><span class="line">cookie= driver.get_cookies() # 获得cookie信息 </span><br><span class="line">print cookie #将获得cookie的信息打印</span><br></pre></td></tr></table></figure><blockquote><p><img src="/2018/01/01/selenium常用API/cookie打印信息.png" alt="cookie打印信息"></p></blockquote></blockquote><p>(2)再进行cookie的添加、删除等操作。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver.get(&quot;http://www.youdao.com&quot;)</span><br><span class="line">driver.add_cookie(&#123;&apos;name&apos;:&apos;key-aaaaaaa&apos;, &apos;value&apos;:&apos;value-bbbbbb&apos;&#125;) #向cookie的name 和value添加会话信息。</span><br></pre></td></tr></table></figure></blockquote><h3 id="16-调用javascript"><a href="#16-调用javascript" class="headerlink" title="16.调用javascript"></a>16.调用javascript</h3><p>当webdriver遇到没法完成的操作时，可以考虑调用JavaScript来完成。<br>webdriver提供<code>execute_script()</code>方法用来调用js代码：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#修改元素的属性</span><br><span class="line">js = &apos;document.querySelectorAll(&quot;select&quot;)[0].style.display=&quot;block&quot;;&apos;</span><br><span class="line">driver.execute_script(js)</span><br></pre></td></tr></table></figure></blockquote><h3 id="17-控制浏览器滚动条"><a href="#17-控制浏览器滚动条" class="headerlink" title="17.控制浏览器滚动条"></a>17.控制浏览器滚动条</h3><p>(1)上下滚动：<br><code>document.body.scrollTop</code> #网页被卷去的高。置顶设置：scrollTop为0；置底设置：scrollTop大于窗口的高度像素。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#将页面滚动条拖到底部</span><br><span class="line">js=&quot;var q=document.documentElement.scrollTop=10000&quot;</span><br><span class="line">driver.execute_script(js)</span><br><span class="line">time.sleep(3)</span><br><span class="line">#将滚动条移动到页面的顶部</span><br><span class="line">js1=&quot;var q=document.documentElement.scrollTop=0&quot;</span><br><span class="line">driver.execute_script(js1)</span><br><span class="line">time.sleep(3)</span><br></pre></td></tr></table></figure></blockquote><p>(2)左右滚动：<br><code>window.scrollTo(左边距,上边距)</code> #指定左右滚动的坐标即可</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">js=&quot; window.scrollTo(200,1000);&quot; </span><br><span class="line">driver.execute_script(js)</span><br></pre></td></tr></table></figure></blockquote><h3 id="18-窗口截图"><a href="#18-窗口截图" class="headerlink" title="18.窗口截图"></a>18.窗口截图</h3><p>Webdriver提供了截图函数<code>get_screenshot_as_file()</code>来截取当前窗口:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">driver.find_element_by_id(&apos;kw_error&apos;).send_key(&apos;selenium&apos;) </span><br><span class="line">driver.find_element_by_id(&apos;su&apos;).click() </span><br><span class="line">except: </span><br><span class="line">driver.get_screenshot_as_file(&quot;D:\\baidu_error.jpg&quot;) #截图，保存到指定路径</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure></blockquote><h3 id="19-获取对象的属性值"><a href="#19-获取对象的属性值" class="headerlink" title="19.获取对象的属性值"></a>19.获取对象的属性值</h3><p>有时候我们定位页面上的元素发现常用的id、name等属性是相同的。这个时候我们只能通过常规的定位方法定位出一组元素，然后观察通过元素的属性可以定位出单个元素。<br>可使用.get_attribute()方法:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 选择页面上所有的tag name为input的元素</span><br><span class="line">inputs = driver.find_elements_by_tag_name(&apos;input&apos;)</span><br><span class="line">#然后循环遍历出属性data-node值为594434493的元素，单击勾选</span><br><span class="line">for input in inputs:</span><br><span class="line">if input.get_attribute(&apos;data-node&apos;) == &apos;594434493&apos;:</span><br><span class="line">input.click()</span><br></pre></td></tr></table></figure></blockquote><h3 id="20-验证码处理"><a href="#20-验证码处理" class="headerlink" title="20.验证码处理"></a>20.验证码处理</h3><p>(1)去掉验证码。<br>(2)设置万能码。<br>(3)验证码识别技术<br>例如可以通过Python-tesseract来识别图片验证码,能够读取任何常规的图片文件(JPG,GIF,PNG,TIFF 等)。不过，目前市面上的验证码识别技术识别率都不是100% 。<br>(4)记录cookie<br>通过向浏览器中添加cookie可以绕过登录的验证码,这种方式最大的问题是如何从浏览器的Cookie中找到用户名和密码对应的key值，并传传输入对应的登录信息。如果网站登录时根本不将用户名和密码写Cookie，这会存在一定的安全风险。那么这种方式就不起作用了。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#访问xx网站 </span><br><span class="line">driver.get(&quot;http://www.xx.cn&quot;)</span><br><span class="line">#将用户名密码写入浏览器cookie </span><br><span class="line">driver.add_cookie(&#123;&apos;name&apos;:&apos;Login_UserNumber&apos;, &apos;value&apos;:&apos;username&apos;&#125;) </span><br><span class="line">driver.add_cookie(&#123;&apos;name&apos;:&apos;Login_Passwd&apos;, &apos;value&apos;:&apos;password&apos;&#125;)</span><br><span class="line">#再次访问xx网站，将会自动登录 </span><br><span class="line">driver.get(&quot;http://www.xx.cn/&quot;) </span><br><span class="line">time.sleep(3)</span><br></pre></td></tr></table></figure></blockquote><p>(5)内部提供一个接口获得验证码，然后通过js代码把获取的验证码填写进去：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#自动获取验证码并填写</span><br><span class="line">js=&quot;$.getJSON(&apos;http://xxx.xxx.com/util/getCode.jsonp?callback=?&apos;,function(data)&#123;$(&apos;.imgcode&apos;).val(data.code);&#125;)&quot;</span><br><span class="line">driver.execute_script(js)</span><br></pre></td></tr></table></figure></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;selenium常用API笔记。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="selenium" scheme="http://pythonfood.github.io/categories/selenium/"/>
    
    
      <category term="selenium" scheme="http://pythonfood.github.io/tags/selenium/"/>
    
  </entry>
  
  <entry>
    <title>selenium安装-windows</title>
    <link href="http://pythonfood.github.io/2018/01/01/selenium%E5%AE%89%E8%A3%85-windows/"/>
    <id>http://pythonfood.github.io/2018/01/01/selenium安装-windows/</id>
    <published>2018-01-01T01:00:00.000Z</published>
    <updated>2018-02-23T10:18:00.724Z</updated>
    
    <content type="html"><![CDATA[<p>selenium环境搭建的简单步骤：安装Python——安装pip——安装selenium——安装浏览器驱动。<br><a id="more"></a></p><h3 id="1-安装Python"><a href="#1-安装Python" class="headerlink" title="1.安装Python"></a>1.<a href="https://pythonfood.github.io/2017/12/28/python安装-windows/#more">安装Python</a></h3><h3 id="2-安装pip"><a href="#2-安装pip" class="headerlink" title="2.安装pip"></a>2.安装pip</h3><blockquote><p>方法1：自动安装</p><blockquote><p>在第1步安装python时，已经安装了pip。</p></blockquote><p>方法2：手动安装</p><blockquote><p>(1)下载pip压缩包：<a href="https://pypi.python.org/pypi/pip#downloads" target="_blank" rel="noopener">https://pypi.python.org/pypi/pip#downloads</a><br>(2)解压后cmd进入解压目录，执行<code>python setup.py install</code>进行安装。</p></blockquote></blockquote><h3 id="3-安装selenium"><a href="#3-安装selenium" class="headerlink" title="3.安装selenium"></a>3.安装selenium</h3><blockquote><p>方法1：命令行安装</p><blockquote><p>进入cmd输入命令’pip install selenium’。</p></blockquote><p>方法2：下载whl包安装</p><blockquote><p>(1)下载selenium安装包：<a href="https://pypi.python.org/pypi/selenium" target="_blank" rel="noopener">https://pypi.python.org/pypi/selenium</a> 或 <a href="https://www.seleniumhq.org/download/" target="_blank" rel="noopener">https://www.seleniumhq.org/download/</a><br>(2)下载完成后，进入cmd输入命令<code>pip install</code>，再直接将文件拖入cmd窗口，回车即可安装。</p></blockquote></blockquote><h3 id="4-安装浏览器驱动"><a href="#4-安装浏览器驱动" class="headerlink" title="4.安装浏览器驱动"></a>4.安装浏览器驱动</h3><blockquote><p>(1)下载浏览器驱动</p><blockquote><p>不同浏览器需下载不同驱动，不同版本浏览器对应不同版本驱动。这里只给出chrome和firefox的驱动下载地址：<br>1)chrome：<a href="http://npm.taobao.org/mirrors/chromedriver" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver</a> 或 <a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/index.html</a><br>2)firefox：<a href="https://github.com/mozilla/geckodriver/releases" target="_blank" rel="noopener">https://github.com/mozilla/geckodriver/releases</a></p></blockquote><p>(2)安装浏览器驱动</p><blockquote><p>下载完驱动后解压，将驱动放置在可执行路径下。这里给出三种路径：<br>1)将浏览器驱动放到python的Path路径下。<br>2)将浏览器驱动放到浏览器的Path路径下。<br>3)自定义路径，新建driver文件夹，将驱动放在driver文件下，最后将该路径添加到环境变量中。</p></blockquote></blockquote><h3 id="5-验证环境（小示例）"><a href="#5-验证环境（小示例）" class="headerlink" title="5.验证环境（小示例）"></a>5.验证环境（小示例）</h3><blockquote><p>(1)创建python文件selenium_python.py，内容如下：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(&apos;http://www.baidu.com/&apos;)</span><br></pre></td></tr></table></figure></blockquote><p>(2)cmd执行命令<code>python selenium_python.py</code>。<br>(3)脚本自动执行，结果如下：</p><blockquote><p><img src="/2018/01/01/selenium安装-windows/脚本执行结果.png" alt="脚本执行结果"></p></blockquote></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;selenium环境搭建的简单步骤：安装Python——安装pip——安装selenium——安装浏览器驱动。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="selenium" scheme="http://pythonfood.github.io/categories/selenium/"/>
    
    
      <category term="selenium" scheme="http://pythonfood.github.io/tags/selenium/"/>
    
  </entry>
  
  <entry>
    <title>python初探</title>
    <link href="http://pythonfood.github.io/2017/12/28/python%E5%88%9D%E6%8E%A2/"/>
    <id>http://pythonfood.github.io/2017/12/28/python初探/</id>
    <published>2017-12-28T10:11:57.000Z</published>
    <updated>2018-02-08T08:03:05.224Z</updated>
    
    <content type="html"><![CDATA[<p>人生苦短，我用python。<br><a id="more"></a></p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><pre><code>#!/usr/bin/python3# -*- coding: utf-8 -*-# 第一个注释# 第二个注释&apos;&apos;&apos;第三注释第四注释&apos;&apos;&apos;&quot;&quot;&quot;第五注释第六注释&quot;&quot;&quot;</code></pre><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><pre><code>第一个字符必须是字母表中字母或下划线&apos;_&apos;。标识符的其他的部分有字母、数字和下划线组成。标识符对大小写敏感。</code></pre><h3 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h3><pre><code>&gt;&gt;&gt; import keyword&gt;&gt;&gt; keyword.kwlist[&apos;False&apos;, &apos;None&apos;, &apos;True&apos;, &apos;and&apos;, &apos;as&apos;, &apos;assert&apos;, &apos;break&apos;, &apos;class&apos;, &apos;continue&apos;, &apos;def&apos;, &apos;del&apos;, &apos;elif&apos;, &apos;else&apos;, &apos;except&apos;, &apos;finally&apos;, &apos;for&apos;, &apos;from&apos;, &apos;global&apos;, &apos;if&apos;, &apos;import&apos;, &apos;in&apos;, &apos;is&apos;, &apos;lambda&apos;, &apos;nonlocal&apos;, &apos;not&apos;, &apos;or&apos;, &apos;pass&apos;, &apos;raise&apos;, &apos;return&apos;, &apos;try&apos;, &apos;while&apos;, &apos;with&apos;, &apos;yield&apos;]</code></pre><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><pre><code>print(&apos;hello world&apos;)input(&apos;\n\n按下 enter 键后退出&apos;)</code></pre><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生苦短，我用python。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://pythonfood.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://pythonfood.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python安装-windows</title>
    <link href="http://pythonfood.github.io/2017/12/28/python%E5%AE%89%E8%A3%85-windows/"/>
    <id>http://pythonfood.github.io/2017/12/28/python安装-windows/</id>
    <published>2017-12-28T10:00:00.000Z</published>
    <updated>2018-02-22T09:00:53.171Z</updated>
    
    <content type="html"><![CDATA[<p>人生苦短，我用python。<br><a id="more"></a></p><h3 id="1-进入python官网，下载最新python安装包"><a href="#1-进入python官网，下载最新python安装包" class="headerlink" title="1. 进入python官网，下载最新python安装包"></a>1. 进入<a href="https://www.python.org/downloads/" target="_blank" rel="noopener">python官网</a>，下载最新python安装包</h3><p><img src="/2017/12/28/python安装-windows/1. 下载最新python安装包.png" alt="1. 下载最新python安装包"></p><h3 id="2-下载完成后进行安装，安装时选自定义安装（customize-installation）"><a href="#2-下载完成后进行安装，安装时选自定义安装（customize-installation）" class="headerlink" title="2. 下载完成后进行安装，安装时选自定义安装（customize installation）"></a>2. 下载完成后进行安装，安装时选自定义安装（customize installation）</h3><p>ps:最好勾选Add python 3.6 to path，如果未勾选，需手动配置环境变量</p><p><img src="/2017/12/28/python安装-windows/2. 下载完成后进行安装.png" alt="2. 下载完成后进行安装">    </p><h3 id="3-一路勾选全部选项，自定义安装路径，完成安装后点击close退出"><a href="#3-一路勾选全部选项，自定义安装路径，完成安装后点击close退出" class="headerlink" title="3. 一路勾选全部选项，自定义安装路径，完成安装后点击close退出"></a>3. 一路勾选全部选项，自定义安装路径，完成安装后点击close退出</h3><p>ps:记得勾选pip安装选项，便于后续安装其他库</p><p><img src="/2017/12/28/python安装-windows/3. 完成安装后点击close退出.png" alt="3. 完成安装后点击close退出"></p><h3 id="4-进入cmd，输入python，测试是否安装成功"><a href="#4-进入cmd，输入python，测试是否安装成功" class="headerlink" title="4. 进入cmd，输入python，测试是否安装成功"></a>4. 进入cmd，输入python，测试是否安装成功</h3><p><img src="/2017/12/28/python安装-windows/4. 测试是否安装成功.png" alt="4. 测试是否安装成功"></p><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生苦短，我用python。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://pythonfood.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://pythonfood.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>monkey</title>
    <link href="http://pythonfood.github.io/2017/12/27/monkey/"/>
    <id>http://pythonfood.github.io/2017/12/27/monkey/</id>
    <published>2017-12-27T12:00:00.000Z</published>
    <updated>2018-02-09T09:35:12.818Z</updated>
    
    <content type="html"><![CDATA[<p>Monkey是Android中的一个命令行工具，可以运行在模拟器里或实际设备中。它向系统发送伪随机的用户事件流(如按键输入、触摸屏输入、手势输入等)，实现对正在开发的应用程序进行压力测试。Monkey测试是一种为了测试软件的稳定性、健壮性的快速有效的方法。<br><a id="more"></a></p><h3 id="常用选项："><a href="#常用选项：" class="headerlink" title="常用选项："></a>常用选项：</h3><blockquote><p><code>--help</code>：打印帮助信息<br><code>-v</code>：指定打印信息的详细级别，一个-v增加一个级别，默认级别为0。</p></blockquote><h3 id="事件选项："><a href="#事件选项：" class="headerlink" title="事件选项："></a>事件选项：</h3><blockquote><p><code>-s</code>：指定产生随机事件种子值，相同的种子值产生相同的事件序列。<br><code>--throttle</code>：每个事件结束后的间隔时间。<br><code>--pct-touch</code>：指定(触摸事件)的百分比<br><code>--pct-motion</code>：（滑动事件)<br><code>--pct-trackball</code>：(轨迹球事件)<br><code>--pct-nav</code>：（导航事件 up/down/left/right）<br><code>--pct-majornav</code>：(主要导航事件 back key 、 menu key)<br><code>--pct-syskeys</code>：(系统按键事件 Home 、Back 、startCall 、 endCall 、 volumeControl)<br><code>--pct-appswitch</code> ：（activity之间的切换）<br><code>--pct-anyevent</code> ：（任意事件）</p></blockquote><h3 id="约束选项："><a href="#约束选项：" class="headerlink" title="约束选项："></a>约束选项：</h3><blockquote><p><code>-p</code>：指定有效的package（如不指定，则对系统中所有package有效），一个-p 对应一个有效package。<br><code>-c</code>：activity必须至少包含一个指定的category，才能被启动，否则启动不了。</p></blockquote><h3 id="调试选项："><a href="#调试选项：" class="headerlink" title="调试选项："></a>调试选项：</h3><blockquote><p><code>--dbg-no-events</code>：初始化启动的activity，但是不产生任何事件。<br><code>--hprof</code>：指定该项后在事件序列发送前后会立即生成分析报告  —— 一般建议指定该项。<br><code>--ignore-crashes</code>：忽略崩溃<br><code>--ignore-timeouts</code>：忽略超时<br><code>--ignore-security-exceptions</code>：忽略安全异常<br><code>--kill-process-after-error</code>：发生错误后直接杀掉进程<br><code>--monitor-native-crashes</code>：跟踪本地方法的崩溃问题<br><code>--wait-dbg</code>：知道连接了调试器才执行monkey测试。</p></blockquote><h3 id="小示例："><a href="#小示例：" class="headerlink" title="小示例："></a>小示例：</h3><pre><code>adb shell monkey -p（指定包名） com.hiveview.cloudscreen.py --throttle（操作延时ms） 1000 -s(指定seed值) 1500859116902 -v -v（信息反馈级别） 1000（执行次数）adb shell monkey -p com.hiveview.cloudscreen.py --throttle 100 --pct-majornav 50 --pct-nav 50 -v -v 1000 &gt;d:\monkey.txtadb shell monkey -p com.hiveview.cloudscreen.py --throttle 100 --ignore-crashes --ignore-timeouts --monitor-native-crashes --pct-majornav 50 --pct-nav 50 -v -v 1000 &gt;d:\monkey_log.txtadb shell monkey -p com.hiveview.cloudscreen.py --throttle 100 --pct-nav 50 --pct-majornav 50 -v -v 1000 &gt;d:\monkey_log.txt</code></pre><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Monkey是Android中的一个命令行工具，可以运行在模拟器里或实际设备中。它向系统发送伪随机的用户事件流(如按键输入、触摸屏输入、手势输入等)，实现对正在开发的应用程序进行压力测试。Monkey测试是一种为了测试软件的稳定性、健壮性的快速有效的方法。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="monkey" scheme="http://pythonfood.github.io/categories/monkey/"/>
    
    
      <category term="monkey" scheme="http://pythonfood.github.io/tags/monkey/"/>
    
  </entry>
  
  <entry>
    <title>安卓专项测试-流量</title>
    <link href="http://pythonfood.github.io/2017/12/27/%E5%AE%89%E5%8D%93%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95-%E6%B5%81%E9%87%8F/"/>
    <id>http://pythonfood.github.io/2017/12/27/安卓专项测试-流量/</id>
    <published>2017-12-27T11:25:00.000Z</published>
    <updated>2018-03-06T03:40:02.165Z</updated>
    
    <content type="html"><![CDATA[<p>python脚本实现安卓app的流量消耗测试。<br><a id="more"></a></p><h3 id="1-用到的adb命令"><a href="#1-用到的adb命令" class="headerlink" title="1.用到的adb命令"></a>1.用到的adb命令</h3><p>(1)获取进程ID指令：<br><code>adb shell &quot;ps | grep packagename&quot;</code><br>(2)获取进程ID流量：<br><code>adb shell cat /proc/pid/net/dev</code></p><h3 id="2-脚本实现策略"><a href="#2-脚本实现策略" class="headerlink" title="2.脚本实现策略"></a>2.脚本实现策略</h3><p>(1)设定一个场景，测试一段时间(此处最好再写一个自动化测试的脚本)。<br>(2)记录网卡eth0和eth1的Recevice和Transmit值，取本次流量值和上次流量值之差为所消耗的流量。</p><h3 id="3-测试数据分析"><a href="#3-测试数据分析" class="headerlink" title="3.测试数据分析"></a>3.测试数据分析</h3><p>(1)不同版本之间对比<br>(2)竞品之间对比</p><h3 id="4-代码实现示例"><a href="#4-代码实现示例" class="headerlink" title="4.代码实现示例"></a>4.代码实现示例</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">import time</span><br><span class="line">import csv</span><br><span class="line"></span><br><span class="line">#控制类</span><br><span class="line">class Controller(object):</span><br><span class="line">    def __init__(self,count):</span><br><span class="line">        self.counter = count</span><br><span class="line">        self.allData = [(&apos;timestamp&apos;,&apos;traffic&apos;)]</span><br><span class="line">    </span><br><span class="line">    #单次获取流量值    </span><br><span class="line">    def traffic(self):</span><br><span class="line">        cmd = &apos;adb shell &quot;ps | grep com.android.browser&quot;&apos;</span><br><span class="line">        #截取进程id</span><br><span class="line">        pid = os.popen(cmd).readlines()[0].split(&apos; &apos;)[5]</span><br><span class="line">        #获取进程id所使用的流量</span><br><span class="line">        traffic = os.popen(&apos;adb shell cat /proc/&apos;+pid+&apos;/net/dev&apos;)</span><br><span class="line">        </span><br><span class="line">        for line in traffic:</span><br><span class="line">            if &apos;eth0&apos; in line:</span><br><span class="line">                #将所有空行换成&apos;#&apos;</span><br><span class="line">                line = &apos;#&apos;.join(line.split())</span><br><span class="line">                recevice0 = line.split(&apos;#&apos;)[1]</span><br><span class="line">                transmit0 = line.split(&apos;#&apos;)[9]</span><br><span class="line">            elif &apos;eth1&apos; in line:</span><br><span class="line">                #将所有空行换成&apos;#&apos;</span><br><span class="line">                line = &apos;#&apos;.join(line.split())</span><br><span class="line">                recevice1 = line.split(&apos;#&apos;)[1]</span><br><span class="line">                transmit1 = line.split(&apos;#&apos;)[9]</span><br><span class="line">        #计算流量总和        </span><br><span class="line">        alltraffic = int(recevice0)+int(transmit0)+int(recevice1)+int(transmit1)</span><br><span class="line">        #流量总和按KB计算</span><br><span class="line">        alltraffic = alltraffic/1024</span><br><span class="line">        </span><br><span class="line">        currenttime = self.getCurrentTime()</span><br><span class="line">        self.allData.append((currenttime,alltraffic))</span><br><span class="line">    </span><br><span class="line">    #多次获取流量值    </span><br><span class="line">    def run(self):</span><br><span class="line">        while self.counter&gt;0:</span><br><span class="line">            self.traffic()</span><br><span class="line">            self.counter = self.counter-1</span><br><span class="line">            time.sleep(5)</span><br><span class="line">    </span><br><span class="line">    #获取当前时间戳       </span><br><span class="line">    def getCurrentTime(self):</span><br><span class="line">        currentTime = time.strftime(&apos;%Y-%m-%d_%H:%M:%S&apos;, time.localtime())</span><br><span class="line">        return currentTime</span><br><span class="line">    </span><br><span class="line">    #数据存储</span><br><span class="line">    def SavaDataToCsv(self):</span><br><span class="line">        with open(&apos;traffic.csv&apos;, &apos;w&apos;, newline=&apos;&apos;) as csvfile:</span><br><span class="line">            writer = csv.writer(csvfile)</span><br><span class="line">            writer.writerows(self.allData)</span><br><span class="line">    </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    controller = Controller(5)</span><br><span class="line">    controller.run()</span><br><span class="line">    controller.SavaDataToCsv()</span><br></pre></td></tr></table></figure></blockquote><h3 id="5-测试结果示例"><a href="#5-测试结果示例" class="headerlink" title="5.测试结果示例"></a>5.测试结果示例</h3><p><img src="/2017/12/27/安卓专项测试-流量/流量消耗.png" alt="流量消耗"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python脚本实现安卓app的流量消耗测试。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="专项测试" scheme="http://pythonfood.github.io/categories/%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="专项测试" scheme="http://pythonfood.github.io/tags/%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>安卓专项测试-电量</title>
    <link href="http://pythonfood.github.io/2017/12/27/%E5%AE%89%E5%8D%93%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95-%E7%94%B5%E9%87%8F/"/>
    <id>http://pythonfood.github.io/2017/12/27/安卓专项测试-电量/</id>
    <published>2017-12-27T11:24:00.000Z</published>
    <updated>2018-03-06T03:37:33.542Z</updated>
    
    <content type="html"><![CDATA[<p>python脚本实现安卓app的电量消耗测试。<br><a id="more"></a></p><h3 id="1-用到的adb命令"><a href="#1-用到的adb命令" class="headerlink" title="1.用到的adb命令"></a>1.用到的adb命令</h3><p>(1)获取电量信息：<br><code>adb shell dumpsys battery</code><br>(2)切换非充电状态：<br><code>adb shell dumpsys battery set status 1</code></p><h3 id="2-脚本实现策略"><a href="#2-脚本实现策略" class="headerlink" title="2.脚本实现策略"></a>2.脚本实现策略</h3><p>(1)设定一个场景，测试一段时间(此处最好再写一个自动化测试的脚本)。<br>(2)记录电量level值，取最后一次和第一次电量差值，获取消耗的电量值。</p><h3 id="3-测试数据分析"><a href="#3-测试数据分析" class="headerlink" title="3.测试数据分析"></a>3.测试数据分析</h3><p>(1)不同版本之间对比<br>(2)竞品之间对比</p><h3 id="4-代码实现示例"><a href="#4-代码实现示例" class="headerlink" title="4.代码实现示例"></a>4.代码实现示例</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">import time</span><br><span class="line">import csv</span><br><span class="line"></span><br><span class="line">#控制类</span><br><span class="line">class Controller(object):</span><br><span class="line">    def __init__(self,count):</span><br><span class="line">        self.counter = count</span><br><span class="line">        self.allData = [(&apos;timestamp&apos;,&apos;power&apos;)]</span><br><span class="line">    </span><br><span class="line">    #单次获取电量值    </span><br><span class="line">    def power(self):</span><br><span class="line">        #获取电量状态</span><br><span class="line">        powerStatus = os.popen(&apos;adb shell dumpsys battery&apos;)</span><br><span class="line">        </span><br><span class="line">        for line in powerStatus:</span><br><span class="line">            if &apos;level&apos; in line:</span><br><span class="line">                power = line.split(&apos;:&apos;)[1].strip(&apos;\n&apos;)</span><br><span class="line">        </span><br><span class="line">        currenttime = self.getCurrentTime()</span><br><span class="line">        self.allData.append((currenttime,power))</span><br><span class="line">    </span><br><span class="line">    #多次获取电量值    </span><br><span class="line">    def run(self):</span><br><span class="line">        os.popen(&apos;adb shell dumpsys battery set status 1&apos;)</span><br><span class="line">        while self.counter&gt;0:</span><br><span class="line">            self.power()</span><br><span class="line">            self.counter = self.counter-1</span><br><span class="line">            time.sleep(5)</span><br><span class="line">    </span><br><span class="line">    #获取当前时间 戳       </span><br><span class="line">    def getCurrentTime(self):</span><br><span class="line">        currentTime = time.strftime(&apos;%Y-%m-%d_%H:%M:%S&apos;, time.localtime())</span><br><span class="line">        return currentTime</span><br><span class="line">    </span><br><span class="line">    #数据存储</span><br><span class="line">    def SavaDataToCsv(self):</span><br><span class="line">        with open(&apos;power.csv&apos;, &apos;w&apos;, newline=&apos;&apos;) as csvfile:</span><br><span class="line">            writer = csv.writer(csvfile)</span><br><span class="line">            writer.writerows(self.allData)</span><br><span class="line">    </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    controller = Controller(5)</span><br><span class="line">    controller.run()</span><br><span class="line">    controller.SavaDataToCsv()</span><br></pre></td></tr></table></figure></blockquote><h3 id="5-测试结果示例"><a href="#5-测试结果示例" class="headerlink" title="5.测试结果示例"></a>5.测试结果示例</h3><p><img src="/2017/12/27/安卓专项测试-电量/电量消耗.png" alt="电量消耗"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python脚本实现安卓app的电量消耗测试。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="专项测试" scheme="http://pythonfood.github.io/categories/%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="专项测试" scheme="http://pythonfood.github.io/tags/%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>安卓专项测试-内存</title>
    <link href="http://pythonfood.github.io/2017/12/27/%E5%AE%89%E5%8D%93%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95-%E5%86%85%E5%AD%98/"/>
    <id>http://pythonfood.github.io/2017/12/27/安卓专项测试-内存/</id>
    <published>2017-12-27T11:23:00.000Z</published>
    <updated>2018-03-06T03:22:14.847Z</updated>
    
    <content type="html"><![CDATA[<p>python脚本实现安卓app的内存状态测试。<br><a id="more"></a></p><h3 id="1-用到的adb命令"><a href="#1-用到的adb命令" class="headerlink" title="1.用到的adb命令"></a>1.用到的adb命令</h3><p>(1)<code>adb shell top -d 刷新时间 &gt; meminfo</code></p><ul><li>VSS - 虚拟耗用内存</li><li>RSS - 实际使用物理内存</li></ul><p>(2)<code>cat meminfo | grep com.android.browser</code></p><h3 id="2-脚本实现策略"><a href="#2-脚本实现策略" class="headerlink" title="2.脚本实现策略"></a>2.脚本实现策略</h3><p>(1)打开app进行测试(此处最好再写一个自动化测试的脚本)。<br>(2)执行<code>adb shell top -d 1 &gt; D:\adt-workspace\appMemInfo\memInfo</code>，打印内存信息。<br>(3)执行脚本读取内存信息，保存到csv文件。</p><h3 id="3-测试数据分析"><a href="#3-测试数据分析" class="headerlink" title="3.测试数据分析"></a>3.测试数据分析</h3><p>曲线图分析：查看内存是否是一味上涨的趋势，不会回收或者部分回收。</p><h3 id="4-代码实现示例"><a href="#4-代码实现示例" class="headerlink" title="4.代码实现示例"></a>4.代码实现示例</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line">import csv</span><br><span class="line"></span><br><span class="line">#控制类</span><br><span class="line">class Controller(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.allData = [(&apos;id&apos;, &apos;VSS&apos;, &apos;RSS&apos;)]</span><br><span class="line">    </span><br><span class="line">    #读取数据文件    </span><br><span class="line">    def readFile(self):</span><br><span class="line">        with open(&apos;meminfo&apos;, &apos;r&apos;, ) as memfile:</span><br><span class="line">            meminfo = memfile.readlines()</span><br><span class="line">            print(meminfo)</span><br><span class="line">        return meminfo</span><br><span class="line">    </span><br><span class="line">    #分析数据    </span><br><span class="line">    def analyzeData(self):</span><br><span class="line">        meminfo = self.readFile()</span><br><span class="line">        i=0 </span><br><span class="line">        for line in meminfo:</span><br><span class="line">            if &apos;com.android.browser&apos; in line:</span><br><span class="line">                line = &apos;#&apos;.join(line.split())</span><br><span class="line">                print(line)</span><br><span class="line">                vss = line.split(&apos;#&apos;)[5].strip(&apos;K&apos;)</span><br><span class="line">                rss = line.split(&apos;#&apos;)[6].strip(&apos;K&apos;)</span><br><span class="line">                self.allData.append((i, vss, rss))</span><br><span class="line">                i=i+1</span><br><span class="line">    #存取数据    </span><br><span class="line">    def saveDataToCsv(self):</span><br><span class="line">        with open(&apos;meminfo.csv&apos;, &apos;w&apos;, newline=&apos;&apos;) as csvfile:</span><br><span class="line">            writer = csv.writer(csvfile)</span><br><span class="line">            writer.writerows(self.allData)</span><br><span class="line">        </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    controller = Controller()</span><br><span class="line">    controller.analyzeData()</span><br><span class="line">    controller.saveDataToCsv()</span><br></pre></td></tr></table></figure></blockquote><h3 id="5-测试结果示例"><a href="#5-测试结果示例" class="headerlink" title="5.测试结果示例"></a>5.测试结果示例</h3><p><img src="/2017/12/27/安卓专项测试-内存/内存信息.png" alt="内存信息"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python脚本实现安卓app的内存状态测试。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="专项测试" scheme="http://pythonfood.github.io/categories/%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="专项测试" scheme="http://pythonfood.github.io/tags/%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>安卓专项测试-cpu</title>
    <link href="http://pythonfood.github.io/2017/12/27/%E5%AE%89%E5%8D%93%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95-cpu/"/>
    <id>http://pythonfood.github.io/2017/12/27/安卓专项测试-cpu/</id>
    <published>2017-12-27T11:22:00.000Z</published>
    <updated>2018-03-06T03:22:04.546Z</updated>
    
    <content type="html"><![CDATA[<p>python脚本实现安卓app的cpu使用率测试。<br><a id="more"></a></p><h3 id="1-用到的adb命令"><a href="#1-用到的adb命令" class="headerlink" title="1.用到的adb命令"></a>1.用到的adb命令</h3><p><code>adb shell &quot;dumpsys cpuinfo | grep packagename&quot;</code></p><h3 id="2-脚本实现策略"><a href="#2-脚本实现策略" class="headerlink" title="2.脚本实现策略"></a>2.脚本实现策略</h3><p>(1)打开app进行测试(此处最好再写一个自动化测试的脚本)。<br>(2)执行脚本定时获取CPU使用状态。</p><h3 id="3-测试数据分析"><a href="#3-测试数据分析" class="headerlink" title="3.测试数据分析"></a>3.测试数据分析</h3><p>曲线图分析：cpu使用率如果保持恒定并合理则正常；如果随着使用cpu使用率持续上升，接近100%可能存在问题。</p><h3 id="4-代码实现示例"><a href="#4-代码实现示例" class="headerlink" title="4.代码实现示例"></a>4.代码实现示例</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">import time</span><br><span class="line">import csv    </span><br><span class="line"></span><br><span class="line">#控制类</span><br><span class="line">class Controller(object):</span><br><span class="line">    def __init__(self,count):</span><br><span class="line">        self.counter = count</span><br><span class="line">        self.allData = [(&apos;timestamp&apos;,&apos;cpustatus&apos;)]</span><br><span class="line">    </span><br><span class="line">    #单次查看CPU状态״̬</span><br><span class="line">    def CpuStatus(self):</span><br><span class="line">        cmd = &apos;adb shell &quot;dumpsys cpuinfo | grep com.android.calculator2&quot;&apos;</span><br><span class="line">        cpustatus = os.popen(cmd).readlines()</span><br><span class="line">        for line in cpustatus:</span><br><span class="line">            cpuvalue = line.split(&apos;%&apos;)[0].strip()  </span><br><span class="line">            break  </span><br><span class="line">            </span><br><span class="line">        currenttime = self.GetCurrentTime()</span><br><span class="line">        self.allData.append((currenttime, cpuvalue))</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    #多次查看CPU状态    </span><br><span class="line">    def run(self):</span><br><span class="line">        while self.counter&gt;0:</span><br><span class="line">            self.CpuStatus()</span><br><span class="line">            self.counter = self.counter-1</span><br><span class="line">            time.sleep(3)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    #获取当前时间戳         </span><br><span class="line">    def GetCurrentTime(self):</span><br><span class="line">        #时间格式如果写成%Y-%m-%d %H:%M:%S，写入csv时会被自定义格式隐藏秒</span><br><span class="line">        currentTime = time.strftime(&apos;%Y-%m-%d_%H:%M:%S&apos;, time.localtime()) </span><br><span class="line">        return currentTime</span><br><span class="line">    </span><br><span class="line">    #数据存储</span><br><span class="line">    def SaveDataToCSV(self):</span><br><span class="line">        with open(&apos;cpuStatus.csv&apos;, &apos;w&apos;, newline=&apos;&apos;) as csvfile:</span><br><span class="line">            writer = csv.writer(csvfile)</span><br><span class="line">            writer.writerows(self.allData)</span><br><span class="line">        </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    controller = Controller(10)</span><br><span class="line">    controller.run()</span><br><span class="line">    controller.SaveDataToCSV()</span><br></pre></td></tr></table></figure></blockquote><h3 id="5-测试结果示例"><a href="#5-测试结果示例" class="headerlink" title="5.测试结果示例"></a>5.测试结果示例</h3><p><img src="/2017/12/27/安卓专项测试-cpu/cpu使用率.png" alt="cpu使用率"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python脚本实现安卓app的cpu使用率测试。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="专项测试" scheme="http://pythonfood.github.io/categories/%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="专项测试" scheme="http://pythonfood.github.io/tags/%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>安卓专项测试-启动时间</title>
    <link href="http://pythonfood.github.io/2017/12/27/%E5%AE%89%E5%8D%93%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95-%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4/"/>
    <id>http://pythonfood.github.io/2017/12/27/安卓专项测试-启动时间/</id>
    <published>2017-12-27T11:21:00.000Z</published>
    <updated>2018-03-06T03:27:12.743Z</updated>
    
    <content type="html"><![CDATA[<p>python脚本实现安卓app的启动时间测试。<br><a id="more"></a></p><h3 id="1-用到的adb命令"><a href="#1-用到的adb命令" class="headerlink" title="1.用到的adb命令"></a>1.用到的adb命令</h3><p>(1)查看activity：</p><blockquote><p><code>adb shell dumpsys window | findstr mCurrentFocus</code><br><code>adb shell dumpsys activity activities</code></p></blockquote><p>(2)启动app：</p><blockquote><p><code>adb shell am start -W -n package/activity</code></p></blockquote><p>(3)停止app：</p><blockquote><p><code>adb shell am force-stop package</code></p></blockquote><p>(4)home退出app：</p><blockquote><p><code>adb shell input keyevent 3</code></p></blockquote><h3 id="2-脚本实现策略"><a href="#2-脚本实现策略" class="headerlink" title="2.脚本实现策略"></a>2.脚本实现策略</h3><p>策略一：获取命令执行时间，作为启动时间参考值，比较好实现。<br>策略二：在命令前后加上时间戳，以差值作为参考值，比较准确。</p><h3 id="3-测试数据分析"><a href="#3-测试数据分析" class="headerlink" title="3.测试数据分析"></a>3.测试数据分析</h3><p>一般剔除第一次数据，取剩余次数数据进行分析，因为第一次往往不准确。<br>(1)均值。<br>(2)曲线的波动范围。<br>(3)不同版本对比。<br>(4)和竞品对比。</p><h3 id="4-代码实现示例"><a href="#4-代码实现示例" class="headerlink" title="4.代码实现示例"></a>4.代码实现示例</h3><p>(1)冷启动</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">import time</span><br><span class="line">import csv</span><br><span class="line"></span><br><span class="line">#app类</span><br><span class="line">class App(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.content = &apos;&apos;</span><br><span class="line">        self.startTime = 0</span><br><span class="line">        </span><br><span class="line">    #启动app        </span><br><span class="line">    def LaunchApp(self):</span><br><span class="line">        cmd = &apos;adb shell am start -W -n com.android.calculator2/com.android.calculator2.Calculator&apos;</span><br><span class="line">        self.content = os.popen(cmd)</span><br><span class="line">   </span><br><span class="line">    #停止app</span><br><span class="line">    def StopApp(self):</span><br><span class="line">        #冷启动时强制退出</span><br><span class="line">        cmd = &apos;adb shell am force-stop com.android.calculator2&apos;</span><br><span class="line">        os.popen(cmd)</span><br><span class="line">    </span><br><span class="line">    #获取启动时间    </span><br><span class="line">    def GetLaunchedTime(self):</span><br><span class="line">        for line in self.content.readlines():</span><br><span class="line">            if &apos;ThisTime&apos; in line:</span><br><span class="line">                #split(&apos;:&apos;)[1]截取启动时间；strip(&apos;\n&apos;)去掉换行符</span><br><span class="line">                self.startTime = line.split(&apos;:&apos;)[1].strip(&apos;\n&apos;)</span><br><span class="line">                break</span><br><span class="line">        return self.startTime</span><br><span class="line"></span><br><span class="line">#控制类</span><br><span class="line">class Controller(object):</span><br><span class="line">    def __init__(self,count):</span><br><span class="line">        self.app = App()</span><br><span class="line">        self.counter = count</span><br><span class="line">        self.allData = [(&apos;timestamp&apos;,&apos;elapsedtime&apos;)]</span><br><span class="line">    </span><br><span class="line">    #单次启动和停止</span><br><span class="line">    def LaunchAndStop(self):</span><br><span class="line">        self.app.LaunchApp()</span><br><span class="line">        elapsedtime = self.app.GetLaunchedTime()</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        self.app.StopApp()</span><br><span class="line">        currenttime = self.GetCurrentTime()</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        self.allData.append((currenttime,elapsedtime))</span><br><span class="line">        </span><br><span class="line">    #多次执行启动和停止    </span><br><span class="line">    def run(self):</span><br><span class="line">        while self.counter&gt;0:</span><br><span class="line">            self.LaunchAndStop()</span><br><span class="line">            self.counter = self.counter-1</span><br><span class="line">    </span><br><span class="line">    #获取当前时间戳        </span><br><span class="line">    def GetCurrentTime(self):</span><br><span class="line">        #时间格式如果写成%Y-%m-%d %H:%M:%S，写入csv时会被自定义格式隐藏秒</span><br><span class="line">        currentTime = time.strftime(&apos;%Y-%m-%d_%H:%M:%S&apos;, time.localtime()) </span><br><span class="line">        return currentTime</span><br><span class="line">    </span><br><span class="line">    #数据存储</span><br><span class="line">    def SaveDataToCSV(self):</span><br><span class="line">        csvfile=open(&apos;coldStartTime.csv&apos;, &apos;w&apos;, newline=&apos;&apos;)    </span><br><span class="line">        writer = csv.writer(csvfile)</span><br><span class="line">        writer.writerows(self.allData)</span><br><span class="line">        csvfile.close()   </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    controller = Controller(10)</span><br><span class="line">    controller.run()</span><br><span class="line">    controller.SaveDataToCSV()</span><br></pre></td></tr></table></figure></blockquote><p>(2)热启动</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">import time</span><br><span class="line">import csv</span><br><span class="line"></span><br><span class="line">#app类</span><br><span class="line">class App(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.content = &apos;&apos;</span><br><span class="line">        self.startTime = 0</span><br><span class="line">        </span><br><span class="line">    #启动app        </span><br><span class="line">    def LaunchApp(self):</span><br><span class="line">        cmd = &apos;adb shell am start -W -n com.android.calculator2/com.android.calculator2.Calculator&apos;</span><br><span class="line">        self.content = os.popen(cmd)</span><br><span class="line">   </span><br><span class="line">    #停止app</span><br><span class="line">    def StopApp(self):</span><br><span class="line">        #热启动时home键退出</span><br><span class="line">        cmd = &apos;adb shell input keyevent 3&apos;</span><br><span class="line">        os.popen(cmd)</span><br><span class="line">    </span><br><span class="line">    #获取启动时间    </span><br><span class="line">    def GetLaunchedTime(self):</span><br><span class="line">        for line in self.content.readlines():</span><br><span class="line">            if &apos;ThisTime&apos; in line:</span><br><span class="line">                #split(&apos;:&apos;)[1]截取启动时间；strip(&apos;\n&apos;)去掉换行符</span><br><span class="line">                self.startTime = line.split(&apos;:&apos;)[1].strip(&apos;\n&apos;)</span><br><span class="line">                break</span><br><span class="line">        return self.startTime</span><br><span class="line"></span><br><span class="line">#控制类</span><br><span class="line">class Controller(object):</span><br><span class="line">    def __init__(self,count):</span><br><span class="line">        self.app = App()</span><br><span class="line">        self.counter = count</span><br><span class="line">        self.allData = [(&apos;timestamp&apos;,&apos;elapsedtime&apos;)]</span><br><span class="line">    </span><br><span class="line">    #单次启动和停止</span><br><span class="line">    def LaunchAndStop(self):</span><br><span class="line">        self.app.LaunchApp()</span><br><span class="line">        elapsedtime = self.app.GetLaunchedTime()</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        self.app.StopApp()</span><br><span class="line">        currenttime = self.GetCurrentTime()</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        self.allData.append((currenttime,elapsedtime))</span><br><span class="line">        </span><br><span class="line">    #多次执行启动和停止    </span><br><span class="line">    def run(self):</span><br><span class="line">        while self.counter&gt;0:</span><br><span class="line">            self.LaunchAndStop()</span><br><span class="line">            self.counter = self.counter-1</span><br><span class="line">    </span><br><span class="line">    #获取当前时间戳        </span><br><span class="line">    def GetCurrentTime(self):</span><br><span class="line">        #时间格式如果写成%Y-%m-%d %H:%M:%S，写入csv时会被自定义格式隐藏秒</span><br><span class="line">        currentTime = time.strftime(&apos;%Y-%m-%d_%H:%M:%S&apos;, time.localtime()) </span><br><span class="line">        return currentTime</span><br><span class="line">    </span><br><span class="line">    #数据存储</span><br><span class="line">    def SaveDataToCSV(self):</span><br><span class="line">        with open(&apos;hotStartTime.csv&apos;, &apos;w&apos;, newline=&apos;&apos;) as csvfile:</span><br><span class="line">            writer = csv.writer(csvfile)</span><br><span class="line">            writer.writerows(self.allData)</span><br><span class="line">    </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    controller = Controller(10)</span><br><span class="line">    controller.run()</span><br><span class="line">    controller.SaveDataToCSV()</span><br></pre></td></tr></table></figure></blockquote><h3 id="5-测试结果示例"><a href="#5-测试结果示例" class="headerlink" title="5.测试结果示例"></a>5.测试结果示例</h3><p>(1)冷启动</p><p><img src="/2017/12/27/安卓专项测试-启动时间/冷启动时间.png" alt="冷启动时间"></p><p>(2)热启动</p><p><img src="/2017/12/27/安卓专项测试-启动时间/热启动时间.png" alt="热启动时间"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python脚本实现安卓app的启动时间测试。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="专项测试" scheme="http://pythonfood.github.io/categories/%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="专项测试" scheme="http://pythonfood.github.io/tags/%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>安卓专项测试</title>
    <link href="http://pythonfood.github.io/2017/12/27/%E5%AE%89%E5%8D%93%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95/"/>
    <id>http://pythonfood.github.io/2017/12/27/安卓专项测试/</id>
    <published>2017-12-27T11:10:00.000Z</published>
    <updated>2018-03-06T02:03:55.930Z</updated>
    
    <content type="html"><![CDATA[<p>安卓专项测试主要包括：响应时间、cpu、内存、电量、流量、FPS、过度渲染。<br><a id="more"></a></p><h3 id="响应时间："><a href="#响应时间：" class="headerlink" title="响应时间："></a>响应时间：</h3><blockquote><p>1.安装：普通安装、覆盖安装<br>2.启动：冷启动、热启动</p><blockquote><p>(1)adb命令：adb logcat、adb shell am start、adb shell screenrecord等。</p><blockquote><p>小示例：<br>1)adb shell screenrecord /sdcard/demo.mp4<br>2)adb pull /sdcard/demo.mp4 d:\record<br>3)用按帧播放的视频软件播放分析，比如KMplayer。</p></blockquote><p>(2)代码里打点（埋点）。<br>(3)高速相机。<br>(4)秒表。<br>(5)第三方工具或云测平台。</p></blockquote><p>3.跳转：页面之间、控件之间</p></blockquote><h3 id="cpu"><a href="#cpu" class="headerlink" title="cpu:"></a>cpu:</h3><blockquote><p>1.活动状态<br>2.静默状态</p><blockquote><p>(1)第三方工具：腾讯GT、网易Emmagee、阿里易测等。（小白首选）。<br>(2)dumpsys命令：adb shell dumpsys cpuinfo | grep {PackageName}。<br>(3)top命令：adb shell top | grep {PackageName}。</p><blockquote><p>小示例：<br>1)adb shell<br>2)top | grep com.peng.cloudp.tv</p><blockquote><p>第一列PID:进度ID<br>第二列PR:优先级<br>第三列CPU:瞬时CPU占用率<br>第四列进程状态:R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程<br>第五列THR:当前应用所用的线程数<br>第六列VSS:虚拟消耗内存<br>第七列RSS:实际使用物理内存<br>第八列UID:进程所有者的用户ID<br>第九列PR:进程名称</p></blockquote></blockquote></blockquote></blockquote><h3 id="内存："><a href="#内存：" class="headerlink" title="内存："></a>内存：</h3><blockquote><p>1.命令查看内存数据</p><blockquote><p>(1)adb shell dumpsys meminfo {PackageName}查看内存是否是一味上涨的趋势，不会回收或者部分回收。<br>(2)/system/build.prop 查看每个应用分配的最高内存值。<br>adb shell procrank (没有可以从网上下载procrank文件)。</p><blockquote><p>PID:进程ID<br>VSS:虚拟消耗内存<br>RSS:实际使用物理内存，是共享内存+私有内存。<br>PSS:占用私有内存加上平均分配的的共享内存。<br>USS:私有内存，如果应用终止了，这部分内存会释放。如果这个值超过应用被分配的最大值，就会闪退。</p></blockquote></blockquote><p>2.Memory Monitor查看内存风险<br>3.MAT分析内存泄漏<br>4.Zombie辅助检查内存占用</p></blockquote><h3 id="电量："><a href="#电量：" class="headerlink" title="电量："></a>电量：</h3><blockquote><p>1.待机：无网络待机、wifi待机、3G待机等。<br>2.活动状态：不断地进行某些场景操作、看视频、灭屏下载、唤醒等。<br>3.静默状态：打开app后不操作，后台运行。</p><blockquote><p>(1)通过硬件测试：耗电量测试仪、腾讯的电量宝等<br>(2)通过adb shell dumps batterystats命令。（android5.0以上使用）<br>(3)第三方工具或云测平台。<br>(4)android自带的电量统计。</p></blockquote></blockquote><h3 id="流量："><a href="#流量：" class="headerlink" title="流量："></a>流量：</h3><blockquote><p>1.活动状态<br>2.静默状态</p><blockquote><p>(1)通过Tcpdump抓包，然后用Wireshark分析。如果想更自动化，可以用FildderCore二次开发。<br>(2)查看Linux流量统计文件。</p><blockquote><p>小示例：<br>1)ps | grep com.peng.cloudp.tv （获取的pid为9696）<br>2)cat /proc/9696/status （通过pid值获取uid为10035）<br>3)cat /proc/uid_stat/10035/tcp_snd （通过uid获取发送的流量byte,为15584）<br>4)cat /proc/uid_stat/10035/tcp_rcv （通过uid获取接收的流量byte,为16778）</p></blockquote><p>(3)利用类似DDMS的工具查看流量。（小白首选）<br>(4)通过Android API 的 TrafficStats类来统计。<br>(5)第三方工具或云测平台。</p></blockquote></blockquote><h3 id="FPS："><a href="#FPS：" class="headerlink" title="FPS："></a>FPS：</h3><blockquote><p>1.adb shell dumpsys gfxinfo</p><blockquote><p>小示例：<br>1)adb shell dumpsys gfxinfo com.peng.cloudp.tv &gt;&gt; com.peng.cloudp.tv.txt<br>2)抓取数据后用表格进行分析</p></blockquote><p>2.monitor.bat进行测试</p><p>3.打开【设置-开发者选项-GPU呈现模式分析-在屏幕上显示为条形图】，开启后点击应用，可以看到条形图。</p><blockquote><p>测试应用流畅度：<br>(1)条形图高于绿线，说明出现卡顿<br>(2)条形图低于绿线，说明比较流畅</p></blockquote></blockquote><h3 id="过度渲染："><a href="#过度渲染：" class="headerlink" title="过度渲染："></a>过度渲染：</h3><blockquote><p>1.打开【设置-开发者选项-调试GPU过度绘制-显示过度绘制区域】，开启后点击应用，可以看到各种颜色的区域。</p><blockquote><p>颜色的标识：<br>(1)蓝色1x过度绘制<br>(2)绿色2x过度绘制<br>(3)淡红色3x过度绘制<br>(4)红色超过4x过度绘制</p></blockquote><p>2.颜色越浅越好:蓝-绿-淡红-红。最理想的是一个像素只绘制一次，合格的页面是白色、蓝色为主，绿色以上区域不能超过整个的三分之一。</p><blockquote><p>验收标准：<br>(1)控制过度绘制为2x<br>(2)不允许存在4x过度绘制<br>(3)不允许存在面积超过屏幕1/4区域的3x过度绘制（淡红色区域）</p></blockquote></blockquote><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安卓专项测试主要包括：响应时间、cpu、内存、电量、流量、FPS、过度渲染。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="专项测试" scheme="http://pythonfood.github.io/categories/%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="专项测试" scheme="http://pythonfood.github.io/tags/%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>流程分析</title>
    <link href="http://pythonfood.github.io/2017/12/27/%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://pythonfood.github.io/2017/12/27/流程分析/</id>
    <published>2017-12-27T09:10:07.000Z</published>
    <updated>2018-02-09T06:21:30.081Z</updated>
    
    <content type="html"><![CDATA[<p>现在的软件几乎都是用事件触发来控制流程的，事件触发时的情景便形成了场景，而同一事件不同的触发顺序和处理结果就形成事件流。这种在软件设计方面的思想也可引入到软件测试中，可以比较生动地描绘出事件触发时的情景，有利于测试设用例场景用来描述流经用例的路径。<br><a id="more"></a></p><h3 id="场景设计法三个流程："><a href="#场景设计法三个流程：" class="headerlink" title="场景设计法三个流程："></a>场景设计法三个流程：</h3><blockquote><p>1.基本流：通过业务流程输入都为正确的，能够最后到达目标的流程<br>2.备选流：通过实现业务流程时，因错误操作或异常输入，导致流程存在反复，但最终能够完成期望业务的流程。<br>3.异常流：通过实现业务流程时，因错误操作或异常输入，导致业务没有正确完成。</p></blockquote><p><img src="/2017/12/27/流程分析/流程图.jpg" alt="流程图"></p><h3 id="流程分析应用步骤："><a href="#流程分析应用步骤：" class="headerlink" title="流程分析应用步骤："></a>流程分析应用步骤：</h3><blockquote><p>1.理解需求，确定业务流程（基本流、备选流、异常流）。<br>2.绘制流程图（再次明确流程路径）。<br>3.根据业务流程图，抽取测试路径（每次路径需包含一个从未走过的路径）。<br>4.细化路径设计测试用例。</p></blockquote><h3 id="流程分析法注意点："><a href="#流程分析法注意点：" class="headerlink" title="流程分析法注意点："></a>流程分析法注意点：</h3><blockquote><p>需使用等价类、边界值、正交试验、判定表、因果图等方法保证单个功能的正确性。</p></blockquote><h4 id="小示例："><a href="#小示例：" class="headerlink" title="小示例："></a>小示例：</h4><p>1.画出流程图<br><img src="/2017/12/27/流程分析/1.画出流程图.png" alt="1.画出流程图"><br>2.流程图类需求<br><img src="/2017/12/27/流程分析/2.流程图类需求.png" alt="2.流程图类需求"><br>3.根据需求画流程图，流程覆盖写用例<br><img src="/2017/12/27/流程分析/3.根据需求画流程图，流程覆盖写用例.png" alt="3.根据需求画流程图，流程覆盖写用例"></p><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在的软件几乎都是用事件触发来控制流程的，事件触发时的情景便形成了场景，而同一事件不同的触发顺序和处理结果就形成事件流。这种在软件设计方面的思想也可引入到软件测试中，可以比较生动地描绘出事件触发时的情景，有利于测试设用例场景用来描述流经用例的路径。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="测试用例" scheme="http://pythonfood.github.io/categories/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
    
      <category term="测试用例" scheme="http://pythonfood.github.io/tags/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>状态迁移</title>
    <link href="http://pythonfood.github.io/2017/12/27/%E7%8A%B6%E6%80%81%E8%BF%81%E7%A7%BB/"/>
    <id>http://pythonfood.github.io/2017/12/27/状态迁移/</id>
    <published>2017-12-27T09:10:06.000Z</published>
    <updated>2018-02-09T06:22:14.322Z</updated>
    
    <content type="html"><![CDATA[<p>状态迁移关注被测对象的状态变化，在需求规格说明书中是否有不可达到的状态和非法的状态，是否产生非法的状态迁移。<br><a id="more"></a></p><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><blockquote><p>被测对象在特定输入条件下所保持的响应形式</p></blockquote><h3 id="状态迁移应用步骤："><a href="#状态迁移应用步骤：" class="headerlink" title="状态迁移应用步骤："></a>状态迁移应用步骤：</h3><blockquote><p>1.根据需求明确状态节点。<br>2.绘制状态迁移图。<br>3.绘制状态迁移树。<br>4.抽取测试用例。</p></blockquote><h4 id="小示例："><a href="#小示例：" class="headerlink" title="小示例："></a>小示例：</h4><p>1.状态迁移类需求<br><img src="/2017/12/27/状态迁移/1.状态迁移类需求.png" alt="1.状态迁移类需求"><br>2.根据需求画状态迁移图案例1<br><img src="/2017/12/27/状态迁移/2.根据需求画状态迁移图案例1.png" alt="2.根据需求画状态迁移图案例1"><br>3.根据需求画状态迁移图案例2<br><img src="/2017/12/27/状态迁移/3.根据需求画状态迁移图案例2.png" alt="3.根据需求画状态迁移图案例2"></p><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;状态迁移关注被测对象的状态变化，在需求规格说明书中是否有不可达到的状态和非法的状态，是否产生非法的状态迁移。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="测试用例" scheme="http://pythonfood.github.io/categories/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
    
      <category term="测试用例" scheme="http://pythonfood.github.io/tags/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>正交试验</title>
    <link href="http://pythonfood.github.io/2017/12/27/%E6%AD%A3%E4%BA%A4%E8%AF%95%E9%AA%8C/"/>
    <id>http://pythonfood.github.io/2017/12/27/正交试验/</id>
    <published>2017-12-27T09:10:05.000Z</published>
    <updated>2018-02-09T06:22:03.782Z</updated>
    
    <content type="html"><![CDATA[<p>正交试验是研究多因素多水平的一种设计方法，它是根据正交性从全面试验中挑选出部分有代表性的点进行试验，这些有代表性的点具备了“均匀分散，齐整可比”的特点，正交试验设计是一种基于正交表的、高效率、快速、经济的试验。<br><a id="more"></a></p><h3 id="正交试验重要概念："><a href="#正交试验重要概念：" class="headerlink" title="正交试验重要概念："></a>正交试验重要概念：</h3><blockquote><p>1.因子：所有参与试验的影响试验结果的条件成为因子。<br>2.水平：影响试验因子的取值或输入称为水平。<br>3.整齐可比：在同一张正交表中，每个因子每个水平出现的次数完全相同。试验中，每个因子的每个水平与其他因子的水平参与试验的机率完全相同。<br>4.均匀分散：同一张正交表中，任意两列水平搭配是完全相同的。</p></blockquote><h3 id="正交试验应用步骤："><a href="#正交试验应用步骤：" class="headerlink" title="正交试验应用步骤："></a>正交试验应用步骤：</h3><blockquote><p>1.分析需求获取因子和水平。<br>2.根据因子和水平选择合适的正交表。<br>3.替换因子和水平，获取试验次数。<br>4.根据试验或其他因素补充试验次数。<br>5.细化输出获取测试用例。</p></blockquote><h3 id="正交试验注意点："><a href="#正交试验注意点：" class="headerlink" title="正交试验注意点："></a>正交试验注意点：</h3><blockquote><p>1.选择正交表的因子与水平恰好与正交表相同。<br>2.根据对象因子与正交表中的因子不同，选择正交表中因子稍大于被测对象因子数，且试验次数最少的，多余的因子弃用。<br>3.被测对象水平与正交表中的水平不同，可根据实际情况进行合并，然后拆分。<br>4.因子水平都不相同，则可选择因子，水平稍大于被测对象的，且实验次数最少的。</p></blockquote><h4 id="小示例："><a href="#小示例：" class="headerlink" title="小示例："></a>小示例：</h4><p>1.提取因子和水平<br><img src="/2017/12/27/正交试验/1.提取因子和水平.png" alt="1.提取因子和水平"><br>2.设计正交试验表，补充缺少的必要用例<br><img src="/2017/12/27/正交试验/2.设计正交试验表，补充缺少的必要用例.png" alt="2.设计正交试验表，补充缺少的必要用例"><br>3.替换因子水平得出用例<br><img src="/2017/12/27/正交试验/3.替换因子水平得出用例.png" alt="3.替换因子水平得出用例"></p><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正交试验是研究多因素多水平的一种设计方法，它是根据正交性从全面试验中挑选出部分有代表性的点进行试验，这些有代表性的点具备了“均匀分散，齐整可比”的特点，正交试验设计是一种基于正交表的、高效率、快速、经济的试验。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="测试用例" scheme="http://pythonfood.github.io/categories/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
    
      <category term="测试用例" scheme="http://pythonfood.github.io/tags/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>因果图</title>
    <link href="http://pythonfood.github.io/2017/12/27/%E5%9B%A0%E6%9E%9C%E5%9B%BE/"/>
    <id>http://pythonfood.github.io/2017/12/27/因果图/</id>
    <published>2017-12-27T09:10:04.000Z</published>
    <updated>2018-02-09T06:21:52.091Z</updated>
    
    <content type="html"><![CDATA[<p>因果图是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，它适合于检查程序输入条件的各种组合情况。<br><a id="more"></a></p><h3 id="输入与输出的关系："><a href="#输入与输出的关系：" class="headerlink" title="输入与输出的关系："></a>输入与输出的关系：</h3><blockquote><p>1.恒等：若ci是1，则ei也是1；否则ei为0。<br>2.非：若ci是1，则ei是0；否则ei是1。<br>3.或：若c1或c2或c3是1，则ei是1；否则ei为0。“或”可有任意个输入。<br>4.与：若c1和c2都是1，则ei为1；否则ei为0。“与”也可有任意个输入。</p></blockquote><p><img src="/2017/12/27/因果图/因果图基本图形符.png" alt="因果图基本图形符"></p><h3 id="输入与输入的关系："><a href="#输入与输入的关系：" class="headerlink" title="输入与输入的关系："></a>输入与输入的关系：</h3><blockquote><p>1.E约束（异）：a和b中至多有一个可能为1，即a和b不能同时为1。<br>2.I约束（或）：a、b和c中至少有一个必须是1，即 a、b 和c不能同时为0。<br>3.O约束（唯一）；a和b必须有一个，且仅有1个为1。<br>4.R约束（要求）：a是1时，b必须是1，即不可能a是1时b是0。</p></blockquote><p><img src="/2017/12/27/因果图/因果图约束条件.png" alt="因果图约束条件"></p><h3 id="输出与输出的关系："><a href="#输出与输出的关系：" class="headerlink" title="输出与输出的关系："></a>输出与输出的关系：</h3><blockquote><p>1.M(屏蔽)：a出现时，b必定不出现；a不出现时，b则不确定。</p></blockquote><h4 id="小示例："><a href="#小示例：" class="headerlink" title="小示例："></a>小示例：</h4><p>1.根据关系画用例的因果图<br><img src="/2017/12/27/因果图/1.根据关系画用例的因果图.png" alt="1.根据关系画用例的因果图"><br>2.根据用例因果图设计判定表<br><img src="/2017/12/27/因果图/2.根据用例因果图设计判定表.png" alt="2.根据用例因果图设计判定表"><br>3.去除因果图判定表的无效项<br><img src="/2017/12/27/因果图/3.去除因果图判定表的无效项.png" alt="3.去除因果图判定表的无效项"></p><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因果图是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，它适合于检查程序输入条件的各种组合情况。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="测试用例" scheme="http://pythonfood.github.io/categories/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
    
      <category term="测试用例" scheme="http://pythonfood.github.io/tags/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>判定表</title>
    <link href="http://pythonfood.github.io/2017/12/27/%E5%88%A4%E5%AE%9A%E8%A1%A8/"/>
    <id>http://pythonfood.github.io/2017/12/27/判定表/</id>
    <published>2017-12-27T09:10:03.000Z</published>
    <updated>2018-02-09T06:21:40.261Z</updated>
    
    <content type="html"><![CDATA[<p>判定表是分析和表达多逻辑条件下执行不同操作的情况的工具。（在遇到复杂业务逻辑时可以利用该表理清业务逻辑关系）<br><a id="more"></a></p><h3 id="判定表重要概念："><a href="#判定表重要概念：" class="headerlink" title="判定表重要概念："></a>判定表重要概念：</h3><blockquote><p>1.条件</p><blockquote><p>条件桩：列出了所有条件，通常认为列出条件的次序无关紧要。<br>条件项：列出了所有条件的取值组合，在所有可能情况下的真假值。</p></blockquote><p>2.动作</p><blockquote><p>动作桩：列出所有可能的操作，这些操作的排列顺序没有约束。<br>动作项：列出在条件项的各种取值情况下应该采取的动作。</p></blockquote><p>3.规则</p><blockquote><p>规则：任何一个条件组合的特定取值及其他相应要执行的操作称为规则。在判定表中贯穿条件项和动作项的一列就是一条规则。</p></blockquote></blockquote><h3 id="判定表的4个组成部分："><a href="#判定表的4个组成部分：" class="headerlink" title="判定表的4个组成部分："></a>判定表的4个组成部分：</h3><p><img src="/2017/12/27/判定表/判定表的4个组成部分.jpg" alt="判定表的4个组成部分"></p><h3 id="判定表应用步骤："><a href="#判定表应用步骤：" class="headerlink" title="判定表应用步骤："></a>判定表应用步骤：</h3><blockquote><p>1.理解需求，列出条件桩和动作桩。<br>2.设计及优化判定表。（2的n次方种）<br>3.填写动作项。<br>4.根据判定表中输出结果的表现，进行判定表的合并（非必须），简化判定表。<br>5.抽取测试用例。</p></blockquote><h4 id="小示例："><a href="#小示例：" class="headerlink" title="小示例："></a>小示例：</h4><p>根据判定条件编写判定表测试用例<br><img src="/2017/12/27/判定表/根据判定条件编写判定表测试用例.png" alt="根据判定条件编写判定表测试用例"></p><h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a><em>持续更新…</em></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;判定表是分析和表达多逻辑条件下执行不同操作的情况的工具。（在遇到复杂业务逻辑时可以利用该表理清业务逻辑关系）&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="测试用例" scheme="http://pythonfood.github.io/categories/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
    
      <category term="测试用例" scheme="http://pythonfood.github.io/tags/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
  </entry>
  
</feed>
