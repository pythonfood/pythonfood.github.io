<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>python多线程 | PythonFood</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="python food,Python Food," />
  
  <meta name="description" content="人生苦短，我用python。">
<meta name="keywords" content="python">
<meta property="og:type" content="article">
<meta property="og:title" content="python多线程">
<meta property="og:url" content="http://pythonfood.github.io/2017/12/30/python多线程/index.html">
<meta property="og:site_name" content="PythonFood">
<meta property="og:description" content="人生苦短，我用python。">
<meta property="og:updated_time" content="2018-12-05T07:02:28.170Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="python多线程">
<meta name="twitter:description" content="人生苦短，我用python。">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  <script src="/js/pace.min.js"></script>
  

  
  

</head>

<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">Python Food</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.png" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        Python Food
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        A snake that grows up slowly
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="Home" target="_blank" href="//pythonfood.github.io">
                            <i class="fa fa-home fa-2x"></i></a>
                    
                        <a title="Github" target="_blank" href="//github.com/pythonfood">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-python多线程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      python多线程
    </h1>
    <div class="post-title-bar">
      <ul>
          
              <li>
                  <i class="fa fa-book"></i>
                  
                      <a href="/categories/python/">python</a>
                  
              </li>
          
        <li>
          <i class="fa fa-calendar"></i>  2017-12-30
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <p>人生苦短，我用python。<br><a id="more"></a></p>
<h2 id="一、线程"><a href="#一、线程" class="headerlink" title="一、线程"></a>一、线程</h2><p>线程是CPU分配资源的基本单位。但一个程序开始运行，这个程序就变成了一个进程，而一个进程相当于一个或者多个线程。当没有多线程编程时，一个进程也是一个主线程，但有多线程编程时，一个进程包含多个线程，包括主线程。使用线程可以实现程序的并发。</p>
<blockquote>
<p>进程VS线程：</p>
<p>功能：<br>(1)进程，能够完成多任务，比如 在一台电脑上能够同时运行多个QQ<br>(2)线程，能够完成多任务，比如 一个QQ中的多个聊天窗口</p>
<p>定义不同:<br>(1)进程是系统进行资源分配和调度的一个独立单位<br>(2)线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</p>
<p>区别：<br>(1)一个程序至少有一个进程,一个进程至少有一个线程.<br>(2)线程的划分尺度小于进程(资源比进程少)，使得多线程程序的并发性高。<br>(3)进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率<br>(4)线线程不能够独立执行，必须依存在进程中</p>
<p>优缺点：<br>线程执行开销小，但不利于资源的管理和保护；而进程正相反</p>
</blockquote>
<p>Python3通过两个标准库<code>_thread</code>和<code>threading</code>提供对线程的支持:<br>(1)<code>_thread</code>提供了低级别的、原始的线程以及一个简单的锁，它相比于threading模块的功能还是比较有限的。<br>(2)<code>threading</code>模块除了包含_thread 模块中的所有方法外，还提供的其他方法： </p>
<ul>
<li><code>threading.currentThread()</code>: 返回当前的线程变量。 </li>
<li><code>threading.enumerate()</code>: 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。 </li>
<li><code>threading.activeCount()</code>: 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。<br>除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法:</li>
<li><code>run()</code>: 用以表示线程活动的方法。</li>
<li><code>start()</code>:启动线程活动。</li>
<li><code>join([time])</code>: 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。</li>
<li><code>isAlive()</code>: 返回线程是否活动的。</li>
<li><code>getName()</code>: 返回线程名。</li>
<li><code>setName()</code>: 设置线程名。</li>
</ul>
<h2 id="二、-thread模块"><a href="#二、-thread模块" class="headerlink" title="二、_thread模块"></a>二、_thread模块</h2><p>函数式：调用_thread模块中的start_new_thread()函数来产生新线程。<br><code>_thread.start_new_thread ( function, args[, kwargs] )</code></p>
<ul>
<li>function - 线程函数。</li>
<li>args - 传递给线程函数的参数,他必须是个tuple类型。</li>
<li>kwargs - 可选参数。</li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import _thread</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 为线程定义一个函数</span><br><span class="line">def print_time(threadName, delay):</span><br><span class="line">	count = 0</span><br><span class="line">	while count &lt; 5:</span><br><span class="line">		time.sleep(delay)</span><br><span class="line">		count += 1</span><br><span class="line">		print(&apos;s%: s%&apos; % (threadName, time.ctime(time.time())))</span><br><span class="line"></span><br><span class="line"># 创建两个线程</span><br><span class="line">try:</span><br><span class="line">	_thread.start_new_thread(print_time, (&apos;thread-1&apos;, 2))</span><br><span class="line">	_thread.start_new_thread(print_time, (&apos;thread-2&apos;, 4))</span><br><span class="line">except:</span><br><span class="line">	print(&apos;E：无法启动线程&apos;)</span><br><span class="line">	</span><br><span class="line">while 1：</span><br><span class="line">	pass</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="三、threading模块"><a href="#三、threading模块" class="headerlink" title="三、threading模块"></a>三、threading模块</h2><p>1、用threading.Thread直接在线程中运行函数</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接创建线程:</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sing</span><span class="params">(name,**kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        print(<span class="string">'正在唱歌&lt;&lt;%s&gt;&gt;_%d'</span> % (name, i))</span><br><span class="line">        print(kwargs)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dance</span><span class="params">(name,**kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        print(<span class="string">'正在跳舞&lt;&lt;%s&gt;&gt;_%d'</span> % (name, i))</span><br><span class="line">        print(kwargs)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 主线程会等待所有的子线程结束后才结束</span></span><br><span class="line">    print(<span class="string">'开始%s'</span> % time.ctime())</span><br><span class="line">	</span><br><span class="line">    <span class="comment"># threading.Thread(target=这个线程实例所调用对象, args=调用对象的位置参数元组, kwargs=调用对象的关键字参数字典)</span></span><br><span class="line">    t1 = threading.Thread(target=sing, args=(<span class="string">'欢乐颂'</span>,), kwargs=&#123;<span class="string">'时长'</span>:<span class="string">'5min'</span>&#125;)  <span class="comment"># 创建线程</span></span><br><span class="line">    t2 = threading.Thread(target=dance, args=(<span class="string">'新年好'</span>,), kwargs=&#123;<span class="string">'时长'</span>:<span class="string">'20min'</span>&#125;)</span><br><span class="line">	</span><br><span class="line">    t1.start()  <span class="comment"># start() 启动线程活动</span></span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()  <span class="comment"># join([time]) 等待线程中止，可设置超时时间</span></span><br><span class="line">    t2.join()</span><br><span class="line">	</span><br><span class="line">    print(<span class="string">'线程是否活动：'</span>, t1.isAlive())  <span class="comment"># isAlive() 返回线程是否活动的</span></span><br><span class="line">    print(<span class="string">'线程是否活动：'</span>, t2.isAlive())</span><br><span class="line">	</span><br><span class="line">    t1.setName(<span class="string">'thread-t1'</span>)  <span class="comment">#  setName() 设置线程名</span></span><br><span class="line">    print(<span class="string">'获取线程名称：'</span>, t1.getName())  <span class="comment"># getName() 返回线程名</span></span><br><span class="line">    print(<span class="string">'当前运行的线程：'</span>, threading.currentThread())  <span class="comment"># threading.currentThread() 返回当前的线程变量</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        print(<span class="string">'当前运行的线程数%d'</span> % threading.activeCount())  <span class="comment"># threading.activeCount() 返回正在运行的线程数量</span></span><br><span class="line">        print(<span class="string">'当前运行的所有线程：'</span>, threading.enumerate())  <span class="comment"># threading.enumerate() 返回一个包含正在运行的线程的列表</span></span><br><span class="line">        <span class="keyword">if</span> len(threading.enumerate()) &lt;= <span class="number">1</span>:  <span class="comment"># len(threading.enumerate()) 等同与 threading.activeCount()</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        </span><br><span class="line">    print(<span class="string">'结束%s'</span> % time.ctime())</span><br></pre></td></tr></table></figure>
</blockquote>
<p>2、通过继承threading.Thread类来创建线程</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用类创建线程:</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        super().__init__()  <span class="comment"># 使用父类__init__进行初始化</span></span><br><span class="line">        self.name = name</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span>  <span class="comment"># 重写父类Thread的run()方法，定义线程的功能函数,用于后面start()调用</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            print(<span class="string">'I am '</span> + self.name + <span class="string">' @ '</span> + str(i))</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t = MyThread(<span class="string">'Thread-t'</span>)  <span class="comment"># 实例化就生成一个线程</span></span><br><span class="line">    t.start()  <span class="comment"># 执行start()方法，会运行这个类中的run()方法，所以这里会执行t.run()</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="四、线程同步"><a href="#四、线程同步" class="headerlink" title="四、线程同步"></a>四、线程同步</h2><p><strong>1、多线程共享全局变量</strong></p>
<p>在一个进程内的所有线程共享全局变量，能够在不适用其他方式的前提下完成多线程之间的数据共享（这点要比多进程要好）</p>
<p>缺点就是，线程是对全局变量随意遂改可能造成多线程之间对全局变量的混乱（即线程非安全）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">g_num = <span class="number">100</span></span><br><span class="line">g_nums = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br><span class="line">print(<span class="string">'多线程执行前g_num=%d'</span> % g_num)</span><br><span class="line">print(<span class="string">'多线程执行前g_nums='</span>, g_nums)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work1</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    g_num += <span class="number">1</span>  <span class="comment"># 线程修改全局变量</span></span><br><span class="line">    nums.append(<span class="number">400</span>)  <span class="comment"># 列表当做实参传递到线程中，也可以修改</span></span><br><span class="line">    print(<span class="string">'多线程work1执行后g_num=%d'</span> % g_num)</span><br><span class="line">    print(<span class="string">'多线程work1执行后g_nums='</span>, nums)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work2</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    g_num += <span class="number">1</span></span><br><span class="line">    nums.append(<span class="number">500</span>)</span><br><span class="line">    print(<span class="string">'多线程work2执行后g_num=%d'</span> % g_num)</span><br><span class="line">    print(<span class="string">'多线程work2执行后g_nums='</span>, nums)</span><br><span class="line">    </span><br><span class="line">t1 = threading.Thread(target=work1, args=(g_nums,))</span><br><span class="line">t2 = threading.Thread(target=work2, args=(g_nums,))</span><br><span class="line">t1.start()</span><br><span class="line">time.sleep(<span class="number">1</span>)  <span class="comment"># 延时一会，保证t1线程中的事情做完</span></span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure>
<p><strong>2、线程同步：</strong></p>
<p>如果没有控制多个线程对同一资源的访问，对数据造成破坏，使得线程运行的结果不可预期。这种现象称为“线程不安全”。<br>解决思路就是引入线程同步，同步就是协同步调，按预定的先后次序进行运行。</p>
<p>线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁。互斥锁为资源引入一个状态：锁定/非锁定。</p>
<ul>
<li>锁的好处：确保了某段关键代码只能由一个线程从头到尾完整地执行</li>
<li>锁的坏处：<ul>
<li>阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了</li>
<li>由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁</li>
</ul>
</li>
</ul>
<p>使用Thread对象的<code>Lock()</code>和<code>Rlock()</code>可以实现简单的线程同步，这两个对象都有<code>acquire()</code>方法和<code>release()</code>方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到acquire()和release()方法之间。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">g_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        mutexFlag = mutex.acquire(<span class="keyword">True</span>)  <span class="comment"># acquire([blocking]) 锁定</span></span><br><span class="line">        <span class="comment"># True表示堵塞 即如果这个锁在上锁之前已经被上锁了，那么这个线程会在这里一直等待到解锁为止</span></span><br><span class="line">        <span class="comment"># False表示非堵塞，即不管本次调用能够成功上锁，都不会卡在这,而是继续执行下面的代码</span></span><br><span class="line">        <span class="keyword">if</span> mutexFlag:</span><br><span class="line">            g_num +=<span class="number">1</span></span><br><span class="line">            mutex.release()  <span class="comment"># release() 解锁</span></span><br><span class="line">    print(<span class="string">'work1:g_num=%d'</span> % g_num)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        mutexFlag = mutex.acquire(<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">if</span> mutexFlag:</span><br><span class="line">            g_num +=<span class="number">1</span></span><br><span class="line">            mutex.release()</span><br><span class="line">    print(<span class="string">'work1:g_num=%d'</span> % g_num)</span><br><span class="line"></span><br><span class="line">mutex = threading.Lock()  <span class="comment"># 创建一个互斥锁，这个锁的默认状态是未上锁</span></span><br><span class="line">    </span><br><span class="line">t1 = threading.Thread(target=work1)</span><br><span class="line">t2 = threading.Thread(target=work2)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">print(<span class="string">'g_num=%d'</span> % g_num)</span><br></pre></td></tr></table></figure></p>
<p><strong>3、死锁：</strong></p>
<p>死锁：是指两个或两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p>
<p>避免死锁：</p>
<ul>
<li>程序设计时要尽量避免（银行家算法）</li>
<li>添加超时时间等</li>
</ul>
<p>RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。上面的例子如果使用RLock代替Lock，则不会发生死锁。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> mutexA.acquire():  <span class="comment"># 对mutexA上锁</span></span><br><span class="line">            print(self.name+<span class="string">'----do1---up----'</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> mutexB.acquire():  <span class="comment"># 等待mutexB解锁</span></span><br><span class="line">                print(self.name+<span class="string">'----do1---down----'</span>)</span><br><span class="line">                mutexB.release()</span><br><span class="line">            mutexA.release()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> mutexB.acquire():   <span class="comment"># 对mutexB上锁</span></span><br><span class="line">            print(self.name+<span class="string">'----do2---up----'</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> mutexA.acquire():   <span class="comment"># 等待mutexA解锁</span></span><br><span class="line">                print(self.name+<span class="string">'----do2---down----'</span>)</span><br><span class="line">                mutexA.release()</span><br><span class="line">            mutexB.release()</span><br><span class="line"></span><br><span class="line">mutexA = threading.Lock()</span><br><span class="line">mutexB = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t1 = MyThread1()</span><br><span class="line">    t2 = MyThread2()</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure>
<h2 id="五、全局解释器锁"><a href="#五、全局解释器锁" class="headerlink" title="五、全局解释器锁"></a>五、全局解释器锁</h2><p>Python GIL(Global Interpreter Lock)<br>如果使用多核CPU，在Cpython解释器中，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p>
<p>GIL是Python解释器设计的历史遗留问题，通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。所以，在Python中，可以使用多线程，但不要指望能有效利用多核。如果一定要通过多线程利用多核，那只能通过C扩展来实现，不过这样就失去了Python简单易用的特点。不过，也不用过于担心，Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。</p>
<p>面向I/O的（会调用内建的操作系统C代码的）程序来说，GIL会在这个I/O调用之前被释放，以允许其他线程在这个线程等待I/O的时候运行。如果某线程并未使用很多I/O操作，它会在自己的时间片内一直占用处理器和GIL。也就是说，I/O密集型的Python程序比计算密集型的Python程序更能充分利用多线程的好处。</p>
<p>1、i/o密集型<br>多线程用于IO密集型，如socket，爬虫，web。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from threading import Thread</span><br><span class="line">from multiprocessing import Process</span><br><span class="line">import time</span><br><span class="line">import os</span><br><span class="line">def work():</span><br><span class="line">    time.sleep(2) #模拟I/O操作，可以打开一个文件来测试I/O,与sleep是一个效果</span><br><span class="line">    print(os.getpid())</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    t_l=[]</span><br><span class="line">    start_time=time.time()</span><br><span class="line">    for i in range(1000):</span><br><span class="line">        t=Thread(target=work) #耗时大概为2秒</span><br><span class="line">        # t=Process(target=work) #耗时大概为25秒,创建进程的开销远高于线程，而且对于I/O密集型，多cpu根本不管用</span><br><span class="line">        t_l.append(t)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    for t in t_l:</span><br><span class="line">        t.join()</span><br><span class="line">    stop_time=time.time()</span><br><span class="line">    print(&apos;run time is %s&apos; %(stop_time-start_time))</span><br></pre></td></tr></table></figure>
</blockquote>
<p>2、cpu密集型<br>多进程用于计算密集型，如金融分析，视频解码。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">from threading import Thread</span><br><span class="line">from multiprocessing import Process</span><br><span class="line">import os</span><br><span class="line">import time</span><br><span class="line">def work():</span><br><span class="line">    res=0</span><br><span class="line">    for i in range(1000000):</span><br><span class="line">        res+=i</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    t_l=[]</span><br><span class="line">    start_time=time.time()</span><br><span class="line"></span><br><span class="line">    for i in range(300):</span><br><span class="line">        # t=Thread(target=work) #多线程49.64094281196594</span><br><span class="line">        t=Process(target=work) #多进程11.664679050445557</span><br><span class="line">        t_l.append(t)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    for i in t_l:</span><br><span class="line">        i.join()</span><br><span class="line"></span><br><span class="line">    stop_time=time.time()</span><br><span class="line">    print(&apos;run time is %s&apos; %(stop_time-start_time))</span><br><span class="line"></span><br><span class="line">    print(&apos;主线程&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># run time is 49.64094281196594</span><br><span class="line"># 主线程</span><br><span class="line"></span><br><span class="line"># run time is 11.664679050445557</span><br><span class="line"># 主线程</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="六、线程优先级队列"><a href="#六、线程优先级队列" class="headerlink" title="六、线程优先级队列"></a>六、线程优先级队列</h2><p>Queue模块中提供了同步的、线程安全的队列类，包括：</p>
<ul>
<li>FIFO(先入先出)队列 Queue</li>
<li>LIFO(后入先出)队列 LifoQueue</li>
<li>优先级队列 PriorityQueue</li>
</ul>
<p>这些队列都实现了锁原语（可以理解为原子操作，即要么不做，要么就做完），能够在多线程中直接使用，可以使用队列来实现线程间的同步。</p>
<p>Queue模块中的常用方法:</p>
<ul>
<li><code>Queue.qsize()</code> 返回队列的大小 </li>
<li><code>Queue.empty()</code> 如果队列为空，返回True,反之False </li>
<li><code>Queue.full()</code> 如果队列满了，返回True,反之False</li>
<li><code>Queue.full</code> 与 maxsize 大小对应 </li>
<li><code>Queue.get([block[, timeout]])</code>获取队列，timeout等待时间 </li>
<li><code>Queue.get_nowait()</code> 相当Queue.get(False)</li>
<li><code>Queue.put(item)</code> 写入队列，timeout等待时间 </li>
<li><code>Queue.put_nowait(item)</code> 相当Queue.put(item, False)</li>
<li><code>Queue.task_done()</code> 在完成一项工作之后，Queue.task_done()函数向任务已经完成的队列发送一个信号</li>
<li><code>Queue.join()</code> 实际上意味着等到队列为空，再执行别的操作</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="comment"># Queue.qsize() 返回队列的大小</span></span><br><span class="line"><span class="comment"># Queue.empty() 如果队列为空，返回True,反之False</span></span><br><span class="line"><span class="comment"># Queue.full() 如果队列满了，返回True,反之False</span></span><br><span class="line"><span class="comment"># Queue.full 与 maxsize 大小对应</span></span><br><span class="line"><span class="comment"># Queue.get([block[, timeout]])获取队列，timeout等待时间</span></span><br><span class="line"><span class="comment"># Queue.get_nowait() 相当Queue.get(False)</span></span><br><span class="line"><span class="comment"># Queue.put(item) 写入队列，timeout等待时间</span></span><br><span class="line"><span class="comment"># Queue.put_nowait(item) 相当Queue.put(item, False)</span></span><br><span class="line"><span class="comment"># Queue.task_done() 在完成一项工作之后，Queue.task_done()函数向任务已经完成的队列发送一个信号</span></span><br><span class="line"><span class="comment"># Queue.join() 实际上意味着等到队列为空，再执行别的操作</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> queue</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">if</span> queue.qsize() &lt; <span class="number">1000</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">                    count = count +<span class="number">1</span></span><br><span class="line">                    msg = <span class="string">'生成产品'</span>+str(count)</span><br><span class="line">                    queue.put(msg)</span><br><span class="line">                    print(msg)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> queue</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">if</span> queue.qsize() &gt; <span class="number">100</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                    msg = self.name + <span class="string">'消费了 '</span>+queue.get()</span><br><span class="line">                    print(msg)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    queue = Queue()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">500</span>):</span><br><span class="line">        queue.put(<span class="string">'初始产品'</span>+str(i))</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        p = Producer()</span><br><span class="line">        p.start()</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        c = Consumer()</span><br><span class="line">        c.start()</span><br></pre></td></tr></table></figure>
<h2 id="七、ThreadLocal"><a href="#七、ThreadLocal" class="headerlink" title="七、ThreadLocal"></a>七、ThreadLocal</h2><p>ThreadLoca可以解决参数在一个线程中各个函数之间互相传递的问题。</p>
<p>ThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">local_school = threading.local()  <span class="comment"># 创建全局ThreadLocal对象</span></span><br><span class="line"><span class="comment"># 全局变量local_school就是一个ThreadLocal对象，每个Thread对它都可以读写student属性，但互不影响。</span></span><br><span class="line"><span class="comment"># 但每个属性如local_school.student都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，ThreadLocal内部会处理。</span></span><br><span class="line"><span class="comment"># 可以理解为全局变量local_school是一个dict，不但可以用local_school.student，还可以绑定其他变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_student</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 获取当前线程关联的student属性</span></span><br><span class="line">    std = local_school.student  </span><br><span class="line">    print(<span class="string">'Student %s in %s '</span>  % (std, threading.current_thread().name))</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_thread</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="comment"># 绑定ThreadLocal的student</span></span><br><span class="line">    local_school.student = name</span><br><span class="line">    process_student()</span><br><span class="line">    </span><br><span class="line">t1 = threading.Thread(target=process_thread, args=(<span class="string">'Jack'</span>), name=<span class="string">'Thread-t1'</span>)</span><br><span class="line">t2 = threading.Thread(target=process_thread, args=(<span class="string">'Tom'</span>), name=<span class="string">'Thread-t2'</span>)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br></pre></td></tr></table></figure>
<h1 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a>持续更新…</h1>
            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2018年12月05日 15:02</p>
        <p>原始链接： <a class="post-url" href="/2017/12/30/python多线程/" title="python多线程">http://pythonfood.github.io/2017/12/30/python多线程/</a></p>
        <footer>
            <a href="http://pythonfood.github.io">
                <img src="/images/logo.png" alt="Python Food">
                Python Food
            </a>
        </footer>
    </div>
</div>

      
        
            
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;">赏</a>
</div>

<div id="reward" class="post-modal reward-lay">
    <a class="close" href="javascript:;" id="reward-close">×</a>
    <span class="reward-title">
        <i class="icon icon-quote-left"></i>
        多少都行~
        <i class="icon icon-quote-right"></i>
    </span>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/images/wechat_code.jpg" alt="打赏二维码">
        </div>
        <div class="reward-select">
            
            <label class="reward-select-item checked" data-id="wechat" data-wechat="/images/wechat_code.jpg">
                <img class="reward-select-item-wechat" src="/images/wechat.png" alt="微信">
            </label>
            
            
            <label class="reward-select-item" data-id="alipay" data-alipay="/images/alipay_code.jpg">
                <img class="reward-select-item-alipay" src="/images/alipay.png" alt="支付宝">
            </label>
            
        </div>
    </div>
</div>


        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://pythonfood.github.io/2017/12/30/python多线程/&title=《python多线程》 — PythonFood&pic=/images/banner.jpg" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://pythonfood.github.io/2017/12/30/python多线程/&title=《python多线程》 — PythonFood&source=人生苦短，我用python。" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://pythonfood.github.io/2017/12/30/python多线程/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《python多线程》 — PythonFood&url=http://pythonfood.github.io/2017/12/30/python多线程/&via=http://pythonfood.github.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://pythonfood.github.io/2017/12/30/python多线程/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=http://pythonfood.github.io/2017/12/30/python多线程/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/python/" class="color2">python</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#一、线程"><span class="post-toc-text">一、线程</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#二、-thread模块"><span class="post-toc-text">二、_thread模块</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#三、threading模块"><span class="post-toc-text">三、threading模块</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#四、线程同步"><span class="post-toc-text">四、线程同步</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#五、全局解释器锁"><span class="post-toc-text">五、全局解释器锁</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#六、线程优先级队列"><span class="post-toc-text">六、线程优先级队列</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#七、ThreadLocal"><span class="post-toc-text">七、ThreadLocal</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#持续更新…"><span class="post-toc-text">持续更新…</span></a>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2017/12/30/python协程/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          python协程
        
      </span>
    </a>
  
  
    <a href="/2017/12/30/python多进程/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">python多进程</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
        <div id="SOHUCS" sid="python多线程" ></div>
<script type="text/javascript">
    (function(){
        var appid = 'cytnRgqDg';
        var conf = '61714297a608dcad6779ec4ea0059b2a';
        var width = window.innerWidth || document.documentElement.clientWidth;
        if (width < 960) {
            window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); </script>
    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2019 Python Food<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "http://pythonfood.github.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 1
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/categories/app测试/">app测试</a><a class="category-link" href="/categories/django/">django</a><a class="category-link" href="/categories/github/">github</a><a class="category-link" href="/categories/hexo/">hexo</a><a class="category-link" href="/categories/linux/">linux</a><a class="category-link" href="/categories/markdown/">markdown</a><a class="category-link" href="/categories/mongodb/">mongodb</a><a class="category-link" href="/categories/mysql/">mysql</a><a class="category-link" href="/categories/python/">python</a><a class="category-link" href="/categories/redis/">redis</a><a class="category-link" href="/categories/web测试/">web测试</a><a class="category-link" href="/categories/持续集成/">持续集成</a><a class="category-link" href="/categories/接口测试/">接口测试</a><a class="category-link" href="/categories/数据结构与算法/">数据结构与算法</a><a class="category-link" href="/categories/服务器/">服务器</a><a class="category-link" href="/categories/测试框架/">测试框架</a><a class="category-link" href="/categories/测试用例/">测试用例</a><a class="category-link" href="/categories/爬虫/">爬虫</a><a class="category-link" href="/categories/网络/">网络</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/adb/" style="font-size: 10px;">adb</a> <a href="/tags/appium/" style="font-size: 13.33px;">appium</a> <a href="/tags/app测试/" style="font-size: 10px;">app测试</a> <a href="/tags/django/" style="font-size: 10px;">django</a> <a href="/tags/fiddler/" style="font-size: 10px;">fiddler</a> <a href="/tags/github/" style="font-size: 10px;">github</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/jenkins/" style="font-size: 10px;">jenkins</a> <a href="/tags/jmeter/" style="font-size: 10px;">jmeter</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a> <a href="/tags/monkey/" style="font-size: 10px;">monkey</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/postman/" style="font-size: 10px;">postman</a> <a href="/tags/python/" style="font-size: 20px;">python</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/selenium/" style="font-size: 11.67px;">selenium</a> <a href="/tags/unittest/" style="font-size: 10px;">unittest</a> <a href="/tags/web测试/" style="font-size: 10px;">web测试</a> <a href="/tags/安卓性能/" style="font-size: 15px;">安卓性能</a> <a href="/tags/接口测试/" style="font-size: 10px;">接口测试</a> <a href="/tags/接口脚本/" style="font-size: 10px;">接口脚本</a> <a href="/tags/测试用例/" style="font-size: 16.67px;">测试用例</a> <a href="/tags/爬虫/" style="font-size: 18.33px;">爬虫</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/adb/" style="font-size: 10px;">adb</a> <a href="/tags/appium/" style="font-size: 13.33px;">appium</a> <a href="/tags/app测试/" style="font-size: 10px;">app测试</a> <a href="/tags/django/" style="font-size: 10px;">django</a> <a href="/tags/fiddler/" style="font-size: 10px;">fiddler</a> <a href="/tags/github/" style="font-size: 10px;">github</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/jenkins/" style="font-size: 10px;">jenkins</a> <a href="/tags/jmeter/" style="font-size: 10px;">jmeter</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a> <a href="/tags/monkey/" style="font-size: 10px;">monkey</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/postman/" style="font-size: 10px;">postman</a> <a href="/tags/python/" style="font-size: 20px;">python</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/selenium/" style="font-size: 11.67px;">selenium</a> <a href="/tags/unittest/" style="font-size: 10px;">unittest</a> <a href="/tags/web测试/" style="font-size: 10px;">web测试</a> <a href="/tags/安卓性能/" style="font-size: 15px;">安卓性能</a> <a href="/tags/接口测试/" style="font-size: 10px;">接口测试</a> <a href="/tags/接口脚本/" style="font-size: 10px;">接口脚本</a> <a href="/tags/测试用例/" style="font-size: 16.67px;">测试用例</a> <a href="/tags/爬虫/" style="font-size: 18.33px;">爬虫</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>
<script src="/js/search.js"></script>
<script src="/js/main.js"></script>


  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  <script src="/js/particles.js"></script>







  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  <script src="/js/animate.js"></script>

  </div>
</body>
</html>